/**
 * A class for a Subject to observe.
 * @class Subject
 * @template T
 */
class Subject {
    /**
     * Constructs an observable Subject.
     * @param value The initial value.
     * @param equalityFunc The function to use to check for equality.
     * @param mutateFunc The function to use to mutate the subject's value.
     */
    constructor(value, equalityFunc, mutateFunc) {
        this.value = value;
        this.equalityFunc = equalityFunc;
        this.mutateFunc = mutateFunc;
        this._subs = [];
    }
    /**
     * Creates and returns a new Subject.
     * @param v The initial value of the subject.
     * @param equalityFunc The function to use to check for equality.
     * @param mutateFunc The function to use to mutate the subject's value. If not supplied, new values will replace
     * old values by variable assignment.
     * @returns A Subject instance.
     */
    static create(v, equalityFunc, mutateFunc) {
        return new Subject(v, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : Subject.DEFAULT_EQUALITY_FUNC, mutateFunc);
    }
    /**
     * Sets the new value and notifies the subscribers when value changed.
     * @param value The new value.
     */
    set(value) {
        if (!this.equalityFunc(value, this.value)) {
            if (this.mutateFunc) {
                this.mutateFunc(this.value, value);
            }
            else {
                this.value = value;
            }
            this.notify();
        }
    }
    /**
     * Applies a change to a value.
     * @param value The partial value to apply as a change.
     */
    apply(value) {
        Object.assign(this.value, value);
        this.notify();
    }
    /**
     * Notifies subscribers that the subject value has changed.
     */
    notify() {
        const subLen = this._subs.length;
        for (let i = 0; i < subLen; i++) {
            try {
                this._subs[i](this.value);
            }
            catch (error) {
                console.error(`Error in Subject handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
    }
    /**
     * Gets the value of the Subject.
     * @returns The value.
     */
    get() {
        return this.value;
    }
    /**
     * Subscribes to the subject with a callback function. The function will be called whenever the value of this Subject
     * changes.
     * @param fn A callback function.
     * @param initialNotify Whether to immediately notify the callback function with the current value of this Subject
     * after it is subscribed. False by default.
     */
    sub(fn, initialNotify) {
        this._subs.push(fn);
        if (initialNotify) {
            fn(this.value);
        }
    }
    /**
     * Unsubscribes a callback function from this Subject.
     * @param fn The callback function to unsubscribe.
     */
    unsub(fn) {
        const index = this._subs.indexOf(fn);
        if (index >= 0) {
            this._subs.splice(index, 1);
        }
    }
    /**
     * Maps a subject to a new subject.
     * @param fn The function to use to map to the new subject.
     * @returns A new mapped subject.
     */
    map(fn) {
        return new MappedSubject(this, fn);
    }
}
/**
 * Checks if two values are equal using the strict equality operator.
 * @param a The first value.
 * @param b The second value.
 * @returns whether a and b are equal.
 */
Subject.DEFAULT_EQUALITY_FUNC = (a, b) => a === b;
/**
 * A subject that is a mapped stream from another parent subscribable.
 */
class MappedSubject {
    /**
     * Creates a new MappedSubject.
     * @param parent The parent subscribable instance.
     * @param mapFunc The function to map to the new stream.
     */
    constructor(parent, mapFunc) {
        this.parent = parent;
        this.mapFunc = mapFunc;
        this._subs = [];
        /**
         * Maps the parent value to the subject value.
         * @param val The parent value to map.
         */
        this.mapValue = (val) => {
            for (let i = 0; i < this._subs.length; i++) {
                this._subs[i](this.mapFunc(val));
            }
        };
        parent.sub(this.mapValue, true);
    }
    /**
     * Gets the current value of the subject.
     * @returns The current value.
     */
    get() {
        return this.mapFunc(this.parent.get());
    }
    /**
     * Subscribes to the subject with a callback function. The function will be called whenever the value of this Subject
     * changes.
     * @param fn A callback function.
     * @param initialNotify Whether to immediately notify the callback function with the current value of this Subject
     * after it is subscribed. False by default.
     */
    sub(fn, initialNotify) {
        this._subs.push(fn);
        if (initialNotify) {
            fn(this.mapFunc(this.parent.get()));
        }
    }
    /**
     * Unsubscribes a callback function from this Subject.
     * @param fn The callback function to unsubscribe.
     */
    unsub(fn) {
        const index = this._subs.indexOf(fn);
        if (index >= 0) {
            this._subs.splice(index, 1);
        }
    }
    /**
     * Destroys the subscription to the parent subscribable.
     */
    destroy() {
        this.parent.unsub(this.mapValue);
    }
    /**
     * Maps a subject to a new subject.
     * @param fn The function to use to map to the new subject.
     * @returns A new mapped subject.
     */
    map(fn) {
        return new MappedSubject(this, fn);
    }
}

/**
 * A class for subjects that return a computed value.
 * @class ComputedSubject
 * @template T The type of the input value.
 * @template C The type of the computed output value.
 */
class ComputedSubject {
    /**
     * Creates an instance of ComputedSubject.
     * @param value The initial value.
     * @param computeFn The computation function.
     */
    constructor(value, computeFn) {
        this.computeFn = computeFn;
        this._subs = [];
        this._value = value;
        this._computedValue = computeFn(value);
    }
    /**
     * Creates and returns a new ComputedSubject.
     * @param v The initial value of the Subject.
     * @param fn A function which transforms raw values to computed values.
     * @returns A ComputedSubject instance.
     */
    static create(v, fn) {
        return new ComputedSubject(v, fn);
    }
    /**
     * Sets the new value and notifies the subscribers when value changed.
     * @param value The new value.
     */
    set(value) {
        this._value = value;
        const compValue = this.computeFn(value);
        if (compValue !== this._computedValue) {
            this._computedValue = compValue;
            const subLen = this._subs.length;
            for (let i = 0; i < subLen; i++) {
                this._subs[i](this._computedValue, this._value);
            }
        }
    }
    /**
     * Gets the computed value of the Subject.
     * @returns The computed value.
     */
    get() {
        return this._computedValue;
    }
    /**
     * Gets the raw value of the Subject.
     * @returns The raw value.
     */
    getRaw() {
        return this._value;
    }
    /**
     * Subscribes to the subject with a callback function. The function will be called whenever the computed value of
     * this Subject changes.
     * @param fn A callback function.
     * @param initialNotify Whether to immediately notify the callback function with the current compured and raw values
     * of this Subject after it is subscribed. False by default.
     */
    sub(fn, initialNotify) {
        this._subs.push(fn);
        if (initialNotify) {
            fn(this._computedValue, this._value);
        }
    }
    /**
     * Unsubscribes a callback function from this Subject.
     * @param fn The callback function to unsubscribe.
     */
    unsub(fn) {
        const index = this._subs.indexOf(fn);
        if (index >= 0) {
            this._subs.splice(index, 1);
        }
    }
    /**
     * Maps this subject to a new subject.
     * @param fn The function to use to map to the new subject.
     * @returns The mapped subject.
     */
    map(fn) {
        return new MappedSubject(this, fn);
    }
}

/* eslint-disable no-inner-declarations */
/** A releative render position. */
var RenderPosition;
(function (RenderPosition) {
    RenderPosition[RenderPosition["Before"] = 0] = "Before";
    RenderPosition[RenderPosition["After"] = 1] = "After";
    RenderPosition[RenderPosition["In"] = 2] = "In";
})(RenderPosition || (RenderPosition = {}));
/**
 * A display component in the component framework.
 */
class DisplayComponent {
    /**
     * Creates an instance of a DisplayComponent.
     * @param props The propertis of the component.
     */
    constructor(props) {
        this.props = props;
    }
    /**
     * A callback that is called before the component is rendered.
     */
    onBeforeRender() { return; }
    /**
     * A callback that is called after the component is rendered.
     */
    onAfterRender() { return; }
    /**
     * Destroys this component.
     */
    destroy() { return; }
}
/**
 * A reference to a component or element node.
 */
class NodeReference {
    constructor() {
        /** The internal reference instance. */
        this._instance = null;
    }
    /**
     * The instance of the element or component.
     * @returns The instance of the element or component.
     */
    get instance() {
        if (this._instance !== null) {
            return this._instance;
        }
        throw new Error('Instance was null.');
    }
    /**
     * Sets the value of the instance.
     */
    set instance(val) {
        this._instance = val;
    }
    /**
     * Gets the instance, or null if the instance is not populated.
     * @returns The component or element instance.
     */
    getOrDefault() {
        return this._instance;
    }
}
/**
 * The FS component namespace.
 */
// eslint-disable-next-line @typescript-eslint/no-namespace
var FSComponent;
(function (FSComponent) {
    /**
     * Valid SVG element tags.
     */
    const svgTags = {
        'circle': true,
        'clipPath': true,
        'color-profile': true,
        'cursor': true,
        'defs': true,
        'desc': true,
        'ellipse': true,
        'g': true,
        'image': true,
        'line': true,
        'linearGradient': true,
        'marker': true,
        'mask': true,
        'path': true,
        'pattern': true,
        'polygon': true,
        'polyline': true,
        'radialGradient': true,
        'rect': true,
        'stop': true,
        'svg': true,
        'text': true
    };
    /**
     * Builds a JSX based FSComponent.
     * @param type The DOM element tag that will be built.
     * @param props The properties to apply to the DOM element.
     * @param children Any children of this DOM element.
     * @returns The JSX VNode for the component or element.
     */
    // eslint-disable-next-line no-inner-declarations
    function buildComponent(type, props, ...children) {
        let vnode = null;
        if (typeof type === 'string') {
            let element;
            if (svgTags[type] !== undefined) {
                element = document.createElementNS('http://www.w3.org/2000/svg', type);
            }
            else {
                element = document.createElement(type);
            }
            if (props !== null) {
                for (const key in props) {
                    if (key === 'ref' && props.ref !== undefined) {
                        props.ref.instance = element;
                    }
                    else {
                        const prop = props[key];
                        if (prop instanceof Subject || prop instanceof MappedSubject || prop instanceof ComputedSubject) {
                            element.setAttribute(key, prop.get());
                            prop.sub((v) => {
                                element.setAttribute(key, v);
                            });
                        }
                        else {
                            element.setAttribute(key, prop);
                        }
                    }
                }
            }
            vnode = {
                instance: element,
                props: props,
                children: null
            };
            vnode.children = createChildNodes(vnode, children);
        }
        else if (typeof type === 'function') {
            if (children !== null && props === null) {
                props = {
                    children: children
                };
            }
            else if (props !== null) {
                props.children = children;
            }
            const instance = new type(props);
            if (props !== null && props.ref !== null && props.ref !== undefined) {
                props.ref.instance = instance;
            }
            vnode = {
                instance,
                props,
                children: [instance.render()]
            };
        }
        return vnode;
    }
    FSComponent.buildComponent = buildComponent;
    /**
     * Creates the collection of child VNodes.
     * @param parent The parent VNode.
     * @param children The JSX children to convert to nodes.
     * @returns A collection of child VNodes.
     */
    function createChildNodes(parent, children) {
        let vnodes = null;
        if (children !== null && children !== undefined && children.length > 0) {
            vnodes = [];
            for (const child of children) {
                if (child !== null) {
                    if (child instanceof Subject || child instanceof MappedSubject || child instanceof ComputedSubject) {
                        const subjectValue = child.get().toString();
                        const node = {
                            instance: subjectValue === '' ? ' ' : subjectValue,
                            children: null,
                            props: null,
                            root: undefined,
                        };
                        child.sub((v) => {
                            if (node.root !== undefined) {
                                // TODO workaround. gotta find a solution for the text node vanishing when text is empty
                                node.root.nodeValue = v === '' ? ' ' : v.toString();
                            }
                            else {
                                // for debugging
                                console.warn('Subject has no node!');
                            }
                        });
                        vnodes.push(node);
                    }
                    else if (child instanceof Array) {
                        const arrayNodes = createChildNodes(parent, child);
                        if (arrayNodes !== null) {
                            vnodes.push(...arrayNodes);
                        }
                    }
                    else if (typeof child === 'string' || typeof child === 'number') {
                        vnodes.push(createStaticContentNode(child));
                    }
                    else if (typeof child === 'object') {
                        vnodes.push(child);
                    }
                }
            }
        }
        return vnodes;
    }
    FSComponent.createChildNodes = createChildNodes;
    /**
     * Creates a static content VNode.
     * @param content The content to create a node for.
     * @returns A static content VNode.
     */
    function createStaticContentNode(content) {
        return {
            instance: content,
            children: null,
            props: null
        };
    }
    FSComponent.createStaticContentNode = createStaticContentNode;
    /**
     * Renders a VNode to a DOM element.
     * @param node The node to render.
     * @param element The DOM element to render to.
     * @param position The RenderPosition to put the item in.
     */
    function render(node, element, position = RenderPosition.In) {
        if (node.children && node.children.length > 0 && element !== null) {
            const componentInstance = node.instance;
            if (componentInstance.onBeforeRender !== undefined) {
                componentInstance.onBeforeRender();
            }
            if (node.instance instanceof HTMLElement || node.instance instanceof SVGElement) {
                insertNode(node, position, element);
            }
            else {
                for (const child of node.children) {
                    insertNode(child, position, element);
                }
            }
            if (componentInstance.onAfterRender !== undefined) {
                componentInstance.onAfterRender();
            }
        }
    }
    FSComponent.render = render;
    /**
     * Inserts a node into the DOM.
     * @param node The node to insert.
     * @param position The position to insert the node in.
     * @param element The element to insert relative to.
     */
    function insertNode(node, position, element) {
        var _a, _b, _c, _d, _e, _f;
        if (node.instance instanceof HTMLElement || node.instance instanceof SVGElement) {
            switch (position) {
                case RenderPosition.In:
                    element.appendChild(node.instance);
                    node.root = (_a = element.lastChild) !== null && _a !== void 0 ? _a : undefined;
                    break;
                case RenderPosition.Before:
                    element.insertAdjacentElement('beforebegin', node.instance);
                    node.root = (_b = element.previousSibling) !== null && _b !== void 0 ? _b : undefined;
                    break;
                case RenderPosition.After:
                    element.insertAdjacentElement('afterend', node.instance);
                    node.root = (_c = element.nextSibling) !== null && _c !== void 0 ? _c : undefined;
                    break;
            }
            if (node.children !== null) {
                for (const child of node.children) {
                    insertNode(child, RenderPosition.In, node.instance);
                }
            }
        }
        else if (typeof node.instance === 'string') {
            switch (position) {
                case RenderPosition.In:
                    element.insertAdjacentHTML('beforeend', node.instance);
                    node.root = (_d = element.lastChild) !== null && _d !== void 0 ? _d : undefined;
                    break;
                case RenderPosition.Before:
                    element.insertAdjacentHTML('beforebegin', node.instance);
                    node.root = (_e = element.previousSibling) !== null && _e !== void 0 ? _e : undefined;
                    break;
                case RenderPosition.After:
                    element.insertAdjacentHTML('afterend', node.instance);
                    node.root = (_f = element.nextSibling) !== null && _f !== void 0 ? _f : undefined;
                    break;
            }
        }
        else {
            render(node, element);
        }
    }
    /**
     * Render a node before a DOM element.
     * @param node The node to render.
     * @param element The element to render boeore.
     */
    function renderBefore(node, element) {
        render(node, element, RenderPosition.Before);
    }
    FSComponent.renderBefore = renderBefore;
    /**
     * Render a node after a DOM element.
     * @param node The node to render.
     * @param element The element to render after.
     */
    function renderAfter(node, element) {
        render(node, element, RenderPosition.After);
    }
    FSComponent.renderAfter = renderAfter;
    /**
     * Remove a previously rendered element.  Currently, this is just a simple
     * wrapper so that all of our high-level "component maniuplation" state is kept
     * in the FSComponent API, but it's not doing anything other than a simple
     * remove() on the element.   This can probably be enhanced.
     * @param element The element to remove.
     */
    function remove(element) {
        if (element !== null) {
            element.remove();
        }
    }
    FSComponent.remove = remove;
    /**
     * Creates a component or element node reference.
     * @returns A new component or element node reference.
     */
    function createRef() {
        return new NodeReference();
    }
    FSComponent.createRef = createRef;
    /**
     * An empty callback handler.
     */
    FSComponent.EmptyHandler = () => { return; };
})(FSComponent || (FSComponent = {}));

new Image();

/**
 * A number with an associated unit. Each NumberUnit is created with a reference unit type,
 * which cannot be changed after instantiation. The reference unit type determines how the
 * value of the NumberUnit is internally represented. Each NumberUnit also maintains an
 * active unit type, which can be dynamically changed at any time.
 */
class NumberUnit {
    /**
     * Constructor.
     * @param number - the initial numeric value of the new NumberUnit.
     * @param unit - the unit type of the new NumberUnit.
     */
    constructor(number, unit) {
        this._number = number;
        this._unit = unit;
        this.readonly = new NumberUnitReadOnly(this);
    }
    /**
     * Gets this NumberUnit's numeric value.
     * @returns this NumberUnit's numeric value.
     */
    get number() {
        return this._number;
    }
    /**
     * Gets this NumberUnit's unit type.
     * @returns this NumberUnit's unit type.
     */
    get unit() {
        return this._unit;
    }
    /**
     * Converts a value to a numeric value with this NumberUnit's unit type.
     * @param value - the value.
     * @param unit - the unit type of the new value. Defaults to this NumberUnit's unit type. This argument is ignored if
     * value is a NumberUnit.
     * @returns the numeric of the value with this NumberUnit's unit type.
     */
    toNumberOfThisUnit(value, unit) {
        if ((typeof value !== 'number') && this.unit.family === value.unit.family) {
            return this.unit.convertFrom(value.number, value.unit);
        }
        if (typeof value === 'number') {
            return unit ? this.unit.convertFrom(value, unit) : value;
        }
        return undefined;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        const converted = this.toNumberOfThisUnit(arg1, arg2);
        if (converted !== undefined) {
            this._number = converted;
            return this;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    add(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const converted = this.toNumberOfThisUnit(arg1, isArg2NumberUnit ? undefined : arg2);
        if (converted !== undefined) {
            let out = isArg2NumberUnit ? arg2 : arg3;
            if (out) {
                out.set(this.number + converted, this.unit);
            }
            else {
                out = this;
                this._number += converted;
            }
            return out;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    subtract(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const converted = this.toNumberOfThisUnit(arg1, isArg2NumberUnit ? undefined : arg2);
        if (converted !== undefined) {
            let out = isArg2NumberUnit ? arg2 : arg3;
            if (out) {
                out.set(this.number - converted, this.unit);
            }
            else {
                out = this;
                this._number -= converted;
            }
            return out;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    /**
     * Scales this NumberUnit by a unit-less factor and returns the result.
     * @param factor - the factor by which to scale.
     * @param out - the NumberUnit to which to write the result. Defaults to this NumberUnit.
     * @returns the scaled NumberUnit, or undefined if the operation could not be carried out.
     */
    scale(factor, out) {
        if (out) {
            return out.set(this.number * factor, this.unit);
        }
        else {
            this._number *= factor;
            return this;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    ratio(value, unit) {
        const converted = this.toNumberOfThisUnit(value, unit);
        if (converted) {
            return this.number / converted;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    /**
     * Calculates the absolute value of this NumberUnit and returns the result.
     * @param out - the NumberUnit to which to write the result. Defaults to this NumberUnit.
     * @returns the absolute value, or undefined if the operation could not be carried out.
     */
    abs(out) {
        if (out) {
            out.set(Math.abs(this.number), this.unit);
            return this;
        }
        else {
            this._number = Math.abs(this._number);
            return this;
        }
    }
    /**
     * Returns the numeric value of this NumberUnit after conversion to a specified unit.
     * @param unit - the unit to which to convert.
     * @returns the converted numeric value.
     * @throws Error if this NumberUnit's unit type cannot be converted to the specified unit.
     */
    asUnit(unit) {
        return this.unit.convertTo(this.number, unit);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    compare(value, unit) {
        const converted = this.toNumberOfThisUnit(value, unit);
        if (converted === undefined) {
            throw new Error('Invalid unit conversion attempted.');
        }
        const diff = this.number - converted;
        if (Math.abs(diff) < 1e-14) {
            return 0;
        }
        return Math.sign(diff);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(value, unit) {
        const converted = this.toNumberOfThisUnit(value, unit);
        if (converted === undefined) {
            return false;
        }
        const diff = this.number - converted;
        return Math.abs(diff) < 1e-14;
    }
    /**
     * Checks whether this NumberUnit has a numeric value of NaN.
     * @returns whether this NumberUnit has a numeric value of NaN.
     */
    isNaN() {
        return isNaN(this.number);
    }
    /**
     * Copies this NumberUnit.
     * @returns a copy of this NumberUnit.
     */
    copy() {
        return new NumberUnit(this.number, this.unit);
    }
}
/**
 * A read-only interface for a WT_NumberUnit.
 */
class NumberUnitReadOnly {
    /**
     * Constructor.
     * @param source - the source of the new read-only NumberUnit.
     */
    constructor(source) {
        this.source = source;
    }
    /**
     * Gets this NumberUnit's numeric value.
     * @returns this NumberUnit's numeric value.
     */
    get number() {
        return this.source.number;
    }
    /**
     * Gets this NumberUnit's unit type.
     * @returns this NumberUnit's unit type.
     */
    get unit() {
        return this.source.unit;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    add(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const out = isArg2NumberUnit ? arg2 : arg3;
        if (!out) {
            throw new Error('Cannot mutate a read-only NumberUnit.');
        }
        if (typeof arg1 === 'number') {
            return this.source.add(arg1, arg2, arg3);
        }
        else {
            return this.source.add(arg1, arg2);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    subtract(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const out = isArg2NumberUnit ? arg2 : arg3;
        if (!out) {
            throw new Error('Cannot mutate a read-only NumberUnit.');
        }
        if (typeof arg1 === 'number') {
            return this.source.subtract(arg1, arg2, arg3);
        }
        else {
            return this.source.subtract(arg1, arg2);
        }
    }
    /**
     * Scales this NumberUnit by a unit-less factor and returns the result.
     * @param factor - the factor by which to scale.
     * @param out - the NumberUnit to which to write the result.
     * @returns the scaled NumberUnit.
     * @throws Error if argument out is not specified.
     */
    scale(factor, out) {
        if (!out) {
            throw new Error('Cannot mutate a read-only NumberUnit.');
        }
        return this.source.scale(factor, out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    ratio(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.ratio(arg1, arg2);
        }
        else {
            return this.source.ratio(arg1);
        }
    }
    /**
     * Calculates the absolute value of this NumberUnit and returns the result.
     * @param out - the NumberUnit to which to write the result.
     * @returns the absolute value.
     * @throws Error if argument out is not specified.
     */
    abs(out) {
        if (!out) {
            throw new Error('Cannot mutate a read-only NumberUnit.');
        }
        return this.source.abs(out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    asUnit(unit) {
        return this.source.asUnit(unit);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    compare(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.compare(arg1, arg2);
        }
        else {
            return this.source.compare(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.equals(arg1, arg2);
        }
        else {
            return this.source.equals(arg1);
        }
    }
    /**
     * Checks whether this NumberUnit has a numeric value of NaN.
     * @returns whether this NumberUnit has a numeric value of NaN.
     */
    isNaN() {
        return this.source.isNaN();
    }
    /**
     * Copies this NumberUnit.
     * @returns a copy of this NumberUnit.
     */
    copy() {
        return this.source.copy();
    }
}
/**
 * A unit of measurement.
 */
class AbstractUnit {
    /**
     * Constructor.
     * @param name The name of this unit.
     */
    constructor(name) {
        this.name = name;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
        return this.family === otherUnit.family;
    }
    /** @inheritdoc */
    createNumber(value) {
        return new NumberUnit(value, this);
    }
    /** @inheritdoc */
    equals(other) {
        return this.family === other.family && this.name === other.name;
    }
}
/**
 * A unit that can be converted to another unit of the same type via a fixed linear transformation.
 */
class SimpleUnit extends AbstractUnit {
    /**
     * Constructor.
     * @param family The family to which this unit belongs.
     * @param name The name of this unit.
     * @param scaleFactor The relative linear scale of the new unit compared to the standard unit of the same family.
     * @param zeroOffset The zero offset of the new unit compared to the standard unit of the same family.
     */
    constructor(family, name, scaleFactor, zeroOffset = 0) {
        super(name);
        this.family = family;
        this.scaleFactor = scaleFactor;
        this.zeroOffset = zeroOffset;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
        return otherUnit instanceof SimpleUnit && super.canConvert(otherUnit);
    }
    /** @inheritdoc */
    convertTo(value, toUnit) {
        if (!this.canConvert(toUnit)) {
            throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
        }
        return (value + this.zeroOffset) * (this.scaleFactor / toUnit.scaleFactor) - toUnit.zeroOffset;
    }
    /** @inheritdoc */
    convertFrom(value, fromUnit) {
        if (!this.canConvert(fromUnit)) {
            throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
        }
        return (value + fromUnit.zeroOffset) * (fromUnit.scaleFactor / this.scaleFactor) - this.zeroOffset;
    }
}
/**
 * A unit of measure composed of the multiplicative combination of multiple elementary units.
 */
class CompoundUnit extends AbstractUnit {
    /**
     * Constructor.
     * @param numerator An array of CompoundableUnits containing all the units in the numerator of the compound unit.
     * @param denominator An array of CompoundableUnits containing all the units in the denominator of the compound unit.
     * @param name The name of this unit. If not defined, one will be automatically generated.
     */
    constructor(numerator, denominator, name) {
        // if not specified, build name from component units.
        if (name === undefined) {
            name = '';
            let i = 0;
            while (i < numerator.length - 1) {
                name += `${numerator[i].name}-`;
            }
            name += `${numerator[i].name}`;
            if (denominator.length > 0) {
                name += ' per ';
                i = 0;
                while (i < denominator.length - 1) {
                    name += `${denominator[i].name}-`;
                }
                name += `${denominator[i].name}`;
            }
        }
        super(name);
        this.numerator = Array.from(numerator);
        this.denominator = Array.from(denominator);
        this.numerator.sort((a, b) => a.family.localeCompare(b.family));
        this.denominator.sort((a, b) => a.family.localeCompare(b.family));
        this.family = this.getFamily();
        this.scaleFactor = this.getScaleFactor();
    }
    /**
     * Gets the family string for this unit.
     * @returns the family string for this unit.
     */
    getFamily() {
        let family = this.numerator.map(e => e.family) + '';
        family += (this.denominator.length > 0) ? ('/' + this.denominator.map(e => e.family) + '') : '';
        return family;
    }
    /**
     * Gets the scale factor for this unit.
     * @returns the scale factor for this unit.
     */
    getScaleFactor() {
        let factor = 1;
        factor = this.numerator.reduce((prev, curr) => prev * curr.scaleFactor, factor);
        factor = this.denominator.reduce((prev, curr) => prev / curr.scaleFactor, factor);
        return factor;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
        return otherUnit instanceof CompoundUnit && super.canConvert(otherUnit);
    }
    /** @inheritdoc */
    convertTo(value, toUnit) {
        if (!this.canConvert(toUnit)) {
            throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
        }
        return value * (this.scaleFactor / toUnit.scaleFactor);
    }
    /** @inheritdoc */
    convertFrom(value, fromUnit) {
        if (!this.canConvert(fromUnit)) {
            throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
        }
        return value * (fromUnit.scaleFactor / this.scaleFactor);
    }
}
var UnitFamily;
(function (UnitFamily) {
    UnitFamily["DISTANCE"] = "distance";
    UnitFamily["ANGLE"] = "angle";
    UnitFamily["DURATION"] = "duration";
    UnitFamily["WEIGHT"] = "weight";
    UnitFamily["VOLUME"] = "volume";
    UnitFamily["PRESSURE"] = "pressure";
    UnitFamily["TEMP"] = "temperature";
})(UnitFamily || (UnitFamily = {}));
/**
 * Predefined unit types.
 */
class UnitType {
}
UnitType.METER = new SimpleUnit(UnitFamily.DISTANCE, 'meter', 1);
UnitType.FOOT = new SimpleUnit(UnitFamily.DISTANCE, 'foot', 0.3048);
UnitType.KILOMETER = new SimpleUnit(UnitFamily.DISTANCE, 'kilometer', 1000);
UnitType.MILE = new SimpleUnit(UnitFamily.DISTANCE, 'mile', 1609.34);
UnitType.NMILE = new SimpleUnit(UnitFamily.DISTANCE, 'nautical mile', 1852);
UnitType.GA_RADIAN = new SimpleUnit(UnitFamily.DISTANCE, 'great arc radian', 6378100);
UnitType.RADIAN = new SimpleUnit(UnitFamily.ANGLE, 'radian', 1);
UnitType.DEGREE = new SimpleUnit(UnitFamily.ANGLE, 'degree', Math.PI / 180);
UnitType.ARC_MIN = new SimpleUnit(UnitFamily.ANGLE, 'minute', Math.PI / 180 / 60);
UnitType.ARC_SEC = new SimpleUnit(UnitFamily.ANGLE, 'second', Math.PI / 180 / 3600);
UnitType.MILLISECOND = new SimpleUnit(UnitFamily.DURATION, 'millisecond', 0.001);
UnitType.SECOND = new SimpleUnit(UnitFamily.DURATION, 'second', 1);
UnitType.MINUTE = new SimpleUnit(UnitFamily.DURATION, 'minute', 60);
UnitType.HOUR = new SimpleUnit(UnitFamily.DURATION, 'hour', 3600);
UnitType.KILOGRAM = new SimpleUnit(UnitFamily.WEIGHT, 'kilogram', 1);
UnitType.POUND = new SimpleUnit(UnitFamily.WEIGHT, 'pound', 0.453592);
UnitType.TON = new SimpleUnit(UnitFamily.WEIGHT, 'ton', 907.185);
UnitType.TONNE = new SimpleUnit(UnitFamily.WEIGHT, 'tonne', 1000);
// the following fuel units use the generic conversion factor of 1 gal = 6.7 lbs
UnitType.LITER_FUEL = new SimpleUnit(UnitFamily.WEIGHT, 'liter', 0.80283679);
UnitType.GALLON_FUEL = new SimpleUnit(UnitFamily.WEIGHT, 'gallon', 3.0390664);
UnitType.LITER = new SimpleUnit(UnitFamily.VOLUME, 'liter', 1);
UnitType.GALLON = new SimpleUnit(UnitFamily.VOLUME, 'gallon', 3.78541);
UnitType.HPA = new SimpleUnit(UnitFamily.PRESSURE, 'hectopascal', 1);
UnitType.ATM = new SimpleUnit(UnitFamily.PRESSURE, 'atmosphere', 1013.25);
UnitType.IN_HG = new SimpleUnit(UnitFamily.PRESSURE, 'inch of mercury', 33.8639);
UnitType.MM_HG = new SimpleUnit(UnitFamily.PRESSURE, 'millimeter of mercury', 1.33322);
UnitType.CELSIUS = new SimpleUnit(UnitFamily.TEMP, '° Celsius', 1, 273.15);
UnitType.FAHRENHEIT = new SimpleUnit(UnitFamily.TEMP, '° Fahrenheit', 5 / 9, 459.67);
UnitType.KNOT = new CompoundUnit([UnitType.NMILE], [UnitType.HOUR], 'knot');
UnitType.KPH = new CompoundUnit([UnitType.KILOMETER], [UnitType.HOUR]);
UnitType.MPM = new CompoundUnit([UnitType.METER], [UnitType.MINUTE]);
UnitType.MPS = new CompoundUnit([UnitType.METER], [UnitType.SECOND]);
UnitType.FPM = new CompoundUnit([UnitType.FOOT], [UnitType.MINUTE]);
UnitType.FPS = new CompoundUnit([UnitType.FOOT], [UnitType.SECOND]);
UnitType.KGH = new CompoundUnit([UnitType.KILOGRAM], [UnitType.HOUR]);
UnitType.PPH = new CompoundUnit([UnitType.POUND], [UnitType.HOUR]);
UnitType.LPH_FUEL = new CompoundUnit([UnitType.LITER_FUEL], [UnitType.HOUR]);
UnitType.GPH_FUEL = new CompoundUnit([UnitType.GALLON_FUEL], [UnitType.HOUR]);

/**
 * A class for conversions of degree units.
 */
class Degrees {
    constructor() {
        /**
         * Converts degrees to radians.
         * @param degrees The degrees to convert.
         * @returns The result as radians.
         */
        this.toRadians = (degrees) => degrees * (Math.PI / 180);
    }
}
/**
 * A class for conversions of foot units.
 */
class Feet {
    constructor() {
        /**
         * Converts feet to meters.
         * @param feet The feet to convert.
         * @returns The result as meters.
         */
        this.toMeters = (feet) => feet * 0.3048;
        /**
         * Converts feet to nautical miles.
         * @param feet The feet to convert.
         * @returns The result as nautical miles.
         */
        this.toNauticalMiles = (feet) => feet / 6076.11549;
    }
}
/**
 * A class for conversions of meter units.
 */
class Meters {
    constructor() {
        /**
         * Converts meters to feet.
         * @param meters The meters to convert.
         * @returns The result as feet.
         */
        this.toFeet = (meters) => meters / 0.3048;
        /**
         * Converts meters to nautical miles.
         * @param meters The meters to convert.
         * @returns The result as nautical miles.
         */
        this.toNauticalMiles = (meters) => meters / 1852;
    }
}
/**
 * A class for conversions of nautical mile units.
 */
class NauticalMiles {
    constructor() {
        /**
         * Converts nautical miles to feet.
         * @param nm The nautical miles to convert.
         * @returns The result as feet.
         */
        this.toFeet = (nm) => nm * 6076.11549;
        /**
         * Converts nautical miles to meters.
         * @param nm The nautical miles to convert.
         * @returns The result as meters.
         */
        this.toMeters = (nm) => nm * 1852;
    }
}
/**
 * A class for conversions of radian units.
 */
class Radians {
    constructor() {
        /**
         * Converts radians to degrees.
         * @param radians The radians to convert.
         * @returns The result as degrees.
         */
        this.toDegrees = (radians) => radians * 180 / Math.PI;
    }
}
/**
 * A class for unit conversions.
 */
class Units {
}
/** The degrees unit. */
Units.Degrees = new Degrees();
/** The radians unit. */
Units.Radians = new Radians();
/** The feet unit. */
Units.Feet = new Feet();
/** The meters unit. */
Units.Meters = new Meters();
/** The nautical miles unit. */
Units.NauticalMiles = new NauticalMiles();

/**
 * 2D vector mathematical opertaions.
 */
class Vec2Math {
    /**
     * Gets the polar angle theta of a vector in radians.
     * @param vec - a vector.
     * @returns the polar angle theta of the vector.
     */
    static theta(vec) {
        return Math.atan2(vec[1], vec[0]);
    }
    /**
     * Sets the components of a vector.
     * @param x - the new x-component.
     * @param y - the new y-component.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static set(x, y, vec) {
        vec[0] = x;
        vec[1] = y;
        return vec;
    }
    /**
     * Sets the polar components of a vector.
     * @param r - the new length (magnitude).
     * @param theta - the new polar angle theta, in radians.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static setFromPolar(r, theta, vec) {
        vec[0] = r * Math.cos(theta);
        vec[1] = r * Math.sin(theta);
        return vec;
    }
    /**
     * Add one vector to another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector sum.
     */
    static add(v1, v2, out) {
        out[0] = v1[0] + v2[0];
        out[1] = v1[1] + v2[1];
        return out;
    }
    /**
     * Subtracts one vector from another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector difference.
     */
    static sub(v1, v2, out) {
        out[0] = v1[0] - v2[0];
        out[1] = v1[1] - v2[1];
        return out;
    }
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     */
    static dot(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1];
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v1 The vector to multiply.
     * @param scalar The scalar to apply.
     * @param out The vector to write the results to.
     * @returns The scaled vector.
     */
    static multScalar(v1, scalar, out) {
        out[0] = v1[0] * scalar;
        out[1] = v1[1] * scalar;
        return out;
    }
    /**
     * Gets the magnitude of a vector.
     * @param v1 The vector to get the magnitude for.
     * @returns the vector's magnitude.
     */
    static abs(v1) {
        return Math.hypot(v1[0], v1[1]);
    }
    /**
     * Normalizes the vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns the normalized vector.
     */
    static normalize(v1, out) {
        const mag = Vec2Math.abs(v1);
        out[0] = v1[0] / mag;
        out[1] = v1[1] / mag;
        return out;
    }
    /**
     * Gets the normal of the supplied vector.
     * @param v1 The vector to get the normal for.
     * @param out The vector to write the results to.
     * @param counterClockwise Whether or not to get the counterclockwise normal.
     * @returns the normal vector.
     */
    static normal(v1, out, counterClockwise = false) {
        const x = v1[0];
        const y = v1[1];
        if (!counterClockwise) {
            out[0] = y;
            out[1] = -x;
        }
        else {
            out[0] = -y;
            out[1] = x;
        }
        return out;
    }
    /**
     * Gets the Euclidean distance between two vectors.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns the Euclidean distance between the two vectors.
     */
    static distance(vec1, vec2) {
        return Math.hypot(vec2[0] - vec1[0], vec2[1] - vec1[0]);
    }
    /**
     * Checks if two vectors are equal.
     * @param vec1 - the first vector.
     * @param vec2 - the second vector.
     * @returns whether the two vectors are equal.
     */
    static equals(vec1, vec2) {
        return vec1.length === vec2.length && vec1.every((element, index) => element === vec2[index]);
    }
    /**
     * Copies one vector to another.
     * @param from - the vector from which to copy.
     * @param to - the vector to which to copy.
     * @returns the changed vector.
     */
    static copy(from, to) {
        return Vec2Math.set(from[0], from[1], to);
    }
}
/**
 * 3D vector mathematical opertaions.
 */
class Vec3Math {
    /**
     * Gets the spherical angle theta of a vector in radians.
     * @param vec - a vector.
     * @returns the spherical angle theta of the vector.
     */
    static theta(vec) {
        return Math.atan2(Math.hypot(vec[0], vec[1]), vec[2]);
    }
    /**
     * Gets the spherical angle phi of a vector in radians.
     * @param vec - a vector.
     * @returns the spherical angle phi of the vector.
     */
    static phi(vec) {
        return Math.atan2(vec[1], vec[0]);
    }
    /**
     * Sets the components of a vector.
     * @param x - the new x-component.
     * @param y - the new y-component.
     * @param z - the new z-component.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static set(x, y, z, vec) {
        vec[0] = x;
        vec[1] = y;
        vec[2] = z;
        return vec;
    }
    /**
     * Sets the spherical components of a vector.
     * @param r - the new length (magnitude).
     * @param theta - the new spherical angle theta, in radians.
     * @param phi - the new spherical angle phi, in radians.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static setFromSpherical(r, theta, phi, vec) {
        const sinTheta = Math.sin(theta);
        vec[0] = sinTheta * Math.cos(phi);
        vec[1] = sinTheta * Math.sin(phi);
        vec[2] = Math.cos(theta);
        return vec;
    }
    /**
     * Add one vector to another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector sum.
     */
    static add(v1, v2, out) {
        out[0] = v1[0] + v2[0];
        out[1] = v1[1] + v2[1];
        out[2] = v1[2] + v2[2];
        return out;
    }
    /**
     * Subtracts one vector from another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector difference.
     */
    static sub(v1, v2, out) {
        out[0] = v1[0] - v2[0];
        out[1] = v1[1] - v2[1];
        out[2] = v1[2] - v2[2];
        return out;
    }
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     */
    static dot(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
    }
    /**
     * Gets the cross product of two vectors.
     * @param v1 - the first vector.
     * @param v2 - the second vector.
     * @param out - the vector to which to write the result.
     * @returns the cross product.
     */
    static cross(v1, v2, out) {
        const x1 = v1[0];
        const y1 = v1[1];
        const z1 = v1[2];
        const x2 = v2[0];
        const y2 = v2[1];
        const z2 = v2[2];
        out[0] = y1 * z2 - z1 * y2;
        out[1] = z1 * x2 - x1 * z2;
        out[2] = x1 * y2 - y1 * x2;
        return out;
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v1 The vector to multiply.
     * @param scalar The scalar to apply.
     * @param out The vector to write the results to.
     * @returns The scaled vector.
     */
    static multScalar(v1, scalar, out) {
        out[0] = v1[0] * scalar;
        out[1] = v1[1] * scalar;
        out[2] = v1[2] * scalar;
        return out;
    }
    /**
     * Gets the magnitude of a vector.
     * @param v1 The vector to get the magnitude for.
     * @returns the vector's magnitude.
     */
    static abs(v1) {
        return Math.hypot(v1[0], v1[1], v1[2]);
    }
    /**
     * Normalizes the vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns the normalized vector.
     */
    static normalize(v1, out) {
        const mag = Vec3Math.abs(v1);
        out[0] = v1[0] / mag;
        out[1] = v1[1] / mag;
        out[2] = v1[2] / mag;
        return out;
    }
    /**
     * Gets the Euclidean distance between two vectors.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns the Euclidean distance between the two vectors.
     */
    static distance(vec1, vec2) {
        return Math.hypot(vec2[0] - vec1[0], vec2[1] - vec1[0], vec2[2] - vec1[2]);
    }
    /**
     * Checks if two vectors are equal.
     * @param vec1 - the first vector.
     * @param vec2 - the second vector.
     * @returns whether the two vectors are equal.
     */
    static equals(vec1, vec2) {
        return vec1.length === vec2.length && vec1.every((element, index) => element === vec2[index]);
    }
    /**
     * Copies one vector to another.
     * @param from - the vector from which to copy.
     * @param to - the vector to which to copy.
     * @returns the changed vector.
     */
    static copy(from, to) {
        return Vec3Math.set(from[0], from[1], from[2], to);
    }
}

/**
 * A read-only wrapper for a GeoPoint.
 */
class GeoPointReadOnly {
    /**
     * Constructor.
     * @param source - the source of the new read-only point.
     */
    constructor(source) {
        this.source = source;
    }
    /**
     * The latitude of this point, in degrees.
     * @returns the latitude of this point.
     */
    get lat() {
        return this.source.lat;
    }
    /**
     * The longitude of this point, in degrees.
     * @returns the longitude of this point.
     */
    get lon() {
        return this.source.lon;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distance(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.distance(arg1, arg2);
        }
        else {
            return this.source.distance(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distanceRhumb(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.distanceRhumb(arg1, arg2);
        }
        else {
            return this.source.distanceRhumb(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingTo(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.bearingTo(arg1, arg2);
        }
        else {
            return this.source.bearingTo(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingFrom(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.bearingFrom(arg1, arg2);
        }
        else {
            return this.source.bearingFrom(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingRhumb(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.bearingRhumb(arg1, arg2);
        }
        else {
            return this.source.bearingRhumb(arg1);
        }
    }
    /**
     * Offsets this point by an initial bearing and distance along a great circle.
     * @param bearing - the initial bearing (forward azimuth) by which to offset.
     * @param distance - the distance, in great-arc radians, by which to offset.
     * @param out - the GeoPoint to which to write the results. If not supplied, a new GeoPoint object is created.
     * @returns the offset point.
     * @throws {Error} argument out cannot be undefined.
     */
    offset(bearing, distance, out) {
        if (!out) {
            throw new Error('Cannot mutate a read-only GeoPoint.');
        }
        return this.source.offset(bearing, distance, out);
    }
    /**
     * Offsets this point by a constant bearing and distance along a rhumb line.
     * @param bearing - the bearing by which to offset.
     * @param distance - the distance, in great-arc radians, by which to offset.
     * @param out - the GeoPoint to which to write the results. If not supplied, a new GeoPoint object is created.
     * @returns the offset point.
     * @throws {Error} argument out cannot be undefined.
     */
    offsetRhumb(bearing, distance, out) {
        if (!out) {
            throw new Error('Cannot mutate a read-only GeoPoint.');
        }
        return this.source.offsetRhumb(bearing, distance, out);
    }
    /**
     * Calculates the cartesian (x, y, z) representation of this point, in units of great-arc radians. By convention,
     * in the cartesian coordinate system the origin is at the center of the Earth, the positive x-axis passes through
     * 0 degrees N, 0 degrees E, and the positive z-axis passes through the north pole.
     * @param out - the vector array to which to write the result.
     * @returns the cartesian representation of this point.
     */
    toCartesian(out) {
        return this.source.toCartesian(out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2, arg3) {
        if (typeof arg1 === 'number') {
            return this.source.equals(arg1, arg2, arg3);
        }
        else {
            return this.source.equals(arg1, arg2);
        }
    }
    /**
     * Copies this point.
     * @param to - an optional point to which to copy this point. If this argument is not supplied, a new GeoPoint object
     * will be created.
     * @returns a copy of this point.
     */
    copy(to) {
        return this.source.copy(to);
    }
}
/**
 * A point on Earth's surface. This class uses a spherical Earth model.
 */
class GeoPoint {
    /**
     * Constructor.
     * @param lat - the latitude, in degrees.
     * @param lon - the longitude, in degrees.
     */
    constructor(lat, lon) {
        this._lat = 0;
        this._lon = 0;
        this.set(lat, lon);
        this.readonly = new GeoPointReadOnly(this);
    }
    /**
     * The latitude of this point, in degrees.
     * @returns the latitude of this point.
     */
    get lat() {
        return this._lat;
    }
    /**
     * The longitude of this point, in degrees.
     * @returns the longitude of this point.
     */
    get lon() {
        return this._lon;
    }
    /**
     * Converts an argument list consisting of either a LatLonInterface or lat/lon coordinates into an equivalent
     * LatLonInterface.
     * @param arg1 Argument 1.
     * @param arg2 Argument 2.
     * @returns a LatLonInterface.
     */
    static asLatLonInterface(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return GeoPoint.tempGeoPoint.set(arg1, arg2);
        }
        else {
            return arg1;
        }
    }
    /**
     * Converts an argument list consisting of either a 3D vector or x, y, z components into an equivalent 3D vector.
     * @param arg1 Argument 1.
     * @param arg2 Argument 2.
     * @param arg3 Argument 3.
     * @returns a 3D vector.
     */
    static asVec3(arg1, arg2, arg3) {
        if (typeof arg1 === 'number') {
            return Vec3Math.set(arg1, arg2, arg3, GeoPoint.tempVec3);
        }
        else {
            return arg1;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        let lat, lon;
        if (typeof arg1 === 'number') {
            lat = arg1;
            lon = arg2;
        }
        else {
            lat = arg1.lat;
            lon = arg1.lon;
        }
        lat = GeoPoint.toPlusMinus180(lat);
        lon = GeoPoint.toPlusMinus180(lon);
        if (Math.abs(lat) > 90) {
            lat = 180 - lat;
            lat = GeoPoint.toPlusMinus180(lat);
            lon += 180;
            lon = GeoPoint.toPlusMinus180(lon);
        }
        this._lat = lat;
        this._lon = lon;
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setFromCartesian(arg1, arg2, arg3) {
        const vec = GeoPoint.asVec3(arg1, arg2, arg3);
        const theta = Vec3Math.theta(vec);
        const phi = Vec3Math.phi(vec);
        return this.set(90 - theta * Avionics.Utils.RAD2DEG, phi * Avionics.Utils.RAD2DEG);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distance(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        const lat1 = this.lat * Avionics.Utils.DEG2RAD;
        const lat2 = other.lat * Avionics.Utils.DEG2RAD;
        const lon1 = this.lon * Avionics.Utils.DEG2RAD;
        const lon2 = other.lon * Avionics.Utils.DEG2RAD;
        // haversine formula
        const sinHalfDeltaLat = Math.sin((lat2 - lat1) / 2);
        const sinHalfDeltaLon = Math.sin((lon2 - lon1) / 2);
        const a = sinHalfDeltaLat * sinHalfDeltaLat + Math.cos(lat1) * Math.cos(lat2) * sinHalfDeltaLon * sinHalfDeltaLon;
        return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distanceRhumb(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        const lat1 = this.lat * Avionics.Utils.DEG2RAD;
        const lat2 = other.lat * Avionics.Utils.DEG2RAD;
        const lon1 = this.lon * Avionics.Utils.DEG2RAD;
        const lon2 = other.lon * Avionics.Utils.DEG2RAD;
        const deltaLat = lat2 - lat1;
        let deltaLon = lon2 - lon1;
        const deltaPsi = GeoPoint.deltaPsi(lat1, lat2);
        const correction = GeoPoint.rhumbCorrection(deltaPsi, lat1, lat2);
        if (Math.abs(deltaLon) > Math.PI) {
            deltaLon += -Math.sign(deltaLon) * 2 * Math.PI;
        }
        return Math.sqrt(deltaLat * deltaLat + correction * correction * deltaLon * deltaLon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingTo(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.calculateInitialBearing(this, other);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingFrom(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return (GeoPoint.calculateInitialBearing(this, other) + 180) % 360;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingRhumb(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        const lat1 = this.lat * Avionics.Utils.DEG2RAD;
        const lon1 = this.lon * Avionics.Utils.DEG2RAD;
        const lat2 = other.lat * Avionics.Utils.DEG2RAD;
        const lon2 = other.lon * Avionics.Utils.DEG2RAD;
        let deltaLon = lon2 - lon1;
        const deltaPsi = GeoPoint.deltaPsi(lat1, lat2);
        if (Math.abs(deltaLon) > Math.PI) {
            deltaLon += -Math.sign(deltaLon) * 2 * Math.PI;
        }
        return Math.atan2(deltaLon, deltaPsi) * Avionics.Utils.RAD2DEG;
    }
    /**
     * Offsets this point by an initial bearing and distance along a great circle.
     * @param bearing - the initial bearing (forward azimuth) by which to offset.
     * @param distance - the distance, in great-arc radians, by which to offset.
     * @param out - the GeoPoint to which to write the results. By default this point.
     * @returns the offset point.
     */
    offset(bearing, distance, out) {
        const latRad = this.lat * Avionics.Utils.DEG2RAD;
        const lonRad = this.lon * Avionics.Utils.DEG2RAD;
        const sinLat = Math.sin(latRad);
        const cosLat = Math.cos(latRad);
        const sinBearing = Math.sin(bearing * Avionics.Utils.DEG2RAD);
        const cosBearing = Math.cos(bearing * Avionics.Utils.DEG2RAD);
        const angularDistance = distance;
        const sinAngularDistance = Math.sin(angularDistance);
        const cosAngularDistance = Math.cos(angularDistance);
        const offsetLatRad = Math.asin(sinLat * cosAngularDistance + cosLat * sinAngularDistance * cosBearing);
        const offsetLonDeltaRad = Math.atan2(sinBearing * sinAngularDistance * cosLat, cosAngularDistance - sinLat * Math.sin(offsetLatRad));
        const offsetLat = offsetLatRad * Avionics.Utils.RAD2DEG;
        const offsetLon = (lonRad + offsetLonDeltaRad) * Avionics.Utils.RAD2DEG;
        return (out !== null && out !== void 0 ? out : this).set(offsetLat, offsetLon);
    }
    /**
     * Offsets this point by a constant bearing and distance along a rhumb line.
     * @param bearing - the bearing by which to offset.
     * @param distance - the distance, in great-arc radians, by which to offset.
     * @param out - the GeoPoint to which to write the results. By default this point.
     * @returns the offset point.
     */
    offsetRhumb(bearing, distance, out) {
        const latRad = this.lat * Avionics.Utils.DEG2RAD;
        const lonRad = this.lon * Avionics.Utils.DEG2RAD;
        const bearingRad = bearing * Avionics.Utils.DEG2RAD;
        const deltaLat = distance * Math.cos(bearingRad);
        let offsetLat = latRad + deltaLat;
        let offsetLon;
        if (Math.abs(offsetLat) >= Math.PI / 2) {
            // you can't technically go past the poles along a rhumb line, so we will simply terminate the path at the pole
            offsetLat = Math.sign(offsetLat) * 90;
            offsetLon = 0; // since longitude is meaningless at the poles, we'll arbitrarily pick a longitude of 0 degrees.
        }
        else {
            const deltaPsi = GeoPoint.deltaPsi(latRad, offsetLat);
            const correction = GeoPoint.rhumbCorrection(deltaPsi, latRad, offsetLat);
            const deltaLon = distance * Math.sin(bearingRad) / correction;
            offsetLon = lonRad + deltaLon;
            offsetLat *= Avionics.Utils.RAD2DEG;
            offsetLon *= Avionics.Utils.RAD2DEG;
        }
        return (out !== null && out !== void 0 ? out : this).set(offsetLat, offsetLon);
    }
    /**
     * Calculates the cartesian (x, y, z) representation of this point, in units of great-arc radians. By convention,
     * in the cartesian coordinate system the origin is at the center of the Earth, the positive x-axis passes through
     * 0 degrees N, 0 degrees E, and the positive z-axis passes through the north pole.
     * @param out - the vector array to which to write the result.
     * @returns the cartesian representation of this point.
     */
    toCartesian(out) {
        return GeoPoint.sphericalToCartesian(this, out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2, arg3) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        const tolerance = typeof arg1 === 'number' ? arg3 : arg2;
        if (other) {
            return this.distance(other) <= (tolerance !== null && tolerance !== void 0 ? tolerance : GeoPoint.EQUALITY_TOLERANCE);
        }
        else {
            return false;
        }
    }
    /**
     * Copies this point.
     * @param to - an optional point to which to copy this point. If this argument is not supplied, a new GeoPoint object
     * will be created.
     * @returns a copy of this point.
     */
    copy(to) {
        return to ? to.set(this.lat, this.lon) : new GeoPoint(this.lat, this.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static sphericalToCartesian(arg1, arg2, arg3) {
        const point = GeoPoint.asLatLonInterface(arg1, arg2);
        const theta = (90 - point.lat) * Avionics.Utils.DEG2RAD;
        const phi = point.lon * Avionics.Utils.DEG2RAD;
        return Vec3Math.setFromSpherical(1, theta, phi, arg3 !== null && arg3 !== void 0 ? arg3 : arg2);
    }
    /**
     * Converts an angle, in degrees, to an equivalent value in the range [-180, 180).
     * @param angle - an angle in degrees.
     * @returns the angle's equivalent in the range [-180, 180).
     */
    static toPlusMinus180(angle) {
        return ((angle % 360) + 540) % 360 - 180;
    }
    /**
     * Calculates the initial bearing (forward azimuth) from an origin point to a destination point.
     * @param origin - the origin point.
     * @param destination - the destination point.
     * @returns the initial bearing from the origin to destination.
     */
    static calculateInitialBearing(origin, destination) {
        const lat1 = origin.lat * Avionics.Utils.DEG2RAD;
        const lat2 = destination.lat * Avionics.Utils.DEG2RAD;
        const lon1 = origin.lon * Avionics.Utils.DEG2RAD;
        const lon2 = destination.lon * Avionics.Utils.DEG2RAD;
        const cosLat2 = Math.cos(lat2);
        const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * cosLat2 * Math.cos(lon2 - lon1);
        const y = Math.sin(lon2 - lon1) * cosLat2;
        const bearing = Math.atan2(y, x) * Avionics.Utils.RAD2DEG;
        return (bearing + 360) % 360; // enforce range [0, 360)
    }
    /**
     * Calculates the difference in isometric latitude from a pair of geodetic (geocentric) latitudes.
     * @param latRad1 - geodetic latitude 1, in radians.
     * @param latRad2 - geodetic latitude 2, in radians.
     * @returns the difference in isometric latitude from latitude 1 to latitude 2, in radians.
     */
    static deltaPsi(latRad1, latRad2) {
        return Math.log(Math.tan(latRad2 / 2 + Math.PI / 4) / Math.tan(latRad1 / 2 + Math.PI / 4));
    }
    /**
     * Calculates the rhumb correction factor between two latitudes.
     * @param deltaPsi - the difference in isometric latitude beween the two latitudes.
     * @param latRad1 - geodetic latitude 1, in radians.
     * @param latRad2 - geodetic latitude 2, in radians.
     * @returns the rhumb correction factor between the two latitudes.
     */
    static rhumbCorrection(deltaPsi, latRad1, latRad2) {
        return Math.abs(deltaPsi) > 1e-12 ? ((latRad2 - latRad1) / deltaPsi) : Math.cos(latRad1);
    }
}
/**
 * The default equality tolerance, defined as the maximum allowed distance between two equal points in great-arc
 * radians.
 */
GeoPoint.EQUALITY_TOLERANCE = 1e-7; // ~61 cm
GeoPoint.tempVec3 = new Float64Array(3);
GeoPoint.tempGeoPoint = new GeoPoint(0, 0);

/**
 * A circle on Earth's surface, defined as the set of points on the Earth's surface equidistant (as measured
 * geodetically) from a central point.
 */
class GeoCircle {
    /**
     * Constructor.
     * @param center The center of the new small circle, represented as a position vector in the standard geographic
     * cartesian reference system.
     * @param radius The radius of the new small circle in great-arc radians.
     */
    constructor(center, radius) {
        this._center = new Float64Array(3);
        this._radius = 0;
        this.set(center, radius);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The center of this circle.
     */
    get center() {
        return this._center;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The radius of this circle, in great-arc radians.
     */
    get radius() {
        return this._radius;
    }
    /**
     * Checks whether this circle is a great circle, or equivalently, whether its radius is equal to pi / 2 great-arc
     * radians.
     * @returns Whether this circle is a great circle.
     */
    isGreatCircle() {
        return this._radius === Math.PI / 2;
    }
    /**
     * Calculates the length of an arc along this circle subtended by a central angle.
     * @param angle A central angle, in radians.
     * @returns the length of the arc subtended by the angle, in great-arc radians.
     */
    arcLength(angle) {
        return Math.sin(this._radius) * angle;
    }
    /**
     * Sets the center and radius of this circle.
     * @param center The new center.
     * @param radius The new radius in great-arc radians.
     * @returns this circle, after it has been changed.
     */
    set(center, radius) {
        if (center instanceof Float64Array) {
            if (Vec3Math.abs(center) === 0) {
                // if center has no direction, arbitrarily set the center to 0 N, 0 E.
                Vec3Math.set(1, 0, 0, this._center);
            }
            else {
                Vec3Math.normalize(center, this._center);
            }
        }
        else {
            GeoPoint.sphericalToCartesian(center, this._center);
        }
        this._radius = Math.abs(radius) % Math.PI;
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setAsGreatCircle(arg1, arg2) {
        this.set(GeoCircle._getGreatCircleNormal(arg1, arg2, GeoCircle.vec3Cache[0]), Math.PI / 2);
        return this;
    }
    /**
     * Gets the distance from a point to the center of this circle, in great-arc radians.
     * @param point The point to which to measure the distance.
     * @returns the distance from the point to the center of this circle.
     */
    distanceToCenter(point) {
        if (point instanceof Float64Array) {
            point = Vec3Math.normalize(point, GeoCircle.vec3Cache[0]);
        }
        else {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]);
        }
        const dot = Vec3Math.dot(point, this._center);
        return Math.acos(Utils.Clamp(dot, -1, 1));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    closest(point, out) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]);
        }
        const offset = Vec3Math.multScalar(this._center, Math.cos(this._radius), GeoCircle.vec3Cache[1]);
        const dot = Vec3Math.dot(Vec3Math.sub(point, offset, GeoCircle.vec3Cache[2]), this._center);
        const planeProjected = Vec3Math.sub(point, Vec3Math.multScalar(this._center, dot, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]);
        if (Vec3Math.dot(planeProjected, planeProjected) === 0 || Math.abs(Vec3Math.dot(planeProjected, this._center)) === 1) {
            // the point is equidistant from all points on this circle
            return out instanceof GeoPoint ? out.set(NaN, NaN) : Vec3Math.set(NaN, NaN, NaN, out);
        }
        const displacement = Vec3Math.multScalar(Vec3Math.normalize(Vec3Math.sub(planeProjected, offset, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]), Math.sin(this._radius), GeoCircle.vec3Cache[2]);
        const closest = Vec3Math.add(offset, displacement, GeoCircle.vec3Cache[2]);
        return out instanceof Float64Array ? Vec3Math.normalize(closest, out) : out.setFromCartesian(closest);
    }
    /**
     * Calculates and returns the great-circle distance from a specified point to the closest point that lies on this
     * circle. In other words, calculates the shortest distance from a point to this circle. The distance is signed, with
     * positive distances representing deviation away from the center of the circle, and negative distances representing
     * deviation toward the center of the circle.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @returns the great circle distance, in great-arc radians, from the point to the closest point on this circle.
     */
    distance(point) {
        const distanceToCenter = this.distanceToCenter(point);
        return distanceToCenter - this._radius;
    }
    /**
     * Checks whether a point lies on this circle.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param tolerance - the error tolerance, in great-arc radians, of this operation. Defaults to 1e-8 (roughly 6 cm)
     * if not specified.
     * @returns whether the point lies on this circle.
     */
    includes(point, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const distance = this.distance(point);
        return Math.abs(distance) < tolerance;
    }
    /**
     * Checks whether a point lies within the boundary defined by this circle. This is equivalent to checking whether
     * the distance of the point from the center of this circle is less than or equal to this circle's radius.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param inclusive Whether points that lie on this circle should pass the check. True by default.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to 1e-8 (roughly 6 cm)
     * if not specified.
     * @returns whether the point lies within the boundary defined by this circle.
     */
    encircles(point, inclusive = true, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const distance = this.distance(point);
        return inclusive
            ? distance <= tolerance
            : distance < -tolerance;
    }
    /**
     * Gets the angular distance along an arc between two points that lie on this circle. The arc extends from the first
     * point to the second in a counterclockwise direction when viewed from above the center of the circle.
     * @param start A point on this circle which marks the beginning of an arc.
     * @param end A point on this circle which marks the end of an arc.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `end` lie on this circle.
     * Defaults to 1e-8 (roughly 6 cm) if not specified.
     * @returns the angular width of the arc between the two points, in radians.
     * @throws Error if either point does not lie on this circle.
     */
    angleAlong(start, end, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, GeoCircle.vec3Cache[1]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, GeoCircle.vec3Cache[2]);
        }
        if (!this.includes(start, tolerance) || !this.includes(end, tolerance)) {
            throw new Error(`GeoCircle: at least one of the two specified arc end points does not lie on this circle (start point distance of ${this.distance(start)}, end point distance of ${this.distance(end)}, vs tolerance of ${tolerance}).`);
        }
        if (this._radius <= GeoCircle.ANGULAR_TOLERANCE) {
            return 0;
        }
        const startRadialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, start, GeoCircle.vec3Cache[3]), GeoCircle.vec3Cache[3]);
        const endRadialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, end, GeoCircle.vec3Cache[4]), GeoCircle.vec3Cache[4]);
        const angularDistance = Math.acos(Utils.Clamp(Vec3Math.dot(startRadialNormal, endRadialNormal), -1, 1));
        const isArcGreaterThanSemi = Vec3Math.dot(startRadialNormal, end) < 0;
        return isArcGreaterThanSemi ? 2 * Math.PI - angularDistance : angularDistance;
    }
    /**
     * Gets the distance along an arc between two points that lie on this circle. The arc extends from the first point
     * to the second in a counterclockwise direction when viewed from above the center of the circle.
     * @param start A point on this circle which marks the beginning of an arc.
     * @param end A point on this circle which marks the end of an arc.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `end` lie on this circle.
     * Defaults to 1e-8 (roughly 6 cm) if not specified.
     * @returns the length of the arc between the two points, in great-arc radians.
     * @throws Error if either point does not lie on this circle.
     */
    distanceAlong(start, end, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        return this.arcLength(this.angleAlong(start, end, tolerance));
    }
    /**
     * Calculates the true bearing along this circle at a point on the circle.
     * @param point A point on this circle.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to 1e-8 (roughly 6 cm) if not specified.
     * @returns the bearing along this circle at the point.
     * @throws Error if the point does not lie on this circle.
     */
    bearingAt(point, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[1]);
        }
        if (!this.includes(point, tolerance)) {
            throw new Error(`GeoCircle: the specified point does not lie on this circle (distance of ${Math.abs(this.distance(point))} vs tolerance of ${tolerance}).`);
        }
        if (this._radius <= GeoCircle.ANGULAR_TOLERANCE || 1 - Math.abs(Vec3Math.dot(point, GeoCircle.NORTH_POLE)) <= GeoCircle.ANGULAR_TOLERANCE) {
            // Meaningful bearings cannot be defined along a circle with 0 radius (effectively a point) and at the north and south poles.
            return NaN;
        }
        const radialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, point, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]);
        const northNormal = Vec3Math.normalize(Vec3Math.cross(point, GeoCircle.NORTH_POLE, GeoCircle.vec3Cache[3]), GeoCircle.vec3Cache[3]);
        return (Math.acos(Utils.Clamp(Vec3Math.dot(radialNormal, northNormal), -1, 1)) * (radialNormal[2] >= 0 ? 1 : -1) * Avionics.Utils.RAD2DEG - 90 + 360) % 360;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    offsetDistanceAlong(point, distance, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const angle = distance / Math.sin(this.radius);
        return this._offsetAngleAlong(point, angle, out, tolerance);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    offsetAngleAlong(point, angle, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        return this._offsetAngleAlong(point, angle, out, tolerance);
    }
    /**
     * Offsets a point on this circle by a specified angular distance. The direction of the offset for positive distances
     * is counterclockwise when viewed from above the center of this circle.
     * @param point The point to offset.
     * @param angle The angular distance by which to offset, in radians.
     * @param out A Float64Array or GeoPoint object to which to write the result.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to 1e-8 (roughly 6 cm) if not specified.
     * @returns The offset point.
     * @throws Error if the point does not lie on this circle.
     */
    _offsetAngleAlong(point, angle, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[3]);
        }
        if (!this.includes(point, tolerance)) {
            throw new Error(`GeoCircle: the specified point does not lie on this circle (distance of ${Math.abs(this.distance(point))} vs tolerance of ${tolerance}).`);
        }
        if (this.radius === 0) {
            return out instanceof GeoPoint ? out.setFromCartesian(point) : Vec3Math.copy(point, out);
        }
        // Since point may not lie exactly on this circle due to error tolerance, project point onto this circle to ensure
        // the offset point lies exactly on this circle.
        point = this.closest(point, GeoCircle.vec3Cache[3]);
        const sin = Math.sin(angle / 2);
        const q0 = Math.cos(angle / 2);
        const q1 = sin * this._center[0];
        const q2 = sin * this._center[1];
        const q3 = sin * this._center[2];
        const q0Sq = q0 * q0;
        const q1Sq = q1 * q1;
        const q2Sq = q2 * q2;
        const q3Sq = q3 * q3;
        const q01 = q0 * q1;
        const q02 = q0 * q2;
        const q03 = q0 * q3;
        const q12 = q1 * q2;
        const q13 = q1 * q3;
        const q23 = q2 * q3;
        const rot_11 = q0Sq + q1Sq - q2Sq - q3Sq;
        const rot_12 = 2 * (q12 - q03);
        const rot_13 = 2 * (q13 + q02);
        const rot_21 = 2 * (q12 + q03);
        const rot_22 = q0Sq - q1Sq + q2Sq - q3Sq;
        const rot_23 = 2 * (q23 - q01);
        const rot_31 = 2 * (q13 - q02);
        const rot_32 = 2 * (q23 + q01);
        const rot_33 = (q0Sq - q1Sq - q2Sq + q3Sq);
        const x = point[0];
        const y = point[1];
        const z = point[2];
        const rotX = rot_11 * x + rot_12 * y + rot_13 * z;
        const rotY = rot_21 * x + rot_22 * y + rot_23 * z;
        const rotZ = rot_31 * x + rot_32 * y + rot_33 * z;
        return out instanceof Float64Array
            ? Vec3Math.set(rotX, rotY, rotZ, out)
            : out.setFromCartesian(Vec3Math.set(rotX, rotY, rotZ, GeoCircle.vec3Cache[2]));
    }
    /**
     * Calculates and returns the set of intersection points between this circle and another one, and writes the results
     * to an array of position vectors.
     * @param other The other circle to test for intersections.
     * @param out An array in which to store the results. The results will be stored at indexes 0 and 1. If these indexes
     * are empty, then new Float64Array objects will be created and inserted into the array.
     * @returns The number of solutions written to the out array. Either 0, 1, or 2.
     */
    intersection(other, out) {
        const center1 = this._center;
        const center2 = other._center;
        const radius1 = this._radius;
        const radius2 = other._radius;
        /**
         * Theory: We can model geo circles as the intersection between a sphere and the unit sphere (Earth's surface).
         * Therefore, the intersection of two geo circles is the intersection between two spheres AND the unit sphere.
         * First, we find the intersection of the two non-Earth spheres (which can either be a sphere, a circle, or a
         * point), then we find the intersection of that geometry with the unit sphere.
         */
        const dot = Vec3Math.dot(center1, center2);
        const dotSquared = dot * dot;
        if (dotSquared === 1) {
            // the two circles are concentric; either there are zero solutions or infinite solutions; either way we don't
            // write any solutions to the array.
            return 0;
        }
        // find the position vector to the center of the circle which defines the intersection of the two geo circle
        // spheres.
        const a = (Math.cos(radius1) - dot * Math.cos(radius2)) / (1 - dotSquared);
        const b = (Math.cos(radius2) - dot * Math.cos(radius1)) / (1 - dotSquared);
        const intersection = Vec3Math.add(Vec3Math.multScalar(center1, a, GeoCircle.vec3Cache[0]), Vec3Math.multScalar(center2, b, GeoCircle.vec3Cache[1]), GeoCircle.vec3Cache[0]);
        const intersectionLengthSquared = Vec3Math.dot(intersection, intersection);
        if (intersectionLengthSquared > 1) {
            // the two geo circle spheres do not intersect.
            return 0;
        }
        const cross = Vec3Math.cross(center1, center2, GeoCircle.vec3Cache[1]);
        const crossLengthSquared = Vec3Math.dot(cross, cross);
        if (crossLengthSquared === 0) {
            // this technically can't happen (since we already check if center1 dot center2 === +/-1 above, but just in
            // case...)
            return 0;
        }
        const offset = Math.sqrt((1 - intersectionLengthSquared) / crossLengthSquared);
        let solutionCount = 1;
        if (!out[0]) {
            out[0] = new Float64Array(3);
        }
        out[0].set(cross);
        Vec3Math.multScalar(out[0], offset, out[0]);
        Vec3Math.add(out[0], intersection, out[0]);
        if (offset > 0) {
            if (!out[1]) {
                out[1] = new Float64Array(3);
            }
            out[1].set(cross);
            Vec3Math.multScalar(out[1], -offset, out[1]);
            Vec3Math.add(out[1], intersection, out[1]);
            solutionCount++;
        }
        return solutionCount;
    }
    /**
     * Calculates and returns the set of intersection points between this circle and another one, and writes the results
     * to an array of GeoPoint objects.
     * @param other The other circle to test for intersections.
     * @param out An array in which to store the results. The results will be stored at indexes 0 and 1. If these indexes
     * are empty, then new GeoPoint objects will be created and inserted into the array.
     * @returns The number of solutions written to the out array. Either 0, 1, or 2.
     */
    intersectionGeoPoint(other, out) {
        const solutionCount = this.intersection(other, GeoCircle.intersectionCache);
        for (let i = 0; i < solutionCount; i++) {
            if (!out[i]) {
                out[i] = new GeoPoint(0, 0);
            }
            out[i].setFromCartesian(GeoCircle.intersectionCache[i]);
        }
        return solutionCount;
    }
    /**
     * Calculates and returns the number of intersection points between this circle and another one. Returns NaN if there
     * are an infinite number of intersection points.
     * @param other The other circle to test for intersections.
     * @param tolerance - the error tolerance, in great-arc radians, of this operation. Defaults to 1e-8 (roughly 6 cm)
     * if not specified.
     * @returns the number of intersection points between this circle and the other one.
     */
    numIntersectionPoints(other, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const center1 = this.center;
        const center2 = other.center;
        const radius1 = this.radius;
        const radius2 = other.radius;
        const dot = Vec3Math.dot(center1, center2);
        const dotSquared = dot * dot;
        if (dotSquared === 1) {
            // the two circles are concentric; if they are the same circle there are an infinite number of intersections,
            // otherwise there are none.
            if (dot === 1) {
                // centers are the same
                return (Math.abs(this.radius - other.radius) <= tolerance) ? NaN : 0;
            }
            else {
                // centers are antipodal
                return (Math.abs(Math.PI - this.radius - other.radius) <= tolerance) ? NaN : 0;
            }
        }
        const a = (Math.cos(radius1) - dot * Math.cos(radius2)) / (1 - dotSquared);
        const b = (Math.cos(radius2) - dot * Math.cos(radius1)) / (1 - dotSquared);
        const intersection = Vec3Math.add(Vec3Math.multScalar(center1, a, GeoCircle.vec3Cache[0]), Vec3Math.multScalar(center2, b, GeoCircle.vec3Cache[1]), GeoCircle.vec3Cache[1]);
        const intersectionLengthSquared = Vec3Math.dot(intersection, intersection);
        if (intersectionLengthSquared > 1) {
            return 0;
        }
        const cross = Vec3Math.cross(center1, center2, GeoCircle.vec3Cache[1]);
        const crossLengthSquared = Vec3Math.dot(cross, cross);
        if (crossLengthSquared === 0) {
            return 0;
        }
        const sinTol = Math.sin(tolerance);
        return ((1 - intersectionLengthSquared) / crossLengthSquared > sinTol * sinTol) ? 2 : 1;
    }
    /**
     * Creates a new small circle from a lat/long coordinate pair and radius.
     * @param point The center of the new small circle.
     * @param radius The radius of the new small circle, in great-arc radians.
     * @returns a small circle.
     */
    static createFromPoint(point, radius) {
        return new GeoCircle(GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]), radius);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static createGreatCircle(arg1, arg2) {
        return new GeoCircle(GeoCircle._getGreatCircleNormal(arg1, arg2, GeoCircle.vec3Cache[0]), Math.PI / 2);
    }
    /**
     * Creates a new great circle defined by one point and a bearing offset. The new great circle will be equivalent to
     * the path projected from the point with the specified initial bearing (forward azimuth).
     * @param point A point that lies on the new great circle.
     * @param bearing The initial bearing from the point.
     * @returns a great circle.
     */
    static createGreatCircleFromPointBearing(point, bearing) {
        return new GeoCircle(GeoCircle.getGreatCircleNormalFromPointBearing(point, bearing, GeoCircle.vec3Cache[0]), Math.PI / 2);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static getGreatCircleNormal(arg1, arg2, out) {
        return GeoCircle._getGreatCircleNormal(arg1, arg2, out);
    }
    /**
     * Calculates a normal vector for a great circle given two points which lie on the circle, or a point and initial bearing.
     * @param arg1 A point that lies on the great circle.
     * @param arg2 A second point that lies on the great circle, or an initial bearing from the first point.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static _getGreatCircleNormal(arg1, arg2, out) {
        if (typeof arg2 === 'number') {
            return GeoCircle.getGreatCircleNormalFromPointBearing(arg1, arg2, out);
        }
        else {
            return GeoCircle.getGreatCircleNormalFromPoints(arg1, arg2, out);
        }
    }
    /**
     * Calculates a normal vector for a great circle given two points which lie on the cirlce.
     * @param point1 The first point that lies on the great circle.
     * @param point2 The second point that lies on the great circle.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static getGreatCircleNormalFromPoints(point1, point2, out) {
        if (!(point1 instanceof Float64Array)) {
            point1 = GeoPoint.sphericalToCartesian(point1, GeoCircle.vec3Cache[0]);
        }
        if (!(point2 instanceof Float64Array)) {
            point2 = GeoPoint.sphericalToCartesian(point2, GeoCircle.vec3Cache[1]);
        }
        return Vec3Math.normalize(Vec3Math.cross(point1, point2, out), out);
    }
    /**
     * Calculates a normal vector for a great circle given a point and initial bearing.
     * @param point A point that lies on the great circle.
     * @param bearing The initial bearing from the point.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static getGreatCircleNormalFromPointBearing(point, bearing, out) {
        if (point instanceof Float64Array) {
            point = GeoCircle.tempGeoPoint.setFromCartesian(point);
        }
        const lat = point.lat * Avionics.Utils.DEG2RAD;
        const long = point.lon * Avionics.Utils.DEG2RAD;
        bearing *= Avionics.Utils.DEG2RAD;
        const sinLat = Math.sin(lat);
        const sinLon = Math.sin(long);
        const cosLon = Math.cos(long);
        const sinBearing = Math.sin(bearing);
        const cosBearing = Math.cos(bearing);
        const x = sinLon * cosBearing - sinLat * cosLon * sinBearing;
        const y = -cosLon * cosBearing - sinLat * sinLon * sinBearing;
        const z = Math.cos(lat) * sinBearing;
        return Vec3Math.set(x, y, z, out);
    }
}
GeoCircle.ANGULAR_TOLERANCE = 1e-7; // ~61cm
GeoCircle.NORTH_POLE = new Float64Array([0, 0, 1]);
GeoCircle.tempGeoPoint = new GeoPoint(0, 0);
GeoCircle.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
GeoCircle.intersectionCache = [new Float64Array(3), new Float64Array(3)];

/**
 * Navigational mathematics functions.
 */
class NavMath {
    /**
     * Clamps a value to a min and max.
     * @param val The value to clamp.
     * @param min The minimum value to clamp to.
     * @param max The maximum value to clamp to.
     * @returns The clamped value.
     */
    static clamp(val, min, max) {
        return Math.min(Math.max(val, min), max);
    }
    /**
     * Normalizes a heading to a 0-360 range.
     * @param heading The heading to normalize.
     * @returns The normalized heading.
     */
    static normalizeHeading(heading) {
        if (isFinite(heading)) {
            return (heading % 360 + 360) % 360;
        }
        else {
            console.error(`normalizeHeading: Invalid heading: ${heading}`);
            return NaN;
        }
    }
    /**
     * Gets the turn radius for a given true airspeed.
     * @param airspeedTrue The true airspeed of the plane.
     * @param bankAngle The bank angle of the plane, in degrees.
     * @returns The airplane turn radius.
     */
    static turnRadius(airspeedTrue, bankAngle) {
        return (Math.pow(airspeedTrue, 2) / (11.26 * Math.tan(bankAngle * NavMath.DEG2RAD)))
            / 3.2808399;
    }
    /**
     * Gets the required bank angle for a given true airspeed and turn radius.
     * @param airspeedTrue The true airspeed of the plane.
     * @param radius The airplane turn radius.
     * @returns The required bank angle, in degrees.
     */
    static bankAngle(airspeedTrue, radius) {
        const airspeedMS = airspeedTrue * 0.51444444;
        return Units.Radians.toDegrees(Math.atan(Math.pow(airspeedMS, 2) / (radius * 9.80665)));
    }
    /**
     * Get the turn direction for a given course change.
     * @param startCourse The start course.
     * @param endCourse The end course.
     * @returns The turn direction for the course change.
     */
    static getTurnDirection(startCourse, endCourse) {
        return NavMath.normalizeHeading(endCourse - startCourse) > 180 ? 'left' : 'right';
    }
    /**
     * Converts polar radians to degrees north.
     * @param radians The radians to convert.
     * @returns The angle, in degrees north.
     */
    static polarToDegreesNorth(radians) {
        return NavMath.normalizeHeading((180 / Math.PI) * (Math.PI / 2 - radians));
    }
    /**
     * Converts degrees north to polar radians.
     * @param degrees The degrees to convert.
     * @returns The angle radians, in polar.
     */
    static degreesNorthToPolar(degrees) {
        return NavMath.normalizeHeading(degrees - 90) / (180 / Math.PI);
    }
    /**
     * Calculates the distance along an arc on Earth's surface. The arc begins at the intersection of the great circle
     * passing through the center of a circle of radius `radius` meters in the direction of 'startBearing', and ends at
     * the intersection of the great circle passing through the center of the circle in the direction of 'endBearing',
     * proceeding clockwise (as viewed from above).
     * @param startBearing The degrees of the start of the arc.
     * @param endBearing The degrees of the end of the arc.
     * @param radius The radius of the arc, in meters.
     * @returns The arc distance.
     */
    static calculateArcDistance(startBearing, endBearing, radius) {
        const angularWidth = ((endBearing - startBearing + 360) % 360) * Avionics.Utils.DEG2RAD;
        const conversion = UnitType.GA_RADIAN.convertTo(1, UnitType.METER);
        return angularWidth * Math.sin(radius / conversion) * conversion;
    }
    /**
     * Calculates the intersection of a line and a circle.
     * @param x1 The start x of the line.
     * @param y1 The start y of the line.
     * @param x2 The end x of the line.
     * @param y2 The end y of the line.
     * @param cx The circle center x.
     * @param cy The circle center y.
     * @param r The radius of the circle.
     * @param sRef The reference to the solution object to write the solution to.
     * @returns The number of solutions (0, 1 or 2).
     */
    static circleIntersection(x1, y1, x2, y2, cx, cy, r, sRef) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const a = dx * dx + dy * dy;
        const b = 2 * (dx * (x1 - cx) + dy * (y1 - cy));
        const c = (x1 - cx) * (x1 - cx) + (y1 - cy) * (y1 - cy) - r * r;
        const det = b * b - 4 * a * c;
        if (a < 0.0000001 || det < 0) {
            sRef.x1 = NaN;
            sRef.x2 = NaN;
            sRef.y1 = NaN;
            sRef.y2 = NaN;
            return 0;
        }
        else if (det == 0) {
            const t = -b / (2 * a);
            sRef.x1 = x1 + t * dx;
            sRef.y1 = y1 + t * dy;
            sRef.x2 = NaN;
            sRef.y2 = NaN;
            return 1;
        }
        else {
            const t1 = ((-b + Math.sqrt(det)) / (2 * a));
            sRef.x1 = x1 + t1 * dx;
            sRef.y1 = y1 + t1 * dy;
            const t2 = ((-b - Math.sqrt(det)) / (2 * a));
            sRef.x2 = x1 + t2 * dx;
            sRef.y2 = y1 + t2 * dy;
            return 2;
        }
    }
    /**
     * Gets the degrees north that a point lies on a circle.
     * @param cx The x point of the center of the circle.
     * @param cy The y point of the center of the circle.
     * @param x The x point to get the bearing for.
     * @param y The y point to get the bearing for.
     * @returns The angle in degrees north that the point is relative to the center.
     */
    static northAngle(cx, cy, x, y) {
        return NavMath.polarToDegreesNorth(Math.atan2(y - cy, x - cx));
    }
    /**
     * Checks if a degrees north bearing is between two other degrees north bearings.
     * @param bearing The bearing in degrees north to check.
     * @param start The start bearing in degrees north.
     * @param end The end bearing, in degrees north.
     * @returns True if the bearing is between the two provided bearings, false otherwise.
     */
    static bearingIsBetween(bearing, start, end) {
        const range = this.normalizeHeading(end - start);
        const relativeBearing = this.normalizeHeading(bearing - start);
        return relativeBearing >= 0 && relativeBearing <= range;
    }
    /**
     * Converts a degrees north heading to a degrees north turn circle angle.
     * @param heading The heading to convert.
     * @param turnDirection The direction of the turn.
     * @returns A degrees north turn circle angle.
     */
    static headingToAngle(heading, turnDirection) {
        return NavMath.normalizeHeading(heading + (turnDirection === 'left' ? 90 : -90));
    }
    /**
     * Converts a degrees north turn circle angle to a degrees north heading.
     * @param angle The turn circle angle to convert.
     * @param turnDirection The direction of the turn.
     * @returns A degrees north heading.
     */
    static angleToHeading(angle, turnDirection) {
        return NavMath.normalizeHeading(angle + (turnDirection === 'left' ? -90 : 90));
    }
    /**
     * Calculates the wind correction angle.
     * @param course The current plane true course.
     * @param airspeedTrue The current plane true airspeed.
     * @param windDirection The direction of the wind, in degrees true.
     * @param windSpeed The current speed of the wind.
     * @returns The calculated wind correction angle.
     */
    static windCorrectionAngle(course, airspeedTrue, windDirection, windSpeed) {
        const currCrosswind = windSpeed * (Math.sin((course * Math.PI / 180) - (windDirection * Math.PI / 180)));
        const windCorrection = 180 * Math.asin(currCrosswind / airspeedTrue) / Math.PI;
        return windCorrection;
    }
    /**
     * Calculates the cross track deviation from the provided leg fixes.
     * @param start The location of the starting fix of the leg.
     * @param end The location of the ending fix of the leg.
     * @param pos The current plane location coordinates.
     * @returns The amount of cross track deviation, in nautical miles.
     */
    static crossTrack(start, end, pos) {
        const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
        if (isNaN(path.center[0])) {
            return NaN;
        }
        return UnitType.GA_RADIAN.convertTo(path.distance(pos), UnitType.NMILE);
    }
    /**
     * Calculates the along-track distance from a starting point to another point along a great-circle track running
     * through the starting point.
     * @param start The start of the great-circle track.
     * @param end The end of the great-circle track.
     * @param pos The point for which to calculate the along-track distance.
     * @returns The along-track distance, in nautical miles.
     */
    static alongTrack(start, end, pos) {
        const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
        if (isNaN(path.center[0])) {
            return NaN;
        }
        const distance = path.distanceAlong(start, path.closest(pos, NavMath.vec3Cache[0]));
        return UnitType.GA_RADIAN.convertTo((distance + Math.PI) % (2 * Math.PI) - Math.PI, UnitType.NMILE);
    }
    /**
     * Calculates the desired track from the provided leg fixes.
     * @param start The location of the starting fix of the leg.
     * @param end The location of the ending fix of the leg.
     * @param pos The current plane location coordinates.
     * @returns The desired track, in degrees true.
     */
    static desiredTrack(start, end, pos) {
        const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
        if (isNaN(path.center[0])) {
            return NaN;
        }
        return path.bearingAt(path.closest(pos, NavMath.vec3Cache[0]));
    }
    /**
     * Gets the desired track for a given arc.
     * @param center The center of the arc.
     * @param turnDirection The direction of the turn.
     * @param pos The current plane position.
     * @returns The desired track.
     */
    static desiredTrackArc(center, turnDirection, pos) {
        const northAngle = NavMath.geoPointCache[0].set(pos).bearingFrom(center);
        //TODO: Clamp the arc angle to the start and end angles
        return NavMath.angleToHeading(northAngle, turnDirection);
    }
    /**
     * Gets the percentage along the arc path that the plane currently is.
     * @param start The start of the arc, in degrees north.
     * @param end The end of the arc, in degrees north.
     * @param center The center location of the arc.
     * @param turnDirection The direction of the turn.
     * @param pos The current plane position.
     * @returns The percentage along the arc the plane is.
     */
    static percentAlongTrackArc(start, end, center, turnDirection, pos) {
        const bearingFromCenter = NavMath.geoPointCache[0].set(center).bearingTo(pos);
        const sign = turnDirection === 'right' ? 1 : -1;
        const alpha = ((end - start) * sign + 360) % 360;
        const mid = (start + alpha / 2 * sign + 360) % 360;
        const rotBearing = ((bearingFromCenter - mid) + 540) % 360 - 180;
        const frac = rotBearing * sign / alpha + 0.5;
        return frac;
    }
    /**
     * Gets a position given an arc and a distance from the arc start.
     * @param start The start bearing of the arc.
     * @param center The center of the arc.
     * @param radius The radius of the arc.
     * @param turnDirection The turn direction for the arc.
     * @param distance The distance along the arc to get the position for.
     * @param out The position to write to.
     * @returns The position along the arc that was written to.
     */
    static positionAlongArc(start, center, radius, turnDirection, distance, out) {
        const convertedRadius = UnitType.GA_RADIAN.convertTo(Math.sin(UnitType.METER.convertTo(radius, UnitType.GA_RADIAN)), UnitType.METER);
        const theta = UnitType.RADIAN.convertTo(distance / convertedRadius, UnitType.DEGREE);
        const bearing = turnDirection === 'right' ? start + theta : start - theta;
        center.offset(NavMath.normalizeHeading(bearing), UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), out);
        return out;
    }
    /**
     * Gets the cross track distance for a given arc.
     * @param center The center of the arc.
     * @param radius The radius of the arc, in meters.
     * @param pos The current plane position.
     * @returns The cross track distance, in NM.
     */
    static crossTrackArc(center, radius, pos) {
        return UnitType.METER.convertTo(radius, UnitType.NMILE) - UnitType.GA_RADIAN.convertTo(NavMath.geoPointCache[0].set(pos).distance(center), UnitType.NMILE);
    }
    /**
     * Gets the total difference in degrees between two angles.
     * @param a The first angle.
     * @param b The second angle.
     * @returns The difference between the two angles, in degrees.
     */
    static diffAngle(a, b) {
        let diff = b - a;
        while (diff > 180) {
            diff -= 360;
        }
        while (diff <= -180) {
            diff += 360;
        }
        return diff;
    }
    /**
     * Finds side a given sides b, c, and angles beta, gamma.
     * @param b The length of side b, as a trigonometric ratio.
     * @param c The length of side c, as a trigonometric ratio.
     * @param beta The angle, in radians, of the opposite of side b.
     * @param gamma The angle, in radians, of the opposite of side c
     * @returns The length of side a, as a trigonometric ratio.
     */
    static napierSide(b, c, beta, gamma) {
        return 2 * Math.atan(Math.tan(0.5 * (b - c))
            * (Math.sin(0.5 * (beta + gamma)) / Math.sin(0.5 * (beta - gamma))));
    }
    /**
     * Calculates a normal vector to a provided course in degrees north.
     * @param course The course in degrees north.
     * @param turnDirection The direction of the turn to orient the normal.
     * @param outVector The normal vector for the provided course.
     */
    static normal(course, turnDirection, outVector) {
        const normalCourse = NavMath.headingToAngle(course, turnDirection);
        const polarCourse = NavMath.degreesNorthToPolar(normalCourse);
        outVector[0] = Math.cos(polarCourse);
        outVector[1] = Math.sin(polarCourse);
    }
}
NavMath.DEG2RAD = Math.PI / 180;
NavMath.RAD2DEG = 180 / Math.PI;
NavMath.vec3Cache = [new Float64Array(3)];
NavMath.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
NavMath.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/// <reference types="msfstypes/Coherent/Facilities" />
/**
 * A utility class for working with magnetic variation (magnetic declination).
 */
class MagVar {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static get(arg1, arg2) {
        return MagVar.getMagVar(arg1, arg2);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static magneticToTrue(bearing, arg1, arg2) {
        return NavMath.normalizeHeading(bearing + MagVar.getMagVar(arg1, arg2));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static trueToMagnetic(bearing, arg1, arg2) {
        return NavMath.normalizeHeading(bearing - MagVar.getMagVar(arg1, arg2));
    }
    /**
     * Gets the magnetic variation (magnetic declination) at a specific point on Earth.
     * @param arg1 The query point, or the latitude of the query point.
     * @param arg2 The longitude of the query point.
     * @returns The magnetic variation (magnetic declination) at the point.
     */
    static getMagVar(arg1, arg2) {
        if (typeof Facilities === 'undefined') {
            // In case this code is executed before the Facilities class is created.
            return 0;
        }
        let lat, lon;
        if (typeof arg1 === 'number') {
            lat = arg1;
            lon = arg2;
        }
        else {
            lat = arg1.lat;
            lon = arg1.lon;
        }
        return Facilities.getMagVar(lat, lon);
    }
}

/**
 * A Subject which provides a GeoPointInterface value.
 */
class GeoPointSubject extends Subject {
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        const isArg1Number = typeof arg1 === 'number';
        const equals = isArg1Number ? this.value.equals(arg1, arg2) : this.value.equals(arg1);
        if (!equals) {
            isArg1Number ? this.value.set(arg1, arg2) : this.value.set(arg1);
            this.notify();
        }
    }
    /**
     * Creates a GeoPointSubject.
     * @param initialVal The initial value.
     * @returns a GeoPointSubject.
     */
    static createFromGeoPoint(initialVal) {
        return new GeoPointSubject(initialVal, Subject.DEFAULT_EQUALITY_FUNC);
    }
}

/**
 * A partial implementation of a MutableGeoProjection. Subclasses should use the projectRaw() and invertRaw() methods
 * to define the type of projection to be implemented.
 */
class AbstractGeoProjection {
    constructor() {
        this.center = new GeoPoint(0, 0);
        this.centerTranslation = new Float64Array(2);
        this.scaleFactor = UnitType.GA_RADIAN.convertTo(1, UnitType.NMILE); // 1 pixel = 1 nautical mile
        this.preRotation = new Float64Array(2);
        this.translation = new Float64Array(2);
        this.postRotation = 0;
        this.rotationSin = 0;
        this.rotationCos = 1;
        this.reflectY = 1;
    }
    /**
     * Gets the geographic center of this projection.
     * @returns the geographic center of this projection.
     */
    getCenter() {
        return this.center.readonly;
    }
    /**
     * Gets the nominal scale factor of this projection. At a scale factor of 1, a distance of one great-arc radian will
     * be projected to a distance of one pixel.
     * @returns the nominal scale factor of this projection.
     */
    getScaleFactor() {
        return this.scaleFactor;
    }
    /**
     * Gets the pre-projection rotation of this projection as a vector ([lambda, phi]). The rotation angles are
     * expressed in radians.
     * @returns the pre-projection rotation of this projection.
     */
    getPreRotation() {
        return this.preRotation;
    }
    /**
     * Gets the post-projection (planar) translation of this projection, in pixels.
     * @returns the post-projection translation of this projection.
     */
    getTranslation() {
        return this.translation;
    }
    /**
     * Gets the post-projection (planar) rotation angle of this projection in radians.
     * @returns the post-projection rotation angle of this projection.
     */
    getPostRotation() {
        return this.postRotation;
    }
    /**
     * Checks whether this projection reflects the projected coordinate system across the x-axis.
     * @returns whether this projection reflects the projected coordinate system across the x-axis.
     */
    getReflectY() {
        return this.reflectY === -1;
    }
    /**
     * Sets the geographic center of this projection. The center point of the projection is projected to the origin,
     * before any post-projection transformations are applied.
     * @param point - the new center point.
     * @returns this projection, after it has been changed.
     */
    setCenter(point) {
        this.center.set(point);
        this.updateCenterTranslation();
        return this;
    }
    /**
     * Sets the nominal scale factor of this projection. At a scale factor of 1, a distance of one great-arc radian will
     * be projected to a distance of one pixel.
     * @param factor - the new nominal scale factor.
     * @returns this projection, after it has been changed.
     */
    setScaleFactor(factor) {
        this.scaleFactor = factor;
        return this;
    }
    /**
     * Sets the pre-projection (spherical) rotation of this projection.
     * @param vec - the pre-projection rotation, as a vector ([lambda, phi]). The rotation angles should be expressed in
     * radians.
     * @returns this projection, after it has been changed.
     */
    setPreRotation(vec) {
        this.preRotation.set(vec);
        this.updateCenterTranslation();
        return this;
    }
    /**
     * Sets the post-projection (planar) translation of this projection.
     * @param vec - the new post-projection translation, in pixels.
     * @returns this projection, after it has been changed.
     */
    setTranslation(vec) {
        this.translation.set(vec);
        return this;
    }
    /**
     * Sets the post-projection (planar) rotation of this projection.
     * @param rotation - the new post-projection rotation angle, in radians.
     * @returns this projection, after it has been changed.
     */
    setPostRotation(rotation) {
        this.postRotation = rotation;
        this.rotationCos = Math.cos(rotation);
        this.rotationSin = Math.sin(rotation);
        return this;
    }
    /**
     * Sets whether this reflection should reflect the projected coordinate system across the x-axis. Setting this value
     * to true is useful in the situation where the projected coordinate system should use a positive-y-axis-down
     * convention.
     * @param val True if reflection is desired, false otherwise.
     * @returns this projection, after it has been changed.
     */
    setReflectY(val) {
        this.reflectY = val ? -1 : 1;
        return this;
    }
    /**
     * Copies all projection parameters from another projection. The parameters copied are: center, pre-projection
     * rotation angles, scale factor, post-projection translation, and post-projection rotation angle.
     * @param other the projection from which to copy parameters.
     * @returns this projection, after it has been changed.
     */
    copyParametersFrom(other) {
        return this.setCenter(other.getCenter())
            .setPreRotation(other.getPreRotation())
            .setScaleFactor(other.getScaleFactor())
            .setTranslation(other.getTranslation())
            .setPostRotation(other.getPostRotation())
            .setReflectY(other.getReflectY());
    }
    /**
     * Updates the translation vector to move the center of this projection to the origin.
     */
    updateCenterTranslation() {
        const centerArray = AbstractGeoProjection.tempVec2;
        centerArray[0] = this.center.lon;
        centerArray[1] = this.center.lat;
        this.preRotateForward(centerArray, centerArray);
        this.projectRaw(centerArray, this.centerTranslation);
    }
    /**
     * Applies a forward rotation to a set of lat/lon coordinates using this projection's pre-projection rotation angles.
     * @param vec - the lat/lon coordinates to rotate, as a vector ([long, lat]).
     * @param out - the vector to which to write the result.
     * @returns the rotated lat/lon coordinates.
     */
    preRotateForward(vec, out) {
        const phi = this.preRotation[1];
        const lambda = this.preRotation[0];
        if (phi === 0 && lambda === 0) {
            out.set(vec);
            return out;
        }
        const lat = vec[1];
        const lon = vec[0];
        const rotatedLon = ((lon + lambda * Avionics.Utils.RAD2DEG) % 360 + 540) % 360 - 180; // enforce [-180, 180)
        if (phi === 0) {
            return Vec2Math.set(rotatedLon, lat, out);
        }
        const latRad = lat * Avionics.Utils.DEG2RAD;
        const rotatedLonRad = rotatedLon * Avionics.Utils.DEG2RAD;
        const cosPhi = Math.cos(phi);
        const sinPhi = Math.sin(phi);
        const cosLat = Math.cos(latRad);
        const x = Math.cos(rotatedLonRad) * cosLat;
        const y = Math.sin(rotatedLonRad) * cosLat;
        const z = Math.sin(latRad);
        return Vec2Math.set(Math.atan2(y, x * cosPhi - z * sinPhi) * Avionics.Utils.RAD2DEG, Math.asin(z * cosPhi + x * sinPhi) * Avionics.Utils.RAD2DEG, out);
    }
    /**
     * Applies a reverse rotation to a set of lat/lon coordinates using this projection's pre-projection rotation angles.
     * @param vec - the lat/lon coordinates to rotate, as a vector ([long, lat]).
     * @param out - the vector to which to write the result.
     * @returns the rotated lat/lon coordinates.
     */
    preRotateReverse(vec, out) {
        const phi = this.preRotation[1];
        const lambda = this.preRotation[0];
        if (phi === 0 && lambda === 0) {
            out.set(vec);
            return out;
        }
        const lat = vec[1];
        const lon = vec[0];
        let rotatedLat = lat;
        let rotatedLon = lon;
        if (phi !== 0) {
            const latRad = lat * Avionics.Utils.DEG2RAD;
            const lonRad = lon * Avionics.Utils.DEG2RAD;
            const cosPhi = Math.cos(phi);
            const sinPhi = Math.sin(phi);
            const cosLat = Math.cos(latRad);
            const x = Math.cos(lonRad) * cosLat;
            const y = Math.sin(lonRad) * cosLat;
            const z = Math.sin(latRad);
            rotatedLat = Math.asin(z * cosPhi - x * sinPhi) * Avionics.Utils.RAD2DEG;
            rotatedLon = Math.atan2(y, x * cosPhi + z * sinPhi) * Avionics.Utils.RAD2DEG;
        }
        rotatedLon = ((rotatedLon - lambda * Avionics.Utils.RAD2DEG) % 360 + 540) % 360 - 180; // enforce [-180, 180)
        return Vec2Math.set(rotatedLon, rotatedLat, out);
    }
    /**
     * Projects a set of lat/lon coordinates.
     * @param point - the point to project.
     * @param out - the vector to which to write the result.
     * @returns the projected point, as a vector.
     */
    project(point, out) {
        if (point instanceof Float64Array) {
            out.set(point);
        }
        else {
            out[0] = point.lon;
            out[1] = point.lat;
        }
        this.preRotateForward(out, out);
        this.projectRaw(out, out);
        // translate projected center point to origin
        out[0] -= this.centerTranslation[0];
        out[1] -= this.centerTranslation[1];
        // apply y-reflection
        out[1] *= this.reflectY;
        // apply scale factor
        out[0] *= this.scaleFactor;
        out[1] *= this.scaleFactor;
        // apply post-projection rotation
        const x = out[0];
        const y = out[1];
        out[0] = x * this.rotationCos - y * this.rotationSin;
        out[1] = x * this.rotationSin + y * this.rotationCos;
        // apply post-projection translation
        out[0] += this.translation[0];
        out[1] += this.translation[1];
        return out;
    }
    /**
     * Inverts a set of projected coordinates. This method will determine the geographic point whose projected location
     * is the equal to that described by a 2D position vector.
     * @param vec - the 2D position vector describing the location of the projected coordinates.
     * @param out - the point to which to write the result.
     * @returns the inverted point.
     */
    invert(vec, out) {
        const projected = AbstractGeoProjection.tempVec2;
        projected.set(vec);
        // invert post-projection translation
        projected[0] -= this.translation[0];
        projected[1] -= this.translation[1];
        // invert post-projection rotation
        const x = projected[0];
        const y = projected[1];
        projected[0] = x * this.rotationCos + y * this.rotationSin;
        projected[1] = -x * this.rotationSin + y * this.rotationCos;
        // invert scale factor
        projected[0] /= this.scaleFactor;
        projected[1] /= this.scaleFactor;
        // invert y-reflection
        projected[1] *= this.reflectY;
        // translate projected center point to default projected position
        projected[0] += this.centerTranslation[0];
        projected[1] += this.centerTranslation[1];
        const inverted = this.invertRaw(projected, projected);
        this.preRotateReverse(inverted, inverted);
        if (out instanceof Float64Array) {
            out.set(inverted);
            return out;
        }
        else {
            return out.set(inverted[1], inverted[0]);
        }
    }
}
AbstractGeoProjection.tempVec2 = new Float64Array(2);
/**
 * A Mercator projection.
 */
class MercatorProjection extends AbstractGeoProjection {
    /**
     * Applies a raw projection.
     * @param vec - a [lon, lat] vector describing the geographic point to project.
     * @param out - a 2D vector to which to write the result.
     * @returns the projected point.
     */
    projectRaw(vec, out) {
        out[0] = vec[0] * Avionics.Utils.DEG2RAD;
        out[1] = Math.log(Math.tan((90 + vec[1]) * Avionics.Utils.DEG2RAD / 2));
        return out;
    }
    /**
     * Inverts a raw projection.
     * @param vec - a 2D vector describing the projected point to invert.
     * @param out - a 2D vector to which to write the result.
     * @returns the inverted point.
     */
    invertRaw(vec, out) {
        out[0] = vec[0] * Avionics.Utils.RAD2DEG;
        out[1] = 2 * Math.atan(Math.exp(vec[1])) * Avionics.Utils.RAD2DEG - 90;
        return out;
    }
}

/**
 * Resamples projected geodesic (great-circle) paths between defined endpoints into series of straight line segments.
 */
class GeodesicResampler {
    /**
     * Constructor.
     * @param minDistance The minimum geodesic distance this resampler enforces between two adjacent resampled points, in
     * great-arc radians.
     * @param dpTolerance The Douglas-Peucker tolerance this resampler uses when deciding whether to discard a resampled
     * point during the line simplification process.
     * @param maxDepth The maximum depth of the resampling algorithm used by this resampler. The number of resampled
     * points is bounded from above by 2^[maxDepth] - 1.
     */
    constructor(minDistance, dpTolerance, maxDepth) {
        this.minDistance = minDistance;
        this.dpTolerance = dpTolerance;
        this.maxDepth = maxDepth;
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2)];
        this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3)];
        this.cosMinDistance = Math.cos(minDistance);
        this.dpTolSq = dpTolerance * dpTolerance;
    }
    /**
     * Resamples a projected geodesic (great-circle) path.
     * @param projection The projection to use.
     * @param start The start of the path.
     * @param end The end of the path.
     * @param handler A function to handle the resampled points. The function is called once for each resampled point,
     * in order.
     * @throws Error when the start and end of the path are antipodal.
     */
    resample(projection, start, end, handler) {
        const startVec = GeoPoint.sphericalToCartesian(start, this.vec3Cache[0]);
        const endVec = GeoPoint.sphericalToCartesian(end, this.vec3Cache[1]);
        const startProjected = projection.project(start, this.vec2Cache[0]);
        const endProjected = projection.project(end, this.vec2Cache[1]);
        handler(this.geoPointCache[0].set(start), startProjected, 0);
        const index = this.resampleHelper(projection, start.lat, start.lon, startVec[0], startVec[1], startVec[2], startProjected[0], startProjected[1], end.lat, end.lon, endVec[0], endVec[1], endVec[2], endProjected[0], endProjected[1], handler, 0, 1);
        handler(this.geoPointCache[0].set(end), endProjected, index);
    }
    /**
     * Resamples a projected geodesic (great-circle) path. This method will recursively split the path into two halves
     * and resample the midpoint. Recursion continues as long as the maximum depth has not been reached and at least one
     * of the following conditions is met:
     * * The distance from the midpoint to the endpoints is greater than or equal to the minimum resampling distance.
     * * The Douglas-Peucker metric of the projected midpoint is greater than or equal to the set tolerance.
     * @param projection The projection to use.
     * @param lat1 The latitude of the start of the path.
     * @param lon1 The longitude of the start of the path.
     * @param x1 The x-component of the Cartesian position vector of the start of the path.
     * @param y1 The y-component of the Cartesian position vector of the start of the path.
     * @param z1 The z-component of the Cartesian position vector of the start of the path.
     * @param projX1 The x-component of the projected location of the start of the path.
     * @param projY1 The y-component of the projected location of the start of the path.
     * @param lat2 The latitude of the end of the path.
     * @param lon2 The longitude of the end of the path.
     * @param x2 The x-component of the Cartesian position vector of the end of the path.
     * @param y2 The y-component of the Cartesian position vector of the end of the path.
     * @param z2 The z-component of the Cartesian position vector of the end of the path.
     * @param projX2 The x-component of the projected location of the end of the path.
     * @param projY2 The y-component of the projected location of the end of the path.
     * @param handler A function to handle the resampled points.
     * @param depth The current depth of the resampling algorithm.
     * @param index The index of the next resampled point.
     * @returns The index of the next resampled point.
     * @throws Error when the start and end of the path are antipodal.
     */
    resampleHelper(projection, lat1, lon1, x1, y1, z1, projX1, projY1, lat2, lon2, x2, y2, z2, projX2, projY2, handler, depth, index) {
        if (depth >= this.maxDepth) {
            return index;
        }
        const startVec = Vec3Math.set(x1, y1, z1, this.vec3Cache[0]);
        const endVec = Vec3Math.set(x2, y2, z2, this.vec3Cache[1]);
        const sumVec = Vec3Math.add(startVec, endVec, this.vec3Cache[2]);
        if (Vec3Math.dot(sumVec, sumVec) === 0) {
            throw new Error('Cannot resample from antipodal endpoints.');
        }
        const midVec = Vec3Math.normalize(sumVec, sumVec);
        const startProjected = Vec2Math.set(projX1, projY1, this.vec2Cache[0]);
        const endProjected = Vec2Math.set(projX2, projY2, this.vec2Cache[1]);
        const deltaProjected = Vec2Math.sub(endProjected, startProjected, this.vec2Cache[2]);
        const deltaProjectedDot = Vec2Math.dot(deltaProjected, deltaProjected);
        const midPoint = this.geoPointCache[0].setFromCartesian(midVec);
        const midProjected = projection.project(midPoint, this.vec2Cache[2]);
        const lat0 = midPoint.lat;
        const lon0 = midPoint.lon;
        const x0 = midVec[0];
        const y0 = midVec[1];
        const z0 = midVec[2];
        const projX0 = midProjected[0];
        const projY0 = midProjected[1];
        const cosDistance = Vec3Math.dot(startVec, midVec);
        // cosine of distance increases with decreasing distance, so the check needs to be greater than.
        if (cosDistance > this.cosMinDistance) {
            // calculate Douglas-Peucker metric.
            const area = (projX2 - projX1) * (projY1 - projY0) - (projX1 - projX0) * (projY2 - projY1);
            const dpDisSq = area * area / deltaProjectedDot;
            if (dpDisSq < this.dpTolSq) {
                return index;
            }
        }
        index = this.resampleHelper(projection, lat1, lon1, x1, y1, z1, projX1, projY1, lat0, lon0, x0, y0, z0, projX0, projY0, handler, depth + 1, index);
        handler(this.geoPointCache[0].set(lat0, lon0), Vec2Math.set(projX0, projY0, this.vec2Cache[0]), index);
        return this.resampleHelper(projection, lat0, lon0, x0, y0, z0, projX0, projY0, lat2, lon2, x2, y2, z2, projX2, projY2, handler, depth + 1, index + 1);
    }
}

var DmsDirection;
(function (DmsDirection) {
    DmsDirection["NORTH"] = "N";
    DmsDirection["SOUTH"] = "S";
    DmsDirection["WEST"] = "W";
    DmsDirection["EAST"] = "E";
})(DmsDirection || (DmsDirection = {}));
/**
 * A class to format latitude/longitude to DMS.
 * @class DmsFormatter
 */
class DmsFormatter {
    constructor() {
        this.coordsParts = {
            direction: DmsDirection.NORTH,
            degrees: 0,
            minutes: 0,
            seconds: 0
        };
    }
    /**
     * Builds a DMS string out of the given latitude.
     * @param value The latitude.
     * @returns The DMS string.
     */
    getLatDmsStr(value) {
        const parts = this.parseLat(value);
        if (parts.minutes >= 59.5) {
            parts.minutes = 0;
            parts.degrees++;
        }
        return `${parts.direction} ${parts.degrees.toString().padStart(2, '0')}°${parts.minutes.toFixed(2).padStart(5, '0')}'`;
    }
    /**
     * Builds a DMS string out of the given longitude.
     * @param value The longitude.
     * @returns The DMS string.
     */
    getLonDmsStr(value) {
        const parts = this.parseLon(value);
        if (parts.minutes >= 59.5) {
            parts.minutes = 0;
            parts.degrees++;
        }
        return `${parts.direction}${parts.degrees.toString().padStart(3, '0')}°${parts.minutes.toFixed(2).padStart(5, '0')}'`;
    }
    /**
     * Parses a latitude in to the dms parts.
     * @param value The latitude in degrees.
     * @returns The DMS parts.
     */
    parseLat(value) {
        this.coordsParts.direction = value < 0 ? DmsDirection.SOUTH : DmsDirection.NORTH;
        return this.parse(value);
    }
    /**
     * Parses a longitude in to the dms parts.
     * @param value The longitude in degrees.
     * @returns The DMS parts.
     */
    parseLon(value) {
        this.coordsParts.direction = value < 0 ? DmsDirection.WEST : DmsDirection.EAST;
        return this.parse(value);
    }
    /**
     * Parses the latitude/longitude.
     * @private
     * @param value The value to parse.
     * @returns The DMS parts.
     */
    parse(value) {
        value = Math.abs(value);
        this.coordsParts.degrees = Math.trunc(value);
        value = (value - this.coordsParts.degrees) * 60;
        this.coordsParts.minutes = value;
        this.coordsParts.seconds = (value - this.coordsParts.minutes) * 60;
        return this.coordsParts;
    }
}

/**
 * A Subject which provides a NumberUnitInterface value.
 */
class NumberUnitSubject extends Subject {
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        const isArg1Number = typeof arg1 === 'number';
        const equals = isArg1Number ? this.value.equals(arg1, arg2) : this.value.equals(arg1);
        if (!equals) {
            isArg1Number ? this.value.set(arg1, arg2) : this.value.set(arg1);
            this.notify();
        }
    }
    /**
     * Creates a NumberUnitSubject.
     * @param initialVal The initial value.
     * @returns a NumberUnitSubject.
     */
    static createFromNumberUnit(initialVal) {
        return new NumberUnitSubject(initialVal, Subject.DEFAULT_EQUALITY_FUNC);
    }
}

/**
 * A Subject which allows a 2D vector to be observed.
 */
class Vec2Subject extends Subject {
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        let x, y;
        if (typeof arg1 === 'number') {
            x = arg1;
            y = arg2;
        }
        else {
            x = arg1[0];
            y = arg1[1];
        }
        const equals = x === this.value[0] && y === this.value[1];
        if (!equals) {
            Vec2Math.set(x, y, this.value);
            this.notify();
        }
    }
    /**
     * Creates a Vec2Subject.
     * @param initialVal The initial value.
     * @returns A Vec2Subject.
     */
    static createFromVector(initialVal) {
        return new Vec2Subject(initialVal, Subject.DEFAULT_EQUALITY_FUNC);
    }
}
/**
 * A Subject which allows a N-D vector to be observed.
 */
class VecNSubject extends Subject {
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, ...args) {
        let array;
        if (typeof arg1 === 'number') {
            array = args;
            args.unshift(arg1);
        }
        else {
            array = arg1;
        }
        if (array.length > this.value.length) {
            throw new RangeError(`VecNSubject: Cannot set ${array.length} components on a vector of length ${this.value.length}`);
        }
        let equals = true;
        const len = array.length;
        for (let i = 0; i < len; i++) {
            if (array[i] !== this.value[i]) {
                equals = false;
                break;
            }
        }
        if (!equals) {
            this.value.set(array);
            this.notify();
        }
    }
    /**
     * Creates a VecNSubject.
     * @param initialVal The initial value.
     * @returns A VecNSubject.
     */
    static createFromVector(initialVal) {
        return new VecNSubject(initialVal, Subject.DEFAULT_EQUALITY_FUNC);
    }
}

/**
 * A utitlity class for basic math.
 */
class MathUtils {
    /**
     * Clamps a numerical value to the min/max range.
     * @param value The value to be clamped.
     * @param min The minimum.
     * @param max The maximum.
     *
     * @returns The clamped numerical value..
     */
    static clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }
}

/**
 * Applies time-weighted exponential smoothing (i.e. an exponential moving average) to a sequence of raw values. When
 * a new raw value is added to the sequence, it and the last smoothed value are weighted according to the time elapsed
 * since the last smoothed value was calculated (i.e. since the last raw value was added) and averaged. The calculation
 * of the weighting is such that the weight of each raw value in the sequence decays exponentially with the "age"
 * (i.e. time elapsed between when that value was added to the sequence and when the latest value was added to the
 * sequence) of the value.
 */
class ExpSmoother {
    /**
     * Constructor.
     * @param tau This smoother's time constant. The larger the constant, the greater the smoothing effect.
     * @param initial The initial smoothed value of this smoother. Defaults to null.
     * @param dtThreshold The elapsed time threshold, in seconds, above which this smoother will not smooth a new raw
     * value. Defaults to infinity.
     */
    constructor(tau, initial = null, dtThreshold = Infinity) {
        this.tau = tau;
        this.dtThreshold = dtThreshold;
        this.lastValue = initial;
    }
    /**
     * Gets the last smoothed value.
     * @returns the last smoothed value, or null if none exists.
     */
    last() {
        return this.lastValue;
    }
    /**
     * Adds a new raw value and gets the next smoothed value. If the new raw value is the first to be added since this
     * smoother was created or reset with no initial smoothed value, the returned smoothed value will be equal to the
     * raw value.
     * @param raw The new raw value.
     * @param dt The elapsed time, in seconds, since the last raw value was added.
     * @returns The next smoothed value.
     */
    next(raw, dt) {
        let next;
        if (this.lastValue !== null) {
            const factor = this.calculateFactor(dt);
            next = ExpSmoother.smooth(raw, this.lastValue, factor);
        }
        else {
            next = raw;
        }
        this.lastValue = next;
        return next;
    }
    /**
     * Calculates the smoothing factor for a given time interval.
     * @param dt A time interval, in seconds.
     * @returns the smoothing factor for the given time interval.
     */
    calculateFactor(dt) {
        if (dt > this.dtThreshold) {
            return 0;
        }
        else {
            return Math.exp(-dt / this.tau);
        }
    }
    /**
     * Resets the "history" of this smoother and optionally sets the initial smoothed value.
     * @param value The new initial smoothed value. Defaults to null.
     * @returns The reset smoothed value.
     */
    reset(value) {
        return this.lastValue = (value !== null && value !== void 0 ? value : null);
    }
    /**
     * Applies exponential smoothing.
     * @param value The value to smooth.
     * @param last The last smoothed value.
     * @param factor The smoothing factor.
     * @returns A smoothed value.
     */
    static smooth(value, last, factor) {
        return value * (1 - factor) + last * factor;
    }
}

// eslint-disable-next-line @typescript-eslint/no-namespace
var Wait;
(function (Wait) {
    /**
     * Waits for a set amount of time.
     * @param delay The amount of time to wait in milliseconds.
     * @returns a Promise which is fulfilled after the delay.
     */
    // eslint-disable-next-line no-inner-declarations
    function awaitDelay(delay) {
        return new Promise(resolve => setTimeout(() => resolve(), delay));
    }
    Wait.awaitDelay = awaitDelay;
    /**
     * Waits for a condition to be satisfied.
     * @param predicate A function which evaluates whether the condition is satisfied.
     * @param interval The interval, in milliseconds, at which to evaluate the condition. A zero or negative value
     * causes the condition to be evaluated every frame. Defaults to 0.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected and the condition to be
     * continually evaluated until it is satisfied. Defaults to 0.
     * @returns a Promise which is fulfilled when the condition is satisfied.
     */
    // eslint-disable-next-line no-inner-declarations
    function awaitCondition(predicate, interval = 0, timeout = 0) {
        const t0 = Date.now();
        if (interval <= 0) {
            const loopFunc = (resolve, reject) => {
                if (timeout > 0 && Date.now() - t0 >= timeout) {
                    reject('Await condition timed out.');
                }
                else {
                    predicate() ? resolve() : requestAnimationFrame(loopFunc.bind(undefined, resolve, reject));
                }
            };
            return new Promise((resolve, reject) => { loopFunc(resolve, reject); });
        }
        else {
            return new Promise((resolve, reject) => {
                const timer = setInterval(() => {
                    if (timeout > 0 && Date.now() - t0 > timeout) {
                        clearInterval(timer);
                        reject('Await condition timed out.');
                    }
                    else if (predicate()) {
                        clearInterval(timer);
                        resolve();
                    }
                }, interval);
            });
        }
    }
    Wait.awaitCondition = awaitCondition;
})(Wait || (Wait = {}));

/**
 * Types of subscribable array change event.
 */
var SubscribableArrayEventType;
(function (SubscribableArrayEventType) {
    /** An element was added. */
    SubscribableArrayEventType["Added"] = "Added";
    /** An element was removed. */
    SubscribableArrayEventType["Removed"] = "Removed";
    /** The array was cleared. */
    SubscribableArrayEventType["Cleared"] = "Cleared";
})(SubscribableArrayEventType || (SubscribableArrayEventType = {}));

/**
 * An array-like class to observe changes in a list of objects.
 * @class ArraySubject
 * @template T
 */
class ArraySubject {
    /**
     * Constructs an observable array.
     * @param arr The initial array elements.
     */
    constructor(arr) {
        this._subs = [];
        this.notifyPaused = false;
        this._array = arr;
    }
    /**
     * Gets the length of the array.
     * @readonly
     * @type {number}
     */
    get length() {
        return this._array.length;
    }
    /**
     * Creates and returns a new observable array.
     * @static
     * @template AT The type of the array items.
     * @param arr The initial array elements.
     * @returns A new instance of SubjectArray.
     */
    static create(arr = []) {
        return new ArraySubject(arr);
    }
    /**
     * Inserts a new item at the end or the specified index.
     * @param item The item to insert.
     * @param index The optional index to insert the item to. Will add the item at then end if index not given.
     */
    insert(item, index = -1) {
        if (index === -1 || index > this._array.length - 1) {
            this._array.push(item);
        }
        else {
            this._array.splice(index, 0, item);
        }
        this.notifySubs(index, SubscribableArrayEventType.Added, item);
    }
    /**
     * Inserts items of an array beginning at the specified index.
     * @param [index] The index to begin inserting the array items.
     * @param arr The array to insert.
     */
    insertRange(index = 0, arr) {
        this._array.splice(index, 0, ...arr);
        this.notifySubs(index, SubscribableArrayEventType.Added, arr);
    }
    /**
     * Removes the item at the specified index.
     * @param index The index of the item to remove.
     */
    removeAt(index) {
        const removedItem = this._array.splice(index, 1);
        this.notifySubs(index, SubscribableArrayEventType.Removed, removedItem[0]);
    }
    /**
     * Removes the given item from the array.
     * @param item The item to remove.
     * @returns Returns a boolean indicating if the item was found and removed.
     */
    removeItem(item) {
        const index = this._array.indexOf(item);
        if (index > -1) {
            this.removeAt(index);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Replaces all items in the array with the new array.
     * @param arr The array.
     */
    set(arr) {
        this.clear();
        this.insertRange(0, arr);
    }
    /**
     * Clears all data in the array.
     */
    clear() {
        this._array.length = 0;
        this.notifySubs(0, SubscribableArrayEventType.Cleared);
    }
    /**
     * Subscribes to the subject with a callback function. The function will be called whenever this Subject's array
     * changes.
     * @param fn A callback function.
     * @param initialNotify Whether to immediately notify the callback function after it is subscribed. False by default.
     */
    sub(fn, initialNotify) {
        this._subs.push(fn);
        if (initialNotify) {
            fn(0, SubscribableArrayEventType.Added, this._array, this._array);
        }
    }
    /**
     * Unsubscribes a callback function from this Subject.
     * @param fn The callback function to unsubscribe.
     */
    unsub(fn) {
        const index = this._subs.indexOf(fn);
        if (index >= 0) {
            this._subs.splice(index, 1);
        }
    }
    /**
     * Gets the array.
     * @returns The array.
     */
    getArray() {
        return this._array;
    }
    /**
     * Gets an item from the array.
     * @param index Thex index of the item to get.
     * @returns An item.
     * @throws
     */
    get(index) {
        if (index > this._array.length - 1) {
            throw new Error('Index out of range');
        }
        return this._array[index];
    }
    /**
     * Tries to get the value from the array.
     * @param index The index of the item to get.
     * @returns The value or undefined if not found.
     */
    tryGet(index) {
        return this._array[index];
    }
    /**
     * Notifies the subscribers of a change in the array.
     * @param index The index that was changed.
     * @param type The type of subject event.
     * @param modifiedItem The item modified by the operation.
     * @private
     */
    notifySubs(index, type, modifiedItem) {
        if (!this.notifyPaused) {
            const subLen = this._subs.length;
            for (let i = 0; i < subLen; i++) {
                try {
                    this._subs[i](index, type, modifiedItem, this._array);
                }
                catch (error) {
                    console.error(`Error in ArraySubject handler: ${error}`);
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
        }
    }
}

/**
 * A sorted array.
 */
class SortedArray {
    /**
     * Constructor.
     * @param comparatorFunc A function which defines the relative sorting priority of two elements. The function should
     * return 0 if its arguments are to be sorted identically, a negative number if the first argument is to be sorted
     * before the second argument, and a positive number if the first argument is to be sorted after the second argument.
     * @param equalityFunc A function which checks if two elements are equal. Defaults to the strict equality comparison
     * (`===`) if not defined.
     */
    constructor(comparatorFunc, equalityFunc = SortedArray.DEFAULT_EQUALITY_FUNC) {
        this.comparatorFunc = comparatorFunc;
        this.equalityFunc = equalityFunc;
        this._array = [];
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** A read-only version of the array object backing this sorted array. */
    get array() {
        return this._array;
    }
    /**
     * The number of elements in this array.
     */
    get length() {
        return this._array.length;
    }
    /**
     * Finds the index of the first or last element in this array whose sorting priority is equal to a query element. If
     * no such element in this array exists, `-(index + 1)` is returned, where `index` is the index at which the query
     * element would be found if it were contained in the array.
     * @param element The query element.
     * @param first Whether to find the first index.
     * @returns The index of the first or last element in this array with the same sorting priority as the query, or
     * `-(index + 1)` if no such element exists, where `index` is the index at which the query element would be found if
     * it were contained in the array.
     */
    findIndex(element, first = true) {
        let min = 0;
        let max = this._array.length;
        let index = Math.floor((min + max) / 2);
        while (min < max) {
            const compare = this.comparatorFunc(element, this._array[index]);
            if (compare < 0) {
                max = index;
            }
            else if (compare > 0) {
                min = index + 1;
            }
            else {
                const delta = first ? -1 : 1;
                while (index + delta >= 0 && index + delta < this._array.length && this.comparatorFunc(element, this._array[index + delta]) === 0) {
                    index += delta;
                }
                return index;
            }
            index = Math.floor((min + max) / 2);
        }
        return -(index + 1);
    }
    /**
     * Finds the index of the first element in this array which equals a query element, starting at a specified index.
     * The search proceeds toward the end of the array, ending at the first index containing an element whose sorting
     * priority does not equal the query, or the end of the array, whichever comes first. If no such element in this
     * array exists, -1 is returned instead.
     * @param element The query element.
     * @param startIndex The index at which to start the search.
     * @returns The index of the first element in this array which equals the query element, or -1 if no such element
     * exists.
     */
    searchEquals(element, startIndex) {
        let index = startIndex;
        while (index >= 0 && index < this._array.length && this.comparatorFunc(element, this._array[index]) === 0) {
            if (this.equalityFunc(element, this._array[index])) {
                return index;
            }
            index++;
        }
        return -1;
    }
    /**
     * Gets the element at a specified index, if it exists.
     * @param index An index.
     * @returns The element at the specified index, or undefined if the index is out of bounds.
     */
    get(index) {
        return this._array[index];
    }
    /**
     * Gets the first element in this array, if it exists.
     * @returns The first element in this array, or undefined if this array is empty.
     */
    first() {
        return this._array[0];
    }
    /**
     * Gets the last element in this array, if it exists.
     * @returns The last element in this array, or undefined if this array is empty.
     */
    last() {
        return this._array[this._array.length - 1];
    }
    /**
     * Checks whether this array contains an element. Returns true if and only if there is at least one element in this
     * array which is equal to the specified element according to this array's equality function.
     * @param element The element to check.
     * @returns Whether this array contains the element.
     */
    has(element) {
        return this.searchEquals(element, this.findIndex(element)) >= 0;
    }
    /**
     * Inserts an element into this array. The element will be inserted at the greatest index such that it is located
     * before all the existing elements in the array sorted after it according to this array's sorting function. All
     * existing elements located at indexes greater than or equal to the index at which the element was inserted are
     * shifted to the right.
     * @param element The element to insert.
     * @returns The index at which the element was placed.
     */
    insert(element) {
        let index = this.findIndex(element, false);
        if (index < 0) {
            index = -index - 1;
        }
        this._array.splice(index, 0, element);
        return index;
    }
    /**
     * Inserts all elements in an Iterable into this array. Each element is inserted according to the same behavior used
     * by the `insert()` method. If an element appears more than once in the iterable, one instance of that element will
     * be inserted into this array for each time the element appears in the iterable.
     * @param elements An iterable of elements to insert.
     * @returns The number of elements inserted.
     */
    insertAll(elements) {
        const sorted = Array.from(elements).sort(this.comparatorFunc);
        let toInsertIndex = 0;
        let toInsert = sorted[toInsertIndex];
        const len = this._array.length;
        const insertLen = sorted.length;
        for (let i = 0; i < len && toInsertIndex < insertLen; i++) {
            if (this.comparatorFunc(toInsert, this._array[i]) > 0) {
                this._array.splice(i, 0, toInsert);
                toInsert = sorted[++toInsertIndex];
            }
        }
        for (; toInsertIndex < insertLen; toInsertIndex++) {
            this._array.push(sorted[toInsertIndex]);
        }
        return sorted.length;
    }
    /**
     * Removes the first occurrence of an element from this array. This array is searched for the first element which
     * is equal to the specified element according to this array's equality function, the matching element is removed,
     * and all elements after it are shifted to the left.
     * @param element The element to remove.
     * @returns The (former) index of the removed element, or -1 if no element was removed.
     */
    remove(element) {
        const index = this.searchEquals(element, this.findIndex(element));
        if (index >= 0) {
            this._array.splice(index, 1);
        }
        return index;
    }
    /**
     * Removes all elements in an Iterable from this array. Each element is removed according to the behavior used by the
     * `remove()` method. If an element appears more than once in the iterable, one instance of that element will be
     * removed from this array for each time the element appears in the iterable.
     * @param elements An iterable of elements to remove.
     * @returns The number of elements removed.
     */
    removeAll(elements) {
        const sorted = Array.from(elements).sort(this.comparatorFunc);
        let numRemoved = 0;
        let toRemoveIndex = 0;
        let toRemove = sorted[toRemoveIndex];
        const len = this._array.length;
        const removeLen = sorted.length;
        for (let i = 0; i < len && toRemoveIndex < removeLen; i++) {
            if (this.equalityFunc(toRemove, this._array[i])) {
                this._array.splice(i--, 1);
                toRemove = sorted[++toRemoveIndex];
                numRemoved++;
            }
        }
        return numRemoved;
    }
    /**
     * Finds the index of the first occurrence of an element in this array. This array is searched for the first element
     * which is equal to the specified element according to this array's equality function, and its index is returned.
     * @param element The element for which to search.
     * @returns The index of the first occurrence of the specified element, or -1 if no such element was found.
     */
    indexOf(element) {
        return this.searchEquals(element, this.findIndex(element));
    }
    /**
     * Searches this array for the first element whose sorting priority is equal to a query element. If no such element
     * is found, then undefined is returned instead.
     * @param query The query element.
     * @returns The first element in the array with the same sorting priority as the query, or undefined if no such
     * element exists.
     */
    match(query) {
        const index = this.matchIndex(query);
        return this._array[index];
    }
    /**
     * Searches this array for the index of the first element whose sorting priority is equal to a query element. If no
     * such element is found, then `-(index + 1)` is returned instead, where `index` is the index at which the query
     * element would be found if it were contained in the array.
     * @param query The query element.
     * @returns The index of the first element in this array with the same sorting priority as the query, or
     * `-(index + 1)` if no such element exists, where `index` is the index at which the query element would be found if
     * it were contained in the array.
     */
    matchIndex(query) {
        return this.findIndex(query);
    }
    /**
     * Removes all elements from this array.
     */
    clear() {
        this._array.length = 0;
    }
    /**
     * Gets an IterableIterator over all elements in this array.
     * @returns An IterableIterator over all elements in this array.
     */
    values() {
        return this._array.values();
    }
    /** @inheritdoc */
    [Symbol.iterator]() {
        return this._array.values();
    }
}
SortedArray.DEFAULT_EQUALITY_FUNC = (a, b) => a === b;

/**
 * A subscribable which provides a sorted version of a source SubscribableArray.
 */
class SortedMappedSubscribableArray {
    /**
     * Constructor.
     * @param source The source array subject for this subscribable.
     * @param comparatorFunc A function which defines the relative sorting priority of two elements. The function should
     * return 0 if its arguments are to be sorted identically, a negative number if the first argument is to be sorted
     * before the second argument, and a positive number if the first argument is to be sorted after the second argument.
     * @param equalityFunc A function which checks if two elements are equal. Defaults to the strict equality comparison
     * (`===`) if not defined.
     */
    constructor(source, comparatorFunc, equalityFunc) {
        this.source = source;
        this.comparatorFunc = comparatorFunc;
        this.equalityFunc = equalityFunc;
        this.subs = [];
        this.sorted = new SortedArray(this.comparatorFunc, this.equalityFunc);
        this.sourceHandler = this.onSourceChanged.bind(this);
        source.sub(this.sourceHandler, true);
    }
    /** @inheritdoc */
    get length() {
        return this.sorted.length;
    }
    /**
     * Responds to changes in this subscribable's source array.
     * @param index The index of the change.
     * @param type The type of change.
     * @param item The item(s) involved in the change, if any.
     */
    onSourceChanged(index, type, item) {
        switch (type) {
            case SubscribableArrayEventType.Cleared:
                if (this.sorted.length !== 0) {
                    this.sorted.clear();
                    this.notifySubs(0, SubscribableArrayEventType.Cleared);
                }
                break;
            case SubscribableArrayEventType.Added:
                if (item) {
                    this.insert(item);
                }
                break;
            case SubscribableArrayEventType.Removed:
                if (item) {
                    this.remove(item);
                }
                break;
        }
    }
    /**
     * Inserts elements into this array.
     * @param elements An element or array of elements to insert.
     */
    insert(elements) {
        if (this.sorted.length === 0) {
            // since we know all elements will be added to one contiguous index range, we can do a small optimization here
            // with notifications
            elements instanceof Array ? this.sorted.insertAll(elements) : this.sorted.insert(elements);
            this.notifySubs(0, SubscribableArrayEventType.Added, elements instanceof Array ? this.sorted.array : elements);
        }
        else {
            const sorted = elements instanceof Array ? Array.from(elements).sort(this.comparatorFunc) : [elements];
            const len = sorted.length;
            for (let i = 0; i < len; i++) {
                const toInsert = sorted[i];
                this.notifySubs(this.sorted.insert(toInsert), SubscribableArrayEventType.Added, toInsert);
            }
        }
    }
    /**
     * Removes elements from this array.
     * @param elements An element or array of elements to remove.
     */
    remove(elements) {
        const sorted = elements instanceof Array ? Array.from(elements).sort(this.comparatorFunc) : [elements];
        const len = sorted.length;
        for (let i = 0; i < len; i++) {
            const toRemove = sorted[i];
            const removedIndex = this.sorted.remove(toRemove);
            if (removedIndex >= 0) {
                this.notifySubs(removedIndex, SubscribableArrayEventType.Removed, toRemove);
            }
        }
    }
    /**
     * Notifies subscribers of a change in this array.
     * @param index The index that was changed.
     * @param type The type of subject event.
     * @param modifiedItem The item modified by the operation.
     * @private
     */
    notifySubs(index, type, modifiedItem) {
        const len = this.subs.length;
        for (let i = 0; i < len; i++) {
            try {
                this.subs[i](index, type, modifiedItem, this.sorted.array);
            }
            catch (error) {
                console.error(`SortedMappedSubscribableArray: Error in subscriber handler ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
    }
    /** @inheritdoc */
    getArray() {
        return this.sorted.array;
    }
    /** @inheritdoc */
    get(index) {
        if (index < 0 || index >= this.sorted.length) {
            throw new RangeError(`SortedMappedSubscribableArray: index ${index} out of range`);
        }
        return this.sorted.get(index);
    }
    /** @inheritdoc */
    tryGet(index) {
        return this.sorted.get(index);
    }
    /** @inheritdoc */
    sub(fn, initialNotify) {
        this.subs.push(fn);
        initialNotify && fn(0, SubscribableArrayEventType.Added, this.sorted.array, this.sorted.array);
    }
    /** @inheritdoc */
    unsub(fn) {
        const index = this.subs.indexOf(fn);
        if (index >= 0) {
            this.subs.splice(index, 1);
        }
    }
    /**
     * Destroys this subscribable. After destruction, this subscribable will no longer update in response to changes
     * made to its source.
     */
    destroy() {
        this.source.unsub(this.sourceHandler);
    }
    /**
     * Creates a new SortedMappedSubscribableArray.
     * @param source The source array subject for the new mapped sorted array.
     * @param comparatorFunc A function which defines the relative sorting priority of two elements. The function should
     * return 0 if its arguments are to be sorted identically, a negative number if the first argument is to be sorted
     * before the second argument, and a positive number if the first argument is to be sorted after the second argument.
     * @param equalityFunc A function which checks if two elements are equal. Defaults to the strict equality comparison
     * (`===`) if not defined.
     * @returns A new SortedMappedSubscribableArray.
     */
    static create(source, comparatorFunc, equalityFunc) {
        return new SortedMappedSubscribableArray(source, comparatorFunc, equalityFunc);
    }
}

/**
 * A task queue backed by an array.
 */
class ArrayTaskQueue {
    /**
     * Constructor.
     * @param tasks The array of tasks in this queue.
     */
    constructor(tasks) {
        this.tasks = tasks;
        this.head = 0;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    hasNext() {
        return this.head < this.tasks.length;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    next() {
        return this.tasks[this.head++];
    }
}

/**
 * A process which dispatches tasks in a task queue potentially over multiple frames.
 */
class ThrottledTaskQueueProcess {
    /**
     * Constructor.
     * @param queue The queue to process.
     * @param handler A handler which defines the behavior of this process.
     */
    constructor(queue, handler) {
        this.queue = queue;
        this.handler = handler;
        this._hasStarted = false;
        this._hasEnded = false;
        this._shouldAbort = false;
    }
    /**
     * Checks whether this process has been started.
     * @returns whether this process has been started.
     */
    hasStarted() {
        return this._hasStarted;
    }
    /**
     * Checks whether this process has ended.
     * @returns whether this process has ended.
     */
    hasEnded() {
        return this._hasEnded;
    }
    /**
     * Starts this process.
     */
    start() {
        this._hasStarted = true;
        this.processQueue(0);
    }
    /**
     * Processes the queue.
     * @param elapsedFrameCount The number of frames elapsed since queue processing started.
     */
    processQueue(elapsedFrameCount) {
        let dispatchCount = 0;
        const t0 = performance.now();
        while (!this._shouldAbort && this.queue.hasNext()) {
            if (this.handler.canContinue(elapsedFrameCount, dispatchCount, performance.now() - t0)) {
                const task = this.queue.next();
                task();
                dispatchCount++;
            }
            else {
                break;
            }
        }
        if (this._shouldAbort) {
            return;
        }
        if (!this.queue.hasNext()) {
            this.handler.onFinished(elapsedFrameCount);
            this._hasEnded = true;
        }
        else {
            this.handler.onPaused(elapsedFrameCount);
            requestAnimationFrame(this.processQueue.bind(this, elapsedFrameCount + 1));
        }
    }
    /**
     * Aborts this process. Has no effect if the process has not been started or if it has already ended.
     */
    abort() {
        if (this._hasStarted && !this._hasEnded) {
            this.handler.onAborted();
            this._shouldAbort = true;
            this._hasEnded = true;
        }
    }
}

/**
 * Can be used in classes to provide support for custom events.
 * @class SubEvent
 */
class SubEvent {
    constructor() {
        this.handlers = [];
    }
    /**
     * Subscribe to this event.
     * @param handler The handler to be called when the event is emitted.
     */
    on(handler) {
        this.handlers.push(handler);
    }
    /**
     * Unsubscribe from this event.
     * @param handler The handler to be called when the event is emitted.
     */
    off(handler) {
        this.handlers = this.handlers.filter(h => h !== handler);
    }
    /**
     * Clears all subscriptions to this event.
     */
    clear() {
        this.handlers.length = 0;
    }
    /**
     * Emit event to subscribers.
     * @param sender The object emitting the event.
     * @param [data] The event arguments.
     */
    notify(sender, data) {
        const handlers = [...this.handlers];
        for (let i = 0; i < handlers.length; i++) {
            handlers[i](sender, data);
        }
    }
}

/**
 * A class for caching images.
 * Do your own instrument specific implementation with an init() method
 * that will add images to cache on instrument load to prefill the cache.
 * @class ImageCache
 */
class ImageCache {
    /**
     * Loads the image from the url and adds it to the cache.
     * @static
     * @param key The image key to access it later.
     * @param url The url to load the image from.
     */
    static addToCache(key, url) {
        if (this.cache[key] === undefined) {
            const img = new Image();
            img.src = url;
            this.cache[key] = img;
        }
    }
    /**
     * Gets a cached image element.
     * @static
     * @param key The key of the cached image.
     * @returns The cached image element.
     */
    static get(key) {
        return this.cache[key];
    }
}
ImageCache.cache = {};

/**
 * Utility class for manipulating bit flags.
 */
class BitFlags {
    /**
     * Generates a bit flag with a boolean value of true at a specified index.
     * @param index The index of the flag. Must be between 0 and 32, inclusive.
     * @returns a bit flag.
     * @throws Error if index is out of bounds.
     */
    static createFlag(index) {
        if (index < 0 || index > 32) {
            throw new Error(`Invalid index ${index} for bit flag. Index must be between 0 and 32.`);
        }
        return 1 << index;
    }
    /**
     * Gets the inverse of some bit flags.
     * @param flags The bit flag group containing the flags to invert.
     * @param mask An optional bit mask to use when applying the inverse operation. The operation will only be performed
     * at the indexes where the mask has a value of 1 (true). If a mask is not specified, the operation will be performed
     * at all indexes.
     * @returns the inverse
     */
    static not(flags, mask = ~0) {
        return flags ^ mask;
    }
    /**
     * Gets the union of zero or more bit flags.
     * @param flags A list of bit flags.
     * @returns the union of the bit flags.
     */
    static union(...flags) {
        let result = 0;
        const len = flags.length;
        for (let i = 0; i < len; i++) {
            result |= flags[i];
        }
        return result;
    }
    /**
     * Gets the intersection of zero or more bit flags.
     * @param flags A list of bit flags.
     * @returns the intersection of the bit flags.
     */
    static intersection(...flags) {
        const len = flags.length;
        if (len === 0) {
            return 0;
        }
        let result = flags[0];
        for (let i = 1; i < len; i++) {
            result &= flags[i];
        }
        return result;
    }
    /**
     * Checks if a bit flag group meets at least one condition from a list of conditions.
     * @param flags A bit flag group.
     * @param conditions The conditions to meet, as a bit flag group.
     * @returns whether the bit flag group meets at least one condition.
     */
    static isAny(flags, conditions) {
        return (flags & conditions) !== 0;
    }
    /**
     * Checks if a bit flag group meets all the conditions from a list of conditions.
     * @param flags A bit flag group.
     * @param conditions The conditions to meet, as a bit flag group.
     * @returns whether the bit flag group meets all the conditions.
     */
    static isAll(flags, conditions) {
        return (flags & conditions) === conditions;
    }
    /**
     * Iterates through a bit flag group and executes a callback function once for each flag.
     * @param flags A bit flag group.
     * @param callback A function which will be called once for each flag.
     * @param valueFilter The value on which to filter. If defined, only flags with values equal to the filter will be
     * iterated, otherwise all flags will be iterated regardless of their values.
     * @param startIndex The index of the flag at which to start (inclusive). Defaults to 0.
     * @param endIndex The index of the flag at which to end (exclusive). Defaults to 32.
     */
    static forEach(flags, callback, valueFilter, startIndex, endIndex) {
        startIndex = Utils.Clamp(startIndex !== null && startIndex !== void 0 ? startIndex : (startIndex = 0), 0, 32);
        endIndex = Utils.Clamp(endIndex !== null && endIndex !== void 0 ? endIndex : (endIndex = 32), 0, 32);
        for (let i = startIndex; i < endIndex; i++) {
            const value = (flags & (1 << i)) !== 0;
            if (valueFilter === undefined || valueFilter === value) {
                callback(value, i, flags);
            }
        }
    }
}

/**
 * A utility class for creating number formatters.
 */
class NumberFormatter {
    /**
     * Formats a number to a string.
     * @param precision The precision to which to round the number. A value of 0 denotes no rounding.
     * @param roundFunc The rounding function to use.
     * @param maxDigits The maximum number of digits to enforce.
     * @param forceDecimalZeroes Whether to force trailing zeroes after the decimal point.
     * @param pad The number of digits to which to pad with zeroes in front of the decimal point.
     * @param showCommas Whether to show commas.
     * @param forceSign Whether to force the display of a positive sign.
     * @param nanString The string to use for NaN.
     * @param number The number to format.
     * @returns A formatted string.
     */
    static formatNumber(precision, roundFunc, maxDigits, forceDecimalZeroes, pad, showCommas, forceSign, nanString, number) {
        if (isNaN(number)) {
            return nanString;
        }
        const sign = number < 0 ? '-' : '+';
        const abs = Math.abs(number);
        let formatted;
        if (precision != 0) {
            const rounded = roundFunc(abs / precision) * precision;
            const precisionString = `${precision}`;
            const decimalIndex = precisionString.indexOf('.');
            if (decimalIndex >= 0) {
                formatted = rounded.toFixed(precisionString.length - decimalIndex - 1);
            }
            else {
                formatted = `${rounded}`;
            }
        }
        else {
            formatted = `${abs}`;
        }
        let decimalIndex = formatted.indexOf('.');
        if (!forceDecimalZeroes && decimalIndex >= 0) {
            formatted = formatted.replace(/0+$/, '');
            if (formatted.indexOf('.') == formatted.length - 1) {
                formatted = formatted.substring(0, formatted.length - 1);
            }
        }
        decimalIndex = formatted.indexOf('.');
        if (decimalIndex >= 0 && formatted.length - 1 > maxDigits) {
            const shift = Math.max(maxDigits - decimalIndex, 0);
            const shiftPrecision = Math.pow(0.1, shift);
            formatted = (roundFunc(abs / shiftPrecision) * shiftPrecision).toFixed(shift);
        }
        if (pad === 0) {
            formatted = formatted.replace(/^0\./, '.');
        }
        else if (pad > 1) {
            decimalIndex = formatted.indexOf('.');
            if (decimalIndex < 0) {
                decimalIndex = formatted.length;
            }
            formatted = formatted.padStart(pad + formatted.length - decimalIndex, '0');
        }
        if (showCommas) {
            const parts = formatted.split('.');
            parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            formatted = parts.join('.');
        }
        return ((forceSign || sign === '-') ? sign : '') + formatted;
    }
    /**
     * Creates a number formatter.
     * @param options Options to customize the formatter.
     * @returns A number formatter.
     */
    static create(options) {
        const optsToUse = Object.assign({}, NumberFormatter.DEFAULT_OPTIONS);
        Object.assign(optsToUse, options);
        return NumberFormatter.formatNumber.bind(undefined, optsToUse.precision, NumberFormatter.roundFuncs[optsToUse.round], optsToUse.maxDigits, optsToUse.forceDecimalZeroes, optsToUse.pad, optsToUse.showCommas, optsToUse.forceSign, optsToUse.nanString);
    }
}
NumberFormatter.DEFAULT_OPTIONS = {
    precision: 0,
    round: 0,
    maxDigits: Infinity,
    forceDecimalZeroes: true,
    pad: 1,
    showCommas: false,
    forceSign: false,
    nanString: 'NaN'
};
NumberFormatter.roundFuncs = {
    [-1]: Math.floor,
    [0]: Math.round,
    [1]: Math.ceil
};

/** A class that linearly drives a SimVar value towards a given set point. */
class LinearServo {
    /**
     * Creates an instance of a LinearServo.
     * @param rate The rate, in units per second, to drive the servo.
     */
    constructor(rate) {
        this.rate = rate;
    }
    /**
     * Drives the servo towards the set point.
     * @param currentValue The current value.
     * @param setValue The value to drive towards.
     * @returns The output value.
     */
    drive(currentValue, setValue) {
        if (this.currentTime === undefined) {
            this.currentTime = new Date().appTime();
            return currentValue;
        }
        const currentTime = new Date().appTime();
        const deltaTime = currentTime - this.currentTime;
        this.currentTime = currentTime;
        const deltaValue = setValue - currentValue;
        const maximumDrive = this.rate * (deltaTime / 1000);
        const output = Math.abs(deltaValue) > maximumDrive
            ? currentValue + (Math.sign(deltaValue) * maximumDrive)
            : setValue;
        return output;
    }
}

/** A PID controller. */
class PidController {
    /**
     * Creates a new PidController.
     * @param kP The proportional gain of the controller.
     * @param kI The integral gain of the controller.
     * @param kD The differential gain of the controller.
     * @param maxOut The maximum output of the controller.
     * @param minOut The minumum output of the controller.
     * @param maxI The maximum integral gain.
     * @param minI The minimum integral gain.
     */
    constructor(kP, kI, kD, maxOut, minOut, maxI = Number.MAX_SAFE_INTEGER, minI = Number.MIN_SAFE_INTEGER) {
        this.kP = kP;
        this.kI = kI;
        this.kD = kD;
        this.maxOut = maxOut;
        this.minOut = minOut;
        this.maxI = maxI;
        this.minI = minI;
        /** The previously sampled error. */
        this.previousError = 0;
        /** The previously generated output. */
        this.previousOutput = 0;
        /** The currently accumulated integral. */
        this.integral = 0;
    }
    /**
     * Gets the output of the PID controller at a given time.
     * @param deltaTime The difference in time between the previous sample and this sample.
     * @param error The amount of error seen between the desired output and the current output.
     * @returns The PID output.
     */
    getOutput(deltaTime, error) {
        const p = this.kP * error;
        if (Math.sign(error) === Math.sign(this.previousError)) {
            this.integral += ((error * deltaTime) + ((deltaTime * (error - this.previousError)) / 2)) * this.kI;
            this.integral = PidController.clamp(this.integral, this.maxI, this.minI);
        }
        else {
            this.integral = 0;
        }
        const i = this.integral;
        const d = this.kD * ((error - this.previousError) / deltaTime);
        const output = PidController.clamp(p + i + d, this.maxOut, this.minOut);
        this.previousError = error;
        this.previousOutput = output;
        return output;
    }
    /** Resets the controller. */
    reset() {
        this.previousError = 0;
        this.previousOutput = 0;
        this.integral = 0;
    }
    /**
     * Clamps a number to maximum and minimum values.
     * @param value The value to clamp.
     * @param max The maximum value.
     * @param min The minumum value.
     * @returns The clamped value.
     */
    static clamp(value, max, min) {
        return Math.min(Math.max(value, min), max);
    }
}

/**
 * A simple timer for handling debounce.
 */
class DebounceTimer {
    constructor() {
        this.timer = null;
    }
    /**
     * Checks whether an action is pending on this timer.
     * @returns Whether an action is pending on this timer.
     */
    isPending() {
        return this.timer !== null;
    }
    /**
     * Schedules an action. Waits for a specified amount of time, and executes the action only if no other action is
     * scheduled on this timer during the delay.
     * @param action The action to schedule.
     * @param delay The debounce delay, in milliseconds.
     */
    schedule(action, delay) {
        this.clear();
        this.timer = setTimeout(() => {
            this.timer = null;
            action();
        }, delay);
    }
    /**
     * Clears this timer of any pending actions. Actions that are cleared will not be executed.
     */
    clear() {
        if (this.timer === null) {
            return;
        }
        clearTimeout(this.timer);
        this.timer = null;
    }
}

/**
 * An event bus consumer for a specific topic.
 */
class Consumer {
    /**
     * Creates an instance of a Consumer.
     * @param bus The event bus to subscribe to.
     * @param topic The topic of the subscription.
     * @param state The state for the consumer to track.
     * @param currentHandler The current build filter handler stack, if any.
     */
    constructor(bus, topic, state = {}, currentHandler) {
        this.bus = bus;
        this.topic = topic;
        this.state = state;
        this.currentHandler = currentHandler;
    }
    /**
     * Handles an event using the provided event handler.
     * @param handler The event handler for the event.
     */
    handle(handler) {
        if (this.currentHandler !== undefined) {
            /**
             * The handler reference to store.
             * @param data The input data to the handler.
             */
            this.handlerReference = (data) => {
                if (this.currentHandler !== undefined) {
                    this.currentHandler(data, this.state, handler);
                }
            };
            this.bus.on(this.topic, this.handlerReference);
        }
        else {
            this.bus.on(this.topic, handler);
        }
    }
    /**
     * Disables handling of the event.
     * @param handler The handler to disable.
     */
    off(handler) {
        if (this.handlerReference !== undefined) {
            this.bus.off(this.topic, this.handlerReference);
        }
        else {
            this.bus.off(this.topic, handler);
        }
    }
    /**
     * Caps the event subscription to a specified frequency, in Hz.
     * @param frequency The frequency, in Hz, to cap to.
     * @returns A new consumer with the applied frequency filter.
     */
    atFrequency(frequency) {
        const deltaTimeTrigger = 1000 / frequency;
        return new Consumer(this.bus, this.topic, { previousTime: Date.now() }, (data, state, next) => {
            const currentTime = Date.now();
            const deltaTime = currentTime - state.previousTime;
            if (deltaTimeTrigger <= deltaTime) {
                while ((state.previousTime + deltaTimeTrigger) < currentTime) {
                    state.previousTime += deltaTimeTrigger;
                }
                this.with(data, next);
            }
        });
    }
    /**
     * Quantizes the numerical event data to consume only at the specified decimal precision.
     * @param precision The decimal precision to snap to.
     * @returns A new consumer with the applied precision filter.
     */
    withPrecision(precision) {
        return new Consumer(this.bus, this.topic, { lastValue: 0 }, (data, state, next) => {
            const dataValue = data;
            const multiplier = Math.pow(10, precision);
            const currentValueAtPrecision = Math.round(dataValue * multiplier) / multiplier;
            if (currentValueAtPrecision !== state.lastValue) {
                state.lastValue = currentValueAtPrecision;
                this.with(currentValueAtPrecision, next);
            }
        });
    }
    /**
     * Filter the subscription to consume only when the value has changed by a minimum amount.
     * @param amount The minimum amount threshold below which the consumer will not consume.
     * @returns A new consumer with the applied change threshold filter.
     */
    whenChangedBy(amount) {
        return new Consumer(this.bus, this.topic, { lastValue: 0 }, (data, state, next) => {
            const dataValue = data;
            const diff = Math.abs(dataValue - state.lastValue);
            if (diff >= amount) {
                state.lastValue = dataValue;
                this.with(data, next);
            }
        });
    }
    /**
     * Filter the subscription to consume only if the value has changed. At all.  Really only
     * useful for strings or other events that don't change much.
     * @returns A new consumer with the applied change threshold filter.
     */
    whenChanged() {
        return new Consumer(this.bus, this.topic, { lastValue: '' }, (data, state, next) => {
            if (state.lastValue !== data) {
                state.lastValue = data;
                this.with(data, next);
            }
        });
    }
    /**
     * Filters events by time such that events will not be consumed until a minimum duration
     * has passed since the previous event.
     * @param deltaTime The minimum delta time between events.
     * @returns A new consumer with the applied change threshold filter.
     */
    onlyAfter(deltaTime) {
        return new Consumer(this.bus, this.topic, { previousTime: Date.now() }, (data, state, next) => {
            const currentTime = Date.now();
            const timeDiff = currentTime - state.previousTime;
            if (timeDiff > deltaTime) {
                state.previousTime += deltaTime;
                this.with(data, next);
            }
        });
    }
    /**
     * Builds a handler stack from the current handler.
     * @param data The data to send in to the handler.
     * @param handler The handler to use for processing.
     */
    with(data, handler) {
        if (this.currentHandler !== undefined) {
            this.currentHandler(data, this.state, handler);
        }
        else {
            handler(data);
        }
    }
}

/**
 * A typed container for subscribers interacting with the Event Bus.
 */
class EventSubscriber {
    /**
     * Creates an instance of an EventSubscriber.
     * @param bus The EventBus that is the parent of this instance.
     */
    constructor(bus) {
        this.bus = bus;
    }
    /**
     * Subscribes to a topic on the bus.
     * @param topic The topic to subscribe to.
     * @returns A consumer to bind the event handler to.
     */
    on(topic) {
        return new Consumer(this.bus, topic);
    }
}

/// <reference types="msfstypes/JS/common" />
/**
 * An event bus that can be used to publish data from backend
 * components and devices to consumers.
 */
class EventBus {
    /**
     * Creates an instance of an EventBus.
     * @param useStorageSync Whether or not to use storage sync (optional, default false)
     */
    constructor(useStorageSync) {
        this._topicHandlersMap = new Map();
        this._wildcardHandlers = new Array();
        this._eventCache = new Map();
        this._busId = Math.floor(Math.random() * 2147483647);
        const syncFunc = useStorageSync ? EventBusStorageSync : EventBusCoherentSync;
        this._busSync = new syncFunc(this.pub.bind(this), this._busId);
        console.log('sending resync request');
        this.syncEvent('event_bus', 'resync_request', false);
        this.on('event_bus', (data) => {
            if (data == 'resync_request') {
                console.log('got resync request');
                this.resyncEvents();
            }
        });
    }
    /**
     * Subscribes to a topic on the bus.
     * @param topic The topic to subscribe to.
     * @param handler The handler to be called when an event happens.
     */
    on(topic, handler) {
        var _a;
        const handlers = this._topicHandlersMap.get(topic);
        const isNew = !(handlers && handlers.push(handler));
        if (isNew) {
            this._topicHandlersMap.set(topic, [handler]);
        }
        const lastState = (_a = this._eventCache.get(topic)) === null || _a === void 0 ? void 0 : _a.data;
        if (this._eventCache.get(topic) !== undefined) {
            handler(lastState);
        }
    }
    /**
     * Unsubscribes a handler from the topic's events.
     * @param topic The topic to unsubscribe from.
     * @param handler The handler to unsubscribe from topic.
     */
    off(topic, handler) {
        const handlers = this._topicHandlersMap.get(topic);
        if (handlers) {
            handlers.splice(handlers.indexOf(handler) >>> 0, 1);
        }
    }
    /**
     * Subscribe to the handler as * to all topics.
     * @param handler The handler to subscribe to all events.
     */
    onAll(handler) {
        this._wildcardHandlers.push(handler);
    }
    /**
     * Unsubscribe the handler from all topics.
     * @param handler The handler to unsubscribe from all events.
     */
    offAll(handler) {
        const handlerIndex = this._wildcardHandlers.indexOf(handler);
        if (handlerIndex > -1) {
            this._wildcardHandlers.splice(handlerIndex >>> 0, 1);
        }
    }
    /**
     * Publishes an event to the topic on the bus.
     * @param topic The topic to publish to.
     * @param data The data portion of the event.
     * @param sync Whether or not this message needs to be synced on local stoage.
     * @param isCached Whether or not this message will be resync'd across the bus on load.
     */
    pub(topic, data, sync = false, isCached = true) {
        if (isCached) {
            this._eventCache.set(topic, { data: data, synced: sync });
        }
        const handlers = this._topicHandlersMap.get(topic);
        if (handlers !== undefined) {
            const len = handlers.length;
            for (let i = 0; i < len; i++) {
                try {
                    handlers[i](data);
                }
                catch (error) {
                    console.error(`Error in EventBus Handler: ${error}`);
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
        }
        // We don't know if anything is subscribed on busses in other instruments,
        // so we'll unconditionally sync if sync is true and trust that the
        // publisher knows what it's doing.
        if (sync) {
            this.syncEvent(topic, data, isCached);
        }
        // always push to wildcard handlers
        const wcLen = this._wildcardHandlers.length;
        for (let i = 0; i < wcLen; i++) {
            this._wildcardHandlers[i](topic, data);
        }
    }
    /**
     * Re-sync all synced events
     */
    resyncEvents() {
        for (const [topic, event] of this._eventCache) {
            if (event.synced) {
                this.syncEvent(topic, event.data, true);
            }
        }
    }
    /**
     * Publish an event to the sync bus.
     * @param topic The topic to publish to.
     * @param data The data to publish.
     * @param isCached Whether or not this message will be resync'd across the bus on load.
     */
    syncEvent(topic, data, isCached) {
        // console.log(`sending synced event to ${topic}:`);
        // console.log(data);
        this._busSync.sendEvent(topic, data, isCached);
    }
    /**
     * Gets a typed publisher from the event bus..
     * @returns The typed publisher.
     */
    getPublisher() {
        return this;
    }
    /**
     * Gets a typed subscriber from the event bus.
     * @returns The typed subscriber.
     */
    getSubscriber() {
        return new EventSubscriber(this);
    }
}
/**
 * A class that manages event bus synchronization via data storage.
 */
class EventBusStorageSync {
    /**
     * Creates an instance of EventBusStorageSync.
     * @param recvEventCb A callback to execute when an event is received on the bus.
     * @param busId The ID of the bus.  Derp.
     */
    constructor(recvEventCb, busId) {
        this.recvEventCb = recvEventCb;
        this.busId = busId;
        window.addEventListener('storage', this.receiveEvent.bind(this));
    }
    /**
     * Sends an event via storage events.
     * @param topic The topic to send data on.
     * @param data The data to send.
     */
    sendEvent(topic, data) {
        // TODO can we do the stringing more gc friendly?
        // TODO we could not stringify on simple types, but the receiver wouldn't know I guess
        // TODO add handling for busIds to avoid message loops
        //console.log('send' + topic.toString());
        localStorage.setItem(EventBusStorageSync.EB_KEY, `${topic.toString()},${data !== undefined ? JSON.stringify(data) : EventBusStorageSync.EMPTY_DATA}`);
        // TODO move removeItem to a function called at intervals instead of every time?
        localStorage.removeItem(EventBusStorageSync.EB_KEY);
    }
    /**
     * Receives an event from storage and syncs onto the bus.
     * @param e The storage event that was received.
     */
    receiveEvent(e) {
        // TODO only react on topics that have subscribers
        //console.log('recv' + e.key);
        if (e.key === EventBusStorageSync.EB_KEY && e.newValue) {
            const val = e.newValue.split(',');
            this.recvEventCb(val[0], val.length > 1 ? JSON.parse(val[1]) : undefined, true);
        }
    }
}
EventBusStorageSync.EMPTY_DATA = '{}';
EventBusStorageSync.EB_KEY = 'eb.evt';
/**
 * A class that manages event bus synchronization via Coherent notifications.
 */
class EventBusCoherentSync {
    /**
     * Creates an instance of EventBusCoherentSync.
     * @param recvEventCb A callback to execute when an event is received on the bus.
     * @param busId The ID of the bus.  Derp.
     */
    constructor(recvEventCb, busId) {
        this.evtNum = 0;
        this.lastEventSynced = -1;
        this.recvEventCb = recvEventCb;
        this.busId = busId;
        this.listener = RegisterViewListener(EventBusCoherentSync.EB_LISTENER_KEY);
        this.listener.on(EventBusCoherentSync.EB_KEY, this.receiveEvent.bind(this));
    }
    /**
     * Sends an event via Coherent events.
     * @param topic The topic to send data on.
     * @param data The data to send.
     * @param isCached Whether or not this event is cached.
     */
    sendEvent(topic, data, isCached) {
        // console.log('send ' + topic.toString());
        this.listener.triggerToAllSubscribers(EventBusCoherentSync.EB_KEY, { topic, data, isCached, busId: this.busId, evtNum: this.evtNum++ });
    }
    /**
     * Receives an event via Coherent and syncs onto the bus.
     * @param e The storage event that was received.
     */
    receiveEvent(e) {
        // If we've sent this event, don't act on it.
        if (e.busId == this.busId) {
            return;
        }
        if (this.lastEventSynced !== e.evtNum) {
            // TODO only react on topics that have subscribers
            // console.log(`coherent recv ${e['topic']}`);
            this.lastEventSynced = e.evtNum;
            this.recvEventCb(e['topic'], e['data'], undefined, e['isCached']);
        }
    }
}
EventBusCoherentSync.EMPTY_DATA = '{}';
EventBusCoherentSync.EB_KEY = 'eb.evt';
EventBusCoherentSync.EB_LISTENER_KEY = 'JS_LISTENER_SIMVARS';

/**
 * A basic event-bus publisher.
 */
class BasePublisher {
    /**
     * Creates an instance of BasePublisher.
     * @param bus The common event bus.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(bus, pacer = undefined) {
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.publishActive = false;
        this.pacer = pacer;
    }
    /**
     * Start publishing.
     */
    startPublish() {
        this.publishActive = true;
    }
    /**
     * Stop publishing.
     */
    stopPublish() {
        this.publishActive = false;
    }
    /**
     * Tells whether or not the publisher is currently active.
     * @returns True if the publisher is active, false otherwise.
     */
    isPublishing() {
        return this.publishActive;
    }
    /**
     * A callback called when the publisher receives an update cycle.
     */
    onUpdate() {
        return;
    }
    /**
     * Publish a message if publishing is acpive
     * @param topic The topic key to publish to.
     * @param data The data type for chosen topic.
     * @param sync Whether or not the event should be synced via local storage.
     */
    publish(topic, data, sync = false) {
        if (this.publishActive && (!this.pacer || this.pacer.canPublish(topic, data))) {
            this.publisher.pub(topic, data, sync);
        }
    }
}
/**
 * A base class for publishers that need to handle simvars with built-in
 * support for pacing callbacks.
 */
class SimVarPublisher extends BasePublisher {
    /**
     * Create a SimVarPublisher
     * @param simVarMap A map of simvar event type keys to a SimVarDefinition.
     * @param bus The EventBus to use for publishing.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(simVarMap, bus, pacer = undefined) {
        super(bus, pacer);
        this.simvars = simVarMap;
        this.subscribed = new Set();
    }
    /**
     * Subscribe to an event type to begin publishing.
     * @param data Key of the event type in the simVarMap
     */
    subscribe(data) {
        this.subscribed.add(data);
    }
    /**
     * Unsubscribe to an event to stop publishing.
     * @param data Key of the event type in the simVarMap
     */
    unsubscribe(data) {
        // TODO If we have multiple subscribers we may want to add reference counting here.
        this.subscribed.delete(data);
    }
    /**
     * Read the value of a given simvar by its key.
     * @param key The key of the simvar in simVarMap
     * @returns The value returned by SimVar.GetSimVarValue()
     */
    getValue(key) {
        const simvar = this.simvars.get(key);
        if (simvar === undefined) {
            return undefined;
        }
        return SimVar.GetSimVarValue(simvar.name, simvar.type);
    }
    /**
     * Publish all subscribed data points to the bus.
     */
    onUpdate() {
        for (const data of this.subscribed.values()) {
            const value = this.getValue(data);
            if (value !== undefined) {
                this.publish(data, value);
            }
        }
    }
    /**
     * Change the simvar read for a given key.
     * @param key The key of the simvar in simVarMap
     * @param value The new value to set the simvar to.
     */
    updateSimVarSource(key, value) {
        this.simvars.set(key, value);
    }
}

/**
 * A publisher for publishing H:Events on the bus.
 */
class HEventPublisher extends BasePublisher {
    /**
     * Dispatches an H:Event to the event bus.
     * @param hEvent The H:Event to dispatch.
     * @param sync Whether this event should be synced (optional, default false)
     */
    dispatchHEvent(hEvent, sync = false) {
        //console.log(`dispaching hevent:  ${hEvent}`);
        this.publish('hEvent', hEvent, sync);
    }
}

/**
 * Valid type arguments for Set/GetSimVarValue
 */
var SimVarValueType;
(function (SimVarValueType) {
    SimVarValueType["Number"] = "number";
    SimVarValueType["Degree"] = "degrees";
    SimVarValueType["Knots"] = "knots";
    SimVarValueType["Feet"] = "feet";
    SimVarValueType["Meters"] = "meters";
    SimVarValueType["FPM"] = "feet per minute";
    SimVarValueType["Radians"] = "radians";
    SimVarValueType["InHG"] = "inches of mercury";
    SimVarValueType["MB"] = "Millibars";
    SimVarValueType["Bool"] = "Bool";
    SimVarValueType["Celsius"] = "celsius";
    SimVarValueType["MHz"] = "MHz";
    SimVarValueType["KHz"] = "KHz";
    SimVarValueType["NM"] = "nautical mile";
    SimVarValueType["String"] = "string";
    SimVarValueType["RPM"] = "Rpm";
    SimVarValueType["PPH"] = "Pounds per hour";
    SimVarValueType["GPH"] = "gph";
    SimVarValueType["Farenheit"] = "farenheit";
    SimVarValueType["PSI"] = "psi";
    SimVarValueType["GAL"] = "gallons";
    SimVarValueType["Hours"] = "Hours";
    SimVarValueType["Volts"] = "Volts";
    SimVarValueType["Amps"] = "Amperes";
    SimVarValueType["Seconds"] = "seconds";
    SimVarValueType["Enum"] = "Enum";
    SimVarValueType["LLA"] = "latlonalt";
})(SimVarValueType || (SimVarValueType = {}));

/**
 * A publisher for control interactions.
 * This is meant to handle the events for which there aren't existing HEvents
 * in the sim to allow us to maintain a decoupled, event-driven architecture.
 */
class ControlPublisher extends BasePublisher {
    /**
     * Create a ControlPublisher.
     * @param bus The EventBus to publish to.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer = undefined) {
        super(bus, pacer);
    }
    /**
     * Publish a control event.
     * @param event The event from ControlEvents.
     * @param value The value of the event.
     */
    publishEvent(event, value) {
        this.publish(event, value, true);
    }
    /** debug logger */
    startPublish() {
        super.startPublish();
        console.log('control publisher started.');
    }
}

/// <reference types="msfstypes/Pages/VCockpit/Instruments/Shared/utils/XMLLogic" />
/** The kind of data to return. */
var CompositeLogicXMLValueType;
(function (CompositeLogicXMLValueType) {
    CompositeLogicXMLValueType[CompositeLogicXMLValueType["Any"] = 0] = "Any";
    CompositeLogicXMLValueType[CompositeLogicXMLValueType["Number"] = 1] = "Number";
    CompositeLogicXMLValueType[CompositeLogicXMLValueType["String"] = 2] = "String";
})(CompositeLogicXMLValueType || (CompositeLogicXMLValueType = {}));
/**
 *
 */
class CompositeLogicXMLHost {
    constructor() {
        this.anyHandlers = new Array();
        this.stringHandlers = new Array();
        this.numberHandlers = new Array();
        this.anyResultCache = new Array();
        this.stringResultCache = new Array();
        this.numberResultCache = new Array();
        this.context = new LogicXMLContext();
    }
    /**
     * Add a new logic element to calcluate a number or a string.
     * @param logic A CompositeLogicXMLElement.
     * @param handler A callback hander to take new values of either type.
     * @returns The current value of the logic.
     */
    addLogic(logic, handler) {
        this.anyHandlers.push({ logic: logic, handler: handler });
        return logic.getValue(this.context);
    }
    /**
     * Add a new logic element to calcluate a number.
     * @param logic A CompositeLogicXMLElement.
     * @param handler A callback hander to take new values as numbers.
     * @param precision An optional precision to require for updates to be sent.
     * @returns The current value of the logic.
     */
    addLogicAsNumber(logic, handler, precision) {
        this.numberHandlers.push({ logic: logic, handler: handler, precision: precision });
        return logic.getValueAsNumber(this.context);
    }
    /**
     * Add a new logic element to calcluate a string.
     * @param logic A CompositeLogicXMLElement.
     * @param handler A callback hander to take new values as strings.
     * @returns The current value of the logic.
     */
    addLogicAsString(logic, handler) {
        this.stringHandlers.push({ logic: logic, handler: handler });
        return logic.getValueAsString(this.context);
    }
    /**
     * Add a function to the logic context.
     * @param funcSpec The XMLFunction configuration.
     * @returns The function's current value.
     */
    addFunction(funcSpec) {
        const func = new LogicXMLFunction();
        func.name = funcSpec.name;
        func.callback = funcSpec.logic;
        this.context.addFunction(func);
        return funcSpec.logic.getValue(this.context);
    }
    /**
     * Update every logic element and publish updates.
     */
    update() {
        for (let i = 0; i < this.anyHandlers.length; i++) {
            const newVal = this.anyHandlers[i].logic.getValue(this.context);
            if (newVal !== this.anyResultCache[i]) {
                this.anyResultCache[i] = newVal;
                this.anyHandlers[i].handler(newVal);
            }
        }
        for (let i = 0; i < this.stringHandlers.length; i++) {
            const newVal = this.stringHandlers[i].logic.getValueAsString(this.context);
            if (newVal !== this.stringResultCache[i]) {
                this.stringResultCache[i] = newVal;
                this.stringHandlers[i].handler(newVal);
            }
        }
        for (let i = 0; i < this.numberHandlers.length; i++) {
            let newVal = this.numberHandlers[i].logic.getValueAsNumber(this.context);
            let precision = this.numberHandlers[i].precision;
            if (precision !== undefined) {
                precision = Math.pow(10, precision);
                newVal = Math.round(newVal * precision) / precision;
            }
            if (newVal !== this.numberResultCache[i]) {
                this.numberResultCache[i] = newVal;
                this.numberHandlers[i].handler(newVal);
            }
        }
        this.context.update();
    }
}

/// <reference types="msfstypes/JS/dataStorage" />
/* eslint-disable no-inner-declarations */
// eslint-disable-next-line @typescript-eslint/no-namespace
var DataStore;
(function (DataStore) {
    /**
     * Writes a keyed value to the data store.
     * @param key A key.
     * @param value The value to set.
     */
    function set(key, value) {
        SetStoredData(key, JSON.stringify(value));
    }
    DataStore.set = set;
    /**
     * Retrieves a keyed value from the data store.
     * @param key A key.
     * @returns the value stored under the key, or undefined if one could not be retrieved.
     */
    function get(key) {
        try {
            const string = GetStoredData(key);
            return JSON.parse(string);
        }
        catch (e) {
            return undefined;
        }
    }
    DataStore.get = get;
    /**
     * Removes a key from the data store.
     * @param key The key to remove.
     */
    function remove(key) {
        DeleteStoredData(key);
    }
    DataStore.remove = remove;
})(DataStore || (DataStore = {}));

/**
 * Types of airspaces.
 */
var AirspaceType;
(function (AirspaceType) {
    AirspaceType[AirspaceType["None"] = 0] = "None";
    AirspaceType[AirspaceType["Center"] = 1] = "Center";
    AirspaceType[AirspaceType["ClassA"] = 2] = "ClassA";
    AirspaceType[AirspaceType["ClassB"] = 3] = "ClassB";
    AirspaceType[AirspaceType["ClassC"] = 4] = "ClassC";
    AirspaceType[AirspaceType["ClassD"] = 5] = "ClassD";
    AirspaceType[AirspaceType["ClassE"] = 6] = "ClassE";
    AirspaceType[AirspaceType["ClassF"] = 7] = "ClassF";
    AirspaceType[AirspaceType["ClassG"] = 8] = "ClassG";
    AirspaceType[AirspaceType["Tower"] = 9] = "Tower";
    AirspaceType[AirspaceType["Clearance"] = 10] = "Clearance";
    AirspaceType[AirspaceType["Ground"] = 11] = "Ground";
    AirspaceType[AirspaceType["Departure"] = 12] = "Departure";
    AirspaceType[AirspaceType["Approach"] = 13] = "Approach";
    AirspaceType[AirspaceType["MOA"] = 14] = "MOA";
    AirspaceType[AirspaceType["Restricted"] = 15] = "Restricted";
    AirspaceType[AirspaceType["Prohibited"] = 16] = "Prohibited";
    AirspaceType[AirspaceType["Warning"] = 17] = "Warning";
    AirspaceType[AirspaceType["Alert"] = 18] = "Alert";
    AirspaceType[AirspaceType["Danger"] = 19] = "Danger";
    AirspaceType[AirspaceType["Nationalpark"] = 20] = "Nationalpark";
    AirspaceType[AirspaceType["ModeC"] = 21] = "ModeC";
    AirspaceType[AirspaceType["Radar"] = 22] = "Radar";
    AirspaceType[AirspaceType["Training"] = 23] = "Training";
    AirspaceType[AirspaceType["Max"] = 24] = "Max";
})(AirspaceType || (AirspaceType = {}));

/**
 *
 */
class CoherentAirspace {
    /**
     * Constructor.
     * @param def The airspace definition to use for the new airspace.
     * @param uid A unique string ID for the new airspace.
     */
    constructor(def, uid) {
        /** @inheritdoc */
        this.name = '';
        this._segments = [];
        this.type = def.type;
        this.uid = uid;
        const segments = def.segments;
        const len = segments.length;
        for (let i = 0; i < len; i++) {
            const point = segments[i];
            this._segments[i] = new GeoPoint(point.lat, point.long);
        }
    }
    /** @inheritdoc */
    get segments() {
        return this._segments;
    }
    /** @inheritdoc */
    equals(other) {
        if (other instanceof CoherentAirspace) {
            return this.uid === other.uid;
        }
        return this.type === other.type
            && this.segments.length === other.segments.length
            && this.segments.every((point, index) => point.equals(other.segments[index]));
    }
}
/**
 * A searcher for airspaces.
 */
class AirspaceSearcher {
    /**
     * Constructor.
     * @param cacheSize The maximum size of the Airspace cache.
     */
    constructor(cacheSize = AirspaceSearcher.DEFAULT_CACHE_SIZE) {
        this.cacheSize = cacheSize;
        this.cache = new Map();
        this._isBusy = false;
        this.queue = [];
    }
    /**
     * Checks whether this searcher is currently busy with a search.
     * @returns whether this searcher is currently busy with a search.
     */
    isBusy() {
        return this._isBusy;
    }
    /**
     * Searches for airspaces around a geographic point. If the searcher is not busy, the search will execute
     * immediately. If the search is busy, the search will be queued. Queued searches will be executed one at a time in
     * FIFO order as searches are finished.
     * @param center The center of the search area.
     * @returns a Promise which is fulfilled with an array of airspaces when the search finishes.
     */
    search(center) {
        return new Promise(resolve => {
            if (this._isBusy || this.queue.length > 0) {
                this.enqueueSearch(center, resolve);
            }
            else {
                this.doSearch(center, resolve);
            }
        });
    }
    /**
     * Enqueues a search operation.
     * @param center The center of the search area.
     * @param resolve The Promise resolve function to call with the search results.
     */
    enqueueSearch(center, resolve) {
        this.queue.push(this.doSearch.bind(this, center, resolve));
    }
    /**
     * Executes the next search operation in the queue, if one exists.
     */
    processQueue() {
        const next = this.queue.shift();
        if (next) {
            next();
        }
    }
    /**
     * Executes an airspace search.
     * @param center The center of the search area.
     * @param resolve The Promise resolve function to call with the search results.
     */
    async doSearch(center, resolve) {
        this._isBusy = true;
        try {
            const coherentDefs = await Promise.race([
                this.executeCoherentSearch(center),
                new Promise((timeoutResolve, reject) => setTimeout(() => reject('Airspace search timed out.'), AirspaceSearcher.SEARCH_TIMEOUT))
            ]);
            const airspaces = this.processCoherentDefs(coherentDefs);
            resolve(airspaces);
        }
        catch (e) {
            console.log(e);
            resolve([]);
        }
        this._isBusy = false;
        this.processQueue();
    }
    /**
     * Executes a Coherent airspace search.
     * @param center The center of the search area.
     * @returns a Promise which is fulfilled with an array of Coherent airspace definitions when the search finishes.
     */
    async executeCoherentSearch(center) {
        await Coherent.call('SET_LOAD_LATLON', center.lat, center.lon);
        return await Coherent.call('GET_NEAREST_AIRSPACES');
    }
    /**
     * Processes an array of Coherent airspace definitions into an array of Airspaces.
     * @param defs An array fo Coherent airspace definitions.
     * @returns an array of Airspaces corresponding to the supplied definitions.
     */
    processCoherentDefs(defs) {
        const result = [];
        const len = defs.length;
        for (let i = 0; i < len; i++) {
            const def = defs[i];
            if (def.type === AirspaceType.None) {
                continue;
            }
            const uid = AirspaceSearcher.generateUID(def);
            let airspace = this.cache.get(uid);
            if (!airspace) {
                airspace = new CoherentAirspace(def, uid);
                this.cacheAirspace(airspace);
            }
            result.push(airspace);
        }
        return result;
    }
    /**
     * Adds an airspace to the cache. If the cache size exceeds the maximum after the operation, airspaces will be
     * removed from the cache in FIFO order to maintain the maximum cache size.
     * @param airspace The airspace to cache.
     */
    cacheAirspace(airspace) {
        this.cache.set(airspace.uid, airspace);
        if (this.cache.size > this.cacheSize) {
            this.cache.delete(this.cache.keys().next().value);
        }
    }
    /**
     * Generates a unique string ID for a Coherent airspace definition.
     * @param def The airspace definition.
     * @returns a unique string ID.
     */
    static generateUID(def) {
        const segments = def.segments;
        let uid = `${def.type}[${segments.length}]:`;
        // skip last vertex since it is always a repeat of the first; cap length to 10 to avoid creating super long strings
        const len = Math.min(segments.length - 1, 10);
        for (let i = 0; i < len; i++) {
            const point = segments[i];
            uid += `(${point.lat},${point.long})`;
        }
        // if vertices were skipped, grab the last (unique) vertex to decrease chance of uid collision.
        if (len < segments.length - 1) {
            const point = segments[segments.length - 2];
            uid += `(${point.lat},${point.long})`;
        }
        return uid;
    }
}
/** The amount of time to wait for a search to finish before it times out, in milliseconds. */
AirspaceSearcher.SEARCH_TIMEOUT = 5000;
AirspaceSearcher.DEFAULT_CACHE_SIZE = 1000;

/**
 * A viewlistener that gets autopilot mode information.
 */
// eslint-disable-next-line @typescript-eslint/no-namespace
var APController;
(function (APController) {
})(APController || (APController = {}));
var MSFSAPStates;
(function (MSFSAPStates) {
    MSFSAPStates[MSFSAPStates["LogicOn"] = 1] = "LogicOn";
    MSFSAPStates[MSFSAPStates["APOn"] = 2] = "APOn";
    MSFSAPStates[MSFSAPStates["FDOn"] = 4] = "FDOn";
    MSFSAPStates[MSFSAPStates["FLC"] = 8] = "FLC";
    MSFSAPStates[MSFSAPStates["Alt"] = 16] = "Alt";
    MSFSAPStates[MSFSAPStates["AltArm"] = 32] = "AltArm";
    MSFSAPStates[MSFSAPStates["GS"] = 64] = "GS";
    MSFSAPStates[MSFSAPStates["GSArm"] = 128] = "GSArm";
    MSFSAPStates[MSFSAPStates["Pitch"] = 256] = "Pitch";
    MSFSAPStates[MSFSAPStates["VS"] = 512] = "VS";
    MSFSAPStates[MSFSAPStates["Heading"] = 1024] = "Heading";
    MSFSAPStates[MSFSAPStates["Nav"] = 2048] = "Nav";
    MSFSAPStates[MSFSAPStates["NavArm"] = 4096] = "NavArm";
    MSFSAPStates[MSFSAPStates["WingLevel"] = 8192] = "WingLevel";
    MSFSAPStates[MSFSAPStates["Attitude"] = 16384] = "Attitude";
    MSFSAPStates[MSFSAPStates["ThrottleSpd"] = 32768] = "ThrottleSpd";
    MSFSAPStates[MSFSAPStates["ThrottleMach"] = 65536] = "ThrottleMach";
    MSFSAPStates[MSFSAPStates["ATArm"] = 131072] = "ATArm";
    MSFSAPStates[MSFSAPStates["YD"] = 262144] = "YD";
    MSFSAPStates[MSFSAPStates["EngineRPM"] = 524288] = "EngineRPM";
    MSFSAPStates[MSFSAPStates["TOGAPower"] = 1048576] = "TOGAPower";
    MSFSAPStates[MSFSAPStates["Autoland"] = 2097152] = "Autoland";
    MSFSAPStates[MSFSAPStates["TOGAPitch"] = 4194304] = "TOGAPitch";
    MSFSAPStates[MSFSAPStates["Bank"] = 8388608] = "Bank";
    MSFSAPStates[MSFSAPStates["FBW"] = 16777216] = "FBW";
    MSFSAPStates[MSFSAPStates["AvionicsManaged"] = 33554432] = "AvionicsManaged";
    MSFSAPStates[MSFSAPStates["None"] = -2147483648] = "None";
})(MSFSAPStates || (MSFSAPStates = {}));

/// <reference types="msfstypes/JS/Simplane" />
/**
 * The available facility frequency types.
 */
var FacilityFrequencyType;
(function (FacilityFrequencyType) {
    FacilityFrequencyType[FacilityFrequencyType["None"] = 0] = "None";
    FacilityFrequencyType[FacilityFrequencyType["ATIS"] = 1] = "ATIS";
    FacilityFrequencyType[FacilityFrequencyType["Multicom"] = 2] = "Multicom";
    FacilityFrequencyType[FacilityFrequencyType["Unicom"] = 3] = "Unicom";
    FacilityFrequencyType[FacilityFrequencyType["CTAF"] = 4] = "CTAF";
    FacilityFrequencyType[FacilityFrequencyType["Ground"] = 5] = "Ground";
    FacilityFrequencyType[FacilityFrequencyType["Tower"] = 6] = "Tower";
    FacilityFrequencyType[FacilityFrequencyType["Clearance"] = 7] = "Clearance";
    FacilityFrequencyType[FacilityFrequencyType["Approach"] = 8] = "Approach";
    FacilityFrequencyType[FacilityFrequencyType["Departure"] = 9] = "Departure";
    FacilityFrequencyType[FacilityFrequencyType["Center"] = 10] = "Center";
    FacilityFrequencyType[FacilityFrequencyType["FSS"] = 11] = "FSS";
    FacilityFrequencyType[FacilityFrequencyType["AWOS"] = 12] = "AWOS";
    FacilityFrequencyType[FacilityFrequencyType["ASOS"] = 13] = "ASOS";
    /** Clearance Pre-Taxi*/
    FacilityFrequencyType[FacilityFrequencyType["CPT"] = 14] = "CPT";
    /** Remote Clearance Delivery */
    FacilityFrequencyType[FacilityFrequencyType["GCO"] = 15] = "GCO";
})(FacilityFrequencyType || (FacilityFrequencyType = {}));
/** Additional Approach Types (additive to those defined in simplane). */
var AdditionalApproachType;
(function (AdditionalApproachType) {
    AdditionalApproachType[AdditionalApproachType["APPROACH_TYPE_VISUAL"] = 99] = "APPROACH_TYPE_VISUAL";
})(AdditionalApproachType || (AdditionalApproachType = {}));
/**
 * Flags indicating the approach fix type.
 */
var FixTypeFlags;
(function (FixTypeFlags) {
    FixTypeFlags[FixTypeFlags["None"] = 0] = "None";
    FixTypeFlags[FixTypeFlags["IAF"] = 1] = "IAF";
    FixTypeFlags[FixTypeFlags["IF"] = 2] = "IF";
    FixTypeFlags[FixTypeFlags["MAP"] = 4] = "MAP";
    FixTypeFlags[FixTypeFlags["FAF"] = 8] = "FAF";
    FixTypeFlags[FixTypeFlags["MAHP"] = 16] = "MAHP";
})(FixTypeFlags || (FixTypeFlags = {}));
/**
 * Flags indicating the rnav approach type.
 */
var RnavTypeFlags;
(function (RnavTypeFlags) {
    RnavTypeFlags[RnavTypeFlags["None"] = 0] = "None";
    RnavTypeFlags[RnavTypeFlags["LNAV"] = 1] = "LNAV";
    RnavTypeFlags[RnavTypeFlags["LNAVVNAV"] = 2] = "LNAVVNAV";
    RnavTypeFlags[RnavTypeFlags["LP"] = 4] = "LP";
    RnavTypeFlags[RnavTypeFlags["LPV"] = 8] = "LPV";
})(RnavTypeFlags || (RnavTypeFlags = {}));
var UserFacilityType;
(function (UserFacilityType) {
    UserFacilityType[UserFacilityType["RADIAL_RADIAL"] = 0] = "RADIAL_RADIAL";
    UserFacilityType[UserFacilityType["RADIAL_DISTANCE"] = 1] = "RADIAL_DISTANCE";
    UserFacilityType[UserFacilityType["LAT_LONG"] = 2] = "LAT_LONG";
})(UserFacilityType || (UserFacilityType = {}));
/**
 * ARINC 424 Leg Types
 */
var LegType;
(function (LegType) {
    /** An unknown leg type. */
    LegType[LegType["Unknown"] = 0] = "Unknown";
    /** An arc-to-fix leg. This indicates a DME arc leg to a specified fix.*/
    LegType[LegType["AF"] = 1] = "AF";
    /** A course-to-altitude leg. */
    LegType[LegType["CA"] = 2] = "CA";
    /**
     * A course-to-DME-distance leg. This leg is flown on a wind corrected course
     * to a specific DME distance from another fix.
     */
    LegType[LegType["CD"] = 3] = "CD";
    /** A course-to-fix leg.*/
    LegType[LegType["CF"] = 4] = "CF";
    /** A course-to-intercept leg. */
    LegType[LegType["CI"] = 5] = "CI";
    /** A course-to-radial intercept leg. */
    LegType[LegType["CR"] = 6] = "CR";
    /** A direct-to-fix leg, from an unspecified starting position. */
    LegType[LegType["DF"] = 7] = "DF";
    /**
     * A fix-to-altitude leg. A FA leg is flown on a track from a fix to a
     * specified altitude.
     */
    LegType[LegType["FA"] = 8] = "FA";
    /**
     * A fix-to-distance leg. This leg is flown on a track from a fix to a
     * specific distance from the fix.
     */
    LegType[LegType["FC"] = 9] = "FC";
    /**
     * A fix to DME distance leg. This leg is flown on a track from a fix to
     * a specific DME distance from another fix.
     */
    LegType[LegType["FD"] = 10] = "FD";
    /** A course-to-manual-termination leg. */
    LegType[LegType["FM"] = 11] = "FM";
    /** A hold-to-altitude leg. The hold is flown until a specified altitude is reached. */
    LegType[LegType["HA"] = 12] = "HA";
    /**
     * A hold-to-fix leg. This indicates one time around the hold circuit and
     * then an exit.
     */
    LegType[LegType["HF"] = 13] = "HF";
    /** A hold-to-manual-termination leg. */
    LegType[LegType["HM"] = 14] = "HM";
    /** Initial procedure fix. */
    LegType[LegType["IF"] = 15] = "IF";
    /** A procedure turn leg. */
    LegType[LegType["PI"] = 16] = "PI";
    /** A radius-to-fix leg, with endpoint fixes, a center fix, and a radius. */
    LegType[LegType["RF"] = 17] = "RF";
    /** A track-to-fix leg, from the previous fix to the terminator. */
    LegType[LegType["TF"] = 18] = "TF";
    /** A heading-to-altitude leg. */
    LegType[LegType["VA"] = 19] = "VA";
    /** A heading-to-DME-distance leg. */
    LegType[LegType["VD"] = 20] = "VD";
    /** A heading-to-intercept leg. */
    LegType[LegType["VI"] = 21] = "VI";
    /** A heading-to-manual-termination leg. */
    LegType[LegType["VM"] = 22] = "VM";
    /** A heading-to-radial intercept leg. */
    LegType[LegType["VR"] = 23] = "VR";
    /** A leg representing a discontinuity in the flight plan. */
    LegType[LegType["Discontinuity"] = 99] = "Discontinuity";
})(LegType || (LegType = {}));
/**
 * Types of altitude restrictions on procedure legs.
 */
var AltitudeRestrictionType;
(function (AltitudeRestrictionType) {
    AltitudeRestrictionType[AltitudeRestrictionType["Unused"] = 0] = "Unused";
    AltitudeRestrictionType[AltitudeRestrictionType["At"] = 1] = "At";
    AltitudeRestrictionType[AltitudeRestrictionType["AtOrAbove"] = 2] = "AtOrAbove";
    AltitudeRestrictionType[AltitudeRestrictionType["AtOrBelow"] = 3] = "AtOrBelow";
    AltitudeRestrictionType[AltitudeRestrictionType["Between"] = 4] = "Between";
})(AltitudeRestrictionType || (AltitudeRestrictionType = {}));
var LegTurnDirection;
(function (LegTurnDirection) {
    LegTurnDirection[LegTurnDirection["None"] = 0] = "None";
    LegTurnDirection[LegTurnDirection["Left"] = 1] = "Left";
    LegTurnDirection[LegTurnDirection["Right"] = 2] = "Right";
    LegTurnDirection[LegTurnDirection["Either"] = 3] = "Either";
})(LegTurnDirection || (LegTurnDirection = {}));
var AirwayType;
(function (AirwayType) {
    AirwayType[AirwayType["None"] = 0] = "None";
    AirwayType[AirwayType["Victor"] = 1] = "Victor";
    AirwayType[AirwayType["Jet"] = 2] = "Jet";
    AirwayType[AirwayType["Both"] = 3] = "Both";
})(AirwayType || (AirwayType = {}));
var NdbType;
(function (NdbType) {
    NdbType[NdbType["CompassPoint"] = 0] = "CompassPoint";
    NdbType[NdbType["MH"] = 1] = "MH";
    NdbType[NdbType["H"] = 2] = "H";
    NdbType[NdbType["HH"] = 3] = "HH";
})(NdbType || (NdbType = {}));
var VorType;
(function (VorType) {
    VorType[VorType["Unknown"] = 0] = "Unknown";
    VorType[VorType["VOR"] = 1] = "VOR";
    VorType[VorType["VORDME"] = 2] = "VORDME";
    VorType[VorType["DME"] = 3] = "DME";
    VorType[VorType["TACAN"] = 4] = "TACAN";
    VorType[VorType["VORTAC"] = 5] = "VORTAC";
    VorType[VorType["ILS"] = 6] = "ILS";
    VorType[VorType["VOT"] = 7] = "VOT";
})(VorType || (VorType = {}));
var RunwaySurfaceType;
(function (RunwaySurfaceType) {
    RunwaySurfaceType[RunwaySurfaceType["Concrete"] = 0] = "Concrete";
    RunwaySurfaceType[RunwaySurfaceType["Grass"] = 1] = "Grass";
    RunwaySurfaceType[RunwaySurfaceType["WaterFSX"] = 2] = "WaterFSX";
    RunwaySurfaceType[RunwaySurfaceType["GrassBumpy"] = 3] = "GrassBumpy";
    RunwaySurfaceType[RunwaySurfaceType["Asphalt"] = 4] = "Asphalt";
    RunwaySurfaceType[RunwaySurfaceType["ShortGrass"] = 5] = "ShortGrass";
    RunwaySurfaceType[RunwaySurfaceType["LongGrass"] = 6] = "LongGrass";
    RunwaySurfaceType[RunwaySurfaceType["HardTurf"] = 7] = "HardTurf";
    RunwaySurfaceType[RunwaySurfaceType["Snow"] = 8] = "Snow";
    RunwaySurfaceType[RunwaySurfaceType["Ice"] = 9] = "Ice";
    RunwaySurfaceType[RunwaySurfaceType["Urban"] = 10] = "Urban";
    RunwaySurfaceType[RunwaySurfaceType["Forest"] = 11] = "Forest";
    RunwaySurfaceType[RunwaySurfaceType["Dirt"] = 12] = "Dirt";
    RunwaySurfaceType[RunwaySurfaceType["Coral"] = 13] = "Coral";
    RunwaySurfaceType[RunwaySurfaceType["Gravel"] = 14] = "Gravel";
    RunwaySurfaceType[RunwaySurfaceType["OilTreated"] = 15] = "OilTreated";
    RunwaySurfaceType[RunwaySurfaceType["SteelMats"] = 16] = "SteelMats";
    RunwaySurfaceType[RunwaySurfaceType["Bituminous"] = 17] = "Bituminous";
    RunwaySurfaceType[RunwaySurfaceType["Brick"] = 18] = "Brick";
    RunwaySurfaceType[RunwaySurfaceType["Macadam"] = 19] = "Macadam";
    RunwaySurfaceType[RunwaySurfaceType["Planks"] = 20] = "Planks";
    RunwaySurfaceType[RunwaySurfaceType["Sand"] = 21] = "Sand";
    RunwaySurfaceType[RunwaySurfaceType["Shale"] = 22] = "Shale";
    RunwaySurfaceType[RunwaySurfaceType["Tarmac"] = 23] = "Tarmac";
    RunwaySurfaceType[RunwaySurfaceType["WrightFlyerTrack"] = 24] = "WrightFlyerTrack";
    //SURFACE_TYPE_LAST_FSX
    RunwaySurfaceType[RunwaySurfaceType["Ocean"] = 26] = "Ocean";
    RunwaySurfaceType[RunwaySurfaceType["Water"] = 27] = "Water";
    RunwaySurfaceType[RunwaySurfaceType["Pond"] = 28] = "Pond";
    RunwaySurfaceType[RunwaySurfaceType["Lake"] = 29] = "Lake";
    RunwaySurfaceType[RunwaySurfaceType["River"] = 30] = "River";
    RunwaySurfaceType[RunwaySurfaceType["WasteWater"] = 31] = "WasteWater";
    RunwaySurfaceType[RunwaySurfaceType["Paint"] = 32] = "Paint";
    // UNUSED
    // SURFACE_TYPE_ERASE_GRASS
})(RunwaySurfaceType || (RunwaySurfaceType = {}));
var RunwayLightingType;
(function (RunwayLightingType) {
    RunwayLightingType[RunwayLightingType["Unknown"] = 0] = "Unknown";
    RunwayLightingType[RunwayLightingType["None"] = 1] = "None";
    RunwayLightingType[RunwayLightingType["PartTime"] = 2] = "PartTime";
    RunwayLightingType[RunwayLightingType["FullTime"] = 3] = "FullTime";
    RunwayLightingType[RunwayLightingType["Frequency"] = 4] = "Frequency";
})(RunwayLightingType || (RunwayLightingType = {}));
var AirportPrivateType;
(function (AirportPrivateType) {
    AirportPrivateType[AirportPrivateType["Uknown"] = 0] = "Uknown";
    AirportPrivateType[AirportPrivateType["Public"] = 1] = "Public";
    AirportPrivateType[AirportPrivateType["Military"] = 2] = "Military";
    AirportPrivateType[AirportPrivateType["Private"] = 3] = "Private";
})(AirportPrivateType || (AirportPrivateType = {}));
var GpsBoolean;
(function (GpsBoolean) {
    GpsBoolean[GpsBoolean["Unknown"] = 0] = "Unknown";
    GpsBoolean[GpsBoolean["No"] = 1] = "No";
    GpsBoolean[GpsBoolean["Yes"] = 2] = "Yes";
})(GpsBoolean || (GpsBoolean = {}));
var VorClass;
(function (VorClass) {
    VorClass[VorClass["Unknown"] = 0] = "Unknown";
    VorClass[VorClass["Terminal"] = 1] = "Terminal";
    VorClass[VorClass["LowAlt"] = 2] = "LowAlt";
    VorClass[VorClass["HighAlt"] = 3] = "HighAlt";
    VorClass[VorClass["ILS"] = 4] = "ILS";
    VorClass[VorClass["VOT"] = 5] = "VOT";
})(VorClass || (VorClass = {}));
var FacilityType;
(function (FacilityType) {
    FacilityType["Airport"] = "LOAD_AIRPORT";
    FacilityType["Intersection"] = "LOAD_INTERSECTION";
    FacilityType["VOR"] = "LOAD_VOR";
    FacilityType["NDB"] = "LOAD_NDB";
    FacilityType["USR"] = "USR";
    FacilityType["RWY"] = "RWY";
    FacilityType["VIS"] = "VIS";
})(FacilityType || (FacilityType = {}));
var FacilitySearchType;
(function (FacilitySearchType) {
    FacilitySearchType[FacilitySearchType["None"] = 0] = "None";
    FacilitySearchType[FacilitySearchType["Airport"] = 1] = "Airport";
    FacilitySearchType[FacilitySearchType["Intersection"] = 2] = "Intersection";
    FacilitySearchType[FacilitySearchType["Vor"] = 3] = "Vor";
    FacilitySearchType[FacilitySearchType["Ndb"] = 4] = "Ndb";
    FacilitySearchType[FacilitySearchType["Boundary"] = 5] = "Boundary";
    FacilitySearchType[FacilitySearchType["User"] = 6] = "User";
})(FacilitySearchType || (FacilitySearchType = {}));
/**
 * A type of airspace boundary.
 */
var BoundaryType;
(function (BoundaryType) {
    BoundaryType[BoundaryType["None"] = 0] = "None";
    BoundaryType[BoundaryType["Center"] = 1] = "Center";
    BoundaryType[BoundaryType["ClassA"] = 2] = "ClassA";
    BoundaryType[BoundaryType["ClassB"] = 3] = "ClassB";
    BoundaryType[BoundaryType["ClassC"] = 4] = "ClassC";
    BoundaryType[BoundaryType["ClassD"] = 5] = "ClassD";
    BoundaryType[BoundaryType["ClassE"] = 6] = "ClassE";
    BoundaryType[BoundaryType["ClassF"] = 7] = "ClassF";
    BoundaryType[BoundaryType["ClassG"] = 8] = "ClassG";
    BoundaryType[BoundaryType["Tower"] = 9] = "Tower";
    BoundaryType[BoundaryType["Clearance"] = 10] = "Clearance";
    BoundaryType[BoundaryType["Ground"] = 11] = "Ground";
    BoundaryType[BoundaryType["Departure"] = 12] = "Departure";
    BoundaryType[BoundaryType["Approach"] = 13] = "Approach";
    BoundaryType[BoundaryType["MOA"] = 14] = "MOA";
    BoundaryType[BoundaryType["Restricted"] = 15] = "Restricted";
    BoundaryType[BoundaryType["Prohibited"] = 16] = "Prohibited";
    BoundaryType[BoundaryType["Warning"] = 17] = "Warning";
    BoundaryType[BoundaryType["Alert"] = 18] = "Alert";
    BoundaryType[BoundaryType["Danger"] = 19] = "Danger";
    BoundaryType[BoundaryType["NationalPark"] = 20] = "NationalPark";
    BoundaryType[BoundaryType["ModeC"] = 21] = "ModeC";
    BoundaryType[BoundaryType["Radar"] = 22] = "Radar";
    BoundaryType[BoundaryType["Training"] = 23] = "Training";
})(BoundaryType || (BoundaryType = {}));
/**
 * A type of airspace boundary altitude maxima.
 */
var BoundaryAltitudeType;
(function (BoundaryAltitudeType) {
    BoundaryAltitudeType[BoundaryAltitudeType["Unknown"] = 0] = "Unknown";
    BoundaryAltitudeType[BoundaryAltitudeType["MSL"] = 1] = "MSL";
    BoundaryAltitudeType[BoundaryAltitudeType["AGL"] = 2] = "AGL";
    BoundaryAltitudeType[BoundaryAltitudeType["Unlimited"] = 3] = "Unlimited";
})(BoundaryAltitudeType || (BoundaryAltitudeType = {}));
/**
 * A type of boundary geometry vector.
 */
var BoundaryVectorType;
(function (BoundaryVectorType) {
    BoundaryVectorType[BoundaryVectorType["None"] = 0] = "None";
    BoundaryVectorType[BoundaryVectorType["Start"] = 1] = "Start";
    BoundaryVectorType[BoundaryVectorType["Line"] = 2] = "Line";
    BoundaryVectorType[BoundaryVectorType["Origin"] = 3] = "Origin";
    BoundaryVectorType[BoundaryVectorType["ArcCW"] = 4] = "ArcCW";
    BoundaryVectorType[BoundaryVectorType["ArcCCW"] = 5] = "ArcCCW";
    BoundaryVectorType[BoundaryVectorType["Circle"] = 6] = "Circle";
})(BoundaryVectorType || (BoundaryVectorType = {}));
/**
 * Wind speed units used by METAR.
 */
var MetarWindSpeedUnits;
(function (MetarWindSpeedUnits) {
    MetarWindSpeedUnits[MetarWindSpeedUnits["Knot"] = 0] = "Knot";
    MetarWindSpeedUnits[MetarWindSpeedUnits["MeterPerSecond"] = 1] = "MeterPerSecond";
    MetarWindSpeedUnits[MetarWindSpeedUnits["KilometerPerHour"] = 2] = "KilometerPerHour";
})(MetarWindSpeedUnits || (MetarWindSpeedUnits = {}));
/** Visibility distance units used by METAR. */
var MetarVisibilityUnits;
(function (MetarVisibilityUnits) {
    MetarVisibilityUnits[MetarVisibilityUnits["Meter"] = 0] = "Meter";
    MetarVisibilityUnits[MetarVisibilityUnits["StatuteMile"] = 1] = "StatuteMile";
})(MetarVisibilityUnits || (MetarVisibilityUnits = {}));
/**
 * METAR cloud layer coverage/sky condition.
 */
var MetarCloudLayerCoverage;
(function (MetarCloudLayerCoverage) {
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["SkyClear"] = 0] = "SkyClear";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Clear"] = 1] = "Clear";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["NoSignificant"] = 2] = "NoSignificant";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Few"] = 3] = "Few";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Scattered"] = 4] = "Scattered";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Broken"] = 5] = "Broken";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Overcast"] = 6] = "Overcast";
})(MetarCloudLayerCoverage || (MetarCloudLayerCoverage = {}));
/**
 * METAR significant cloud types.
 */
var MetarCloudLayerType;
(function (MetarCloudLayerType) {
    MetarCloudLayerType[MetarCloudLayerType["Unspecified"] = -1] = "Unspecified";
    MetarCloudLayerType[MetarCloudLayerType["ToweringCumulus"] = 0] = "ToweringCumulus";
    MetarCloudLayerType[MetarCloudLayerType["Cumulonimbus"] = 1] = "Cumulonimbus";
    MetarCloudLayerType[MetarCloudLayerType["AltocumulusCastellanus"] = 2] = "AltocumulusCastellanus";
})(MetarCloudLayerType || (MetarCloudLayerType = {}));
/** METAR phenomenon types. */
var MetarPhenomenonType;
(function (MetarPhenomenonType) {
    MetarPhenomenonType[MetarPhenomenonType["None"] = 0] = "None";
    MetarPhenomenonType[MetarPhenomenonType["Mist"] = 1] = "Mist";
    MetarPhenomenonType[MetarPhenomenonType["Duststorm"] = 2] = "Duststorm";
    MetarPhenomenonType[MetarPhenomenonType["Dust"] = 3] = "Dust";
    MetarPhenomenonType[MetarPhenomenonType["Drizzle"] = 4] = "Drizzle";
    MetarPhenomenonType[MetarPhenomenonType["FunnelCloud"] = 5] = "FunnelCloud";
    MetarPhenomenonType[MetarPhenomenonType["Fog"] = 6] = "Fog";
    MetarPhenomenonType[MetarPhenomenonType["Smoke"] = 7] = "Smoke";
    MetarPhenomenonType[MetarPhenomenonType["Hail"] = 8] = "Hail";
    MetarPhenomenonType[MetarPhenomenonType["SmallHail"] = 9] = "SmallHail";
    MetarPhenomenonType[MetarPhenomenonType["Haze"] = 10] = "Haze";
    MetarPhenomenonType[MetarPhenomenonType["IceCrystals"] = 11] = "IceCrystals";
    MetarPhenomenonType[MetarPhenomenonType["IcePellets"] = 12] = "IcePellets";
    MetarPhenomenonType[MetarPhenomenonType["DustSandWhorls"] = 13] = "DustSandWhorls";
    MetarPhenomenonType[MetarPhenomenonType["Spray"] = 14] = "Spray";
    MetarPhenomenonType[MetarPhenomenonType["Rain"] = 15] = "Rain";
    MetarPhenomenonType[MetarPhenomenonType["Sand"] = 16] = "Sand";
    MetarPhenomenonType[MetarPhenomenonType["SnowGrains"] = 17] = "SnowGrains";
    MetarPhenomenonType[MetarPhenomenonType["Shower"] = 18] = "Shower";
    MetarPhenomenonType[MetarPhenomenonType["Snow"] = 19] = "Snow";
    MetarPhenomenonType[MetarPhenomenonType["Squalls"] = 20] = "Squalls";
    MetarPhenomenonType[MetarPhenomenonType["Sandstorm"] = 21] = "Sandstorm";
    MetarPhenomenonType[MetarPhenomenonType["UnknownPrecip"] = 22] = "UnknownPrecip";
    MetarPhenomenonType[MetarPhenomenonType["VolcanicAsh"] = 23] = "VolcanicAsh";
})(MetarPhenomenonType || (MetarPhenomenonType = {}));
/** METAR phenomenon intensities. */
var MetarPhenomenonIntensity;
(function (MetarPhenomenonIntensity) {
    MetarPhenomenonIntensity[MetarPhenomenonIntensity["Light"] = -1] = "Light";
    MetarPhenomenonIntensity[MetarPhenomenonIntensity["Normal"] = 0] = "Normal";
    MetarPhenomenonIntensity[MetarPhenomenonIntensity["Heavy"] = 1] = "Heavy";
})(MetarPhenomenonIntensity || (MetarPhenomenonIntensity = {}));
/**
 * Methods for working with FS ICAO strings.
 */
class ICAO {
    /**
     * Gets the facility type from an ICAO.
     * @param icao The icao to get the facility type for.
     * @returns The ICAO facility type.
     * @throws An error if the facility type cannot be determined.
     */
    static getFacilityType(icao) {
        switch (icao[0]) {
            case 'A':
                return FacilityType.Airport;
            case 'W':
                return FacilityType.Intersection;
            case 'V':
                return FacilityType.VOR;
            case 'N':
                return FacilityType.NDB;
            case 'U':
                return FacilityType.USR;
            case 'R':
                return FacilityType.RWY;
            case 'S':
                return FacilityType.VIS;
            default:
                throw new Error(`ICAO ${icao} has unknown type: ${icao[0]}`);
        }
    }
    /**
     * Gets whether an icao is a facility type.
     * @param icao The icao to get the facility type for.
     * @returns a bool whether or not this icao is a facility type.
     */
    static isFacility(icao) {
        switch (icao[0]) {
            case 'A':
            case 'W':
            case 'V':
            case 'N':
            case 'U':
            case 'R':
            case 'S':
                return true;
        }
        return false;
    }
    /**
     * Gets the ident for a given ICAO string.
     * @param icao The FS ICAO to get the ident for.
     * @returns The ICAO ident.
     */
    static getIdent(icao) {
        return icao.substr(7).trim();
    }
}
/**
 * An empty ICAO.
 */
ICAO.emptyIcao = '            ';

/**
 * Methods for working with Runways and Runway Designations.
 */
class RunwayUtils {
    /**
     * Creates an empty one-way runway.
     * @returns an empty one-way runway.
     */
    static createEmptyOneWayRunway() {
        return {
            parentRunwayIndex: -1,
            designation: '',
            direction: 36,
            runwayDesignator: RunwayDesignator.RUNWAY_DESIGNATOR_NONE,
            course: 0,
            elevation: 0,
            latitude: 0,
            longitude: 0
        };
    }
    /**
     * Utility method to return two one-way runways from a single runway facility
     * @param runway is the AirportRunway object to evaluate
     * @param index is the index of the AirportRunway in the Facility
     * @returns splitRunways array of OneWayRunway objects
     */
    static getOneWayRunways(runway, index) {
        const splitRunways = [];
        const designations = runway.designation.split('-');
        for (let i = 0; i < designations.length; i++) {
            const runwayNumber = parseInt(designations[i]);
            let designator = RunwayDesignator.RUNWAY_DESIGNATOR_NONE;
            let course = 0;
            let thresholdDistanceFromCenter = 0;
            let thresholdElevation = 0;
            let ilsFrequency;
            if (i === 0) {
                designator = runway.designatorCharPrimary;
                course = runway.direction;
                thresholdDistanceFromCenter = (runway.length / 2) - runway.primaryThresholdLength;
                thresholdElevation = runway.primaryElevation;
                ilsFrequency = runway.primaryILSFrequency.freqMHz === 0 ? undefined : runway.primaryILSFrequency;
            }
            else if (i === 1) {
                designator = runway.designatorCharSecondary;
                course = NavMath.normalizeHeading(runway.direction + 180);
                thresholdDistanceFromCenter = (runway.length / 2) - runway.secondaryThresholdLength;
                thresholdElevation = runway.secondaryElevation;
                ilsFrequency = runway.secondaryILSFrequency.freqMHz === 0 ? undefined : runway.secondaryILSFrequency;
            }
            const designation = RunwayUtils.getRunwayNameString(runwayNumber, designator);
            const coordinates = RunwayUtils.tempGeoPoint
                .set(runway.latitude, runway.longitude)
                .offset(course - 180, UnitType.METER.convertTo(thresholdDistanceFromCenter, UnitType.GA_RADIAN));
            splitRunways.push({
                parentRunwayIndex: index,
                designation,
                direction: runwayNumber,
                runwayDesignator: designator,
                course,
                elevation: thresholdElevation,
                latitude: coordinates.lat,
                longitude: coordinates.lon,
                ilsFrequency
            });
        }
        return splitRunways;
    }
    /**
     * Utility method to return the runway name from the number and designator (L/R/C/W)
     * @param runwayNumber is the integer part of a runway name (18, 26, 27, etc)
     * @param designator is the RunwayDesignator enum for the runway
     * @param padded Whether single-char runways should be 0-padded.
     * @param prefix A prefix to put before the runway name.
     * @returns the runway name string
     */
    static getRunwayNameString(runwayNumber, designator, padded = true, prefix = '') {
        let numberText = `${runwayNumber}`;
        if (padded) {
            numberText = numberText.padStart(2, '0');
        }
        let string = prefix + numberText;
        switch (designator) {
            case RunwayDesignator.RUNWAY_DESIGNATOR_NONE:
                return string;
            case RunwayDesignator.RUNWAY_DESIGNATOR_LEFT:
                return string += 'L';
            case RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT:
                return string += 'R';
            case RunwayDesignator.RUNWAY_DESIGNATOR_CENTER:
                return string += 'C';
            case RunwayDesignator.RUNWAY_DESIGNATOR_WATER:
                return string += 'W';
            case RunwayDesignator.RUNWAY_DESIGNATOR_A:
                return string += 'A';
            case RunwayDesignator.RUNWAY_DESIGNATOR_B:
                return string += 'B';
        }
    }
    /**
     * Gets a one-way runway from an airport that matches a runway designation by number and designator.
     * @param airport The airport facility in which to search for the match.
     * @param runwayNumber A runway number to match.
     * @param runwayDesignator A runway designator to match.
     * @returns The one-way runway which matches the designation, or undefined if no match could be found.
     */
    static matchOneWayRunway(airport, runwayNumber, runwayDesignator) {
        const length = airport.runways.length;
        for (let r = 0; r < length; r++) {
            const runway = airport.runways[r];
            const designation = runway.designation;
            const primaryRunwayNumber = parseInt(designation.split('-')[0]);
            const secondaryRunwayNumber = parseInt(designation.split('-')[1]);
            if (primaryRunwayNumber === runwayNumber && runway.designatorCharPrimary === runwayDesignator) {
                const oneWayRunways = RunwayUtils.getOneWayRunways(runway, r);
                return oneWayRunways[0];
            }
            else if (secondaryRunwayNumber === runwayNumber && runway.designatorCharSecondary === runwayDesignator) {
                const oneWayRunways = RunwayUtils.getOneWayRunways(runway, r);
                return oneWayRunways[1];
            }
        }
        return undefined;
    }
    /**
     * Gets a one-way runway from an airport that matches a runway designation string.
     * @param airport The airport facility in which to search for the match.
     * @param designation A runway designation.
     * @returns The one-way runway which matches the designation, or undefined if no match could be found.
     */
    static matchOneWayRunwayFromDesignation(airport, designation) {
        const length = airport.runways.length;
        for (let i = 0; i < length; i++) {
            const match = RunwayUtils.getOneWayRunways(airport.runways[i], i).find((r) => {
                return (r.designation === designation);
            });
            if (match) {
                return match;
            }
        }
        return undefined;
    }
    /**
     * Gets a one-way runway from an airport that matches a runway ident.
     * @param airport The airport facility in which to search for the match.
     * @param ident A runway ident.
     * @returns The one-way runway which matches the ident, or undefined if no match could be found.
     */
    static matchOneWayRunwayFromIdent(airport, ident) {
        return RunwayUtils.matchOneWayRunwayFromDesignation(airport, ident.substr(2).trim());
    }
    /**
     * Utility method to return the procedures for a given runway.
     * @param procedures The procedures for the airport.
     * @param runway The given runway to find procedures for.
     * @returns A list of approach procedures for the given runway.
     */
    static getProceduresForRunway(procedures, runway) {
        const oneways = new Array();
        // TODO Make the designation splitting logic a common routine too.
        const designations = runway.designation.split('-');
        for (let i = 0; i < designations.length; i++) {
            const runwayNumber = parseInt(designations[i]);
            let runwayName;
            if (i === 0) {
                runwayName = RunwayUtils.getRunwayNameString(runwayNumber, runway.designatorCharPrimary, false, '');
            }
            else {
                runwayName = RunwayUtils.getRunwayNameString(runwayNumber, runway.designatorCharSecondary, false, '');
            }
            oneways.push(runwayName);
        }
        const found = new Array();
        for (const procedure of procedures) {
            if (oneways.includes(procedure.runway.trim())) {
                found.push(procedure);
            }
            else if (procedure.runwayNumber === 0) {
                found.push(procedure);
            }
        }
        return found;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static getLocFrequency(airport, arg) {
        let runway, runwayDesignation;
        if (typeof arg === 'string') {
            const matchedRunway = RunwayUtils.matchOneWayRunwayFromDesignation(airport, arg);
            if (!matchedRunway) {
                return undefined;
            }
            runway = matchedRunway;
            runwayDesignation = arg;
        }
        else {
            runway = arg;
            runwayDesignation = arg.designation;
        }
        if (runway.ilsFrequency) {
            return runway.ilsFrequency;
        }
        for (let i = 0; i < airport.frequencies.length; i++) {
            const match = airport.frequencies[i].name.search(runwayDesignation);
            if (match > -1) {
                return airport.frequencies[i];
            }
        }
        return undefined;
    }
    /**
     * A comparer for sorting runways by number, and then by L, C, and R.
     * @param r1 The first runway to compare.
     * @param r2 The second runway to compare.
     * @returns -1 if the first is before, 0 if equal, 1 if the first is after.
     */
    static sortRunways(r1, r2) {
        if (r1.direction === r2.direction) {
            let v1 = 0;
            if (r1.designation.indexOf('L') != -1) {
                v1 = 1;
            }
            else if (r1.designation.indexOf('C') != -1) {
                v1 = 2;
            }
            else if (r1.designation.indexOf('R') != -1) {
                v1 = 3;
            }
            let v2 = 0;
            if (r2.designation.indexOf('L') != -1) {
                v2 = 1;
            }
            else if (r2.designation.indexOf('C') != -1) {
                v2 = 2;
            }
            else if (r2.designation.indexOf('R') != -1) {
                v2 = 3;
            }
            return v1 - v2;
        }
        return r1.direction - r2.direction;
    }
    /**
     * Gets the ICAO string for the runway facility associated with a one-way runway.
     * @param airport The runway's parent airport.
     * @param runway A one-way runway.
     * @returns the ICAO string for the runway facility associated with the one-way runway.
     */
    static getRunwayFacilityIcao(airport, runway) {
        return `R  ${airport.icao.substr(7, 4)}RW${runway.designation.padEnd(3, ' ')}`;
    }
    /**
     * Creates a runway waypoint facility from a runway.
     * @param airport The runway's parent airport.
     * @param runway A one-way runway.
     * @returns A runway waypoint facility corresponding to the runway.
     */
    static createRunwayFacility(airport, runway) {
        return {
            icao: RunwayUtils.getRunwayFacilityIcao(airport, runway),
            name: `Runway ${runway.designation}`,
            region: airport.region,
            city: airport.city,
            lat: runway.latitude,
            lon: runway.longitude,
            magvar: airport.magvar,
            runway
        };
    }
    /**
     * Gets an alpha code from a runway number.
     * @param number is the runway number.
     * @returns a letter.
     */
    static getRunwayCode(number) {
        const n = Math.round(number);
        return String.fromCharCode(48 + n + (n > 9 ? 7 : 0));
    }
}
RunwayUtils.tempGeoPoint = new GeoPoint(0, 0);

/// <reference types="msfstypes/JS/common" />
/**
 * A class that handles loading facility data from the simulator.
 */
class FacilityLoader {
    /**
     * Creates an instance of the FacilityLoader.
     * @param facilityRepo A local facility repository.
     * @param onInitialized A callback to call when the facility loader has completed initialization.
     */
    constructor(facilityRepo, onInitialized = () => { }) {
        this.facilityRepo = facilityRepo;
        this.onInitialized = onInitialized;
        if (FacilityLoader.facilityListener === undefined) {
            FacilityLoader.facilityListener = RegisterViewListener('JS_LISTENER_FACILITY', () => {
                FacilityLoader.facilityListener.on('SendAirport', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('SendIntersection', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('SendVor', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('SendNdb', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('NearestSearchCompleted', FacilityLoader.onNearestSearchCompleted);
                setTimeout(() => this.onInitialized(), 2000);
            }, true);
        }
        else {
            setTimeout(() => this.onInitialized(), 2000);
        }
    }
    /**
     * Retrieves a facility.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    getFacility(type, icao) {
        switch (type) {
            case FacilityType.USR:
            case FacilityType.RWY:
            case FacilityType.VIS:
                return this.getFacilityFromRepo(type, icao);
            default:
                return this.getFacilityFromCoherent(type, icao);
        }
    }
    // eslint-disable-next-line jsdoc/require-throws
    /**
     * Retrieves a facility from the local facility repository.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    async getFacilityFromRepo(type, icao) {
        const fac = this.facilityRepo.get(icao);
        if (fac) {
            return fac;
        }
        else if (type === FacilityType.RWY) {
            try {
                const airport = await this.getFacility(FacilityType.Airport, `A      ${icao.substr(3, 4)} `);
                const runway = RunwayUtils.matchOneWayRunwayFromIdent(airport, ICAO.getIdent(icao));
                if (runway) {
                    const runwayFac = RunwayUtils.createRunwayFacility(airport, runway);
                    this.facilityRepo.add(runwayFac);
                    return runwayFac;
                }
            }
            catch (e) {
                // noop
            }
        }
        throw `Facility ${icao} could not be found.`;
    }
    /**
     * Retrieves a facility from Coherent.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    getFacilityFromCoherent(type, icao) {
        const isMismatch = ICAO.getFacilityType(icao) !== type;
        const currentTime = Date.now();
        let queue = FacilityLoader.requestQueue;
        let cache = FacilityLoader.facCache;
        if (isMismatch) {
            queue = FacilityLoader.mismatchRequestQueue;
            cache = FacilityLoader.typeMismatchFacCache;
        }
        let request = queue.get(icao);
        if (request === undefined || currentTime - request.timeStamp > 10000) {
            let resolve = undefined;
            let reject = undefined;
            const promise = new Promise((resolution, rejection) => {
                resolve = resolution;
                reject = rejection;
                const cachedFac = cache.get(icao);
                if (cachedFac === undefined) {
                    Coherent.call(type, icao).then((isValid) => {
                        if (!isValid) {
                            rejection(`Facility ${icao} could not be found.`);
                            FacilityLoader.requestQueue.delete(icao);
                        }
                    });
                }
                else {
                    resolve(cachedFac);
                }
            });
            if (request) {
                request.reject(`Facility request for ${icao} has timed out.`);
            }
            request = { promise, timeStamp: currentTime, resolve: resolve, reject: reject };
            FacilityLoader.requestQueue.set(icao, request);
        }
        return request.promise;
    }
    /**
     * Gets airway data from the sim.
     * @param airwayName The airway name.
     * @param airwayType The airway type.
     * @param icao The 12 character FS ICAO of at least one intersection in the airway.
     * @returns The retrieved airway.
     * @throws an error if no airway is returned
     */
    async getAirway(airwayName, airwayType, icao) {
        if (FacilityLoader.airwayCache.has(airwayName)) {
            const cachedAirway = FacilityLoader.airwayCache.get(airwayName);
            const match = cachedAirway === null || cachedAirway === void 0 ? void 0 : cachedAirway.waypoints.find((w) => {
                w.icao === icao;
            });
            if (match !== undefined && cachedAirway !== undefined) {
                return cachedAirway;
            }
        }
        const fac = await this.getFacility(FacilityType.Intersection, icao);
        const route = fac.routes.find((r) => r.name === airwayName);
        if (route !== undefined) {
            const airwayBuilder = new AirwayBuilder(fac, route, this);
            const status = await airwayBuilder.startBuild();
            if (status === AirwayStatus.COMPLETE) {
                const waypoints = airwayBuilder.waypoints;
                if (waypoints !== null) {
                    const airway = new AirwayObject(airwayName, airwayType);
                    airway.waypoints = [...waypoints];
                    FacilityLoader.addToAirwayCache(airway);
                    return airway;
                }
            }
        }
        throw new Error('Airway could not be found.');
    }
    /**
     * Starts a nearest facilities search session.
     * @param type The type of facilities to search for.
     * @returns The new nearest search session.
     */
    async startNearestSearchSession(type) {
        const sessionId = await Coherent.call('START_NEAREST_SEARCH_SESSION', type);
        let session;
        switch (type) {
            case FacilitySearchType.Airport:
                session = new NearestAirportSearchSession(sessionId);
                break;
            case FacilitySearchType.Intersection:
                session = new NearestIntersectionSearchSession(sessionId);
                break;
            case FacilitySearchType.Vor:
                session = new NearestIntersectionSearchSession(sessionId);
                break;
            default:
                session = new NearestSearchSession(sessionId);
                break;
        }
        FacilityLoader.searchSessions.set(sessionId, session);
        return session;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    async getMetar(arg) {
        const ident = typeof arg === 'string' ? arg : ICAO.getIdent(arg.icao);
        const metar = await Coherent.call('GET_METAR_BY_IDENT', ident);
        return FacilityLoader.cleanMetar(metar);
    }
    /**
     * Searches for the METAR issued for the closest airport to a given location.
     * @param lat The latitude of the center of the search, in degrees.
     * @param lon The longitude of the center of the search, in degrees.
     * @returns The METAR issued for the closest airport to the given location, or undefined if none could be found.
     */
    async searchMetar(lat, lon) {
        const metar = await Coherent.call('GET_METAR_BY_LATLON', lat, lon);
        return FacilityLoader.cleanMetar(metar);
    }
    /**
     * Cleans up a raw METAR object.
     * @param raw A raw METAR object.
     * @returns A cleaned version of the raw METAR object, or undefined if the raw METAR is empty.
     */
    static cleanMetar(raw) {
        if (raw.icao === '') {
            return undefined;
        }
        raw.gust < 0 && delete raw.gust;
        raw.vertVis < 0 && delete raw.vertVis;
        isNaN(raw.altimeterA) && delete raw.altimeterA;
        raw.altimeterQ < 0 && delete raw.altimeterQ;
        isNaN(raw.slp) && delete raw.slp;
        return raw;
    }
    /**
     * Searches for ICAOs by their ident portion only.
     * @param filter The type of facility to filter by. Selecting NONE will search all facility type ICAOs.
     * @param ident The partial or complete ident to search for.
     * @param maxItems The max number of matches to return.
     * @returns A collection of matched ICAOs.
     */
    async searchByIdent(filter, ident, maxItems = 40) {
        const results = await Coherent.call('SEARCH_BY_IDENT', ident, filter, maxItems);
        if (filter === FacilitySearchType.User || filter === FacilitySearchType.None) {
            this.facilityRepo.forEach(fac => {
                const facIdent = ICAO.getIdent(fac.icao);
                if (facIdent === ident) {
                    results.unshift(fac.icao);
                }
                else if (facIdent.startsWith(ident)) {
                    results.push(fac.icao);
                }
            }, FacilityLoader.facRepositorySearchTypes);
        }
        return results;
    }
    /**
     * A callback called when a facility is received from the simulator.
     * @param facility The received facility.
     */
    static onFacilityReceived(facility) {
        const request = FacilityLoader.requestQueue.get(facility.icao);
        if (request !== undefined) {
            request.resolve(facility);
            FacilityLoader.addToFacilityCache(facility, facility['__Type'] === 'JS_FacilityIntersection' && facility.icao[0] !== 'W');
            FacilityLoader.requestQueue.delete(facility.icao);
        }
    }
    /**
     * A callback called when a search completes.
     * @param results The results of the search.
     */
    static onNearestSearchCompleted(results) {
        const session = FacilityLoader.searchSessions.get(results.sessionId);
        if (session !== undefined) {
            session.onSearchCompleted(results);
        }
    }
    /**
     * Adds a facility to the cache.
     * @param fac The facility to add.
     * @param isTypeMismatch Whether to add the facility to the type mismatch cache.
     */
    static addToFacilityCache(fac, isTypeMismatch) {
        const cache = isTypeMismatch ? FacilityLoader.typeMismatchFacCache : FacilityLoader.facCache;
        cache.set(fac.icao, fac);
        if (cache.size > FacilityLoader.MAX_FACILITY_CACHE_ITEMS) {
            cache.delete(cache.keys().next().value);
        }
    }
    /**
     * Adds an airway to the airway cache.
     * @param airway The airway to add.
     */
    static addToAirwayCache(airway) {
        FacilityLoader.airwayCache.set(airway.name, airway);
        if (FacilityLoader.airwayCache.size > FacilityLoader.MAX_AIRWAY_CACHE_ITEMS) {
            FacilityLoader.airwayCache.delete(FacilityLoader.airwayCache.keys().next().value);
        }
    }
}
FacilityLoader.MAX_FACILITY_CACHE_ITEMS = 1000;
FacilityLoader.MAX_AIRWAY_CACHE_ITEMS = 1000;
FacilityLoader.requestQueue = new Map();
FacilityLoader.mismatchRequestQueue = new Map();
FacilityLoader.facCache = new Map();
FacilityLoader.typeMismatchFacCache = new Map();
FacilityLoader.airwayCache = new Map();
FacilityLoader.searchSessions = new Map();
FacilityLoader.facRepositorySearchTypes = [FacilityType.USR];
/**
 * A session for searching for nearest facilities.
 */
class NearestSearchSession {
    /**
     * Creates an instance of a NearestSearchSession.
     * @param sessionId The ID of the session.
     */
    constructor(sessionId) {
        this.sessionId = sessionId;
        this.searchQueue = new Map();
    }
    /**
     * Searches for nearest facilities from the specified point.
     * @param lat The latitude, in degrees.
     * @param lon The longitude, in degrees.
     * @param radius The radius around the point to search, in meters.
     * @param maxItems The maximum number of items.
     * @returns The nearest search results.
     */
    searchNearest(lat, lon, radius, maxItems) {
        const promise = new Promise((resolve) => {
            Coherent.call('SEARCH_NEAREST', this.sessionId, lat, lon, radius, maxItems)
                .then((searchId) => {
                this.searchQueue.set(searchId, { promise, resolve });
            });
        });
        return promise;
    }
    /**
     * A callback called by the facility loader when a nearest search has completed.
     * @param results The search results.
     */
    onSearchCompleted(results) {
        const request = this.searchQueue.get(results.searchId);
        if (request !== undefined) {
            request.resolve(results);
            this.searchQueue.delete(results.searchId);
        }
    }
}
/**
 * A session for searching for nearest airports.
 */
class NearestAirportSearchSession extends NearestSearchSession {
    /**
     * Sets the filter for the airport nearest search.
     * @param showClosed Whether or not to show closed airports.
     * @param classMask A bitmask to determine which JS airport classes to show.
     */
    setAirportFilter(showClosed, classMask) {
        Coherent.call('SET_NEAREST_AIRPORT_FILTER', this.sessionId, showClosed ? 1 : 0, classMask);
    }
}
/**
 * A session for searching for nearest intersections.
 */
class NearestIntersectionSearchSession extends NearestSearchSession {
    /**
     * Sets the filter for the intersection nearest search.
     * @param typeMask A bitmask to determine which JS intersection types to show.
     */
    setIntersectionFilter(typeMask) {
        Coherent.call('SET_NEAREST_INTERSECTION_FILTER', this.sessionId, typeMask);
    }
}
/**
 * An airway.
 */
class AirwayObject {
    /** Builds a Airway
     * @param name - the name of the new airway.
     * @param type - the type of the new airway.
     */
    constructor(name, type) {
        this._waypoints = [];
        this._name = name;
        this._type = type;
    }
    /**
     * Gets the name of the airway
     * @returns the airway name
     */
    get name() {
        return this._name;
    }
    /**
     * Gets the type of the airway
     * @returns the airway type
     */
    get type() {
        return this._type;
    }
    /**
     * Gets the waypoints of this airway.
     * @returns the waypoints of this airway.
     */
    get waypoints() {
        return this._waypoints;
    }
    /**
     * Sets the waypoints of this airway.
     * @param waypoints is the array of waypoints.
     */
    set waypoints(waypoints) {
        this._waypoints = waypoints;
    }
}
/**
 * WT Airway Status Enum
 */
var AirwayStatus;
(function (AirwayStatus) {
    /**
     * @readonly
     * @property {number} INCOMPLETE - indicates waypoints have not been loaded yet.
     */
    AirwayStatus[AirwayStatus["INCOMPLETE"] = 0] = "INCOMPLETE";
    /**
     * @readonly
     * @property {number} COMPLETE - indicates all waypoints have been successfully loaded.
     */
    AirwayStatus[AirwayStatus["COMPLETE"] = 1] = "COMPLETE";
    /**
     * @readonly
     * @property {number} PARTIAL - indicates some, but not all, waypoints have been successfully loaded.
     */
    AirwayStatus[AirwayStatus["PARTIAL"] = 2] = "PARTIAL";
})(AirwayStatus || (AirwayStatus = {}));
/**
 * The Airway Builder.
 */
class AirwayBuilder {
    /** Creates an instance of the AirwayBuilder
     * @param _initialWaypoint is the initial intersection facility
     * @param _initialData is the intersection route to build from
     * @param facilityLoader is an instance of the facility loader
     */
    constructor(_initialWaypoint, _initialData, facilityLoader) {
        this._initialWaypoint = _initialWaypoint;
        this._initialData = _initialData;
        this.facilityLoader = facilityLoader;
        this._waypointsArray = [];
        this._hasStarted = false;
        this._isDone = false;
    }
    // constructor(private _initialWaypoint: IntersectionFacility, private _requestEntry: (entry: string) => Promise<IntersectionFacility>) {
    // }
    /**
     * Get whether this builder has started loading waypoints
     * @returns whether this builder has started
     */
    get hasStarted() {
        return this._hasStarted;
    }
    /**
     * Get whether this builder is done loading waypoints
     * @returns whether this builder is done loading waypoints
     */
    get isDone() {
        return this._isDone;
    }
    /**
     * Get the airway waypoints
     * @returns the airway waypoints, or null
     */
    get waypoints() {
        return this._waypointsArray;
    }
    /** Steps through the airway waypoints
     * @param stepForward is the direction to step; true = forward, false = backward
     * @param arrayInsertFunc is the arrayInsertFunc
     */
    async _step(stepForward, arrayInsertFunc) {
        let isDone = false;
        let current = this._initialData;
        while (!isDone && current) {
            const nextICAO = stepForward ? current.nextIcao : current.prevIcao;
            if (nextICAO && nextICAO.length > 0 && nextICAO[0] != ' ' && this._waypointsArray !== null
                && !this._waypointsArray.find(waypoint => waypoint.icao === nextICAO)) {
                const fac = await this.facilityLoader.getFacility(FacilityType.Intersection, nextICAO);
                arrayInsertFunc(fac);
                const next = fac.routes.find((route) => route.name === current.name);
                if (next !== undefined) {
                    current = next;
                }
                else {
                    isDone = true;
                }
            }
            else {
                isDone = true;
            }
        }
    }
    /** Steps Forward through the airway waypoints
     * @returns the step forward function
     */
    async _stepForward() {
        if (this._waypointsArray !== null) {
            return this._step(true, this._waypointsArray.push.bind(this._waypointsArray));
        }
    }
    /** Steps Backward through the airway waypoints
     * @returns the step backward function
     */
    async _stepBackward() {
        if (this._waypointsArray !== null) {
            return this._step(false, this._waypointsArray.unshift.bind(this._waypointsArray));
        }
    }
    /**
     * Sets the array into which this builder will load waypoints.
     * @param array is the array into which the builder will load waypoints
     */
    setWaypointsArray(array) {
        this._waypointsArray = array;
    }
    /**
     * Begins loading waypoints for this builder's parent airway.
     * @returns a Promise to return a status code corresponding to Airway.Status when this builder has
     * finished loading waypoints.
     */
    startBuild() {
        if (this.hasStarted) {
            return Promise.reject(new Error('Airway builder has already started building.'));
        }
        return new Promise(resolve => {
            this._hasStarted = true;
            if (this._waypointsArray !== null) {
                this._waypointsArray.push(this._initialWaypoint);
                Promise.all([
                    this._stepForward(),
                    this._stepBackward()
                ]).then(() => {
                    this._isDone = true;
                    resolve(AirwayStatus.COMPLETE);
                }).catch(() => {
                    this._isDone = true;
                    resolve(AirwayStatus.PARTIAL);
                });
            }
        });
    }
}

var FacilityRepositorySyncType;
(function (FacilityRepositorySyncType) {
    FacilityRepositorySyncType[FacilityRepositorySyncType["Add"] = 0] = "Add";
    FacilityRepositorySyncType[FacilityRepositorySyncType["Remove"] = 1] = "Remove";
    FacilityRepositorySyncType[FacilityRepositorySyncType["DumpRequest"] = 2] = "DumpRequest";
    FacilityRepositorySyncType[FacilityRepositorySyncType["DumpResponse"] = 3] = "DumpResponse";
})(FacilityRepositorySyncType || (FacilityRepositorySyncType = {}));
/**
 * A repository of facilities.
 */
class FacilityRespository {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.repos = {};
        this.ignoreSync = false;
        bus.getSubscriber().on(FacilityRespository.SYNC_TOPIC).handle(this.onSyncEvent.bind(this));
        this.pubSyncEvent(FacilityRepositorySyncType.DumpRequest);
    }
    /**
     * Retrieves a facility from this repository.
     * @param icao The ICAO of the facility to retrieve.
     * @returns The requested user facility, or undefined if it was not found in this repository.
     */
    get(icao) {
        var _a;
        if (!ICAO.isFacility(icao)) {
            return undefined;
        }
        return (_a = this.repos[ICAO.getFacilityType(icao)]) === null || _a === void 0 ? void 0 : _a.get(icao);
    }
    /**
     * Adds a facility to this repository and all other repositories synced with this one.
     * @param fac The facility to add.
     */
    add(fac) {
        if (!ICAO.isFacility(fac.icao)) {
            return;
        }
        this.addToRepo(fac);
        this.pubSyncEvent(FacilityRepositorySyncType.Add, [fac]);
    }
    /**
     * Removes a facility from this repository and all other repositories synced with this one.
     * @param fac The facility to remove.
     */
    remove(fac) {
        if (!ICAO.isFacility(fac.icao)) {
            return;
        }
        this.removeFromRepo(fac);
        this.pubSyncEvent(FacilityRepositorySyncType.Remove, [fac]);
    }
    /**
     * Iterates over every facility in this respository with a visitor function.
     * @param fn A visitor function.
     * @param types The types of facilities over which to iterate. Defaults to all facility types.
     */
    forEach(fn, types) {
        var _a;
        const keys = types !== null && types !== void 0 ? types : Object.keys(this.repos);
        const len = keys.length;
        for (let i = 0; i < len; i++) {
            (_a = this.repos[keys[i]]) === null || _a === void 0 ? void 0 : _a.forEach(fn);
        }
    }
    /**
     * Adds a facility to this repository.
     * @param fac The facility to add.
     */
    addToRepo(fac) {
        var _a;
        var _b, _c;
        ((_a = (_b = this.repos)[_c = ICAO.getFacilityType(fac.icao)]) !== null && _a !== void 0 ? _a : (_b[_c] = new Map())).set(fac.icao, fac);
    }
    /**
     * Removes a facility from this repository.
     * @param fac The facility to remove.
     */
    removeFromRepo(fac) {
        var _a;
        (_a = this.repos[ICAO.getFacilityType(fac.icao)]) === null || _a === void 0 ? void 0 : _a.delete(fac.icao);
    }
    /**
     * Publishes a sync event over the event bus.
     * @param type The type of sync event.
     * @param facs The event's user facilities.
     */
    pubSyncEvent(type, facs) {
        this.ignoreSync = true;
        this.bus.pub(FacilityRespository.SYNC_TOPIC, { type, facs }, true, false);
        this.ignoreSync = false;
    }
    /**
     * A callback which is called when a sync event occurs.
     * @param data The event data.
     */
    onSyncEvent(data) {
        if (this.ignoreSync) {
            return;
        }
        switch (data.type) {
            case FacilityRepositorySyncType.Add:
            case FacilityRepositorySyncType.DumpResponse:
                data.facs.forEach(fac => this.addToRepo(fac));
                break;
            case FacilityRepositorySyncType.Remove:
                data.facs.forEach(fac => this.removeFromRepo(fac));
                break;
            case FacilityRepositorySyncType.DumpRequest:
                {
                    const facs = [];
                    this.forEach(fac => facs.push(fac));
                    this.pubSyncEvent(FacilityRepositorySyncType.DumpResponse, facs);
                }
                break;
        }
    }
    /**
     * Gets an instance of FacilityRespository.
     * @param bus The event bus.
     * @returns an instance of FacilityRespository.
     */
    static getRepository(bus) {
        var _a;
        return (_a = FacilityRespository.INSTANCE) !== null && _a !== void 0 ? _a : (FacilityRespository.INSTANCE = new FacilityRespository(bus));
    }
}
FacilityRespository.SYNC_TOPIC = 'facilityrepo_sync';

var IcaoSearchFilter;
(function (IcaoSearchFilter) {
    IcaoSearchFilter[IcaoSearchFilter["ALL"] = 0] = "ALL";
    IcaoSearchFilter[IcaoSearchFilter["AIRPORT"] = 1] = "AIRPORT";
    IcaoSearchFilter[IcaoSearchFilter["VOR"] = 2] = "VOR";
    IcaoSearchFilter[IcaoSearchFilter["NDB"] = 3] = "NDB";
    IcaoSearchFilter[IcaoSearchFilter["INTERSECTION"] = 4] = "INTERSECTION";
    IcaoSearchFilter[IcaoSearchFilter["USR"] = 5] = "USR";
})(IcaoSearchFilter || (IcaoSearchFilter = {}));

/// <reference types="msfstypes/JS/simvar" />
/**
 * A publisher for basic ADC/AHRS information.
 */
class ADCPublisher extends SimVarPublisher {
    /**
     * Create an ADCPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        super(ADCPublisher.simvars, bus, pacer);
    }
    /**
     * Updates the ADC publisher.
     */
    onUpdate() {
        super.onUpdate();
    }
}
ADCPublisher.simvars = new Map([
    ['ias', { name: 'AIRSPEED INDICATED', type: SimVarValueType.Knots }],
    ['tas', { name: 'AIRSPEED TRUE', type: SimVarValueType.Knots }],
    ['alt', { name: 'INDICATED ALTITUDE', type: SimVarValueType.Feet }],
    ['vs', { name: 'VERTICAL SPEED', type: SimVarValueType.FPM }],
    ['hdg_deg', { name: 'PLANE HEADING DEGREES MAGNETIC', type: SimVarValueType.Degree }],
    ['pitch_deg', { name: 'PLANE PITCH DEGREES', type: SimVarValueType.Degree }],
    ['roll_deg', { name: 'PLANE BANK DEGREES', type: SimVarValueType.Degree }],
    ['hdg_deg_true', { name: 'PLANE HEADING DEGREES TRUE', type: SimVarValueType.Degree }],
    ['magvar', { name: 'MAGVAR', type: SimVarValueType.Degree }],
    ['kohlsman_setting_hg_1', { name: 'KOHLSMAN SETTING HG', type: SimVarValueType.InHG }],
    ['turn_coordinator_ball', { name: 'TURN COORDINATOR BALL', type: SimVarValueType.Number }],
    ['delta_heading_rate', { name: 'DELTA HEADING RATE', type: SimVarValueType.Degree }],
    ['ambient_temp_c', { name: 'AMBIENT TEMPERATURE', type: SimVarValueType.Celsius }],
    ['ambient_wind_velocity', { name: 'AMBIENT WIND VELOCITY', type: SimVarValueType.Knots }],
    ['ambient_wind_direction', { name: 'AMBIENT WIND DIRECTION', type: SimVarValueType.Degree }],
    ['kohlsman_setting_mb_1', { name: 'KOHLSMAN SETTING MB', type: SimVarValueType.MB }],
    ['baro_units_hpa_1', { name: 'L:XMLVAR_Baro_Selector_HPA_1', type: SimVarValueType.Bool }],
    ['on_ground', { name: 'SIM ON GROUND', type: SimVarValueType.Bool }],
    ['aoa', { name: 'INCIDENCE ALPHA', type: SimVarValueType.Degree }]
]);

/**
 * InstrumentBackplane provides a common control point for aggregating and
 * managing any number of publishers.  This can be used as an "update loop"
 * corral", amongst other things.
 */
class InstrumentBackplane {
    /**
     * Create an InstrumentBackplane
     */
    constructor() {
        this.publishers = new Map();
        this.instruments = new Map();
    }
    /**
     * Initialize all the things. This is initially just a proxy for the
     * private initPublishers() and initInstruments() methods.
     *
     * This should be simplified.
     */
    init() {
        this.initPublishers();
        this.initInstruments();
    }
    /**
     * Update all the things.  This is initially just a proxy for the private
     * updatePublishers() and updateInstruments() methods.
     *
     * This should be simplified.
     */
    onUpdate() {
        this.updatePublishers();
        this.updateInstruments();
    }
    /**
     * Add a publisher to the backplane.
     * @param name - a symbolic name for the publisher for reference
     * @param publisher - a publisher extending BasePublisher
     */
    addPublisher(name, publisher) {
        this.publishers.set(name, publisher);
    }
    /**
     * Add an instrument to the backplane.
     * @param name - a symbolic name for the publisher for reference
     * @param instrument - an instrument implementing Instrment
     */
    addInstrument(name, instrument) {
        this.instruments.set(name, instrument);
    }
    /**
     * Initialize all of the publishers that you hold.
     */
    initPublishers() {
        for (const publisher of this.publishers.values()) {
            publisher.startPublish();
        }
    }
    /**
     * Initialize all of the instruments that you hold.
     */
    initInstruments() {
        for (const instrument of this.instruments.values()) {
            instrument.init();
        }
    }
    /**
     * Update all of the publishers that you hold.
     */
    updatePublishers() {
        for (const publisher of this.publishers.values()) {
            publisher.onUpdate();
        }
    }
    /**
     * Update all of the instruments that you hold.
     */
    updateInstruments() {
        for (const instrument of this.instruments.values()) {
            instrument.onUpdate();
        }
    }
}

/// <reference types="msfstypes/JS/SimPlane" />
/**
 * A publisher for basic GNSS information.
 */
class GNSSPublisher extends BasePublisher {
    /**
     * Create an GNSSPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        super(bus, pacer);
    }
    /**
     * A callback called when the publisher updates.
     */
    onUpdate() {
        this.publishPosition();
        this.publishTime();
        this.publishTrack();
        this.publishGroundSpeed();
    }
    /**
     * Publishes the gps-position event.
     */
    publishPosition() {
        const lat = SimVar.GetSimVarValue('PLANE LATITUDE', SimVarValueType.Degree);
        const lon = SimVar.GetSimVarValue('PLANE LONGITUDE', SimVarValueType.Degree);
        const alt = SimVar.GetSimVarValue('PLANE ALTITUDE', SimVarValueType.Feet);
        this.publish('gps-position', new LatLongAlt(lat, lon, alt));
    }
    /**
     * Publishes the zulu_time and time_of_day events.
     */
    publishTime() {
        const zuluTime = SimVar.GetGlobalVarValue('ZULU TIME', 'seconds');
        const timeOfDay = SimVar.GetSimVarValue('E:TIME OF DAY', 'number');
        this.publish('zulu_time', zuluTime);
        this.publish('time_of_day', timeOfDay);
    }
    /**
     * Publishes the track_deg_true and track_deg_magnetic events.
     */
    publishTrack() {
        const headingTrue = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', SimVarValueType.Degree);
        const velocityEW = SimVar.GetSimVarValue('VELOCITY WORLD X', SimVarValueType.Knots);
        const velocityNS = SimVar.GetSimVarValue('VELOCITY WORLD Z', SimVarValueType.Knots);
        let track = headingTrue;
        if (velocityEW !== 0 || velocityNS !== 0) {
            track = NavMath.normalizeHeading(UnitType.RADIAN.convertTo(Math.atan2(velocityEW, velocityNS), UnitType.DEGREE));
        }
        const magvar = SimVar.GetSimVarValue('MAGVAR', SimVarValueType.Degree);
        const magneticTrack = NavMath.normalizeHeading(track - magvar);
        this.publish('track_deg_true', track);
        this.publish('track_deg_magnetic', magneticTrack);
    }
    /**
     * Publishes the ground_speed event.
     */
    publishGroundSpeed() {
        const gs = SimVar.GetSimVarValue('GROUND VELOCITY', SimVarValueType.Knots);
        this.publish('ground_speed', gs);
    }
}

// Common definitions relevant to all radio types.
/** The basic radio types. */
var RadioType;
(function (RadioType) {
    RadioType["Com"] = "COM";
    RadioType["Nav"] = "NAV";
    RadioType["Adf"] = "ADF";
})(RadioType || (RadioType = {}));
/** The two frequency "banks", active and standby. */
var FrequencyBank;
(function (FrequencyBank) {
    FrequencyBank[FrequencyBank["Active"] = 0] = "Active";
    FrequencyBank[FrequencyBank["Standby"] = 1] = "Standby";
})(FrequencyBank || (FrequencyBank = {}));

/// <reference types="msfstypes/JS/simvar" />
/** Publish simvars for ourselves */
class NavProcSimVarPublisher extends SimVarPublisher {
    /**
     * Create a NavProcSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(NavProcSimVarPublisher.simvars, bus, pacer);
    }
}
NavProcSimVarPublisher.simvars = new Map([
    ['nav1_obs', { name: 'NAV OBS:1', type: SimVarValueType.Degree }],
    ['nav1_cdi', { name: 'NAV CDI:1', type: SimVarValueType.Number }],
    ['nav1_dme', { name: 'NAV DME:1', type: SimVarValueType.NM }],
    ['nav1_has_dme', { name: 'NAV HAS DME:1', type: SimVarValueType.Bool }],
    ['nav1_has_nav', { name: 'NAV HAS NAV:1', type: SimVarValueType.Bool }],
    ['nav1_radial', { name: 'NAV RADIAL:1', type: SimVarValueType.Radians }],
    ['nav1_signal', { name: 'NAV SIGNAL:1', type: SimVarValueType.Number }],
    ['nav1_ident', { name: 'NAV IDENT:1', type: SimVarValueType.String }],
    ['nav1_to_from', { name: 'NAV TOFROM:1', type: SimVarValueType.Enum }],
    ['nav1_localizer', { name: 'NAV HAS LOCALIZER:1', type: SimVarValueType.Bool }],
    ['nav1_localizer_crs', { name: 'NAV LOCALIZER:1', type: SimVarValueType.Number }],
    ['nav1_glideslope', { name: 'NAV HAS GLIDE SLOPE:1', type: SimVarValueType.Bool }],
    ['nav1_gs_error', { name: 'NAV GLIDE SLOPE ERROR:1', type: SimVarValueType.Degree }],
    ['nav1_raw_gs', { name: 'NAV RAW GLIDE SLOPE:1', type: SimVarValueType.Degree }],
    ['nav1_gs_lla', { name: 'NAV GS LATLONALT:1', type: SimVarValueType.LLA }],
    ['nav1_lla', { name: 'NAV VOR LATLONALT:1', type: SimVarValueType.LLA }],
    ['nav1_magvar', { name: 'NAV MAGVAR:1', type: SimVarValueType.Number }],
    ['nav2_obs', { name: 'NAV OBS:2', type: SimVarValueType.Degree }],
    ['nav2_cdi', { name: 'NAV CDI:2', type: SimVarValueType.Number }],
    ['nav2_dme', { name: 'NAV DME:2', type: SimVarValueType.NM }],
    ['nav2_has_dme', { name: 'NAV HAS DME:2', type: SimVarValueType.Bool }],
    ['nav2_has_nav', { name: 'NAV HAS NAV:2', type: SimVarValueType.Bool }],
    ['nav2_radial', { name: 'NAV RADIAL:2', type: SimVarValueType.Radians }],
    ['nav2_signal', { name: 'NAV SIGNAL:2', type: SimVarValueType.Number }],
    ['nav2_ident', { name: 'NAV IDENT:2', type: SimVarValueType.String }],
    ['nav2_to_from', { name: 'NAV TOFROM:2', type: SimVarValueType.Enum }],
    ['nav2_localizer', { name: 'NAV HAS LOCALIZER:2', type: SimVarValueType.Bool }],
    ['nav2_localizer_crs', { name: 'NAV LOCALIZER:2', type: SimVarValueType.Number }],
    ['nav2_glideslope', { name: 'NAV HAS GLIDE SLOPE:2', type: SimVarValueType.Bool }],
    ['nav2_gs_error', { name: 'NAV GLIDE SLOPE ERROR:2', type: SimVarValueType.Degree }],
    ['nav2_raw_gs', { name: 'NAV RAW GLIDE SLOPE:2', type: SimVarValueType.Degree }],
    ['nav2_gs_lla', { name: 'NAV GS LATLONALT:2', type: SimVarValueType.LLA }],
    ['nav2_lla', { name: 'NAV VOR LATLONALT:2', type: SimVarValueType.LLA }],
    ['nav2_magvar', { name: 'NAV MAGVAR:2', type: SimVarValueType.Number }],
    ['gps_dtk', { name: 'GPS WP DESIRED TRACK', type: SimVarValueType.Degree }],
    ['gps_xtk', { name: 'GPS WP CROSS TRK', type: SimVarValueType.NM }],
    ['gps_wp', { name: 'GPS WP NEXT ID', type: SimVarValueType.NM }],
    ['gps_wp_bearing', { name: 'GPS WP BEARING', type: SimVarValueType.Degree }],
    ['gps_wp_distance', { name: 'GPS WP DISTANCE', type: SimVarValueType.NM }],
    ['adf1_bearing', { name: 'ADF RADIAL:1', type: SimVarValueType.Radians }],
    ['adf1_signal', { name: 'ADF SIGNAL:1', type: SimVarValueType.Number }],
    ['mkr_bcn_state_simvar', { name: 'MARKER BEACON STATE', type: SimVarValueType.Number }],
    ['gps_obs_active_simvar', { name: 'GPS OBS ACTIVE', type: SimVarValueType.Bool }],
    ['gps_obs_value_simvar', { name: 'GPS OBS VALUE', type: SimVarValueType.Degree }]
]);
//
// Navigation event configurations
//
var NavSourceType;
(function (NavSourceType) {
    NavSourceType[NavSourceType["Nav"] = 0] = "Nav";
    NavSourceType[NavSourceType["Gps"] = 1] = "Gps";
    NavSourceType[NavSourceType["Adf"] = 2] = "Adf";
})(NavSourceType || (NavSourceType = {}));
//* ENUM for VOR To/From Flag */
var VorToFrom;
(function (VorToFrom) {
    VorToFrom[VorToFrom["OFF"] = 0] = "OFF";
    VorToFrom[VorToFrom["TO"] = 1] = "TO";
    VorToFrom[VorToFrom["FROM"] = 2] = "FROM";
})(VorToFrom || (VorToFrom = {}));
/** Marker beacon signal state. */
var MarkerBeaconState;
(function (MarkerBeaconState) {
    MarkerBeaconState[MarkerBeaconState["Inactive"] = 0] = "Inactive";
    MarkerBeaconState[MarkerBeaconState["Outer"] = 1] = "Outer";
    MarkerBeaconState[MarkerBeaconState["Middle"] = 2] = "Middle";
    MarkerBeaconState[MarkerBeaconState["Inner"] = 3] = "Inner";
})(MarkerBeaconState || (MarkerBeaconState = {}));

/** A publisher to poll and publish nav/com simvars. */
class NavComSimVarPublisher extends SimVarPublisher {
    /**
     * Create a NavComSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(NavComSimVarPublisher.simvars, bus, pacer);
    }
}
NavComSimVarPublisher.simvars = new Map([
    ['nav1ActiveFreq', { name: 'NAV ACTIVE FREQUENCY:1', type: SimVarValueType.MHz }],
    ['nav1StandbyFreq', { name: 'NAV STANDBY FREQUENCY:1', type: SimVarValueType.MHz }],
    ['nav1Ident', { name: 'NAV IDENT:1', type: SimVarValueType.String }],
    ['nav2ActiveFreq', { name: 'NAV ACTIVE FREQUENCY:2', type: SimVarValueType.MHz }],
    ['nav2StandbyFreq', { name: 'NAV STANDBY FREQUENCY:2', type: SimVarValueType.MHz }],
    ['nav2Ident', { name: 'NAV IDENT:2', type: SimVarValueType.String }],
    ['com1ActiveFreq', { name: 'COM ACTIVE FREQUENCY:1', type: SimVarValueType.MHz }],
    ['com1StandbyFreq', { name: 'COM STANDBY FREQUENCY:1', type: SimVarValueType.MHz }],
    ['com2ActiveFreq', { name: 'COM ACTIVE FREQUENCY:2', type: SimVarValueType.MHz }],
    ['com2StandbyFreq', { name: 'COM STANDBY FREQUENCY:2', type: SimVarValueType.MHz }],
    ['adf1StandbyFreq', { name: 'ADF STANDBY FREQUENCY:1', type: SimVarValueType.KHz }],
    ['adf1ActiveFreq', { name: 'ADF ACTIVE FREQUENCY:1', type: SimVarValueType.KHz }]
]);

/// <reference types="msfstypes/JS/simvar" />
var APLockType;
(function (APLockType) {
    APLockType[APLockType["Heading"] = 0] = "Heading";
    APLockType[APLockType["Nav"] = 1] = "Nav";
    APLockType[APLockType["Alt"] = 2] = "Alt";
    APLockType[APLockType["Bank"] = 3] = "Bank";
    APLockType[APLockType["WingLevel"] = 4] = "WingLevel";
    APLockType[APLockType["Vs"] = 5] = "Vs";
    APLockType[APLockType["Flc"] = 6] = "Flc";
    APLockType[APLockType["Pitch"] = 7] = "Pitch";
    APLockType[APLockType["Approach"] = 8] = "Approach";
    APLockType[APLockType["Backcourse"] = 9] = "Backcourse";
    APLockType[APLockType["Glideslope"] = 10] = "Glideslope";
    APLockType[APLockType["VNav"] = 11] = "VNav";
})(APLockType || (APLockType = {}));
/** base publisher for simvars */
class APSimVarPublisher extends SimVarPublisher {
    /**
     * Create an APSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(APSimVarPublisher.simvars, bus, pacer);
    }
}
APSimVarPublisher.simvars = new Map([
    // TODO extend the next two to handle multiple APs?
    ['selected_heading', { name: 'AUTOPILOT HEADING LOCK DIR:1', type: SimVarValueType.Degree }],
    ['selected_altitude', { name: 'AUTOPILOT ALTITUDE LOCK VAR:1', type: SimVarValueType.Feet }],
    ['ap_master_status', { name: 'AUTOPILOT MASTER', type: SimVarValueType.Bool }],
    ['ap_heading_lock', { name: 'AUTOPILOT HEADING LOCK', type: SimVarValueType.Bool }],
    ['ap_nav_lock', { name: 'AUTOPILOT NAV1 LOCK', type: SimVarValueType.Bool }],
    ['ap_bank_hold', { name: 'AUTOPILOT BANK HOLD', type: SimVarValueType.Bool }],
    ['ap_wing_lvl', { name: 'AUTOPILOT WING LEVELER', type: SimVarValueType.Bool }],
    ['ap_approach_hold', { name: 'AUTOPILOT APPROACH HOLD', type: SimVarValueType.Bool }],
    ['ap_backcourse_hold', { name: 'AUTOPILOT BACKCOURSE HOLD', type: SimVarValueType.Bool }],
    ['ap_vs_hold', { name: 'AUTOPILOT VERTICAL HOLD', type: SimVarValueType.Bool }],
    ['ap_flc_hold', { name: 'AUTOPILOT FLIGHT LEVEL CHANGE', type: SimVarValueType.Bool }],
    ['ap_alt_lock', { name: 'AUTOPILOT ALTITUDE LOCK', type: SimVarValueType.Bool }],
    ['ap_glideslope_hold', { name: 'AUTOPILOT GLIDESLOPE HOLD', type: SimVarValueType.Bool }],
    ['ap_pitch_hold', { name: 'AUTOPILOT PITCH HOLD', type: SimVarValueType.Bool }],
    ['vs_hold_fpm', { name: 'AUTOPILOT VERTICAL HOLD VAR:1', type: SimVarValueType.FPM }],
    ['flc_hold_knots', { name: 'AUTOPILOT AIRSPEED HOLD VAR', type: SimVarValueType.Knots }],
    ['flight_director_bank', { name: 'AUTOPILOT FLIGHT DIRECTOR BANK', type: SimVarValueType.Degree }],
    ['flight_director_pitch', { name: 'AUTOPILOT FLIGHT DIRECTOR PITCH', type: SimVarValueType.Degree }],
    ['flight_director_lock', { name: 'AUTOPILOT FLIGHT DIRECTOR ACTIVE', type: SimVarValueType.Bool }],
    ['vnav_active', { name: 'L:XMLVAR_VNAVButtonValue', type: SimVarValueType.Bool }],
    ['alt_lock', { name: 'AUTOPILOT ALTITUDE LOCK', type: SimVarValueType.Bool }],
    ['pitch_ref', { name: 'AUTOPILOT PITCH HOLD REF', type: SimVarValueType.Degree }],
    ['kap_140_simvar', { name: 'L:WT1000_AP_KAP140_INSTALLED', type: SimVarValueType.Bool }]
]);
/**
 * Publishes autopilot data
 */
class AutopilotPublisher extends BasePublisher {
    /**
     * Creates an AutopilotPublisher
     * @param bus The event bus to publish to.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
        super(bus, pacer);
    }
    /**
     * Publish an AP master engage event
     */
    publishMasterEngage() {
        this.publish('ap_master_engage', true);
    }
    /**
     * Publish an AP master disengage event
     */
    publishMasterDisengage() {
        this.publish('ap_master_disengage', true);
    }
    /**
     * Publish a selected alt change
     * @param newAlt The new selected altitude.
     */
    publishAltChange(newAlt) {
        this.publish('alt_select', newAlt);
    }
    /**
     * Publish a selected hdg change
     * @param newHdg The new selected heading.
     */
    publishHdgChange(newHdg) {
        this.publish('heading_select', newHdg);
    }
    /**
     * Publish a selected vs change
     * @param newVs The new selected vs.
     */
    publishVsChange(newVs) {
        this.publish('vs_hold_fpm', newVs);
    }
    /**
     * Publish a selected flc ias change
     * @param newIas The new selected ias.
     */
    publishFlcIasChange(newIas) {
        this.publish('flc_hold_knots', newIas);
    }
    /**
     * Publish a lock set event
     * @param lock The lock/hold set
     */
    publishLockSet(lock) {
        this.publish('ap_lock_set', lock);
    }
    /**
     * Publish a lock release event
     * @param lock The lock/hold released
     */
    publishLockRelease(lock) {
        this.publish('ap_lock_release', lock);
    }
    /**
     * Publish a pitch ref value.
     * @param newPitch The new commanded pitch angle.
     */
    publishPitchRefChange(newPitch) {
        this.publish('pitch_ref', newPitch);
    }
    /**
     * Publish a flight director pitch value.
     * @param newPitch The new commanded pitch angle.
     */
    publishFlightDirectorPitchChange(newPitch) {
        this.publish('flight_director_pitch', newPitch);
    }
    /**
     * Publish a flight director bank value
     * @param newBank The new commanded bank angle.
     */
    publishFlightDirectorBankChange(newBank) {
        this.publish('flight_director_bank', newBank);
    }
    /**
     * Publish an FD lock event
     * @param state is the flight director state (true = on, false = off).
     */
    publishFlightDirectorState(state) {
        this.publish('flight_director_state', state);
    }
    /**
     * Publish alt lock
     * @param locked is if it is locked.
     */
    publishAltLock(locked) {
        this.publish('alt_lock', locked);
    }
    /**
     * Publish KAP140 Installed State
     * @param state is the state of the simvar.
     */
    publishKAP140State(state) {
        this.publish('kap_140_installed', state);
    }
}
/**
 * Manages an autopilot system
 */
class AutopilotInstrument {
    /**
     * Create an AutopilotInstrument
     * @param bus The event bus to publish to
     */
    constructor(bus) {
        this.bus = bus;
        // this.hEvents = this.bus.getSubscriber<HEvent>();
        this.publisher = new AutopilotPublisher(bus);
        this.simVarPublisher = new APSimVarPublisher(bus);
        this.simVarSubscriber = new EventSubscriber(bus);
        this.simVarPublisher.subscribe('ap_master_status');
        this.simVarPublisher.subscribe('selected_altitude');
        this.simVarPublisher.subscribe('selected_heading');
        this.simVarPublisher.subscribe('ap_alt_lock');
        this.simVarPublisher.subscribe('ap_bank_hold');
        this.simVarPublisher.subscribe('ap_wing_lvl');
        this.simVarPublisher.subscribe('ap_flc_hold');
        this.simVarPublisher.subscribe('ap_heading_lock');
        this.simVarPublisher.subscribe('ap_nav_lock');
        this.simVarPublisher.subscribe('ap_approach_hold');
        this.simVarPublisher.subscribe('ap_backcourse_hold');
        this.simVarPublisher.subscribe('ap_pitch_hold');
        this.simVarPublisher.subscribe('ap_glideslope_hold');
        this.simVarPublisher.subscribe('ap_vs_hold');
        this.simVarPublisher.subscribe('vs_hold_fpm');
        this.simVarPublisher.subscribe('flc_hold_knots');
        this.simVarPublisher.subscribe('flight_director_bank');
        this.simVarPublisher.subscribe('flight_director_pitch');
        this.simVarPublisher.subscribe('flight_director_lock');
        this.simVarPublisher.subscribe('vnav_active');
        this.simVarPublisher.subscribe('alt_lock');
        this.simVarPublisher.subscribe('pitch_ref');
        this.simVarPublisher.subscribe('kap_140_simvar');
    }
    /**
     * Initialize the instrument
     */
    init() {
        this.publisher.startPublish();
        this.simVarPublisher.startPublish();
        console.log('initting autopilot');
        this.simVarSubscriber.on('ap_master_status').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishMasterEngage();
            }
            else {
                this.publisher.publishMasterDisengage();
            }
        });
        this.simVarSubscriber.on('selected_altitude').whenChangedBy(1).handle((newAlt) => {
            this.publisher.publishAltChange(newAlt);
        });
        this.simVarSubscriber.on('selected_heading').whenChangedBy(1).handle((newHdg) => {
            this.publisher.publishHdgChange(newHdg);
        });
        this.simVarSubscriber.on('vs_hold_fpm').whenChangedBy(1).handle((newVs) => {
            this.publisher.publishVsChange(newVs);
        });
        this.simVarSubscriber.on('flc_hold_knots').whenChangedBy(1).handle((newIas) => {
            this.publisher.publishFlcIasChange(newIas);
        });
        this.simVarSubscriber.on('ap_alt_lock').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Alt);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Alt);
            }
        });
        this.simVarSubscriber.on('ap_pitch_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Pitch);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Pitch);
            }
        });
        this.simVarSubscriber.on('ap_heading_lock').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Heading);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Heading);
            }
        });
        this.simVarSubscriber.on('ap_nav_lock').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Nav);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Nav);
            }
        });
        this.simVarSubscriber.on('ap_approach_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Approach);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Approach);
            }
        });
        this.simVarSubscriber.on('ap_backcourse_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Backcourse);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Backcourse);
            }
        });
        this.simVarSubscriber.on('ap_bank_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Bank);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Bank);
            }
        });
        this.simVarSubscriber.on('ap_wing_lvl').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.WingLevel);
            }
            else {
                this.publisher.publishLockRelease(APLockType.WingLevel);
            }
        });
        this.simVarSubscriber.on('ap_flc_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Flc);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Flc);
            }
        });
        this.simVarSubscriber.on('ap_vs_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Vs);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Vs);
            }
        });
        this.simVarSubscriber.on('ap_glideslope_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Glideslope);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Glideslope);
            }
        });
        this.simVarSubscriber.on('flight_director_bank').whenChangedBy(.25).handle((newBank) => {
            this.publisher.publishFlightDirectorBankChange(newBank);
        });
        this.simVarSubscriber.on('flight_director_pitch').whenChangedBy(.25).handle((newPitch) => {
            this.publisher.publishFlightDirectorPitchChange(newPitch);
        });
        this.simVarSubscriber.on('flight_director_lock').whenChanged().handle((state) => {
            this.publisher.publishFlightDirectorState(state);
        });
        this.simVarSubscriber.on('vnav_active').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.VNav);
            }
            else {
                this.publisher.publishLockRelease(APLockType.VNav);
            }
        });
        this.simVarSubscriber.on('alt_lock').whenChanged().handle((lock) => {
            this.publisher.publishAltLock(lock);
        });
        this.simVarSubscriber.on('pitch_ref').whenChangedBy(0.1).handle((val) => {
            this.publisher.publishPitchRefChange(val);
        });
        this.simVarSubscriber.on('kap_140_simvar').whenChanged().handle((val) => {
            this.publisher.publishKAP140State(val);
        });
    }
    /** update our publishers */
    onUpdate() {
        this.simVarPublisher.onUpdate();
    }
}

/// <reference types="msfstypes/JS/simvar" />
/**
 * A publisher for Engine information.
 */
class EISPublisher extends SimVarPublisher {
    /**
     * Create an ADCPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        super(EISPublisher.simvars, bus, pacer);
    }
}
EISPublisher.simvars = new Map([
    ['rpm_1', { name: 'GENERAL ENG RPM:1', type: SimVarValueType.RPM }],
    ['recip_ff_1', { name: 'RECIP ENG FUEL FLOW:1', type: SimVarValueType.PPH }],
    ['oil_press_1', { name: 'ENG OIL PRESSURE:1', type: SimVarValueType.PSI }],
    ['oil_temp_1', { name: 'ENG OIL TEMPERATURE:1', type: SimVarValueType.Farenheit }],
    ['egt_1', { name: 'ENG EXHAUST GAS TEMPERATURE:1', type: SimVarValueType.Farenheit }],
    ['vac', { name: 'SUCTION PRESSURE', type: SimVarValueType.InHG }],
    ['fuel_left', { name: 'FUEL LEFT QUANTITY', type: SimVarValueType.GAL }],
    ['fuel_right', { name: 'FUEL RIGHT QUANTITY', type: SimVarValueType.GAL }],
    ['eng_hours_1', { name: 'GENERAL ENG ELAPSED TIME:1', type: SimVarValueType.Hours }],
    ['elec_bus_main_v', { name: 'ELECTRICAL MAIN BUS VOLTAGE', type: SimVarValueType.Volts }],
    ['elec_bus_main_a', { name: 'ELECTRICAL MAIN BUS AMPS', type: SimVarValueType.Amps }],
    ['elec_bus_avionics_v', { name: 'ELECTRICAL AVIONICS BUS VOLTAGE', type: SimVarValueType.Volts }],
    ['elec_bus_avionics_a', { name: 'ELECTRICAL AVIONICS BUS AMPS', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_1_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:1', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_1_a', { name: 'ELECTRICAL GENALT BUS AMPS:1', type: SimVarValueType.Amps }],
    ['elec_bat_a', { name: 'ELECTRICAL BATTERY LOAD', type: SimVarValueType.Amps }],
    ['elec_bat_v', { name: 'ELECTRICAL BATTERY VOLTAGE', type: SimVarValueType.Volts }]
]);

/**
 * A publisher of clock events.
 */
class ClockPublisher extends BasePublisher {
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdate() {
        this.publish('realTime', Date.now());
        this.publish('simTime', ClockPublisher.absoluteTimeToUNIXTime(SimVar.GetSimVarValue('E:ABSOLUTE TIME', 'seconds')));
    }
    /**
     * Converts the sim's absolute time to a UNIX timestamp. The sim's absolute time value is equivalent to a .NET
     * DateTime.Ticks value (epoch = 00:00:00 01 Jan 0001).
     * @param absoluteTime an absolute time value, in units of seconds.
     * @returns the UNIX timestamp corresponding to the absolute time value.
     */
    static absoluteTimeToUNIXTime(absoluteTime) {
        return (absoluteTime - 62135596800) * 1000;
    }
}
/**
 * A clock which keeps track of real-world and sim time.
 */
class Clock {
    /**
     * Constructor.
     * @param bus The event bus to use to publish events from this clock.
     */
    constructor(bus) {
        this.publisher = new ClockPublisher(bus);
    }
    /**
     * Initializes this clock.
     */
    init() {
        this.publisher.startPublish();
    }
    /**
     * Updates this clock.
     */
    onUpdate() {
        this.publisher.onUpdate();
    }
}

/** Transponder modes. */
var XPDRMode;
(function (XPDRMode) {
    XPDRMode[XPDRMode["OFF"] = 0] = "OFF";
    XPDRMode[XPDRMode["STBY"] = 1] = "STBY";
    XPDRMode[XPDRMode["TEST"] = 2] = "TEST";
    XPDRMode[XPDRMode["ON"] = 3] = "ON";
    XPDRMode[XPDRMode["ALT"] = 4] = "ALT";
    XPDRMode[XPDRMode["GROUND"] = 5] = "GROUND";
})(XPDRMode || (XPDRMode = {}));
/** A publiher to poll transponder simvars. */
class XPDRSimVarPublisher extends SimVarPublisher {
    /**
     * Create an XPDRSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(XPDRSimVarPublisher.simvars, bus, pacer);
    }
}
XPDRSimVarPublisher.simvars = new Map([
    ['xpdrMode1', { name: 'TRANSPONDER STATE:1', type: SimVarValueType.Number }],
    ['xpdrCode1', { name: 'TRANSPONDER CODE:1', type: SimVarValueType.Number }],
    ['xpdrIdent', { name: 'TRANSPONDER IDENT:1', type: SimVarValueType.Bool }]
]);

/**
 * Tracks aircraft traffic. Maintains a list of contacts, periodically updates their position, altitude, and reported
 * heading, and uses these data to compute ground speed, ground track, and vertical speed.
 */
class TrafficInstrument {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param options Options with which to initialize this instrument.
     */
    constructor(bus, options) {
        this.bus = bus;
        this.tracked = new Map();
        this.lastUpdateRealTime = 0;
        this.lastUpdateSimTime = 0;
        this.isBusy = false;
        this.options = Object.assign({}, options);
    }
    /**
     * Retrieves a traffic contact by its assigned ID number.
     * @param uid an ID number.
     * @returns the traffic contact with the assigned ID number, or undefined if no such contact exists.
     */
    getContact(uid) {
        return this.tracked.get(uid);
    }
    /**
     * Iterates through all tracked traffic contacts with a visitor function.
     * @param visitor A visitor function.
     */
    forEachContact(visitor) {
        this.tracked.forEach(visitor);
    }
    /**
     * Initializes this instrument. Once initialized, this instrument will automatically track and update traffic
     * contacts.
     */
    init() {
        this.bus.getSubscriber()
            .on('simTime')
            .whenChanged()
            .handle(this.onSimTimeChanged.bind(this));
    }
    /**
     * Updates this instrument's list of contacts.
     * @param data An array of the most recent traffic data entries.
     * @param simTime The sim time at which the traffic data was generated.
     */
    updateContacts(data, simTime) {
        const len = data.length;
        for (let i = 0; i < len; i++) {
            const entry = data[i];
            const contact = this.tracked.get(entry.uId);
            if (contact) {
                this.updateContact(contact, entry, simTime);
            }
            else {
                this.createContact(entry, simTime);
            }
        }
    }
    /**
     * Creates a contact.
     * @param entry The traffic data entry from which to create the new contact.
     * @param simTime The sim time at which the traffic data entry was generated.
     */
    createContact(entry, simTime) {
        const contact = new TrafficContactClass(entry.uId, 1000 / this.options.simTimeUpdateFreq * 5);
        this.tracked.set(contact.uid, contact);
        contact.update(entry.lat, entry.lon, UnitType.METER.convertTo(entry.alt, UnitType.FOOT), entry.heading, simTime);
        this.bus.pub('traffic_contact_added', contact.uid, false, false);
    }
    /**
     * Updates a contact.
     * @param contact The contact to update.
     * @param entry The current traffic data entry for the contact.
     * @param simTime The sim time at which the traffic data entry was generated.
     */
    updateContact(contact, entry, simTime) {
        contact.update(entry.lat, entry.lon, UnitType.METER.convertTo(entry.alt, UnitType.FOOT), entry.heading, simTime);
        this.bus.pub('traffic_contact_updated', contact.uid, false, false);
    }
    /**
     * Removes all contacts whose time since last contact exceeds the deprecation threshold.
     * @param simTime The current sim time.
     */
    deprecateContacts(simTime) {
        this.tracked.forEach(contact => {
            const dt = Math.abs(simTime - contact.lastContactTime);
            if (dt >= this.options.contactDeprecateTime) {
                this.tracked.delete(contact.uid);
                this.bus.pub('traffic_contact_removed', contact.uid, false, false);
            }
        });
    }
    /**
     * A callback which is called when the sim time changes.
     * @param simTime The current sim time.
     */
    async onSimTimeChanged(simTime) {
        const realTime = Date.now();
        if (this.isBusy
            || Math.abs(simTime - this.lastUpdateSimTime) < 1000 / this.options.simTimeUpdateFreq
            || Math.abs(realTime - this.lastUpdateRealTime) < 1000 / this.options.realTimeUpdateFreq) {
            return;
        }
        this.isBusy = true;
        try {
            const data = await Promise.race([Coherent.call('GET_AIR_TRAFFIC'), Wait.awaitDelay(1000)]);
            if (data) {
                this.updateContacts(data, simTime);
                this.deprecateContacts(simTime);
                this.lastUpdateSimTime = simTime;
                this.lastUpdateRealTime = realTime;
            }
        }
        catch (e) {
            console.error(e);
            if (e instanceof Error) {
                console.log(e.stack);
            }
        }
        this.isBusy = false;
    }
    /**
     * This method does nothing.
     */
    onUpdate() {
        // noop
    }
}
/**
 * An aircraft contact that is being tracked. Each contact tracks its last reported position, altitude, and heading.
 * Successively updating these values will allow ground speed, ground track, and vertical speed to be calculated based
 * on changes in the values over time. The calculated values are exponentially smoothed to reduce artifacts from
 * potentially noisy data.
 */
class TrafficContactClass {
    /**
     * Constructor.
     * @param uid This contact's unique ID number.
     * @param contactTimeResetThreshold The maximum allowed elapsed sim time, in milliseconds, since time of last contact
     * before this contact's computed values are reset.
     */
    constructor(uid, contactTimeResetThreshold) {
        this.uid = uid;
        this.contactTimeResetThreshold = contactTimeResetThreshold;
        // reported data
        this._lastPosition = new GeoPoint(NaN, NaN);
        this.lastPosition = this._lastPosition.readonly;
        this._lastAltitude = UnitType.FOOT.createNumber(NaN);
        this.lastAltitude = this._lastAltitude.readonly;
        this._lastHeading = NaN;
        this._lastContactTime = NaN;
        // computed data
        this._groundSpeed = UnitType.KNOT.createNumber(NaN);
        this.groundSpeed = this._groundSpeed.readonly;
        this._groundTrack = NaN;
        this._verticalSpeed = UnitType.FPM.createNumber(NaN);
        this.verticalSpeed = this._verticalSpeed.readonly;
        this.groundSpeedSmoother = new ExpSmoother(TrafficContactClass.GROUND_SPEED_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1000);
        this.groundTrackSmoother = new ExpSmoother(TrafficContactClass.GROUND_TRACK_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1000);
        this.verticalSpeedSmoother = new ExpSmoother(TrafficContactClass.VERTICAL_SPEED_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1000);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get lastHeading() {
        return this._lastHeading;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get lastContactTime() {
        return this._lastContactTime;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get groundTrack() {
        return this._groundTrack;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    predict(simTime, positionOut, altitudeOut) {
        if (this.groundSpeed.isNaN()) {
            positionOut.set(NaN, NaN);
            altitudeOut.set(NaN);
            return;
        }
        const dt = simTime - this.lastContactTime;
        const distance = UnitType.NMILE.convertTo(this._groundSpeed.number * (dt / 3600000), UnitType.GA_RADIAN);
        this._lastPosition.offset(this._groundTrack, distance, positionOut);
        const deltaAlt = this._verticalSpeed.number * (dt / 60000);
        this._lastAltitude.add(deltaAlt, UnitType.FOOT, altitudeOut);
    }
    /**
     * Updates this contact with the current reported position, altitude and heading. Also updates the computed ground
     * speed, ground track, and vertical speed if there are sufficient data to do so.
     * @param lat The current reported latitude.
     * @param lon The current reported longitude.
     * @param altitude The current reported altitude, in feet.
     * @param heading The current reported heading.
     * @param simTime The current sim time.
     */
    update(lat, lon, altitude, heading, simTime) {
        const dt = simTime - this._lastContactTime;
        if (!isNaN(dt) && (dt < 0 || dt > this.contactTimeResetThreshold)) {
            this.reset(lat, lon, altitude, heading, simTime);
            return;
        }
        if (!isNaN(dt) && dt > 0) {
            this.updateComputedValues(dt / 1000, lat, lon, altitude);
        }
        this.setReportedValues(lat, lon, altitude, heading);
        if (this.areComputedValuesValid()) {
            this._lastContactTime = simTime;
        }
        else {
            this.reset(lat, lon, altitude, heading, simTime);
        }
    }
    /**
     * Erases this contact's tracking history and sets the initial reported position, altitude, and heading.
     * @param lat The current reported latitude.
     * @param lon The current reported longitude.
     * @param altitude The current reported altitude, in feet.
     * @param heading The current reported heading.
     * @param simTime The current sim time.
     */
    reset(lat, lon, altitude, heading, simTime) {
        this.setReportedValues(lat, lon, altitude, heading);
        this._groundSpeed.set(NaN);
        this._groundTrack = NaN;
        this._verticalSpeed.set(NaN);
        this.groundSpeedSmoother.reset();
        this.groundTrackSmoother.reset();
        this.verticalSpeedSmoother.reset();
        this._lastContactTime = simTime;
    }
    /**
     * Sets the most recent reported values.
     * @param lat The reported latitude.
     * @param lon The reported longitude.
     * @param altitude The reported altitude, in feet.
     * @param heading The reported heading.
     */
    setReportedValues(lat, lon, altitude, heading) {
        this._lastPosition.set(lat, lon);
        this._lastAltitude.set(altitude);
        this._lastHeading = heading;
    }
    /**
     * Updates this contact's computed values.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param lat The current reported latitude.
     * @param lon The current reported longitude.
     * @param altitude The current reported altitude, in feet.
     */
    updateComputedValues(dt, lat, lon, altitude) {
        const pos = TrafficContactClass.tempGeoPoint.set(lat, lon);
        const distanceNM = UnitType.GA_RADIAN.convertTo(this.lastPosition.distance(pos), UnitType.NMILE);
        const track = pos.bearingFrom(this._lastPosition);
        this.updateGroundSpeed(dt, distanceNM);
        this.updateGroundTrack(dt, track, distanceNM);
        this.updateVerticalSpeed(dt, altitude);
    }
    /**
     * Updates this contact's ground speed.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param distanceNM The distance, in nautical miles, from this contact's position at last contact to this contact's
     * current reported position.
     */
    updateGroundSpeed(dt, distanceNM) {
        const dtHours = dt / 3600;
        const speedKnots = distanceNM / dtHours;
        this._groundSpeed.set(this.groundSpeedSmoother.next(speedKnots, dt));
    }
    /**
     * Updates this contact's ground track.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param track The true ground track from this contact's position at last contact to this contact's current reported
     * position, as measured at the current reported position.
     * @param distanceNM The distance, in nautical miles, from this contact's position at last contact to this contact's
     * current reported position.
     */
    updateGroundTrack(dt, track, distanceNM) {
        const last = this.groundTrackSmoother.last();
        if (distanceNM >= TrafficContactClass.MIN_GROUND_TRACK_DISTANCE) {
            if (last !== null && !isNaN(last)) {
                // need to handle wraparounds
                let delta = track - last;
                if (delta > 180) {
                    delta = delta - 360;
                }
                else if (delta < -180) {
                    delta = delta + 360;
                }
                track = last + delta;
            }
        }
        else {
            // if distance between current and last position is too small, computed ground track will be unreliable
            // (and if distance = 0 the track will be meaningless), so we just copy forward the last computed track,
            // or NaN if there is no previously computed track
            track = last === null ? NaN : last;
        }
        const next = last !== null && isNaN(last) ? this.groundTrackSmoother.reset(track) : this.groundTrackSmoother.next(track, dt);
        this._groundTrack = (next + 360) % 360; // enforce range 0-359
    }
    /**
     * Updates this contact's vertical speed.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param altitude The current reported altitude, in feet.
     */
    updateVerticalSpeed(dt, altitude) {
        const dtMin = dt / 60;
        const deltaAltFeet = altitude - this._lastAltitude.number;
        const vsFPM = deltaAltFeet / dtMin;
        this._verticalSpeed.set(this.verticalSpeedSmoother.next(vsFPM, dt));
    }
    /**
     * Checks whether this contact's calculated ground speed and vertical speeds are valid.
     * @returns whether this contact's calculated ground speed and vertical speeds are valid.
     */
    areComputedValuesValid() {
        const isGroundSpeedValid = this._groundSpeed.isNaN() || this._groundSpeed.number <= TrafficContactClass.MAX_VALID_GROUND_SPEED;
        const isVerticalSpeedValid = this._verticalSpeed.isNaN() || this._verticalSpeed.number <= TrafficContactClass.MAX_VALID_VERTICAL_SPEED;
        return isGroundSpeedValid && isVerticalSpeedValid;
    }
}
TrafficContactClass.GROUND_SPEED_TIME_CONSTANT = 2 / Math.LN2;
TrafficContactClass.GROUND_TRACK_TIME_CONSTANT = 2 / Math.LN2;
TrafficContactClass.VERTICAL_SPEED_TIME_CONSTANT = 2 / Math.LN2;
TrafficContactClass.MAX_VALID_GROUND_SPEED = 1500; // knots
TrafficContactClass.MAX_VALID_VERTICAL_SPEED = 10000; // fpm
TrafficContactClass.MIN_GROUND_TRACK_DISTANCE = 10 / 1852; // nautical miles
TrafficContactClass.tempGeoPoint = new GeoPoint(0, 0);

/**
 * Utility class for working with flight path calculations.
 */
class FlightPathUtils {
    /**
     * Creates an empty arc vector.
     * @returns An empty arc vector.
     */
    static createEmptyCircleVector() {
        return {
            vectorType: 'circle',
            radius: 0,
            centerX: 1,
            centerY: 0,
            centerZ: 0,
            startLat: 0,
            startLon: 0,
            endLat: 0,
            endLon: 0,
            distance: 0
        };
    }
    /**
     * Checks whether a circle vector describes a great-circle path.
     * @param vector A flight path circle vector.
     * @returns Whether the vector describes a great-circle path.
     */
    static isVectorGreatCircle(vector) {
        return vector.radius === Math.PI / 2;
    }
    /**
     * Sets the parameters of a GeoCircle from a flight path circle vector.
     * @param vector A flight path circle vector.
     * @param out The GeoCircle to set.
     * @returns The GeoCircle, after its parameters have been set.
     */
    static setGeoCircleFromVector(vector, out) {
        return out.set(Vec3Math.set(vector.centerX, vector.centerY, vector.centerZ, FlightPathUtils.vec3Cache[0]), vector.radius);
    }
    /**
     * Gets the initial true course bearing of a flight path vector.
     * @param vector A flight path vector.
     * @returns The initial true course bearing of the vector, or undefined if one could not be calculated.
     */
    static getVectorInitialCourse(vector) {
        return FlightPathUtils.setGeoCircleFromVector(vector, FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.startLat, vector.startLon), Math.PI);
    }
    /**
     * Gets the final true course bearing of a flight path vector.
     * @param vector A flight path vector.
     * @returns The final true course bearing of the vector, or undefined if one could not be calculated.
     */
    static getVectorFinalCourse(vector) {
        return FlightPathUtils.setGeoCircleFromVector(vector, FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.endLat, vector.endLon), Math.PI);
    }
    /**
     * Gets the final position of a calculated leg.
     * @param legCalc A set of leg calculations.
     * @param out The GeoPoint object to which to write the result.
     * @returns the final position of the leg, or undefined if one could not be obtained.
     */
    static getLegFinalPosition(legCalc, out) {
        if (legCalc.endLat !== undefined && legCalc.endLon !== undefined) {
            return out.set(legCalc.endLat, legCalc.endLon);
        }
        return undefined;
    }
    /**
     * Gets the final course of a calculated leg.
     * @param legCalc A set of leg calculations.
     * @returns the final course of the leg, or undefined if one could not be obtained.
     */
    static getLegFinalCourse(legCalc) {
        if (legCalc.flightPath.length > 0) {
            const vector = legCalc.flightPath[legCalc.flightPath.length - 1];
            return this.getVectorFinalCourse(vector);
        }
        return undefined;
    }
    /**
     * Gets the circle describing the path of a turn.
     * @param center The center of the turn.
     * @param radius The radius of the turn, in great-arc radians.
     * @param turnDirection The direction of the turn.
     * @param out A GeoCircle object to which to write the result.
     * @returns The circle describing the path of the turn.
     */
    static getTurnCircle(center, radius, turnDirection, out) {
        out.set(center, radius);
        if (turnDirection === 'right') {
            out.set(Vec3Math.multScalar(out.center, -1, FlightPathUtils.vec3Cache[0]), Math.PI - out.radius);
        }
        return out;
    }
    /**
     * Gets the direction of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @returns The direction of the turn described by the circle.
     */
    static getTurnDirectionFromCircle(circle) {
        return circle.radius > Math.PI / 2 ? 'right' : 'left';
    }
    /**
     * Gets the radius of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @returns The radius of the turn described by the circle, in great-arc radians.
     */
    static getTurnRadiusFromCircle(circle) {
        return Math.min(circle.radius, Math.PI - circle.radius);
    }
    /**
     * Gets the center of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @param out A GeoPoint or 3D vector object to which to write the result.
     * @returns The center of a turn described by the circle.
     */
    static getTurnCenterFromCircle(circle, out) {
        return (circle.radius > Math.PI / 2
            ? out instanceof Float64Array
                ? Vec3Math.multScalar(circle.center, -1, out)
                : out.setFromCartesian(-circle.center[0], -circle.center[1], -circle.center[2])
            : out instanceof Float64Array
                ? Vec3Math.copy(circle.center, out)
                : out.setFromCartesian(circle.center));
    }
    /**
     * Gets the signed distance along an arc from a defined start point to a query point. The query point must lie
     * somewhere on the arc's parent circle. A negative distance indicates that the query point lies somewhere before
     * the start of the arc but after the point on the arc's parent circle that is diametrically opposed to the midpoint
     * of the arc.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param end The end point of the arc.
     * @param pos The query point.
     * @returns The signed distance along the arc from the start point to the query point.
     * @throws Error if `start`, `end`, or `pos` does not lie on `circle`.
     */
    static getAlongArcSignedDistance(circle, start, end, pos) {
        const endAngularDistance = circle.angleAlong(start, end, Math.PI);
        const posAngularDistance = circle.angleAlong(start, pos, Math.PI);
        return circle.arcLength((posAngularDistance - (endAngularDistance / 2) + Math.PI) % (2 * Math.PI) - Math.PI + endAngularDistance / 2);
    }
    /**
     * Gets the normalized distance along an arc from a defined start point to a query point. The query point must lie
     * somewhere on the arc's parent circle. The distance is normalized such that 1 equals the arc length from the start
     * point to the end point. A negative distance indicates that the query point lies somewhere before the start of the
     * arc but after the point on the arc's parent circle that is diametrically opposed to the midpoint of the arc.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param end The end point of the arc.
     * @param pos The query point.
     * @returns The normalized distance along the arc from the start point to the query point.
     * @throws Error if `start`, `end`, or `pos` does not lie on `circle`.
     */
    static getAlongArcNormalizedDistance(circle, start, end, pos) {
        const endAngularDistance = circle.angleAlong(start, end, Math.PI);
        const posAngularDistance = circle.angleAlong(start, pos, Math.PI);
        return ((posAngularDistance - (endAngularDistance / 2) + Math.PI) % (2 * Math.PI) - Math.PI) / endAngularDistance + 0.5;
    }
}
FlightPathUtils.vec3Cache = [new Float64Array(3)];
FlightPathUtils.geoPointCache = [new GeoPoint(0, 0)];
FlightPathUtils.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * Builds circle vectors.
 */
class CircleVectorBuilder {
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, ...args) {
        if (args[0] instanceof GeoCircle) {
            this.setFromCircle(vectors, index, ...args);
        }
        else {
            this.setFromPoints(vectors, index, ...args);
        }
        return 1;
    }
    /**
     * Sets the parameters for a circle vector in a flight path vector sequence. If a circle vector does not exist at the
     * specified index in the sequence, a new one will be created.
     * @param vectors A flight path vector sequence.
     * @param index The index in the sequence at which to set the circle vector.
     * @param direction The direction of the circle.
     * @param radius The radius of the circle, in meters.
     * @param center The center of the circle.
     * @param start The start point.
     * @param end The end point.
     * @returns The set circle vector.
     */
    setFromPoints(vectors, index, direction, radius, center, start, end) {
        const circle = FlightPathUtils.getTurnCircle(center, UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), direction, CircleVectorBuilder.geoCircleCache[0]);
        return this.setFromCircle(vectors, index, circle, start, end);
    }
    /**
     * Sets the parameters for a circle vector in a flight path vector sequence. If a circle vector does not exist at the
     * specified index in the sequence, a new one will be created.
     * @param vectors A flight path vector sequence.
     * @param index The index in the sequence at which to set the circle vector.
     * @param circle The circle which defines the vector path.
     * @param start The start point.
     * @param end The end point.
     * @returns The set circle vector.
     */
    setFromCircle(vectors, index, circle, start, end) {
        var _a;
        const vector = (((_a = vectors[index]) === null || _a === void 0 ? void 0 : _a.vectorType) === 'circle' ? vectors[index] : (vectors[index] = FlightPathUtils.createEmptyCircleVector()));
        vector.radius = circle.radius;
        vector.centerX = circle.center[0];
        vector.centerY = circle.center[1];
        vector.centerZ = circle.center[2];
        vector.distance = UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.METER);
        start instanceof Float64Array && (start = CircleVectorBuilder.geoPointCache[0].setFromCartesian(start));
        end instanceof Float64Array && (end = CircleVectorBuilder.geoPointCache[1].setFromCartesian(end));
        vector.startLat = start.lat;
        vector.startLon = start.lon;
        vector.endLat = end.lat;
        vector.endLon = end.lon;
        return vector;
    }
}
CircleVectorBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
CircleVectorBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
/**
 * Builds great-circle paths between defined start and end points.
 */
class GreatCircleBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, pathArg, endArg) {
        if (pathArg instanceof GeoCircle) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.buildFromPath(vectors, index, start, pathArg, endArg);
        }
        else {
            return this.buildFromEndpoints(vectors, index, start, pathArg, endArg);
        }
    }
    /**
     * Builds a sequence of vectors representing the shortest great-circle path between two points.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param end The end point.
     * @param initialCourse The initial true course bearing. Used to define a unique great-circle path when `start` and
     * `end` are antipodal.
     * @returns The number of vectors added to the sequence.
     * @throws Error if `start` and `end` are antipodal and `initialCourse` is undefined.
     */
    buildFromEndpoints(vectors, index, start, end, initialCourse) {
        const startPoint = start instanceof Float64Array
            ? GreatCircleBuilder.geoPointCache[0].setFromCartesian(start)
            : GreatCircleBuilder.geoPointCache[0].set(start);
        const endPoint = end instanceof Float64Array
            ? GreatCircleBuilder.geoPointCache[1].setFromCartesian(end)
            : GreatCircleBuilder.geoPointCache[1].set(end);
        const distance = startPoint.distance(endPoint);
        const path = GreatCircleBuilder.geoCircleCache[0];
        if (distance >= Math.PI - GeoPoint.EQUALITY_TOLERANCE) {
            if (initialCourse === undefined) {
                throw new Error('GreatCircleVectorBuilder: cannot build a unique direct track from antipodal endpoints.');
            }
            else {
                path.setAsGreatCircle(start, initialCourse);
            }
        }
        else {
            path.setAsGreatCircle(start, end);
        }
        return this.buildFromPath(vectors, index, start, path, end);
    }
    /**
     * Builds a sequence of vectors representing a great-circle path from a start point to either a defined endpoint
     * or a distance offset.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param path The great-circle path.
     * @param endArg The end point or distance offset.
     * @returns The number of vectors added to the sequence.
     * @throws Error if `path` is not a great circle.
     */
    buildFromPath(vectors, index, start, path, endArg) {
        if (!path.isGreatCircle()) {
            throw new Error(`GreatCircleVectorBuilder: expected GeoCircle radius of pi / 2; instead was ${path.radius}`);
        }
        const end = typeof endArg === 'number'
            ? path.offsetDistanceAlong(start, UnitType.METER.convertTo(endArg, UnitType.GA_RADIAN), GreatCircleBuilder.vec3Cache[0], Math.PI)
            : endArg;
        return this.circleVectorBuilder.build(vectors, index, path, start, end);
    }
}
GreatCircleBuilder.vec3Cache = [new Float64Array(3)];
GreatCircleBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
GreatCircleBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
/**
 * Builds constant-radius turns toward specified course bearings.
 */
class TurnToCourseBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /**
     * Adds a turn from a defined start point and initial course to a specific final course to a flight path vector
     * sequence.
     * @param vectors The flight path vector sequence to which to add the turn.
     * @param index The index in the sequence at which to add the turn.
     * @param start The start point of the turn.
     * @param radius The radius of the turn, in meters.
     * @param direction The direction of the turn.
     * @param fromCourse The initial true course at the start of the turn.
     * @param toCourse The final true course at the end of the turn.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, radius, direction, fromCourse, toCourse) {
        if (start instanceof Float64Array) {
            start = TurnToCourseBuilder.geoPointCache[0].setFromCartesian(start);
        }
        const radiusRad = UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
        const turnCenterPoint = TurnToCourseBuilder.geoPointCache[1].set(start).offset(fromCourse + (direction === 'left' ? -90 : 90), radiusRad);
        const turnStartBearing = turnCenterPoint.bearingTo(start);
        const turnEndBearing = NavMath.normalizeHeading(turnStartBearing + (toCourse - fromCourse));
        const turnEndPoint = turnCenterPoint.offset(turnEndBearing, radiusRad, TurnToCourseBuilder.geoPointCache[2]);
        return this.circleVectorBuilder.build(vectors, index, direction, radius, turnCenterPoint, start, turnEndPoint);
    }
}
TurnToCourseBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
/**
 * Builds great-circle paths to intercept other geo circles.
 */
class CircleInterceptBuilder {
    constructor() {
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, pathArg, circle) {
        if (circle.includes(start)) {
            return 0;
        }
        let startPath;
        if (pathArg instanceof GeoCircle) {
            if (!pathArg.includes(start)) {
                throw new Error('CircleInterceptBuilder: the starting point does not lie on the starting path.');
            }
            startPath = pathArg;
        }
        else {
            startPath = CircleInterceptBuilder.geoCircleCache[0].setAsGreatCircle(start, pathArg);
        }
        const intersections = CircleInterceptBuilder.intersectionCache;
        const numIntersections = startPath.intersection(circle, intersections);
        if (numIntersections === 0) {
            return 0;
        }
        const endVec = intersections[(numIntersections === 1 || circle.encircles(start)) ? 0 : 1];
        return startPath.isGreatCircle()
            ? this.greatCircleBuilder.build(vectors, index, start, startPath, endVec)
            : this.circleVectorBuilder.build(vectors, index, startPath, start, endVec);
    }
}
CircleInterceptBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
CircleInterceptBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds constant-radius turns to join great-circle paths.
 */
class TurnToJoinGreatCircleBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, startPathArg, endPath, radius) {
        if (!endPath.isGreatCircle()) {
            throw new Error(`TurnToJoinPathBuilder: expected GeoCircle radius of pi / 2; instead was ${endPath.radius}`);
        }
        let startPath;
        if (startPathArg instanceof GeoCircle) {
            if (!startPathArg.isGreatCircle()) {
                throw new Error(`TurnToJoinPathBuilder: expected GeoCircle radius of pi / 2; instead was ${startPathArg.radius}`);
            }
            else if (!startPathArg.includes(start)) {
                throw new Error('TurnToJoinPathBuilder: the starting point does not lie on the starting path.');
            }
            startPath = startPathArg;
        }
        else {
            startPath = TurnToJoinGreatCircleBuilder.geoCircleCache[0].setAsGreatCircle(start, startPathArg);
        }
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, TurnToJoinGreatCircleBuilder.vec3Cache[0]);
        }
        const turnDirection = endPath.encircles(start) ? 'left' : 'right';
        const radiusRad = turnDirection === 'left'
            ? UnitType.METER.convertTo(radius, UnitType.GA_RADIAN)
            : Math.PI - UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
        const turnStartToCenterNormal = Vec3Math.cross(start, startPath.center, TurnToJoinGreatCircleBuilder.vec3Cache[1]);
        const turnStartToCenterPath = TurnToJoinGreatCircleBuilder.geoCircleCache[1].set(turnStartToCenterNormal, Math.PI / 2);
        const turnCenter = turnStartToCenterPath.offsetDistanceAlong(start, radiusRad, TurnToJoinGreatCircleBuilder.vec3Cache[2]);
        const turnCircle = TurnToJoinGreatCircleBuilder.geoCircleCache[1].set(turnCenter, radiusRad);
        const end = turnCircle.closest(Vec3Math.multScalar(endPath.center, turnDirection === 'left' ? -1 : 1, TurnToJoinGreatCircleBuilder.vec3Cache[3]), TurnToJoinGreatCircleBuilder.vec3Cache[1]);
        return this.circleVectorBuilder.build(vectors, index, turnCircle, start, end);
    }
}
TurnToJoinGreatCircleBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
TurnToJoinGreatCircleBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
/**
 * Builds paths to connect two geo circles.
 */
class ConnectCirclesBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /**
     * Builds a sequence of vectors representing a path which consists of a single geo circle which connects two other
     * circles and optionally paths to link the connecting circle with a start point on the from circle and an end point
     * on the to circle.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param fromCircle The circle from which to add the connecting circle.
     * @param toCircle The circle to which to add the connecting circle.
     * @param radius The radius, in meters, of the circle to join the two circles. If not defined, defaults to pi / 2
     * times the radius of the Earth (and therefore the connecting circle will be a great circle).
     * @param from The starting point along `fromCircle`. If not defined, this will be assumed to be equal to the
     * point where the connecting circle meets `fromCircle`.
     * @param to The ending point along `toCircle`. If not defined, this will be assumed to be equal to the point where
     * the connecting circle meets `toCircle`.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, fromCircle, toCircle, radius, from, to) {
        if (radius === 0) {
            return 0;
        }
        const angle = Math.acos(Vec3Math.dot(fromCircle.center, toCircle.center));
        if ((angle <= GeoPoint.EQUALITY_TOLERANCE && fromCircle.radius === toCircle.radius)
            || (Math.PI - angle <= GeoPoint.EQUALITY_TOLERANCE && Math.PI - fromCircle.radius - toCircle.radius <= GeoPoint.EQUALITY_TOLERANCE)) {
            return 0;
        }
        if (from && !(from instanceof Float64Array)) {
            from = GeoPoint.sphericalToCartesian(from, ConnectCirclesBuilder.vec3Cache[0]);
        }
        if (to && !(to instanceof Float64Array)) {
            to = GeoPoint.sphericalToCartesian(to, ConnectCirclesBuilder.vec3Cache[1]);
        }
        const radiusRad = Math.min(Math.PI / 2, radius ? UnitType.METER.convertTo(radius, UnitType.GA_RADIAN) : Infinity);
        const joinCircle = this.findCircleToJoinCircles(fromCircle, toCircle, radiusRad, ConnectCirclesBuilder.geoCircleCache[0], from, to);
        if (!joinCircle) {
            return 0;
        }
        let vectorIndex = index;
        const joinStart = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(fromCircle, ConnectCirclesBuilder.vec3Cache[2]), ConnectCirclesBuilder.vec3Cache[2]);
        const joinEnd = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(toCircle, ConnectCirclesBuilder.vec3Cache[3]), ConnectCirclesBuilder.vec3Cache[3]);
        if (from && Math.acos(Vec3Math.dot(from, joinStart)) > GeoPoint.EQUALITY_TOLERANCE) {
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, fromCircle, from, joinStart);
        }
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, joinCircle, joinStart, joinEnd);
        if (to && Math.acos(Vec3Math.dot(to, joinEnd)) > GeoPoint.EQUALITY_TOLERANCE) {
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, toCircle, joinEnd, to);
        }
        return vectorIndex - index;
    }
    /**
     * Finds a GeoCircle which connects (is tangent to) two other circles.
     * @param fromCircle The circle at the beginning of the connecting circle.
     * @param toCircle The circle at the end of the connecting circle.
     * @param radius The desired radius of the connecting circle, in great-arc radians.
     * @param out A GeoCircle object to which to write the result.
     * @param from The starting point along `fromCircle`. If not defined, this will be assumed to be equal to the
     * point where the connecting circle meets `fromCircle`.
     * @param to The ending point along `toCircle`. If not defined, this will be assumed to be equal to the point where
     * the connecting circle meets `toCircle`.
     * @returns a GeoCircle which connects the two circles, or null if one could not be found.
     */
    findCircleToJoinCircles(fromCircle, toCircle, radius, out, from, to) {
        /*
         * Theory: the locus of all centers of circle of radius r tangent to circle with center C and radius R is
         * equivalent to the set of circles S(C) with center C and positive radius |r +/- R|. If we further restrict the
         * set of tangent circles to those where both the original and tangent circle run in the same direction at the
         * tangent point, the locus of centers can be further reduced to the single circle Sd(C) with center C and
         * positive radius |r - R|. Therefore, to find the centers of the circles of radius r connecting the circles C1 and
         * C2, we need only find the intersections of Sd(C1) and Sd(C2).
         */
        const solutions = [];
        const intersections = ConnectCirclesBuilder.intersectionCache;
        const leftTurnRadius = radius;
        let fromCircleOffsetRadius = Math.abs(leftTurnRadius - fromCircle.radius);
        let toCircleOffsetRadius = Math.abs(leftTurnRadius - toCircle.radius);
        let fromCircleOffset = ConnectCirclesBuilder.geoCircleCache[1].set(fromCircle.center, fromCircleOffsetRadius);
        let toCircleOffset = ConnectCirclesBuilder.geoCircleCache[2].set(toCircle.center, toCircleOffsetRadius);
        const numLeftTurnSolutions = fromCircleOffset.intersection(toCircleOffset, intersections);
        if (numLeftTurnSolutions === 1) {
            solutions.push(ConnectCirclesBuilder.geoCircleCache[1].set(intersections[0], leftTurnRadius));
        }
        else if (numLeftTurnSolutions === 2) {
            solutions.push(ConnectCirclesBuilder.geoCircleCache[1].set(intersections[0], leftTurnRadius));
            solutions.push(ConnectCirclesBuilder.geoCircleCache[2].set(intersections[1], leftTurnRadius));
        }
        if (radius !== Math.PI / 2) {
            const rightTurnRadius = Math.PI - radius;
            fromCircleOffsetRadius = Math.abs(rightTurnRadius - fromCircle.radius);
            toCircleOffsetRadius = Math.abs(rightTurnRadius - toCircle.radius);
            fromCircleOffset = ConnectCirclesBuilder.geoCircleCache[3].set(fromCircle.center, fromCircleOffsetRadius);
            toCircleOffset = ConnectCirclesBuilder.geoCircleCache[4].set(toCircle.center, toCircleOffsetRadius);
            const numRightTurnSolutions = fromCircleOffset.intersection(toCircleOffset, intersections);
            if (numRightTurnSolutions === 1) {
                solutions.push(ConnectCirclesBuilder.geoCircleCache[3].set(intersections[0], rightTurnRadius));
            }
            else if (numRightTurnSolutions === 2) {
                solutions.push(ConnectCirclesBuilder.geoCircleCache[3].set(intersections[0], rightTurnRadius));
                solutions.push(ConnectCirclesBuilder.geoCircleCache[4].set(intersections[1], rightTurnRadius));
            }
        }
        if (solutions.length === 0) {
            return null;
        }
        else if (solutions.length === 1) {
            return out.set(solutions[0].center, solutions[0].radius);
        }
        else {
            // choose the solution that results in the shortest path from fromVec to toVec
            let circle = solutions[0];
            let minDistance = this.calculateJoinCirclesPathDistance(fromCircle, toCircle, solutions[0], from, to);
            for (let i = 1; i < solutions.length; i++) {
                const distance = this.calculateJoinCirclesPathDistance(fromCircle, toCircle, solutions[i], from, to);
                if (distance < minDistance) {
                    circle = solutions[i];
                    minDistance = distance;
                }
            }
            return out.set(circle.center, circle.radius);
        }
    }
    /**
     * Calculates the total distance along the joining path between two circles.
     * @param fromCircle The circle at the beginning of the connecting circle.
     * @param toCircle The circle at the end of the connecting circle.
     * @param joinCircle The connecting circle.
     * @param from The starting point along `fromCircle`. If not defined, this will be assumed to be equal to the
     * point where the connecting circle meets `fromCircle`.
     * @param to The ending point along `toCircle`. If not defined, this will be assumed to be equal to the point where
     * the connecting circle meets `toCircle`.
     * @returns the total distance along the joining path, in great-arc radians.
     */
    calculateJoinCirclesPathDistance(fromCircle, toCircle, joinCircle, from, to) {
        let distance = 0;
        const joinStartVec = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(fromCircle, ConnectCirclesBuilder.vec3Cache[6]), ConnectCirclesBuilder.vec3Cache[6]);
        const joinEndVec = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(toCircle, ConnectCirclesBuilder.vec3Cache[7]), ConnectCirclesBuilder.vec3Cache[7]);
        if (from) {
            distance += fromCircle.distanceAlong(from, joinStartVec, Math.PI);
        }
        distance += joinCircle.distanceAlong(joinStartVec, joinEndVec, Math.PI);
        if (to) {
            distance += toCircle.distanceAlong(joinEndVec, to, Math.PI);
        }
        return distance;
    }
}
ConnectCirclesBuilder.vec3Cache = [
    new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3),
    new Float64Array(3), new Float64Array(3), new Float64Array(3)
];
ConnectCirclesBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0)
];
ConnectCirclesBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds paths connecting initial great-circle paths to final great-circle paths terminating at defined end points.
 */
class JoinGreatCircleToPointBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.joinCirclesBuilder = new ConnectCirclesBuilder();
        this.turnToJoinPathBuilder = new TurnToJoinGreatCircleBuilder();
    }
    /**
     * Builds a sequence of vectors representing a path from a defined start point and initial course which turns and
     * joins a great-circle path which terminates at a defined end point.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point in cartesian form.
     * @param startPath The great-circle path defining the initial course.
     * @param end The end point in cartesian form.
     * @param endPath The great-circle path defining the final course.
     * @param desiredTurnDirection The desired initial turn direction. If not defined, the most efficient turn direction
     * that satisfies the constraints will be chosen.
     * @param minTurnRadius The minimum turn radius, in meters. Defaults to 0.
     * @param intersection The point of intersection between the start and end paths closest to the start point. If
     * not defined, it will be calculated.
     * @returns the number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, end, endPath, desiredTurnDirection, minTurnRadius, intersection) {
        let vectorIndex = index;
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, JoinGreatCircleToPointBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, JoinGreatCircleToPointBuilder.vec3Cache[1]);
        }
        if (!intersection) {
            const intersections = JoinGreatCircleToPointBuilder.intersectionCache;
            const solutionCount = startPath.intersection(endPath, intersections);
            if (solutionCount === 0) {
                return 0;
            }
            // choose the intersection closest to the start point.
            intersection = Vec3Math.dot(intersections[0], start) > 0
                ? intersections[0]
                : intersections[1];
        }
        // Calculate the relative directions of the start point, intersection point, and end point.
        const startToIntersectionDot = Vec3Math.dot(Vec3Math.cross(startPath.center, intersection, JoinGreatCircleToPointBuilder.vec3Cache[2]), start);
        const startToIntersectionSign = startToIntersectionDot < -1e-8 ? 1
            : startToIntersectionDot > 1e-8 ? -1 : 0;
        const intersectionToEndDot = Vec3Math.dot(Vec3Math.cross(endPath.center, intersection, JoinGreatCircleToPointBuilder.vec3Cache[3]), end);
        const intersectionToEndSign = intersectionToEndDot < -1e-8 ? -1
            : intersectionToEndDot > 1e-8 ? 1 : 0;
        const isIntersectionForwardOfStart = startToIntersectionSign > 0;
        const isEndForwardOfIntersection = intersectionToEndSign > 0;
        minTurnRadius !== null && minTurnRadius !== void 0 ? minTurnRadius : (minTurnRadius = 0);
        // Calculate the minimum along-track distance taken up by the initial turn.
        const minTurnRadiusRad = UnitType.METER.convertTo(minTurnRadius, UnitType.GA_RADIAN);
        const pathDot = Vec3Math.dot(startPath.center, endPath.center);
        const theta = Math.acos(-pathDot);
        const tanHalfTheta = Math.tan(theta / 2);
        const minD = Math.asin(Math.tan(minTurnRadiusRad) / tanHalfTheta);
        const intersectionStartDistance = startToIntersectionSign === 0 ? 0 : Math.acos(Vec3Math.dot(intersection, start));
        const intersectionEndDistance = intersectionToEndSign === 0 ? 0 : Math.acos(Vec3Math.dot(intersection, end));
        let d = Math.max(minD, intersectionStartDistance);
        const isStartPastRequiredTurnStart = startToIntersectionSign * intersectionStartDistance < d;
        const isEndBeforeRequiredTurnEnd = intersectionToEndSign * intersectionEndDistance < d;
        // The turn direction required to join the final course with a single constant-radius turn.
        const singleTurnDirection = startPath.encircles(end) === ((isStartPastRequiredTurnStart || isEndBeforeRequiredTurnEnd) && isEndForwardOfIntersection)
            ? 'right'
            : 'left';
        let needSingleTurn = true;
        if (!isEndForwardOfIntersection && isIntersectionForwardOfStart && (desiredTurnDirection === undefined || desiredTurnDirection !== singleTurnDirection)) {
            // Attempt a side step.
            const fromCircleTurnOffsetPath = JoinGreatCircleToPointBuilder.geoCircleCache[0].setAsGreatCircle(start, startPath.center);
            const fromCircleRadius = singleTurnDirection === 'left' ? minTurnRadiusRad : Math.PI - minTurnRadiusRad;
            const fromCircle = JoinGreatCircleToPointBuilder.geoCircleCache[0].set(fromCircleTurnOffsetPath.offsetDistanceAlong(start, fromCircleRadius, JoinGreatCircleToPointBuilder.vec3Cache[2]), fromCircleRadius);
            const toCircleTurnOffsetPath = JoinGreatCircleToPointBuilder.geoCircleCache[1].setAsGreatCircle(end, endPath.center);
            const toCircleRadius = singleTurnDirection === 'left' ? Math.PI - minTurnRadiusRad : minTurnRadiusRad;
            const toCircle = JoinGreatCircleToPointBuilder.geoCircleCache[1].set(toCircleTurnOffsetPath.offsetDistanceAlong(end, toCircleRadius, JoinGreatCircleToPointBuilder.vec3Cache[3]), toCircleRadius);
            const numVectorsAdded = this.joinCirclesBuilder.build(vectors, vectorIndex, fromCircle, toCircle, undefined, start, end);
            if (numVectorsAdded > 0) {
                vectorIndex += numVectorsAdded;
                needSingleTurn = false;
            }
        }
        else if (isEndForwardOfIntersection
            && (isStartPastRequiredTurnStart || isEndBeforeRequiredTurnEnd)
            && (desiredTurnDirection === undefined || desiredTurnDirection !== singleTurnDirection)) {
            // In this case we will allow the calculated path to overshoot the final course path in an attempt to honor the
            // initial desired turn direction, if defined, or otherwise to turn towards the terminator instead of away from
            // it. After the overshoot, the path will turn back to intercept the final course path.
            const toCircleTurnOffsetPath = JoinGreatCircleToPointBuilder.geoCircleCache[0].setAsGreatCircle(end, endPath.center);
            const toCircleRadius = singleTurnDirection === 'left' ? minTurnRadiusRad : Math.PI - minTurnRadiusRad;
            const toCircle = JoinGreatCircleToPointBuilder.geoCircleCache[0].set(toCircleTurnOffsetPath.offsetDistanceAlong(end, toCircleRadius, JoinGreatCircleToPointBuilder.vec3Cache[3]), toCircleRadius);
            let needFindFromCircle = true;
            if (!isEndBeforeRequiredTurnEnd) {
                // The terminator is far enough from the intersection point that an immediate turn from the start point may be
                // sufficient to put the airplane on a course to intercept the final course before the terminator fix.
                const fromCircleTurnOffsetPath = JoinGreatCircleToPointBuilder.geoCircleCache[1].setAsGreatCircle(start, startPath.center);
                const fromCircleRadius = singleTurnDirection === 'left' ? Math.PI - minTurnRadiusRad : minTurnRadiusRad;
                const fromCircle = JoinGreatCircleToPointBuilder.geoCircleCache[1].set(fromCircleTurnOffsetPath.offsetDistanceAlong(start, fromCircleRadius, JoinGreatCircleToPointBuilder.vec3Cache[2]), fromCircleRadius);
                const turnCenterSeparation = Math.acos(Vec3Math.dot(FlightPathUtils.getTurnCenterFromCircle(fromCircle, JoinGreatCircleToPointBuilder.vec3Cache[2]), FlightPathUtils.getTurnCenterFromCircle(toCircle, JoinGreatCircleToPointBuilder.vec3Cache[3])));
                const turnCenterSeparationDiff = turnCenterSeparation - 2 * minTurnRadiusRad;
                if (Math.abs(turnCenterSeparationDiff) <= GeoPoint.EQUALITY_TOLERANCE) {
                    // The turn circles are tangent.
                    needFindFromCircle = false;
                    const tangentVec = fromCircle.closest(toCircle.closest(fromCircle.center, JoinGreatCircleToPointBuilder.vec3Cache[2]), JoinGreatCircleToPointBuilder.vec3Cache[2]);
                    vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, fromCircle, start, tangentVec);
                    vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, toCircle, tangentVec, end);
                    needSingleTurn = false;
                }
                else if (turnCenterSeparationDiff > GeoPoint.EQUALITY_TOLERANCE) {
                    // The turn circles do not intersect.
                    needFindFromCircle = false;
                    const numVectorsAdded = this.joinCirclesBuilder.build(vectors, vectorIndex, fromCircle, toCircle, undefined, start, end);
                    if (numVectorsAdded > 0) {
                        vectorIndex += numVectorsAdded;
                        needSingleTurn = false;
                    }
                }
            }
            if (needFindFromCircle && Math.abs(startPath.distance(toCircle.center)) >= minTurnRadiusRad + GeoPoint.EQUALITY_TOLERANCE) {
                // We need to place the initial turn from the start path such that the turn circle is tangent to the final turn
                // toward the final course path.
                const fromCircleTurnDirection = singleTurnDirection === 'left' ? 'right' : 'left';
                const offset = fromCircleTurnDirection === 'left' ? -minTurnRadiusRad : minTurnRadiusRad;
                const startPathOffset = JoinGreatCircleToPointBuilder.geoCircleCache[1].set(startPath.center, startPath.radius + offset);
                const toCircleOffset = JoinGreatCircleToPointBuilder.geoCircleCache[2].set(toCircle.center, toCircle.radius + offset);
                const intersections = JoinGreatCircleToPointBuilder.intersectionCache;
                const numIntersections = startPathOffset.intersection(toCircleOffset, intersections);
                if (numIntersections === 2) {
                    // Choose the intersection that is farther along the start path. The other one will either lead to a turn
                    // that begins before the start point or one that produces a sub-optimal path.
                    const fromCircleTurnCenter = intersections[fromCircleTurnDirection === 'left' ? 1 : 0];
                    const fromCircle = FlightPathUtils.getTurnCircle(fromCircleTurnCenter, minTurnRadiusRad, fromCircleTurnDirection, JoinGreatCircleToPointBuilder.geoCircleCache[1]);
                    const fromTurnStartVec = startPath.closest(fromCircleTurnCenter, JoinGreatCircleToPointBuilder.vec3Cache[2]);
                    const tangentVec = fromCircle.closest(toCircle.closest(fromCircle.center, JoinGreatCircleToPointBuilder.vec3Cache[3]), JoinGreatCircleToPointBuilder.vec3Cache[3]);
                    vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, fromTurnStartVec);
                    vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, fromCircle, fromTurnStartVec, tangentVec);
                    vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, toCircle, tangentVec, end);
                    needSingleTurn = false;
                }
            }
        }
        if (needSingleTurn) {
            let intersectionToTurnEndSign = isStartPastRequiredTurnStart ? -1 : 1;
            let intersectionToTurnStartSign = -intersectionToTurnEndSign;
            const isTurnInvalid = intersectionToTurnEndSign * d > intersectionEndDistance * intersectionToEndSign;
            const turnStartVec = JoinGreatCircleToPointBuilder.vec3Cache[2];
            const turnStartPoint = JoinGreatCircleToPointBuilder.geoPointCache[0];
            const turnEndPoint = JoinGreatCircleToPointBuilder.geoPointCache[1];
            if (isTurnInvalid) {
                // if we can't make the turn in time by immediately making a turn from startPoint, we will instead have the
                // turn end at the terminator fix, with a radius such that the turn begins at some point along the plane's
                // current track (startPoint projected forward with a bearing of currentCourse). Because of the way we have
                // chosen the direction of the turn and where to start it, this will guarantee a valid solution, albeit not
                // necessarily an optimal one.
                d = Math.max(minD, intersectionEndDistance);
                intersectionToTurnStartSign = (intersectionToEndSign * intersectionEndDistance < d) ? 1
                    : startToIntersectionSign <= 0 ? 1 : -1;
                intersectionToTurnEndSign = -intersectionToTurnStartSign;
            }
            turnStartPoint.setFromCartesian(startPath.offsetDistanceAlong(intersection, d * intersectionToTurnStartSign, turnStartVec, Math.PI));
            endPath.offsetDistanceAlong(intersection, d * intersectionToTurnEndSign, turnEndPoint, Math.PI);
            const startPoint = JoinGreatCircleToPointBuilder.geoPointCache[2].setFromCartesian(start);
            if (!startPoint.equals(turnStartPoint)) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, turnStartPoint);
            }
            const turnRadius = d === minD ? minTurnRadius : UnitType.GA_RADIAN.convertTo(Math.atan(tanHalfTheta * Math.sin(d)), UnitType.METER);
            vectorIndex += this.turnToJoinPathBuilder.build(vectors, vectorIndex, turnStartVec, startPath, endPath, turnRadius);
            const endPoint = JoinGreatCircleToPointBuilder.geoPointCache[2].setFromCartesian(end);
            if (!endPoint.equals(turnEndPoint)) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, endPoint);
            }
        }
        return vectorIndex - index;
    }
}
JoinGreatCircleToPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
JoinGreatCircleToPointBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
JoinGreatCircleToPointBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
JoinGreatCircleToPointBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds procedure turns.
 */
class ProcedureTurnBuilder {
    constructor() {
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /**
     * Builds a sequence of vectors representing a procedure turn from a defined starting point and initial course to a
     * defined end point and final course. A procedure turn begins with a variable-length leg from the start point along
     * the initial course followed by an initial turn to intercept the outbound leg of the procedure turn, then a
     * variable-length outbound leg, a 180-degree turn, a variable-length inbound leg, and finally a turn to intercept
     * the final course at the end point. If a full set of vectors cannot be computed given the restraints imposed by the
     * path geometry and the desired turn radius, parts of the turn beginning with the inbound leg of the procedure turn
     * may be altered or omitted entirely.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point in cartesian form.
     * @param startPath The great-circle path defining the initial course.
     * @param end The end point in cartesian form.
     * @param endPath The great-circle path defining the final course.
     * @param outboundCourse The true course, in degrees, of the outbound leg of the turn.
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @param desiredTurnDirection The desired turn direction.
     * @param initialCourse The initial course. If not defined, it will be calculated from `startPath` and `start`.
     * @param finalCourse The final course. If not defined, it will be calculated from `endPath` and `end`.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, end, endPath, outboundCourse, desiredTurnRadius, desiredTurnDirection, initialCourse, finalCourse) {
        let vectorIndex = index;
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, ProcedureTurnBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, ProcedureTurnBuilder.vec3Cache[1]);
        }
        /*
         * We need to calculate two parameters: (1) the distance to stay on the initial outbound segment, and (2) the
         * distance to stay on the outbound segment of the turn. We ideally would like to choose these parameters such
         * that the procedure turn ends at a location where it can immediately make another turn to intercept the next
         * leg. However, this may not be possible since we are constrained by the fact that the two distance parameters
         * cannot be negative. To simplify the math, we will do an approximated calculation based on a pseudo-Euclidean
         * geometry instead of spherical geometry. The error is proportional to the angle between the outbound path and the
         * the path to intercept; if they are exactly antiparallel the error is zero.
         */
        initialCourse !== null && initialCourse !== void 0 ? initialCourse : (initialCourse = startPath.bearingAt(start, Math.PI));
        finalCourse !== null && finalCourse !== void 0 ? finalCourse : (finalCourse = endPath.bearingAt(end, Math.PI));
        const startPoint = ProcedureTurnBuilder.geoPointCache[0].setFromCartesian(start);
        const initialTurnDirection = NavMath.getTurnDirection(initialCourse, outboundCourse);
        const isInitialTurnTowardEndPath = startPath.encircles(end) === (initialTurnDirection === 'left');
        const deltaOutbound = Math.abs(NavMath.diffAngle(initialCourse, outboundCourse)) * Avionics.Utils.DEG2RAD;
        const thetaOutbound = (Math.PI - deltaOutbound) / 2;
        const desiredTurnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
        // If there is a desired turn direction, honor it. Otherwise choose the direction that results in the shortest path
        // to intercept the next leg.
        const turnDirection = desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : (((initialTurnDirection === 'left') === deltaOutbound < Math.PI) ? 'right' : 'left');
        let desiredAlongTurnOutboundPathDistance = Math.abs(deltaOutbound - Math.PI / 2) > 1e-10
            ? Math.asin(Math.tan(2 * desiredTurnRadiusRad) / Math.tan(deltaOutbound)) * (turnDirection === initialTurnDirection ? -1 : 1)
            : 0;
        const endPointToStartPathXTrackDistance = Math.abs(startPath.distance(end));
        desiredAlongTurnOutboundPathDistance += Math.asin(Math.sin(endPointToStartPathXTrackDistance) / Math.sin(deltaOutbound))
            * (isInitialTurnTowardEndPath ? 1 : -1);
        const alongTurnOutboundPathDistance = Math.max(0, desiredAlongTurnOutboundPathDistance);
        const startToEndToEndPathAngleDiff = Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(start, end, ProcedureTurnBuilder.vec3Cache[2]), startPath.center));
        let desiredAlongStartPathDistance = Math.abs(startToEndToEndPathAngleDiff - Math.PI / 2) > 1e-8
            ? Math.asin(Math.tan(endPointToStartPathXTrackDistance) / Math.tan(startToEndToEndPathAngleDiff))
            : 0;
        desiredAlongStartPathDistance -= desiredAlongTurnOutboundPathDistance === 0 ? 0 : Math.atan(Math.cos(deltaOutbound) * Math.tan(desiredAlongTurnOutboundPathDistance));
        desiredAlongStartPathDistance += Math.asin(Math.sin(deltaOutbound) * Math.sin(2 * desiredTurnRadiusRad)) * (turnDirection === initialTurnDirection ? 1 : -1);
        const alongStartPathDistance = Math.max(0, desiredAlongStartPathDistance);
        const initialTurnStartPoint = alongStartPathDistance > 0
            ? startPath.offsetDistanceAlong(start, alongStartPathDistance, ProcedureTurnBuilder.geoPointCache[1])
            : startPoint;
        const initialTurnCenterPoint = initialTurnStartPoint.offset(initialCourse + (initialTurnDirection === 'left' ? -90 : 90), desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[2]);
        const initialTurnHalfAngularWidth = Math.acos(Math.sin(thetaOutbound) * Math.cos(desiredTurnRadiusRad)) * Avionics.Utils.RAD2DEG;
        const initialTurnStartBearing = initialTurnCenterPoint.bearingTo(initialTurnStartPoint);
        const initialTurnEndBearing = NavMath.normalizeHeading(initialTurnStartBearing + initialTurnHalfAngularWidth * 2 * (initialTurnDirection === 'left' ? -1 : 1));
        const initialTurnEndPoint = initialTurnCenterPoint.offset(initialTurnEndBearing, desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[3]);
        const turnStartPoint = alongTurnOutboundPathDistance > 0
            ? initialTurnEndPoint.offset(outboundCourse, alongTurnOutboundPathDistance, ProcedureTurnBuilder.geoPointCache[4])
            : initialTurnEndPoint;
        const turnCenterPoint = turnStartPoint.offset(outboundCourse + (turnDirection === 'left' ? -90 : 90), desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[5]);
        const turnStartBearing = turnCenterPoint.bearingTo(turnStartPoint);
        let turnEndBearing = NavMath.normalizeHeading(turnStartBearing + 180);
        const turnEndPoint = turnCenterPoint.offset(turnEndBearing, desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[6]);
        const turnEndVec = turnEndPoint.toCartesian(ProcedureTurnBuilder.vec3Cache[2]);
        let finalTurnDirection;
        let finalTurnRadius;
        let finalTurnStartPoint;
        let finalTurnCenterPoint;
        let finalTurnEndPoint;
        let endPoint;
        if (endPath.encircles(turnEndVec) === (initialTurnDirection === 'left')) {
            // the end of the turn lies beyond the path to intercept due to approximation error, so we need to end the turn early.
            const turnCircle = ProcedureTurnBuilder.geoCircleCache[0].set(turnCenterPoint, desiredTurnRadiusRad);
            const intersections = ProcedureTurnBuilder.intersectionCache;
            const numIntersections = turnCircle.intersection(endPath, intersections);
            if (numIntersections === 0) {
                // the path to intersect is completely outside of the turn, which can only happen if there is a major deviation
                // from the pseudo-Euclidean approximation. There is no easy way to recover from this state, so we just bail
                // out with a track directly to the endpoint.
                endPoint = ProcedureTurnBuilder.geoPointCache[7].setFromCartesian(end);
            }
            else {
                if (numIntersections === 2) {
                    // choose the intersection point which gives the smallest angle between the end of the turn and the path to intercept
                    const headingAdjustment = turnDirection === 'left' ? -90 : 90;
                    const angleDiff_0 = Math.abs(NavMath.diffAngle(Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(turnCenterPoint, intersections[0], ProcedureTurnBuilder.vec3Cache[3]), endPath.center)) * Avionics.Utils.RAD2DEG + headingAdjustment, 0));
                    const angleDiff_1 = Math.abs(NavMath.diffAngle(Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(turnCenterPoint, intersections[1], ProcedureTurnBuilder.vec3Cache[3]), endPath.center)) * Avionics.Utils.RAD2DEG + headingAdjustment, 0));
                    turnEndPoint.setFromCartesian(intersections[angleDiff_0 < angleDiff_1 ? 0 : 1]);
                }
                else {
                    turnEndPoint.setFromCartesian(intersections[0]);
                }
                turnEndBearing = turnCenterPoint.bearingTo(turnEndPoint);
            }
        }
        else {
            const turnFinalCourse = NavMath.normalizeHeading(outboundCourse + 180);
            const turnInboundPath = ProcedureTurnBuilder.geoCircleCache[0].setAsGreatCircle(turnEndPoint, turnFinalCourse);
            const intersections = ProcedureTurnBuilder.intersectionCache;
            const numIntersections = turnInboundPath.intersection(endPath, intersections);
            // Only move forward if the end of the turn does not lie on the path to intercept.
            if (numIntersections !== 0 && !endPath.includes(turnEndVec)) {
                const intersection = intersections[(numIntersections === 1 || endPath.encircles(turnEndVec)) ? 0 : 1];
                // Only move forward if the intersection lies before the endpoint, otherwise we will just end the leg at the
                // end of the procedure turn.
                if (Vec3Math.dot(GeoCircle.getGreatCircleNormal(intersection, end, ProcedureTurnBuilder.vec3Cache[3]), endPath.center) > 0) {
                    // Because we used an approximation to place the procedure turn, the inbound segment of the turn may not
                    // allow for a turn of the desired radius to perfectly intercept the final path. Therefore, we need to
                    // explicitly calculate the maximum allowed turn radius for this final turn and adjust the turn radius as
                    // needed. Note that if the initial and final paths are antiparallel, these calculations are not strictly
                    // necessary, but we will carry them out in all cases to account for floating point errors that may have
                    // accrued during previous calculations.
                    const deltaInbound = Math.acos(Vec3Math.dot(endPath.center, turnInboundPath.center));
                    const thetaInbound = (Math.PI - deltaInbound) / 2;
                    const tanThetaInbound = Math.tan(thetaInbound);
                    const desiredFinalTurnAlongTrackDistance = Math.asin(Math.tan(desiredTurnRadiusRad) / tanThetaInbound);
                    const finalTurnAlongTrackDistance = Math.min(desiredFinalTurnAlongTrackDistance, Math.acos(Vec3Math.dot(intersection, turnEndVec)), Math.acos(Vec3Math.dot(intersection, end)));
                    const finalTurnRadiusRad = finalTurnAlongTrackDistance === desiredFinalTurnAlongTrackDistance
                        ? desiredTurnRadiusRad
                        : Math.atan(Math.sin(finalTurnAlongTrackDistance) * tanThetaInbound);
                    finalTurnDirection = NavMath.getTurnDirection(turnFinalCourse, finalCourse);
                    finalTurnRadius = UnitType.GA_RADIAN.convertTo(finalTurnRadiusRad, UnitType.METER);
                    finalTurnStartPoint = turnInboundPath.offsetDistanceAlong(intersection, -finalTurnAlongTrackDistance, ProcedureTurnBuilder.geoPointCache[7], Math.PI);
                    finalTurnCenterPoint = finalTurnStartPoint.offset(turnFinalCourse + (finalTurnDirection === 'left' ? -90 : 90), finalTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[8]);
                    finalTurnEndPoint = endPath.offsetDistanceAlong(intersection, finalTurnAlongTrackDistance, ProcedureTurnBuilder.geoPointCache[9], Math.PI);
                }
            }
        }
        // Set vectors.
        if (initialTurnStartPoint !== startPoint) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, initialTurnStartPoint);
        }
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, initialTurnDirection, desiredTurnRadius, initialTurnCenterPoint, initialTurnStartPoint, initialTurnEndPoint);
        if (turnStartPoint !== initialTurnEndPoint) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, initialTurnEndPoint, turnStartPoint);
        }
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, desiredTurnRadius, turnCenterPoint, turnStartPoint, turnEndPoint);
        if (finalTurnCenterPoint) {
            if (!finalTurnStartPoint.equals(turnEndPoint)) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, finalTurnStartPoint);
            }
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, finalTurnDirection, finalTurnRadius, finalTurnCenterPoint, finalTurnStartPoint, finalTurnEndPoint);
        }
        else {
            if (endPoint) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, endPoint);
            }
        }
        return vectorIndex - index;
    }
}
ProcedureTurnBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
ProcedureTurnBuilder.geoPointCache = [
    new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0),
    new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)
];
ProcedureTurnBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
ProcedureTurnBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];

/**
 * Abstract implementation of FlightPathLegCalculator.
 */
class AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     * @param skipWhenActive Whether this calculator will skip calculations for active legs when the leg has already
     * been calculated. False by default.
     */
    constructor(facilityCache, skipWhenActive = false) {
        this.facilityCache = facilityCache;
        this.skipWhenActive = skipWhenActive;
    }
    /**
     * Gets a geographical position from an ICAO string.
     * @param icao An ICAO string.
     * @param out A GeoPoint object to which to write the result.
     * @returns The geographical position corresponding to the ICAO string, or undefined if one could not be obtained.
     */
    getPositionFromIcao(icao, out) {
        const facility = this.facilityCache.get(icao);
        return facility ? out.set(facility) : undefined;
    }
    /**
     * Gets the geographic position for a flight plan leg terminator.
     * @param leg A flight plan leg.
     * @param icao The ICAO string of the leg's terminator fix.
     * @param out A GeoPoint object to which to write the result.
     * @returns The position of the leg terminator, or undefined if it could not be determined.
     */
    getTerminatorPosition(leg, icao, out) {
        if (leg.lat !== undefined && leg.lon !== undefined) {
            return out.set(leg.lat, leg.lon);
        }
        else {
            const facility = this.facilityCache.get(icao);
            return facility ? out.set(facility.lat, facility.lon) : undefined;
        }
    }
    /**
     * Gets the true course for a flight plan leg. If the leg defines an origin or fix VOR facility, then the magnetic
     * variation defined at the VOR is used to adjust magnetic course, otherwise the computed magnetic variation for the
     * specified point is used.
     * @param leg A flight plan leg.
     * @param point The location from which to get magnetic variation, if an origin VOR is not found.
     * @returns the true course for the flight plan leg.
     */
    getLegTrueCourse(leg, point) {
        if (leg.trueDegrees) {
            return leg.course;
        }
        const facIcao = (leg.originIcao && ICAO.isFacility(leg.originIcao) && ICAO.getFacilityType(leg.originIcao) === FacilityType.VOR) ? leg.originIcao
            : (leg.fixIcao && ICAO.isFacility(leg.fixIcao) && ICAO.getFacilityType(leg.fixIcao) === FacilityType.VOR) ? leg.fixIcao
                : undefined;
        const facility = facIcao ? this.facilityCache.get(facIcao) : undefined;
        const magVar = facility
            ? -facility.magneticVariation
            : Facilities.getMagVar(point.lat, point.lon);
        return NavMath.normalizeHeading(leg.course + magVar);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculate(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c;
        const calcs = (_a = legs[calculateIndex].calculated) !== null && _a !== void 0 ? _a : {
            startLat: undefined,
            startLon: undefined,
            endLat: undefined,
            endLon: undefined,
            ingressTurn: FlightPathUtils.createEmptyCircleVector(),
            egressTurn: FlightPathUtils.createEmptyCircleVector(),
            distance: 0,
            distanceWithTurns: 0,
            initialDtk: undefined,
            cumulativeDistance: 0,
            cumulativeDistanceWithTurns: 0,
            flightPath: []
        };
        const vectors = calcs.flightPath;
        if (this.skipWhenActive && activeLegIndex === calculateIndex && vectors.length > 0) {
            state.currentPosition = FlightPathUtils.getLegFinalPosition(calcs, (_b = state.currentPosition) !== null && _b !== void 0 ? _b : new GeoPoint(0, 0));
            state.currentCourse = (_c = FlightPathUtils.getLegFinalCourse(calcs)) !== null && _c !== void 0 ? _c : state.currentCourse;
            return calcs;
        }
        try {
            const vectorCount = this.calculateVectors(legs, calculateIndex, activeLegIndex, state, vectors);
            vectors.length = vectorCount;
        }
        catch (e) {
            console.error(e);
            vectors.length = 0;
        }
        return calcs;
    }
}
/**
 * Calculates flight path vectors for discontinuity legs.
 */
class DiscontinuityLegCalculator extends AbstractFlightPathLegCalculator {
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    vectors) {
        state.currentCourse = undefined;
        state.currentPosition = undefined;
        return 0;
    }
}
/**
 * Calculates flight path vectors for track to fix legs.
 */
class TrackToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.vectorBuilder = new GreatCircleBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state, vectors) {
        var _a, _b;
        const prevLeg = (_a = legs[calculateIndex - 1]) === null || _a === void 0 ? void 0 : _a.leg;
        const leg = legs[calculateIndex].leg;
        let vectorIndex = 0;
        const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[0]);
        if (!terminatorPos) {
            return vectorIndex;
        }
        (_b = state.currentPosition) !== null && _b !== void 0 ? _b : (state.currentPosition = terminatorPos.copy());
        const distance = state.currentPosition.distance(terminatorPos);
        if ((!prevLeg || (prevLeg.type !== LegType.FM && prevLeg.type !== LegType.VM)) && distance > GeoPoint.EQUALITY_TOLERANCE) {
            vectorIndex += this.vectorBuilder.build(vectors, vectorIndex, state.currentPosition, terminatorPos, state.currentCourse);
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(vectors[vectorIndex - 1]);
        }
        state.currentPosition.set(terminatorPos);
        return vectorIndex;
    }
}
/**
 * Calculates flight path vectors for direct to fix legs.
 */
class DirectToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleVectorBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state, vectors) {
        var _a, _b;
        const leg = legs[calculateIndex].leg;
        let vectorIndex = 0;
        const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[1]);
        if (!terminatorPos) {
            return vectorIndex;
        }
        (_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = terminatorPos.copy());
        const startPoint = this.geoPointCache[0].set(state.currentPosition);
        const initialCourse = leg.course !== 0
            ? leg.course % 360
            : (_b = state.currentCourse) !== null && _b !== void 0 ? _b : state.planeHeading;
        const distanceToTerminator = state.currentPosition.distance(terminatorPos);
        if (distanceToTerminator < GeoPoint.EQUALITY_TOLERANCE) {
            state.currentPosition.set(terminatorPos);
            return 0;
        }
        else if (Math.abs(distanceToTerminator - Math.PI) < GeoPoint.EQUALITY_TOLERANCE) {
            // terminator is antipodal to current position
            const path = this.geoCircleCache[0].setAsGreatCircle(state.currentPosition, initialCourse);
            vectorIndex += this.greatCircleVectorBuilder.build(vectors, vectorIndex, state.currentPosition, path, terminatorPos);
            state.currentCourse = path.bearingAt(terminatorPos, Math.PI);
            state.currentPosition.set(terminatorPos);
            return vectorIndex;
        }
        const startVec = startPoint.toCartesian(this.vec3Cache[0]);
        const terminatorVec = terminatorPos.toCartesian(this.vec3Cache[1]);
        const startPath = this.geoCircleCache[0].setAsGreatCircle(startPoint, initialCourse);
        state.currentCourse = initialCourse;
        const startPathEncirclesTerminator = startPath.encircles(terminatorVec);
        const startPathIncludesTerminator = startPath.includes(terminatorVec);
        const turnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
            : leg.turnDirection === LegTurnDirection.Right ? 'right'
                : startPathEncirclesTerminator && !startPathIncludesTerminator ? 'left' : 'right';
        const startToTurnCenterPath = this.geoCircleCache[0].setAsGreatCircle(startPoint, initialCourse + (turnDirection === 'left' ? -90 : 90));
        let maxTurnRadiusRad;
        if (!startPathIncludesTerminator && startPathEncirclesTerminator === (turnDirection === 'left')) {
            // terminator lies on the same side as the turn, which means there is the possibility that the turn circle can
            // encircle the terminator, which would make defining a great circle intersecting the terminator fix and also
            // tangent to the turn circle impossible. Therefore, we compute the maximum allowed turn radius, defined as the
            // radius such that the terminator fix lies exactly on the turn circle.
            const startToTerminatorPathNormal = GeoCircle.getGreatCircleNormal(startVec, terminatorVec, this.vec3Cache[2]);
            // the angle between the great-circle path from the start point to the turn center and the path from the start
            // point to the terminator fix
            const theta = Math.acos(Vec3Math.dot(startToTurnCenterPath.center, startToTerminatorPathNormal));
            maxTurnRadiusRad = Math.atan(Math.sin(distanceToTerminator) / (Math.cos(theta) * (1 + Math.cos(distanceToTerminator))));
        }
        else {
            // terminator lies on the starting path or on the opposite side as the turn. Either way, no turn can encircle the
            // terminator, and so there is no maximum turn radius.
            maxTurnRadiusRad = Math.PI / 2;
        }
        const turnRadiusRad = Math.min(maxTurnRadiusRad, state.desiredTurnRadius.asUnit(UnitType.GA_RADIAN));
        const turnCenterVec = startToTurnCenterPath.offsetDistanceAlong(startVec, turnRadiusRad, this.vec3Cache[2]);
        const turnCenterPoint = this.geoPointCache[2].setFromCartesian(turnCenterVec);
        // Find the great-circle path from the terminator fix that is tangent to the turn circle. There are guaranteed to
        // be two such paths. We choose between the two based on the initial turn direction.
        const turnCenterToTerminatorDistance = Math.acos(Vec3Math.dot(turnCenterVec, terminatorVec));
        // the angle between the the great-circle path from the terminator fix to the turn center and the two
        // great-circle paths from the terminator fix that are tangent to the turn circle.
        const alpha = Math.asin(Math.min(1, Math.sin(turnRadiusRad) / Math.sin(turnCenterToTerminatorDistance)));
        const terminatorFixBearingToTurnCenter = terminatorPos.bearingTo(turnCenterPoint);
        const finalPathCourse = NavMath.normalizeHeading(terminatorFixBearingToTurnCenter + alpha * Avionics.Utils.RAD2DEG * (turnDirection === 'left' ? -1 : 1) + 180);
        const finalPath = this.geoCircleCache[0].setAsGreatCircle(terminatorPos, finalPathCourse);
        const turnEndPoint = finalPath.closest(turnCenterPoint, this.geoPointCache[3]);
        if (!turnEndPoint.equals(startPoint)) {
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER), turnCenterPoint, startPoint, turnEndPoint);
        }
        state.currentPosition.set(turnEndPoint);
        state.currentCourse = finalPathCourse;
        if (!state.currentPosition.equals(terminatorPos)) {
            vectorIndex += this.greatCircleVectorBuilder.build(vectors, vectorIndex, state.currentPosition, terminatorPos);
        }
        state.currentPosition.set(terminatorPos);
        return vectorIndex;
    }
}
/**
 * Calculates flight path vectors for legs which define a turn ending at a defined terminator fix.
 */
class TurnToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state, vectors) {
        var _a, _b;
        const leg = legs[calculateIndex].leg;
        let vectorIndex = 0;
        const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[0]);
        const turnCenter = this.getTurnCenter(leg);
        if (!terminatorPos || !turnCenter) {
            return vectorIndex;
        }
        if (state.currentPosition && !state.currentPosition.equals(terminatorPos)) {
            const direction = leg.turnDirection === LegTurnDirection.Left ? 'left' : 'right';
            const radius = this.getTurnRadius(leg, turnCenter);
            if (radius) {
                const circle = FlightPathUtils.getTurnCircle(turnCenter, radius, direction, this.geoCircleCache[0]);
                const currentVec = circle.closest(state.currentPosition, this.vec3Cache[0]);
                const terminatorVec = circle.closest(terminatorPos, this.vec3Cache[1]);
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, circle, currentVec, terminatorVec);
                state.currentCourse = circle.bearingAt(terminatorVec);
                const turnVector = vectors[vectorIndex - 1];
                ((_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = new GeoPoint(0, 0))).set(turnVector.endLat, turnVector.endLon);
            }
        }
        (_b = state.currentPosition) !== null && _b !== void 0 ? _b : (state.currentPosition = terminatorPos.copy());
        return vectorIndex;
    }
}
/**
 * Calculates flight path vectors for radius to fix legs.
 */
class RadiusToFixLegCalculator extends TurnToFixLegCalculator {
    constructor() {
        super(...arguments);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getTurnCenter(leg) {
        return this.facilityCache.get(leg.arcCenterFixIcao);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getTurnRadius(leg, center) {
        var _a;
        return (_a = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[2])) === null || _a === void 0 ? void 0 : _a.distance(center);
    }
}
/**
 * Calculates flight path vectors for arc to fix legs.
 */
class ArcToFixLegCalculator extends TurnToFixLegCalculator {
    // eslint-disable-next-line jsdoc/require-jsdoc
    getTurnCenter(leg) {
        return this.facilityCache.get(leg.originIcao);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    getTurnRadius(leg, center) {
        return UnitType.METER.convertTo(leg.rho, UnitType.GA_RADIAN);
    }
}
/**
 * Calculates flight path vectors for legs which define a great-circle path terminating at an intercept with another
 * geo circle.
 */
class CircleInterceptLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     * @param includeInitialTurn Whether this calculator should calculate an initial turn toward the intercept course.
     */
    constructor(facilityCache, includeInitialTurn) {
        super(facilityCache, includeInitialTurn);
        this.includeInitialTurn = includeInitialTurn;
        this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.turnBuilder = new TurnToCourseBuilder();
        this.interceptBuilder = new CircleInterceptBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state, vectors) {
        var _a;
        const leg = legs[calculateIndex].leg;
        let vectorIndex = 0;
        const course = this.getInterceptCourse(legs, calculateIndex, state);
        const circleToIntercept = this.getCircleToIntercept(legs, calculateIndex, state, this.geoCircleCache[0]);
        if (course === undefined || !circleToIntercept || !state.currentPosition) {
            return vectorIndex;
        }
        const startCourse = (_a = state.currentCourse) !== null && _a !== void 0 ? _a : course;
        if (this.includeInitialTurn && Math.abs(NavMath.diffAngle(course, startCourse)) >= 1) {
            const turnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
                : leg.turnDirection === LegTurnDirection.Right ? 'right'
                    : NavMath.getTurnDirection(startCourse, course);
            vectorIndex += this.turnBuilder.build(vectors, vectorIndex, state.currentPosition, state.desiredTurnRadius.asUnit(UnitType.METER), turnDirection, startCourse, course);
            const turnVector = vectors[vectorIndex - 1];
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(turnVector);
            state.currentPosition.set(turnVector.endLat, turnVector.endLon);
        }
        else {
            state.currentCourse = course;
        }
        const numVectorsAdded = this.interceptBuilder.build(vectors, vectorIndex, state.currentPosition, course, circleToIntercept);
        if (numVectorsAdded > 0) {
            vectorIndex += numVectorsAdded;
            const lastVector = vectors[vectorIndex - 1];
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
            state.currentPosition.set(lastVector.endLat, lastVector.endLon);
        }
        return vectorIndex;
    }
}
/**
 * Calculates flight path vectors for course to DME legs.
 */
class CourseToDMELegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getInterceptCourse(legs, index) {
        const leg = legs[index].leg;
        const dmeFacility = this.facilityCache.get(leg.originIcao);
        return dmeFacility ? this.getLegTrueCourse(leg, dmeFacility) : undefined;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getCircleToIntercept(legs, index, state, out) {
        const leg = legs[index].leg;
        const dmeFacility = this.facilityCache.get(leg.originIcao);
        return dmeFacility ? out.set(dmeFacility, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN)) : undefined;
    }
}
/**
 * Calculates flight path vectors for course to radial intercept legs.
 */
class CourseToRadialLegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getInterceptCourse(legs, index) {
        const leg = legs[index].leg;
        const radialFacility = this.facilityCache.get(leg.originIcao);
        return radialFacility ? this.getLegTrueCourse(leg, radialFacility) : undefined;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getCircleToIntercept(legs, index, state, out) {
        const leg = legs[index].leg;
        const radialFacility = this.facilityCache.get(leg.originIcao);
        if (!radialFacility) {
            return undefined;
        }
        const magVar = (ICAO.getFacilityType(radialFacility.icao) === FacilityType.VOR)
            ? -radialFacility.magneticVariation
            : MagVar.get(radialFacility);
        return out.setAsGreatCircle(radialFacility, leg.theta + magVar);
    }
}
/**
 * Calculates flight path vectors for fix to DME legs.
 */
class FixToDMELegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getInterceptCourse(legs, index) {
        const leg = legs[index].leg;
        const startFacility = this.facilityCache.get(leg.fixIcao);
        return startFacility ? this.getLegTrueCourse(leg, startFacility) : undefined;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getCircleToIntercept(legs, index, state, out) {
        const leg = legs[index].leg;
        const dmeFacility = this.facilityCache.get(leg.originIcao);
        return dmeFacility ? out.set(dmeFacility, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN)) : undefined;
    }
}
/**
 * Calculates flight path vectors for course to intercept legs.
 */
class CourseToInterceptLegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getInterceptCourse(legs, index, state) {
        const leg = legs[index].leg;
        return state.currentPosition ? this.getLegTrueCourse(leg, state.currentPosition) : undefined;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getCircleToIntercept(legs, index, state, out) {
        return this.predictLegPath(legs, index + 1, out);
    }
    /**
     * Predicts the path of a leg. If a prediction cannot be made, NaN will be written to all fields of the result.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param out A GeoCircle to which to write the result.
     * @returns the predicted path of the leg.
     */
    predictLegPath(legs, index, out) {
        var _a;
        const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
        if (!leg) {
            return undefined;
        }
        switch (leg.type) {
            case LegType.CF:
                {
                    const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[2]);
                    return terminator ? out.setAsGreatCircle(terminator, this.getLegTrueCourse(leg, terminator)) : undefined;
                }
            case LegType.AF:
                {
                    const facility = this.facilityCache.get(leg.originIcao);
                    return facility ? out.set(facility, UnitType.METER.convertTo(leg.rho, UnitType.GA_RADIAN)) : undefined;
                }
            case LegType.RF:
                {
                    const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[2]);
                    const centerFacility = this.facilityCache.get(leg.arcCenterFixIcao);
                    return terminator && centerFacility ? out.set(centerFacility, terminator.distance(centerFacility)) : undefined;
                }
            case LegType.FM:
            case LegType.VM:
                {
                    const origin = this.facilityCache.get(leg.originIcao);
                    return origin ? out.setAsGreatCircle(origin, this.getLegTrueCourse(leg, origin)) : undefined;
                }
            default:
                return undefined;
        }
    }
}
/**
 * Calculates flight path vectors for track from fix legs.
 */
class TrackFromFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.vectorBuilder = new GreatCircleBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state, vectors) {
        var _a;
        const leg = legs[calculateIndex].leg;
        let vectorIndex = 0;
        const fixIcaoPoint = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        const startPoint = fixIcaoPoint !== null && fixIcaoPoint !== void 0 ? fixIcaoPoint : state.currentPosition;
        if (!startPoint) {
            return vectorIndex;
        }
        const course = this.getLegTrueCourse(leg, startPoint);
        const path = this.geoCircleCache[0].setAsGreatCircle(startPoint, course);
        vectorIndex += this.vectorBuilder.build(vectors, vectorIndex, startPoint, path, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN));
        if (vectorIndex > 0) {
            const lastVector = vectors[vectorIndex - 1];
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
            ((_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = new GeoPoint(0, 0))).set(lastVector.endLat, lastVector.endLon);
        }
        return vectorIndex;
    }
}
/**
 * Calculates flight path vectors for course to fix legs.
 */
class CourseToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [
            new GeoCircle(new Float64Array(3), 0),
            new GeoCircle(new Float64Array(3), 0),
            new GeoCircle(new Float64Array(3), 0)
        ];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
        this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state, vectors) {
        var _a, _b, _c;
        const leg = legs[calculateIndex].leg;
        const prevLeg = legs[calculateIndex - 1];
        let vectorIndex = 0;
        const startPoint = state.currentPosition ? this.geoPointCache[0].set(state.currentPosition) : undefined;
        const endPoint = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[1]);
        if (!endPoint) {
            return vectorIndex;
        }
        const endCourse = this.getLegTrueCourse(leg, endPoint);
        const endVec = endPoint.toCartesian(this.vec3Cache[1]);
        const endPath = this.geoCircleCache[1].setAsGreatCircle(endPoint, endCourse);
        if (!startPoint || (prevLeg && (prevLeg.leg.type === LegType.FM || prevLeg.leg.type === LegType.VM))) {
            // Begins at a discontinuity OR previous leg is a manual termination leg.
            // Default to a track with start arbitrarily placed 5 NM from the terminator fix.
            const midPoint = endPath.offsetDistanceAlong(endVec, UnitType.NMILE.convertTo(-5, UnitType.GA_RADIAN), this.geoPointCache[2]);
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, midPoint, endPoint);
        }
        else {
            const startVec = startPoint.toCartesian(this.vec3Cache[0]);
            const currentCourse = (_a = state.currentCourse) !== null && _a !== void 0 ? _a : startPoint.bearingTo(endPoint);
            const startPath = this.geoCircleCache[0].setAsGreatCircle(startPoint, currentCourse);
            const startToEndPath = this.geoCircleCache[2].setAsGreatCircle(startVec, endVec);
            const pathDot = Vec3Math.dot(startPath.center, endPath.center);
            if (-pathDot > 1 - GeoPoint.EQUALITY_TOLERANCE) {
                // The start and end paths are anti-parallel, which means we need to execute a procedure turn to do a 180.
                // Favor right turn unless we are explicitly told to turn left.
                const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left' : 'right';
                vectorIndex += this.procTurnBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, currentCourse + 45 * (desiredTurnDirection === 'left' ? -1 : 1), state.desiredTurnRadius.asUnit(UnitType.METER), desiredTurnDirection, currentCourse, endCourse);
            }
            else if (endPath.angleAlong(startVec, endVec, Math.PI) < Math.PI
                && (pathDot > 1 - GeoPoint.EQUALITY_TOLERANCE
                    || (prevLeg && ((_b = prevLeg.calculated) === null || _b === void 0 ? void 0 : _b.flightPath.length) && endPath.includes(startVec, UnitType.METER.convertTo(10, UnitType.GA_RADIAN)))
                    || Vec3Math.dot(startToEndPath.center, endPath.center) >= 0.996194698 // 5 degrees
                )) {
                /*
                 * The start and end paths are parallel, so we can just connect the start and end with a track.
                 *
                 * OR the start point lies on the final course path (within a generous tolerance) and the previous leg has at
                 * least one calculated vector. In this case we will simply create a track from the start to end and let turn
                 * anticipation handle the initial turn into the final course.
                 *
                 * OR the difference between the course from start to end points and the final course is < 5 degrees, in which
                 * case we will just use the track to prevent us from calculating really long and suboptimal intercept paths.
                 */
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, endPoint);
            }
            else {
                const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
                    : leg.turnDirection === LegTurnDirection.Right ? 'right'
                        : NavMath.getTurnDirection(currentCourse, endCourse);
                vectorIndex += this.joinGreatCircleToPointBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, desiredTurnDirection, state.desiredTurnRadius.asUnit(UnitType.METER));
            }
        }
        ((_c = state.currentPosition) !== null && _c !== void 0 ? _c : (state.currentPosition = new GeoPoint(0, 0))).set(endPoint);
        state.currentCourse = endCourse;
        return vectorIndex;
    }
}
/**
 * Calculates flight path vectors for procedure turn legs.
 */
class ProcedureTurnLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
        this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state, vectors) {
        var _a, _b, _c;
        const leg = legs[calculateIndex].leg;
        let vectorIndex = 0;
        const origin = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        if (!origin) {
            return vectorIndex;
        }
        // If current lat/lon is not defined, then set it to the origin's location, simulating an IF at the leg origin.
        (_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = origin.copy());
        const nextLeg = (_b = legs[calculateIndex + 1]) === null || _b === void 0 ? void 0 : _b.leg;
        if (!origin.equals(state.currentPosition)) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, state.currentPosition, origin, state.currentCourse);
            state.currentCourse = origin.bearingFrom(state.currentPosition);
            state.currentPosition.set(origin);
        }
        if (!nextLeg) {
            return vectorIndex;
        }
        const nextLegTerminatorFix = this.getTerminatorPosition(nextLeg, nextLeg.fixIcao, this.geoPointCache[1]);
        if (!nextLegTerminatorFix) {
            return vectorIndex;
        }
        const inboundCourse = (_c = this.predictLegFinalTrueCourse(legs, calculateIndex + 1, nextLegTerminatorFix)) !== null && _c !== void 0 ? _c : 0;
        const outboundCourse = NavMath.normalizeHeading(inboundCourse + 180);
        const turnInitialCourse = leg.trueDegrees ? leg.course : MagVar.magneticToTrue(leg.course, origin);
        if (outboundCourse === turnInitialCourse) {
            return vectorIndex;
        }
        // must intercept the next leg at least 1 NM from the terminator fix
        const inboundPathEndpoint = nextLegTerminatorFix.offset(inboundCourse + 180, UnitType.NMILE.convertTo(1, UnitType.GA_RADIAN));
        const outboundPath = this.geoCircleCache[0].setAsGreatCircle(origin, outboundCourse);
        const inboundPath = this.geoCircleCache[1].setAsGreatCircle(inboundPathEndpoint, inboundCourse);
        const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
            : leg.turnDirection === LegTurnDirection.Right ? 'right'
                : undefined;
        vectorIndex += this.procTurnBuilder.build(vectors, vectorIndex, origin, outboundPath, inboundPathEndpoint, inboundPath, turnInitialCourse, state.desiredTurnRadius.asUnit(UnitType.METER), desiredTurnDirection, outboundCourse, inboundCourse);
        // addVectorsForProcTurn() is guaranteed to add at least one vector.
        const lastVector = vectors[vectorIndex - 1];
        state.currentPosition.set(lastVector.endLat, lastVector.endLon);
        state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
        return vectorIndex;
    }
    /**
     * Predicts the final true course of a leg at its terminator fix.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param terminator The location of the leg's terminator fix.
     * @returns the predicted final course of a leg at its terminator fix, or undefined if a prediction cannot be made.
     */
    predictLegFinalTrueCourse(legs, index, terminator) {
        var _a;
        const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
        if (!leg) {
            return undefined;
        }
        switch (leg.type) {
            case LegType.IF:
                return this.predictLegInitialTrueCourse(legs, index + 1, terminator);
            case LegType.CF:
                return this.getLegTrueCourse(leg, terminator);
            default:
                return undefined;
        }
    }
    /**
     * Predicts the initial true course of a leg at its origin fix.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param origin The location of the leg's origin.
     * @returns the predicted final course of a leg at its terminator fix, or undefined if a prediction cannot be made.
     */
    predictLegInitialTrueCourse(legs, index, origin) {
        var _a;
        const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
        if (!leg) {
            return undefined;
        }
        try {
            switch (leg.type) {
                case LegType.IF:
                case LegType.TF:
                case LegType.DF:
                case LegType.CF:
                    {
                        const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[2]);
                        return terminator ? origin.bearingTo(terminator) : undefined;
                    }
                case LegType.CD:
                case LegType.VD:
                case LegType.CR:
                case LegType.VR:
                case LegType.FC:
                case LegType.FD:
                    return this.getLegTrueCourse(leg, origin);
                case LegType.FA:
                case LegType.CA:
                case LegType.VA:
                case LegType.FM:
                case LegType.VM:
                case LegType.CI:
                case LegType.VI:
                    return leg.trueDegrees ? leg.course : MagVar.magneticToTrue(leg.course, origin);
                default:
                    return undefined;
            }
        }
        catch (e) {
            return undefined;
        }
    }
}
/**
 * Calculates flight path vectors for course to manual legs.
 */
class CourseToManualLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state, vectors) {
        const leg = legs[calculateIndex].leg;
        let vectorIndex = 0;
        if (!state.currentPosition) {
            return vectorIndex;
        }
        const course = leg.trueDegrees ? leg.course : MagVar.magneticToTrue(leg.course, state.currentPosition);
        const normalizedEnd = state.currentPosition.offset(course, UnitType.NMILE.convertTo(1, UnitType.GA_RADIAN), this.geoPointCache[0]);
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, state.currentPosition, normalizedEnd);
        state.currentPosition.set(normalizedEnd);
        state.currentCourse = course;
        return vectorIndex;
    }
}
/**
 * Calculates flight path vectors for course to altitude legs.
 */
class CourseToAltitudeLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state, vectors) {
        const leg = legs[calculateIndex].leg;
        let vectorIndex = 0;
        if (!state.currentPosition) {
            return vectorIndex;
        }
        const course = this.getLegTrueCourse(leg, state.currentPosition);
        const path = this.geoCircleCache[0].setAsGreatCircle(state.currentPosition, course);
        const originVec = state.currentPosition.toCartesian(this.vec3Cache[0]);
        const climbStartVec = activeLegIndex === calculateIndex
            ? path.closest(state.planePosition, this.vec3Cache[1])
            : originVec;
        const originToClimbStartDistance = (path.distanceAlong(originVec, climbStartVec) + 3 * Math.PI) % (2 * Math.PI) - Math.PI; // -pi to +pi
        const targetFeet = UnitType.METER.convertTo(leg.altitude1, UnitType.FOOT);
        const deltaAltitude = Math.max(0, targetFeet - state.planeAltitude.asUnit(UnitType.FOOT));
        const distanceRemaining = UnitType.NMILE.convertTo((deltaAltitude / state.planeClimbRate.asUnit(UnitType.FPM)) / 60 * state.planeSpeed.asUnit(UnitType.KNOT), UnitType.GA_RADIAN);
        const offsetDistance = Math.max(UnitType.FOOT.convertTo(100, UnitType.GA_RADIAN), originToClimbStartDistance + distanceRemaining);
        const legEndVec = path.offsetDistanceAlong(originVec, offsetDistance, this.vec3Cache[1]);
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, originVec, path, legEndVec);
        state.currentPosition.setFromCartesian(legEndVec);
        state.currentCourse = path.bearingAt(legEndVec);
        return vectorIndex;
    }
}
/**
 * Calculates flight path vectors for hold legs.
 */
class HoldLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.turnToCourseBuilder = new TurnToCourseBuilder();
        this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
        this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state, vectors) {
        var _a, _b, _c, _d;
        const leg = legs[calculateIndex].leg;
        let vectorIndex = 0;
        const holdPos = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        if (!holdPos) {
            return vectorIndex;
        }
        // If current lat/lon is not defined, then set it to the facility's location, simulating an IF at the hold's
        // facility.
        (_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = holdPos.copy());
        if (!state.currentPosition.equals(holdPos)) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, state.currentPosition, holdPos, state.currentCourse);
            state.currentCourse = holdPos.bearingFrom(state.currentPosition);
        }
        const course = this.getLegTrueCourse(leg, holdPos);
        const distance = leg.distanceMinutes
            ? UnitType.NMILE.convertTo(leg.distance * (state.planeSpeed.asUnit(UnitType.KNOT) / 60), UnitType.GA_RADIAN)
            : UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN);
        const turnDirection = leg.turnDirection === LegTurnDirection.Right ? 'right' : 'left';
        const turnRadiusMeters = state.desiredTurnRadius.asUnit(UnitType.METER);
        const inboundPath = this.geoCircleCache[0].setAsGreatCircle(holdPos, course);
        // Handle hold entry
        state.currentPosition.set(holdPos);
        (_b = state.currentCourse) !== null && _b !== void 0 ? _b : (state.currentCourse = course);
        const turnDirectionSign = turnDirection === 'left' ? -1 : 1;
        const normalizedEntryCourse = ((state.currentCourse - course) + 540) % 360 - 180; // -180 to +180
        let isDirectEntry = true;
        if (normalizedEntryCourse > 110) {
            isDirectEntry = false;
            // teardrop entry
            if (normalizedEntryCourse * turnDirectionSign > 135) {
                // need to make initial turn to get a 45-degree outbound leg
                const outboundCourse = course + 135 * turnDirectionSign;
                vectorIndex += this.turnToCourseBuilder.build(vectors, vectorIndex, holdPos, turnRadiusMeters, turnDirection === 'left' ? 'right' : 'left', state.currentCourse, outboundCourse);
                const turnVector = vectors[vectorIndex - 1];
                state.currentPosition.set(turnVector.endLat, turnVector.endLon);
                state.currentCourse = (_c = FlightPathUtils.getVectorFinalCourse(turnVector)) !== null && _c !== void 0 ? _c : outboundCourse;
            }
            vectorIndex += this.joinGreatCircleToPointBuilder.build(vectors, vectorIndex, state.currentPosition, this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, state.currentCourse), holdPos, inboundPath, turnDirection, turnRadiusMeters);
        }
        else if (normalizedEntryCourse * turnDirectionSign < -70) {
            isDirectEntry = false;
            // parallel entry
            const parallelCourse = course + 180;
            vectorIndex += this.turnToCourseBuilder.build(vectors, vectorIndex, holdPos, turnRadiusMeters, turnDirection === 'left' ? 'right' : 'left', state.currentCourse, parallelCourse);
            const turnVector = vectors[vectorIndex - 1];
            state.currentPosition.set(turnVector.endLat, turnVector.endLon);
            state.currentCourse = (_d = FlightPathUtils.getVectorFinalCourse(turnVector)) !== null && _d !== void 0 ? _d : parallelCourse;
            vectorIndex += this.procTurnBuilder.build(vectors, vectorIndex, state.currentPosition, this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, state.currentCourse), holdPos, inboundPath, course + 135 * turnDirectionSign, turnRadiusMeters, turnDirection === 'left' ? 'right' : 'left', state.currentCourse, course);
        }
        if (leg.type !== LegType.HF || isDirectEntry) {
            const egressCenterCourse = NavMath.normalizeHeading(course + 90 * turnDirectionSign);
            const turnRadiusRad = state.desiredTurnRadius.asUnit(UnitType.GA_RADIAN);
            const egressCenter = holdPos.offset(egressCenterCourse, turnRadiusRad, this.geoPointCache[1]);
            const egressTurnEnd = holdPos.offset(egressCenterCourse, turnRadiusRad * 2, this.geoPointCache[2]);
            const oppositeCourse = NavMath.normalizeHeading(course + 180);
            const egressEnd = egressTurnEnd.offset(oppositeCourse, distance, this.geoPointCache[3]);
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, turnRadiusMeters, egressCenter, holdPos, egressTurnEnd);
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, egressTurnEnd, egressEnd);
            const ingressCenterCourse = NavMath.normalizeHeading(oppositeCourse + 90 * turnDirectionSign);
            const ingressCenter = egressEnd.offset(ingressCenterCourse, turnRadiusRad, this.geoPointCache[1]);
            const ingressTurnEnd = egressEnd.offset(ingressCenterCourse, turnRadiusRad * 2, this.geoPointCache[2]);
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, turnRadiusMeters, ingressCenter, egressEnd, ingressTurnEnd);
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, ingressTurnEnd, holdPos);
        }
        state.currentPosition.set(holdPos);
        state.currentCourse = course;
        return vectorIndex;
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * Calculates the flight path vectors for a given set of legs.
 */
class FlightPathCalculator {
    /**
     * Creates an instance of the FlightPathCalculator.
     * @param facilityLoader The facility loader to use with this instance.
     * @param options The options to use with this flight path calculator.
     */
    constructor(facilityLoader, options) {
        this.facilityLoader = facilityLoader;
        this.options = options;
        this.vector3Cache = [new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [
            GeoCircle.createFromPoint(this.geoPointCache[0], 0), GeoCircle.createFromPoint(this.geoPointCache[0], 0),
            GeoCircle.createFromPoint(this.geoPointCache[0], 0), GeoCircle.createFromPoint(this.geoPointCache[0], 0)
        ];
        this.intersectionVecArrayCache = [new Float64Array(3), new Float64Array(3)];
        this.intersectionGeoPointArrayCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.facilityCache = new Map();
        this.legCalculatorMap = this.createLegCalculatorMap();
        this.state = new FlightPathStateClass();
    }
    /**
     * Creates a map from leg types to leg calculators.
     * @returns A map from leg types to leg calculators.
     */
    createLegCalculatorMap() {
        let calc;
        return {
            [LegType.Unknown]: calc = new TrackToFixLegCalculator(this.facilityCache),
            [LegType.IF]: calc,
            [LegType.TF]: calc,
            [LegType.AF]: new ArcToFixLegCalculator(this.facilityCache),
            [LegType.CD]: calc = new CourseToDMELegCalculator(this.facilityCache),
            [LegType.VD]: calc,
            [LegType.CF]: new CourseToFixLegCalculator(this.facilityCache),
            [LegType.CR]: calc = new CourseToRadialLegCalculator(this.facilityCache),
            [LegType.VR]: calc,
            [LegType.FC]: new TrackFromFixLegCalculator(this.facilityCache),
            [LegType.FD]: new FixToDMELegCalculator(this.facilityCache),
            [LegType.RF]: new RadiusToFixLegCalculator(this.facilityCache),
            [LegType.DF]: new DirectToFixLegCalculator(this.facilityCache),
            [LegType.FA]: calc = new CourseToAltitudeLegCalculator(this.facilityCache),
            [LegType.CA]: calc,
            [LegType.VA]: calc,
            [LegType.FM]: calc = new CourseToManualLegCalculator(this.facilityCache),
            [LegType.VM]: calc,
            [LegType.CI]: calc = new CourseToInterceptLegCalculator(this.facilityCache),
            [LegType.VI]: calc,
            [LegType.PI]: new ProcedureTurnLegCalculator(this.facilityCache),
            [LegType.HA]: calc = new HoldLegCalculator(this.facilityCache),
            [LegType.HM]: calc,
            [LegType.HF]: calc,
            [LegType.Discontinuity]: new DiscontinuityLegCalculator(this.facilityCache)
        };
    }
    /**
     * Calculates a flight path for a given set of flight plan legs.
     * @param legs The legs of the flight plan and/or procedure.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the leg to start at.
     * @param count The number of legs to calculate.
     */
    async calculateFlightPath(legs, activeLegIndex, initialIndex = 0, count = Number.POSITIVE_INFINITY) {
        count = Math.min(legs.length - initialIndex, count);
        this.state.updatePlaneState(this.options);
        await this.loadFacilities(legs, initialIndex, count);
        this.initCurrentLatLon(legs, initialIndex);
        this.initCurrentCourse(legs, initialIndex);
        this.calculateLegPaths(legs, activeLegIndex, initialIndex, count);
        this.computeLegToLegTurns(legs, initialIndex, count);
        this.updateLegDistanceWithTurns(legs, initialIndex, count);
    }
    /**
     * Loads facilities required for flight path calculations from the flight plan.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     * @param count The number of legs to calculate.
     */
    async loadFacilities(legs, initialIndex, count) {
        const facilityPromises = [];
        for (let i = initialIndex; i < initialIndex + count; i++) {
            this.stageFacilityLoad(legs[i].leg.fixIcao, facilityPromises);
            this.stageFacilityLoad(legs[i].leg.originIcao, facilityPromises);
            this.stageFacilityLoad(legs[i].leg.arcCenterFixIcao, facilityPromises);
        }
        if (facilityPromises.length > 0) {
            await Promise.all(facilityPromises);
        }
    }
    /**
     * Initializes the current lat/lon.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    initCurrentLatLon(legs, initialIndex) {
        var _a;
        var _b;
        let index = Math.min(initialIndex, legs.length);
        while (--index >= 0) {
            const leg = legs[index];
            if (leg.leg.type === LegType.Discontinuity) {
                return;
            }
            const calc = leg.calculated;
            if (calc && calc.endLat !== undefined && calc.endLon !== undefined) {
                ((_a = (_b = this.state).currentPosition) !== null && _a !== void 0 ? _a : (_b.currentPosition = new GeoPoint(0, 0))).set(calc.endLat, calc.endLon);
                return;
            }
        }
        this.state.currentPosition = undefined;
    }
    /**
     * Initializes the current course.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    initCurrentCourse(legs, initialIndex) {
        let index = Math.min(initialIndex, legs.length);
        while (--index >= 0) {
            const leg = legs[index];
            if (leg.leg.type === LegType.Discontinuity) {
                return;
            }
            const legCalc = leg.calculated;
            if (legCalc && legCalc.flightPath.length > 0) {
                this.state.currentCourse = FlightPathUtils.getLegFinalCourse(legCalc);
                if (this.state.currentCourse !== undefined) {
                    return;
                }
            }
        }
        this.state.currentCourse = undefined;
    }
    /**
     * Calculates flight paths for a sequence of flight plan legs.
     * @param legs A sequence of flight plan legs.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the first leg to calculate.
     * @param count The number of legs to calculate.
     */
    calculateLegPaths(legs, activeLegIndex, initialIndex, count) {
        const end = initialIndex + count;
        for (let i = initialIndex; i < end; i++) {
            this.calculateLegPath(legs, i, activeLegIndex);
        }
    }
    /**
     * Calculates a flight path for a leg in a sequence of legs.
     * @param legs A sequence of flight plan legs.
     * @param calculateIndex The index of the leg to calculate.
     * @param activeLegIndex The index of the active leg.
     */
    calculateLegPath(legs, calculateIndex, activeLegIndex) {
        var _a, _b, _c;
        const definition = legs[calculateIndex];
        definition.calculated = this.legCalculatorMap[definition.leg.type].calculate(legs, calculateIndex, activeLegIndex, this.state);
        definition.calculated.distance = 0;
        const len = definition.calculated.flightPath.length;
        for (let i = 0; i < len; i++) {
            definition.calculated.distance += definition.calculated.flightPath[i].distance;
        }
        definition.calculated.cumulativeDistance = definition.calculated.distance + ((_c = (_b = (_a = legs[calculateIndex - 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistance) !== null && _c !== void 0 ? _c : 0);
        const start = definition.calculated.flightPath[0];
        const end = definition.calculated.flightPath[definition.calculated.flightPath.length - 1];
        definition.calculated.initialDtk = undefined;
        if (start !== undefined) {
            const trueDtk = FlightPathUtils.getVectorInitialCourse(start);
            if (!isNaN(trueDtk)) {
                definition.calculated.initialDtk = MagVar.trueToMagnetic(trueDtk, start.startLat, start.startLon);
            }
        }
        definition.calculated.startLat = start === null || start === void 0 ? void 0 : start.startLat;
        definition.calculated.startLon = start === null || start === void 0 ? void 0 : start.startLon;
        definition.calculated.endLat = end === null || end === void 0 ? void 0 : end.endLat;
        definition.calculated.endLon = end === null || end === void 0 ? void 0 : end.endLon;
        if (!end && this.state.currentPosition) {
            definition.calculated.endLat = this.state.currentPosition.lat;
            definition.calculated.endLon = this.state.currentPosition.lon;
        }
    }
    /**
     * Updates leg distances with turn anticipation.
     * @param legs A sequence of flight plan legs.
     * @param initialIndex The index of the first leg to update.
     * @param count The number of legs to update.
     */
    updateLegDistanceWithTurns(legs, initialIndex, count) {
        var _a, _b, _c;
        const end = initialIndex + count;
        for (let i = initialIndex; i < end; i++) {
            const leg = legs[i];
            const calc = leg.calculated;
            calc.distanceWithTurns = 0;
            const len = calc.flightPath.length;
            for (let j = 0; j < len; j++) {
                calc.distanceWithTurns += this.calculateVectorWithTurnDistance(j, calc);
            }
            calc.cumulativeDistanceWithTurns = calc.distanceWithTurns + ((_c = (_b = (_a = legs[i - 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistanceWithTurns) !== null && _c !== void 0 ? _c : 0);
        }
    }
    /**
     * Calculates a flight path vector distance that includes a possible ingress or egress
     * turn.
     * @param index The index of the flight path vector in the calculations.
     * @param calcs The calculations to use.
     * @returns The flight path vector distance including turns.
     */
    calculateVectorWithTurnDistance(index, calcs) {
        let distance = 0;
        const start = this.geoPointCache[0];
        const end = this.geoPointCache[1];
        const vector = calcs.flightPath[index];
        if (index === 0 && calcs.ingressTurn.radius !== 0) {
            distance += calcs.ingressTurn.distance;
            start.set(calcs.ingressTurn.endLat, calcs.ingressTurn.endLon);
        }
        else {
            start.set(vector.startLat, vector.startLon);
        }
        if (index === calcs.flightPath.length - 1 && calcs.egressTurn.radius !== 0) {
            distance += calcs.egressTurn.distance;
            end.set(calcs.egressTurn.startLat, calcs.egressTurn.startLon);
        }
        else {
            end.set(vector.endLat, vector.endLon);
        }
        const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
        distance += UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.METER);
        return distance;
    }
    /**
     * Computes leg to leg turns for a given sequence of legs.
     * @param legs A sequence of legs.
     * @param startIndex The index of the first leg for which to compute turns.
     * @param count The total number of legs for which to compute turns.
     */
    computeLegToLegTurns(legs, startIndex, count) {
        var _a, _b;
        const turnRadiusMeters = this.state.desiredTurnRadius.asUnit(UnitType.METER);
        const end = startIndex + count;
        let currentIndex = startIndex;
        while (currentIndex < end) {
            const legBeforeCalc = (_a = legs[currentIndex]) === null || _a === void 0 ? void 0 : _a.calculated;
            const legAfterCalc = (_b = legs[currentIndex + 1]) === null || _b === void 0 ? void 0 : _b.calculated;
            if (legBeforeCalc && legAfterCalc) {
                const vectorBefore = legBeforeCalc.flightPath[legBeforeCalc.flightPath.length - 1];
                const vectorAfter = legAfterCalc.flightPath[0];
                if (vectorBefore && vectorAfter) {
                    if (vectorBefore.radius === Math.PI / 2 && vectorAfter.radius === Math.PI / 2) {
                        currentIndex = this.computeLegToLegTrackTrackTurn(legs, currentIndex, currentIndex + 1, vectorBefore, vectorAfter, turnRadiusMeters);
                        continue;
                    }
                    else if (vectorAfter.radius === Math.PI / 2) {
                        currentIndex = this.computeLegToLegArcTrackTurn(legs, currentIndex, currentIndex + 1, vectorBefore, vectorAfter, true, turnRadiusMeters);
                        continue;
                    }
                    else if (vectorBefore.radius === Math.PI / 2) {
                        currentIndex = this.computeLegToLegArcTrackTurn(legs, currentIndex, currentIndex + 1, vectorAfter, vectorBefore, false, turnRadiusMeters);
                        continue;
                    }
                }
                this.setEmptyLegToLegTurn(legBeforeCalc, legAfterCalc);
            }
            currentIndex++;
        }
    }
    /**
     * Calculates a leg to leg turn between two track vectors.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param fromTrack The track vector on which the turn begins.
     * @param toTrack The track vector on which the turn ends.
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @param previousTanTheta The tangent of the theta value of the previous turn. Theta is defined as the (acute)
     * angle between either `fromTrack` or `toTrack` and the great circle passing through the turn vertex (where the two
     * tracks meet) and the center of the turn. If this value is defined, the anticipation of both turns will be adjusted
     * if necessary such that the turns do not overlap if they share a common flight path vector. If the value is
     * undefined, the anticipation of the current turn will be restricted by the previous turn, if necessary, without
     * changing the anticipation of the previous turn.
     * @returns the index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    computeLegToLegTrackTrackTurn(legs, fromIndex, toIndex, fromTrack, toTrack, desiredTurnRadius, previousTanTheta) {
        var _a, _b;
        let lastComputedIndex = toIndex;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const fromLegCalc = legs[fromIndex].calculated;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const toLegCalc = legs[toIndex].calculated;
        const turnVertexPoint = this.geoPointCache[0].set(fromTrack.endLat, fromTrack.endLon);
        const fromTrackBearing = turnVertexPoint.bearingFrom(fromTrack.startLat, fromTrack.startLon);
        const toTrackBearing = turnVertexPoint.bearingTo(toTrack.endLat, toTrack.endLon);
        const trackAngleDiff = Math.abs(NavMath.diffAngle(fromTrackBearing, toTrackBearing));
        if (trackAngleDiff < 1
            || trackAngleDiff > 179
            || fromTrack.distance === 0
            || toTrack.distance === 0
            || !turnVertexPoint.equals(toTrack.startLat, toTrack.startLon, 1e-5)) {
            this.setEmptyLegToLegTurn(fromLegCalc, toLegCalc);
            return lastComputedIndex;
        }
        const theta = (180 - trackAngleDiff) / 2;
        const tanTheta = Math.tan(theta * Avionics.Utils.DEG2RAD);
        // D is defined as the distance from the start/end of the turn to the turn vertex along the from- and to- tracks
        // (i.e. the anticipation).
        const desiredD = Math.asin(Math.tan(UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN)) / tanTheta);
        let restrictedD = Infinity;
        if (previousTanTheta === undefined) {
            // Check to see if there is a previous anticipated turn and if it shares a common flight path vector with this one.
            if (fromLegCalc.ingressTurn.radius > 0 && fromLegCalc.flightPath.length === 1) {
                restrictedD = turnVertexPoint.distance(fromLegCalc.ingressTurn.endLat, fromLegCalc.ingressTurn.endLon);
            }
        }
        else {
            // D is restricted by a previous turn. The values of D_current and D_previous are restricted such that their sum
            // cannot exceed the total length of their shared vector (the from- vector for this turn). Therefore, we set the
            // maximum value of D_current such that at D_current(max), the radius of this turn equals the radius of the
            // previous turn. This will maximize min(radius_current, radius_prev).
            const tanThetaRatio = previousTanTheta / tanTheta;
            const totalD = UnitType.METER.convertTo(fromTrack.distance, UnitType.GA_RADIAN);
            const cosTotalD = Math.cos(totalD);
            let prevTurnRestrictedD = Math.acos((tanThetaRatio * cosTotalD + 1) / Math.sqrt(tanThetaRatio * tanThetaRatio + 2 * tanThetaRatio * cosTotalD + 1));
            if (prevTurnRestrictedD > totalD) {
                prevTurnRestrictedD = Math.PI - prevTurnRestrictedD;
            }
            restrictedD = prevTurnRestrictedD;
        }
        // We need to scan forward in the leg sequence to compute any restrictions on D imposed by later turns.
        if (toLegCalc.flightPath.length === 1) {
            const nextVector = (_b = (_a = legs[toIndex + 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.flightPath[0];
            if (nextVector) {
                let nextTurnRestrictedD;
                if (!FlightPathUtils.isVectorGreatCircle(nextVector)) {
                    nextTurnRestrictedD = UnitType.METER.convertTo(toTrack.distance / 2, UnitType.GA_RADIAN);
                }
                else {
                    // if the next turn to share a vector with this turn is to a track vector, we need to recursively compute
                    // future turns since the next turn may be restricted by the turn after that, etc.
                    lastComputedIndex = this.computeLegToLegTrackTrackTurn(legs, toIndex, toIndex + 1, toTrack, nextVector, desiredTurnRadius, tanTheta);
                    turnVertexPoint.set(fromTrack.endLat, fromTrack.endLon);
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    const nextTurnEgress = legs[toIndex].calculated.egressTurn;
                    nextTurnRestrictedD = turnVertexPoint.distance(nextTurnEgress.startLat, nextTurnEgress.startLon);
                }
                restrictedD = Math.min(restrictedD, nextTurnRestrictedD);
            }
        }
        const D = Math.min(desiredD, restrictedD, UnitType.METER.convertTo(fromTrack.distance, UnitType.GA_RADIAN), UnitType.METER.convertTo(toTrack.distance, UnitType.GA_RADIAN));
        // distance from the turn vertex to the center of the turn
        const H = Math.atan(Math.tan(D) / Math.cos(theta * Avionics.Utils.DEG2RAD));
        const turnRadiusRad = desiredD === D
            ? UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN)
            : Math.atan(Math.sin(D) * tanTheta);
        const turnDirection = NavMath.getTurnDirection(fromTrackBearing, toTrackBearing);
        const turnBisectorBearing = toTrackBearing + theta * (turnDirection === 'left' ? -1 : 1);
        const turnCenter = turnVertexPoint.offset(turnBisectorBearing, H, this.geoPointCache[1]);
        const fromTrackPath = this.geoCircleCache[0].setAsGreatCircle(turnVertexPoint, fromTrackBearing);
        const toTrackPath = this.geoCircleCache[1].setAsGreatCircle(turnVertexPoint, toTrackBearing);
        const turnStart = fromTrackPath.closest(turnCenter, this.geoPointCache[2]);
        const turnMiddle = turnVertexPoint.offset(turnBisectorBearing, H - turnRadiusRad, this.geoPointCache[3]);
        const turnEnd = toTrackPath.closest(turnCenter, this.geoPointCache[4]);
        this.setLegToLegTurn(fromLegCalc, toLegCalc, turnDirection, UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER), turnCenter, turnStart, turnMiddle, turnEnd);
        return lastComputedIndex;
    }
    /**
     * Calculates a leg to leg turn between an arc vector and a track vector.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param arc The arc vector.
     * @param track The track vector.
     * @param isArcFirst Whether the arc vector precedes the track vector (i.e. whether the arc vector is the vector on
     * which the turn begins).
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @returns the index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    computeLegToLegArcTrackTurn(legs, fromIndex, toIndex, arc, track, isArcFirst, desiredTurnRadius) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const fromLegCalc = legs[fromIndex].calculated;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const toLegCalc = legs[toIndex].calculated;
        if (arc.distance === 0 || track.distance === 0) {
            this.setEmptyLegToLegTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        /*
         * Theory: find the center of the turn circle. Since the turn circle is tangent to both the arc circle and the
         * great circle defined by the track path, it follows that the center of the turn circle lies at a distance equal
         * to the turn radius from both the arc circle and great circle. Therefore, we can find the center by applying a
         * radial offset equal to +/-[turn radius] to both the arc circle and great circle (the sign of the offset depends
         * on the direction of the arc and track path) and solving for the points of intersection between the offset
         * circles.
         */
        const fromVector = isArcFirst ? arc : track;
        const toVector = isArcFirst ? track : arc;
        const fromVectorEndPoint = this.geoPointCache[0].set(fromVector.endLat, fromVector.endLon);
        const toVectorStartPoint = this.geoPointCache[1].set(toVector.startLat, toVector.startLon);
        if (!fromVectorEndPoint.equals(toVectorStartPoint, 1e-5)) {
            this.setEmptyLegToLegTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        const fromVectorEndBearing = FlightPathUtils.getVectorFinalCourse(fromVector);
        const toVectorStartBearing = FlightPathUtils.getVectorInitialCourse(toVector);
        const vectorBearingDiff = Math.abs(NavMath.diffAngle(fromVectorEndBearing, toVectorStartBearing));
        if (vectorBearingDiff < 1) {
            this.setEmptyLegToLegTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        const circle = FlightPathUtils.setGeoCircleFromVector(arc, this.geoCircleCache[0]);
        const arcCenter = FlightPathUtils.getTurnCenterFromCircle(circle, this.geoPointCache[2]);
        const arcRadius = FlightPathUtils.getTurnRadiusFromCircle(circle);
        const arcDirection = FlightPathUtils.getTurnDirectionFromCircle(circle);
        // define the circles
        const arcCircle = this.geoCircleCache[0].set(arcCenter, arcRadius);
        const trackPath = FlightPathUtils.setGeoCircleFromVector(track, this.geoCircleCache[1]);
        const trackPathNormalPoint = this.geoPointCache[3].setFromCartesian(trackPath.center);
        const arcStartRadial = arcCircle.bearingAt(this.geoPointCache[4].set(arc.startLat, arc.startLon), Math.PI) + 90;
        const arcEndRadial = arcCircle.bearingAt(this.geoPointCache[4].set(arc.endLat, arc.endLon), Math.PI) + 90;
        // calculate whether the arc intersects the track; if they don't (or if they are entirely coincident), something
        // has gone wrong!
        const arcTrackIntersectionCount = arcCircle.numIntersectionPoints(trackPath);
        if (arcTrackIntersectionCount === 0 || isNaN(arcTrackIntersectionCount)) {
            this.setEmptyLegToLegTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        const turnDirection = NavMath.getTurnDirection(fromVectorEndBearing, toVectorStartBearing);
        let isInside;
        let turnRadiusRad;
        let arcCircleOffsetSign;
        let trackPathOffsetSign;
        if (arcTrackIntersectionCount === 1) {
            // arc circle and track path are tangent
            const isForward = Math.abs(NavMath.diffAngle(fromVectorEndBearing, toVectorStartBearing)) < 90;
            if (isForward) {
                this.setEmptyLegToLegTurn(fromLegCalc, toLegCalc);
                return toIndex;
            }
            else {
                // in this case, the plane effectively needs to make a 180...
                isInside = false;
                turnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
                arcCircleOffsetSign = 1;
                trackPathOffsetSign = trackPath.encircles(arcCenter) ? -1 : 1;
            }
        }
        else {
            const desiredTurnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
            isInside = isArcFirst
                ? Math.abs(NavMath.diffAngle(fromVectorEndPoint.bearingFrom(arcCenter), toVectorStartBearing)) >= 90
                : Math.abs(NavMath.diffAngle(fromVectorEndPoint.bearingFrom(arcCenter), fromVectorEndBearing)) < 90;
            /**
             * Now we must calculate the maximum allowed turn radius such that the turn does not start or end beyond the
             * limits of the arc or track. First, we convert the track limit to a pseudo-arc limit, then take the more
             * restrictive of the pseudo-arc limit and the actual arc limit. This maximally restrictive arc limit is then
             * used to compute the turn radius that would result in a turn which has an endpoint exactly at the limit.
             */
            const turnVertexRadialNormal = GeoCircle.getGreatCircleNormal(arcCenter, fromVectorEndPoint, this.vector3Cache[0]);
            // if the turn is inside the arc, then clamp track limit distance to half the length of the track path within the
            // arc, since that is the point at which turn radius is maximized.
            const maxTrackLimitDistance = isInside
                ? Math.atan(Math.abs(Vec3Math.dot(trackPath.center, turnVertexRadialNormal)) * Math.tan(arcRadius))
                : Infinity;
            const trackLimitDistance = Math.min(UnitType.METER.convertTo(track.distance / 2, UnitType.GA_RADIAN), maxTrackLimitDistance);
            const trackLimitPoint = isArcFirst
                ? toVectorStartPoint.offset(toVectorStartBearing, trackLimitDistance, this.geoPointCache[4])
                : fromVectorEndPoint.offset(fromVectorEndBearing + 180, trackLimitDistance, this.geoPointCache[4]);
            // the great circle which passes through the center of the arc and is perpendicular to the track
            const trackPerpendicularDiameter = this.geoCircleCache[2].set(Vec3Math.cross(Vec3Math.multScalar(trackPath.center, (isArcFirst === isInside ? -1 : 1), this.vector3Cache[1]), arcCircle.center, this.vector3Cache[1]), Math.PI / 2);
            const antipodes = this.intersectionVecArrayCache;
            trackPerpendicularDiameter.intersection(arcCircle, antipodes);
            // compute the great circle which passes through the appropriate antipode and the track limit endpoint. The
            // intersection of this great circle with the arc that is NOT the antipode is the pseudo-arc limit endpoint.
            const intersectingPath = this.geoCircleCache[3].setAsGreatCircle(isInside === (turnDirection === 'left') ? antipodes[0] : antipodes[1], trackLimitPoint);
            const arcIntersections = this.intersectionGeoPointArrayCache;
            const numArcIntersections = intersectingPath.intersectionGeoPoint(arcCircle, arcIntersections);
            let arcLimitAngularWidth = Infinity;
            if (numArcIntersections > 0) {
                const pseudoArcLimitPoint = arcIntersections[0];
                const pseudoArcLimitPointAngle = arcCenter.bearingTo(pseudoArcLimitPoint);
                arcLimitAngularWidth = Math.abs(NavMath.diffAngle((isArcFirst ? arcEndRadial : arcStartRadial), pseudoArcLimitPointAngle));
            }
            let arcTurnRadiusLimit = 0;
            const arcAngularWidth = ((arcDirection === 'left' ? (arcStartRadial - arcEndRadial) : (arcEndRadial - arcStartRadial)) + 360) % 360;
            arcLimitAngularWidth = Math.min(arcLimitAngularWidth, arcAngularWidth / 2);
            if (arcLimitAngularWidth > 0) {
                const arcLimitPointAngle = arcStartRadial + arcLimitAngularWidth * (arcDirection === 'left' ? -1 : 1);
                const arcLimitPoint = arcCenter.offset(arcLimitPointAngle, arcRadius, this.geoPointCache[4]);
                const arcLimitRadialPath = this.geoCircleCache[2].setAsGreatCircle(arcCenter, arcLimitPoint);
                // the angle between the radial to the arc endpoint and the track path (directed away from the arc at the point of intersection)
                const theta = Math.acos(Vec3Math.dot(arcLimitRadialPath.center, trackPath.center) * (isArcFirst === isInside ? -1 : 1));
                if (theta >= Math.PI / 2) {
                    if (isInside) {
                        const d = Math.asin(Math.sin(Math.acos(Math.abs(Vec3Math.dot(trackPath.center, turnVertexRadialNormal)))) * Math.sin(arcRadius));
                        arcTurnRadiusLimit = (arcRadius - d) / 2;
                    }
                    else {
                        arcTurnRadiusLimit = Infinity;
                    }
                }
                else {
                    const arcLimitRadialTrackIntersections = this.intersectionVecArrayCache;
                    arcLimitRadialPath.intersection(trackPath, arcLimitRadialTrackIntersections);
                    const arcLimitPointVec = arcLimitPoint.toCartesian(this.vector3Cache[0]);
                    const thresholdNormal = Vec3Math.normalize(Vec3Math.cross(arcLimitRadialPath.center, arcLimitPointVec, this.vector3Cache[1]), this.vector3Cache[1]);
                    const arcLimitRadialTrackIntersection = arcLimitRadialTrackIntersections[Vec3Math.dot(arcLimitRadialTrackIntersections[0], thresholdNormal) >= 0 ? 0 : 1];
                    // cosine of the distance from the arc endpoint to the intersection of the radial to the arc endpoint and the track path
                    const cosD = Vec3Math.dot(arcLimitRadialTrackIntersection, arcLimitPointVec);
                    const sinTheta = Math.sin(theta);
                    const sign = isInside ? -1 : 1;
                    arcTurnRadiusLimit = Math.acos((1 + sinTheta * cosD * sign) / Math.sqrt(1 + 2 * sinTheta * cosD * sign + sinTheta * sinTheta));
                }
            }
            turnRadiusRad = Math.min(desiredTurnRadiusRad, arcTurnRadiusLimit);
            arcCircleOffsetSign = isInside ? -1 : 1;
            trackPathOffsetSign = turnDirection === 'left' ? -1 : 1;
        }
        if (turnRadiusRad === 0) {
            this.setEmptyLegToLegTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        const arcCircleOffset = this.geoCircleCache[2].set(arcCircle.center, arcCircle.radius + turnRadiusRad * arcCircleOffsetSign);
        const trackPathOffset = this.geoCircleCache[3].set(trackPath.center, trackPath.radius + turnRadiusRad * trackPathOffsetSign);
        const intersections = this.intersectionGeoPointArrayCache;
        const intersectionCount = arcCircleOffset.intersectionGeoPoint(trackPathOffset, this.intersectionGeoPointArrayCache);
        if (intersectionCount === 0) {
            this.setEmptyLegToLegTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        let turnCenter;
        if (intersectionCount === 2) {
            if (arcTrackIntersectionCount === 1 || fromVectorEndPoint.distance(intersections[0]) >= fromVectorEndPoint.distance(intersections[1])) {
                turnCenter = intersections[1];
            }
            else {
                turnCenter = intersections[0];
            }
        }
        else {
            turnCenter = intersections[0];
        }
        const arcTangentBearing = (turnCenter.bearingTo(arcCenter) + (arcCircleOffsetSign === 1 ? 0 : 180)) % 360;
        const trackTangentBearing = (turnCenter.bearingTo(trackPathNormalPoint) + (trackPathOffsetSign === 1 ? 0 : 180)) % 360;
        const turnStartBearing = isArcFirst ? arcTangentBearing : trackTangentBearing;
        const turnEndBearing = isArcFirst ? trackTangentBearing : arcTangentBearing;
        let turnAngularDelta = turnEndBearing - turnStartBearing;
        if (turnDirection === 'right' && turnEndBearing <= turnStartBearing) {
            turnAngularDelta += 360;
        }
        else if (turnDirection === 'left' && turnEndBearing >= turnStartBearing) {
            turnAngularDelta -= 360;
        }
        const turnMiddleBearing = ((turnStartBearing + turnAngularDelta / 2) + 360) % 360;
        const turnStart = turnCenter.offset(turnStartBearing, turnRadiusRad, this.geoPointCache[0]);
        const turnEnd = turnCenter.offset(turnEndBearing, turnRadiusRad, this.geoPointCache[1]);
        const turnMiddle = turnCenter.offset(turnMiddleBearing, turnRadiusRad, this.geoPointCache[2]);
        turnRadiusRad = UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER);
        this.setLegToLegTurn(fromLegCalc, toLegCalc, turnDirection, turnRadiusRad, turnCenter, turnStart, turnMiddle, turnEnd);
        return toIndex;
    }
    /**
     * Stages a facility to be loaded.
     * @param icao The ICAO of the facility.
     * @param facilityPromises The array of facility load promises to push to.
     */
    stageFacilityLoad(icao, facilityPromises) {
        if (icao !== ICAO.emptyIcao && !this.facilityCache.has(icao)) {
            let facilityType;
            try {
                facilityType = ICAO.getFacilityType(icao);
            }
            catch (err) {
                //console.log(err);
            }
            if (facilityType !== undefined) {
                try {
                    facilityPromises.push(this.facilityLoader.getFacility(ICAO.getFacilityType(icao), icao)
                        .then(facility => {
                        this.facilityCache.set(facility.icao, facility);
                        return true;
                    })
                        .catch(() => false));
                }
                catch (err) {
                    //console.log(err);
                }
            }
        }
    }
    /**
     * Sets the parameters for a leg to leg turn.
     * @param fromLegCalc The calculations for the leg on which the turn begins.
     * @param toLegCalc The calculations for the leg on which the turn ends.
     * @param direction The direction of the turn.
     * @param radius The radius of the turn, in meters.
     * @param center The location of the center of the turn.
     * @param start The location of the start of the turn.
     * @param middle The location of the midpoint of the turn.
     * @param end The location of the end of the turn.
     */
    setLegToLegTurn(fromLegCalc, toLegCalc, direction, radius, center, start, middle, end) {
        var _a, _b;
        const egress = (_a = fromLegCalc.egressTurn) !== null && _a !== void 0 ? _a : (fromLegCalc.egressTurn = FlightPathUtils.createEmptyCircleVector());
        const ingress = (_b = toLegCalc.ingressTurn) !== null && _b !== void 0 ? _b : (toLegCalc.ingressTurn = FlightPathUtils.createEmptyCircleVector());
        const circle = FlightPathUtils.getTurnCircle(center, UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), direction, this.geoCircleCache[0]);
        egress.radius = circle.radius;
        egress.centerX = circle.center[0];
        egress.centerY = circle.center[1];
        egress.centerZ = circle.center[2];
        egress.startLat = start.lat;
        egress.startLon = start.lon;
        egress.endLat = middle.lat;
        egress.endLon = middle.lon;
        egress.distance = radius === 0 ? 0 : UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, middle, Math.PI), UnitType.METER);
        ingress.radius = circle.radius;
        ingress.centerX = circle.center[0];
        ingress.centerY = circle.center[1];
        ingress.centerZ = circle.center[2];
        ingress.startLat = middle.lat;
        ingress.startLon = middle.lon;
        ingress.endLat = end.lat;
        ingress.endLon = end.lon;
        ingress.distance = radius === 0 ? 0 : UnitType.GA_RADIAN.convertTo(circle.distanceAlong(middle, end, Math.PI), UnitType.METER);
    }
    /**
     * Sets an empty leg to leg turn.
     * @param fromLegCalc The calculations for the leg on which the turn begins.
     * @param toLegCalc The calculations for the leg on which the turn ends.
     */
    setEmptyLegToLegTurn(fromLegCalc, toLegCalc) {
        var _a, _b;
        const fromEnd = { lat: (_a = fromLegCalc.endLat) !== null && _a !== void 0 ? _a : 0, lon: (_b = fromLegCalc.endLon) !== null && _b !== void 0 ? _b : 0 };
        this.setLegToLegTurn(fromLegCalc, toLegCalc, 'left', 0, fromEnd, fromEnd, fromEnd, fromEnd);
    }
}
/**
 *
 */
class FlightPathStateClass {
    constructor() {
        this._planePosition = new GeoPoint(0, 0);
        this.planePosition = this._planePosition.readonly;
        this._planeHeading = 0;
        this._planeAltitude = UnitType.FOOT.createNumber(0);
        this.planeAltitude = this._planeAltitude.readonly;
        this._planeSpeed = UnitType.KNOT.createNumber(0);
        this.planeSpeed = this._planeSpeed.readonly;
        this._planeClimbRate = UnitType.FPM.createNumber(0);
        this.planeClimbRate = this._planeClimbRate.readonly;
        this._desiredTurnRadius = UnitType.METER.createNumber(0);
        this.desiredTurnRadius = this._desiredTurnRadius.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get planeHeading() {
        return this._planeHeading;
    }
    /**
     * Updates this state with the latest information on the airplane.
     * @param options Flight path calculator options.
     */
    updatePlaneState(options) {
        this._planePosition.set(SimVar.GetSimVarValue('PLANE LATITUDE', SimVarValueType.Degree), SimVar.GetSimVarValue('PLANE LONGITUDE', SimVarValueType.Degree));
        this._planeAltitude.set(SimVar.GetSimVarValue('INDICATED ALTITUDE', 'feet'));
        this._planeHeading = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', 'degree');
        this._planeSpeed.set(Math.max(SimVar.GetSimVarValue('GROUND VELOCITY', SimVarValueType.Knots), options.defaultSpeed));
        this._planeClimbRate.set(Math.max(SimVar.GetSimVarValue('VERTICAL SPEED', 'feet per minute'), options.defaultClimbRate));
        this._desiredTurnRadius.set(NavMath.turnRadius(this._planeSpeed.asUnit(UnitType.KNOT), options.bankAngle));
    }
}

/**
 * The details of procedures selected in the flight plan.
 */
class ProcedureDetails {
    constructor() {
        /** The origin runway object, consisting of the index of the origin runway
         * in the origin runway information and the direction */
        this.originRunway = undefined;
        /** The index of the departure in the origin airport information. */
        this.departureIndex = -1;
        /** The index of the departure transition in the origin airport departure information. */
        this.departureTransitionIndex = -1;
        /** The index of the selected runway in the original airport departure information. */
        this.departureRunwayIndex = -1;
        /** The index of the arrival in the destination airport information. */
        this.arrivalIndex = -1;
        /** The index of the arrival transition in the destination airport arrival information. */
        this.arrivalTransitionIndex = -1;
        /** The index of the selected runway transition at the destination airport arrival information. */
        this.arrivalRunwayTransitionIndex = -1;
        /** The index of the apporach in the destination airport information.*/
        this.approachIndex = -1;
        /** The index of the approach transition in the destination airport approach information.*/
        this.approachTransitionIndex = -1;
        /**
         * The destination runway object, consisting of the index of the destination runway
         * in the destination runway information and the direction
         */
        this.destinationRunway = undefined;
    }
}
/**
 * A prototype for signalling application-specific type metadata for plan segments.
 */
var FlightPlanSegmentType;
(function (FlightPlanSegmentType) {
    FlightPlanSegmentType["Origin"] = "Origin";
    FlightPlanSegmentType["Departure"] = "Departure";
    FlightPlanSegmentType["Enroute"] = "Enroute";
    FlightPlanSegmentType["Arrival"] = "Arrival";
    FlightPlanSegmentType["Approach"] = "Approach";
    FlightPlanSegmentType["Destination"] = "Destination";
    FlightPlanSegmentType["MissedApproach"] = "MissedApproach";
    FlightPlanSegmentType["RandomDirectTo"] = "RandomDirectTo";
})(FlightPlanSegmentType || (FlightPlanSegmentType = {}));
/**
 * A segment of a flight plan.
 */
class FlightPlanSegment {
    /**
     * Creates a new FlightPlanSegment.
     * @param segmentIndex The index of the segment within the flight plan.
     * @param offset The leg offset within the original flight plan that
     * the segment starts at.
     * @param legs The legs in the flight plan segment.
     * @param segmentType The type of segment this is.
     * @param airway The airway associated with this segment, if any.
     */
    constructor(segmentIndex, offset, legs, segmentType = FlightPlanSegmentType.Enroute, airway) {
        this.segmentIndex = segmentIndex;
        this.offset = offset;
        this.legs = legs;
        this.segmentType = segmentType;
        this.airway = airway;
    }
}
/** An empty flight plan segment. */
FlightPlanSegment.Empty = new FlightPlanSegment(-1, -1, []);

var PlanChangeType;
(function (PlanChangeType) {
    PlanChangeType["Added"] = "Added";
    PlanChangeType["Inserted"] = "Inserted";
    PlanChangeType["Removed"] = "Removed";
    PlanChangeType["Changed"] = "Changed";
    PlanChangeType["Cleared"] = "Cleared";
})(PlanChangeType || (PlanChangeType = {}));
var ActiveLegType;
(function (ActiveLegType) {
    ActiveLegType["Lateral"] = "Lateral";
    ActiveLegType["Vertical"] = "Vertical";
    ActiveLegType["Calculating"] = "Calculating";
})(ActiveLegType || (ActiveLegType = {}));
var OriginDestChangeType;
(function (OriginDestChangeType) {
    OriginDestChangeType["OriginAdded"] = "OriginAdded";
    OriginDestChangeType["OriginRemoved"] = "OriginRemoved";
    OriginDestChangeType["DestinationAdded"] = "DestinationAdded";
    OriginDestChangeType["DestinationRemoved"] = "DestinationRemoved";
})(OriginDestChangeType || (OriginDestChangeType = {}));
/**
 * A flight plan managed by the flight plan system.
 */
class FlightPlan {
    /**
     * Creates an instance of a FlightPlan.
     * @param planIndex The index within the flight planner of this flight plan.
     * @param calculator The flight path calculator to use to calculate the flight path.
     */
    constructor(planIndex, calculator) {
        this.planIndex = planIndex;
        this.calculator = calculator;
        this._activeLateralLeg = 0;
        this._activeVerticalLeg = 0;
        this._activeCalculatingLeg = 0;
        /** The direct to metadata for this plan. */
        this.directToData = { segmentIndex: -1, segmentLegIndex: -1 };
        /** Events fired when the plan is modified. */
        this.events = {};
        /** A callback fired when a flight plan leg is to be named. */
        this.onLegNameRequested = this.buildDefaultLegName;
        /** The details about the selected procedures. */
        this.procedureDetails = new ProcedureDetails();
        /** The flight plan segments that make up this flight plan. */
        this.planSegments = [];
        /** User assignable data. */
        this.userData = {};
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The ICAO of the origin airport in the flight plan, if any. */
    get originAirport() {
        return this._originAirport;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The ICAO of the destination airport in the flight plan, if any. */
    get destinationAirport() {
        return this._destinationAirport;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active lateral navigation leg. */
    get activeLateralLeg() {
        return this._activeLateralLeg;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active vertical navigation leg. */
    get activeVerticalLeg() {
        return this._activeVerticalLeg;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active calculating leg. */
    get activeCalculatingLeg() {
        return this._activeCalculatingLeg;
    }
    /**
     * Gets the current number of legs in the flight plan.
     * @returns The number of legs in the plan.
     */
    get length() {
        const segment = this.planSegments[this.planSegments.length - 1];
        if (segment !== undefined) {
            return segment.offset + segment.legs.length;
        }
        return 0;
    }
    /**
     * Gets the current number of segments in the flight plan.
     * @returns The number of legs in the plan.
     */
    get segmentCount() {
        return this.planSegments.length;
    }
    /**
     * Gets the legs for the flightplan.
     * @yields The flight plan legs.
     */
    *legs() {
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment !== undefined) {
                for (let l = 0; l < segment.legs.length; l++) {
                    yield segment.legs[l];
                }
            }
        }
    }
    /**
     * Gets the segments for the flightplan.
     * @yields The flight plan segments.
     */
    *segments() {
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment !== undefined) {
                yield segment;
            }
        }
    }
    /**
     * Gets all of the segments of a given type.
     * @param segmentType The type of the segments to retrieve.
     * @yields The segments of the requested type.
     */
    *segmentsOfType(segmentType) {
        for (const segment of this.segments()) {
            if (segment.segmentType == segmentType) {
                yield segment;
            }
        }
    }
    /**
     * Adds a segment to the flight plan at a specified index.
     * @param segmentIndex The index of the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any.
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    addSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
        const segment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
        this.planSegments[segmentIndex] = segment;
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, PlanChangeType.Added, segment);
        return segment;
    }
    /**
     * Inserts a segment into the flight plan at the specified index and
     * reflows the subsequent segments.
     * @param segmentIndex The index to insert the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    insertSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
        const segment = this.planSegments[segmentIndex];
        if (segment !== undefined) {
            const newSegment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
            this.planSegments.splice(segmentIndex, 0, newSegment);
            this.reflowSegments();
            this.reflowSegmentOffsets();
            notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, PlanChangeType.Inserted, newSegment);
            return newSegment;
        }
        else {
            return this.addSegment(segmentIndex, segmentType, airway, notify);
        }
    }
    /**
     * Reflows the flight plan segments after an insert.
     */
    reflowSegments() {
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment !== undefined && segment.segmentIndex !== i) {
                segment.segmentIndex = i;
            }
        }
    }
    /**
     * Deletes a segment from the flight plan, leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    deleteSegment(segmentIndex, notify = true) {
        const segment = this.planSegments[segmentIndex];
        if (segmentIndex === this.planSegments.length - 1) {
            this.planSegments.splice(segmentIndex, 1);
        }
        else {
            delete this.planSegments[segmentIndex];
        }
        if (this.directToData.segmentIndex === segmentIndex) ;
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, PlanChangeType.Removed, segment);
    }
    /**
     * Removes a segment from the flight plan and reflows the segments following
     * the removed segment, not leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeSegment(segmentIndex, notify = true) {
        const segment = this.planSegments[segmentIndex];
        this.planSegments.splice(segmentIndex, 1);
        this.reflowSegments();
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, PlanChangeType.Removed, segment);
    }
    /**
     * Gets a flight plan segment from the plan.
     * @param segmentIndex The index of the segment to get; if not specified returns the active segment.
     * @returns The requested flight plan segment.
     * @throws An error if the flight plan segment could not be found.
     */
    getSegment(segmentIndex) {
        if (segmentIndex === undefined) {
            let calculatedSegmentIndex = 0;
            for (const segment of this.segments()) {
                if (this.activeLateralLeg == 0 && segment.legs.length == 0) {
                    calculatedSegmentIndex++;
                }
                else if (this.activeLateralLeg > segment.offset + segment.legs.length) {
                    calculatedSegmentIndex++;
                }
                else {
                    break;
                }
            }
            const segment = this.planSegments[calculatedSegmentIndex];
            if (segment !== undefined) {
                return segment;
            }
        }
        else if (segmentIndex >= 0) {
            const segment = this.planSegments[segmentIndex];
            if (segment !== undefined) {
                return segment;
            }
        }
        throw new Error(`Flight plan segment with segment index ${segmentIndex} could not be found.`);
    }
    /**
     * Adds a leg to the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param leg The leg to add to the plan.
     * @param index The index of the leg in the segment to insert. Will add to the end of the segment if omitted.
     * @param isInDirectToSequence Whether the new leg is part of a direct to sequence.
     * @param isInMissedApproachSequence Whether the new leg is part of a missed approach sequence.
     * @param notify Whether or not to send notifications after the operation.
     * @returns the leg that was added.
     */
    addLeg(segmentIndex, leg, index, isInDirectToSequence = false, isInMissedApproachSequence = false, notify = true) {
        const segment = this.getSegment(segmentIndex);
        const legDefinition = { leg, isInDirectToSequence, isInMissedApproachSequence };
        if (index === undefined) {
            segment.legs.push(legDefinition);
            index = segment.legs.length - 1;
        }
        else {
            segment.legs.splice(index, 0, legDefinition);
        }
        legDefinition.name = this.onLegNameRequested(leg);
        this.reflowSegmentOffsets();
        notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, index, PlanChangeType.Added, legDefinition);
        return legDefinition;
    }
    /**
     * Gets a leg from the flight plan.
     * @param index The index of the leg to get.
     * @returns The definition of the plan leg.
     * @throws An error if the leg could not be found.
     */
    getLeg(index) {
        for (const segment of this.segments()) {
            if (segment.offset <= index && index < segment.offset + segment.legs.length) {
                return segment.legs[index - segment.offset];
            }
        }
        throw new Error('Leg with index ${index} could not be found.');
    }
    /**
     * Removes a leg from the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param index The index of the leg in the segment to remove. Will remove from the end of the segment if ommitted.
     * @param notify Whether or not to send notifications after the operation.
     * @returns the leg that was removed, or null if a leg was not removed.
     */
    removeLeg(segmentIndex, index, notify = true) {
        const segment = this.getSegment(segmentIndex);
        let legDefinition;
        if (index === undefined) {
            legDefinition = segment.legs.pop();
            index = segment.legs.length;
        }
        else {
            const deleted = segment.legs.splice(index, 1);
            legDefinition = deleted[0];
        }
        if (this.directToData.segmentIndex === segmentIndex && this.directToData.segmentLegIndex === index) ;
        this.reflowSegmentOffsets();
        notify && legDefinition && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, index, PlanChangeType.Removed, legDefinition);
        return legDefinition !== null && legDefinition !== void 0 ? legDefinition : null;
    }
    /**
     * Calculates the flight path for the plan.
     * @param index The leg index to start calculating from.
     * @param notify Whether or not to send notifications after the operation.
     */
    async calculate(index, notify = true) {
        const legs = [...this.legs()];
        await this.calculator.calculateFlightPath(legs, this.activeLateralLeg, index === undefined ? this.activeCalculatingLeg : index);
        notify && this.events.onCalculated && this.events.onCalculated(index);
    }
    /**
     * Sets the origin airport in the flight plan.
     * @param facilityIcao The origin airport to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setOriginAirport(facilityIcao, notify = true) {
        this._originAirport = facilityIcao;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginAdded, facilityIcao);
    }
    /**
     * Removes the origin airport from the flight plan.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeOriginAirport(notify = true) {
        const facilityIcao = this._originAirport;
        this._originAirport = undefined;
        this.procedureDetails.departureIndex = -1;
        this.procedureDetails.departureRunwayIndex = -1;
        this.procedureDetails.departureTransitionIndex = -1;
        this.procedureDetails.originRunway = undefined;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginRemoved, facilityIcao);
    }
    /**
     * Sets the destination airport in the flight plan.
     * @param facilityIcao The destination airport to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setDestinationAirport(facilityIcao, notify = true) {
        this._destinationAirport = facilityIcao;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationAdded, facilityIcao);
    }
    /**
     * Removes the destination airport from the flight plan.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeDestinationAirport(notify = true) {
        const facilityIcao = this._destinationAirport;
        this._destinationAirport = undefined;
        this.procedureDetails.approachIndex = -1;
        this.procedureDetails.approachTransitionIndex = -1;
        this.procedureDetails.arrivalIndex = -1;
        this.procedureDetails.arrivalRunwayTransitionIndex = -1;
        this.procedureDetails.arrivalTransitionIndex = -1;
        this.procedureDetails.destinationRunway = undefined;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationRemoved, facilityIcao);
    }
    /**
     * Sets the active lateral leg index in the flight plan.
     * @param index The index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setLateralLeg(index, notify = true) {
        let previousLegIndex = -1;
        let previousSegmentIndex = -1;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        if (this.length > 0) {
            previousSegmentIndex = this.getSegmentIndex(this._activeLateralLeg);
            if (previousSegmentIndex > -1) {
                previousLegIndex = this._activeLateralLeg - this.getSegment(previousSegmentIndex).offset;
            }
            this._activeLateralLeg = Utils.Clamp(index, 0, this.length - 1);
            segmentIndex = this.getSegmentIndex(this._activeLateralLeg);
            if (segmentIndex > -1) {
                segmentLegIndex = this._activeLateralLeg - this.getSegment(segmentIndex).offset;
            }
        }
        else {
            this._activeLateralLeg = 0;
        }
        notify
            && this.events.onActiveLegChanged
            && this.events.onActiveLegChanged(this._activeLateralLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Lateral);
    }
    /**
     * Sets the active lateral leg index in the flight plan.
     * @param index The index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setVerticalLeg(index, notify = true) {
        let previousLegIndex = -1;
        let previousSegmentIndex = -1;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        if (this.length > 0) {
            previousSegmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
            if (previousSegmentIndex > -1) {
                previousLegIndex = this._activeVerticalLeg - this.getSegment(previousSegmentIndex).offset;
            }
            this._activeVerticalLeg = Utils.Clamp(index, 0, this.length - 1);
            segmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
            if (segmentIndex > -1) {
                segmentLegIndex = this._activeVerticalLeg - this.getSegment(segmentIndex).offset;
            }
        }
        else {
            this._activeVerticalLeg = 0;
        }
        notify
            && this.events.onActiveLegChanged
            && this.events.onActiveLegChanged(this._activeVerticalLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Vertical);
    }
    /**
     * Sets the active calculating leg index in the flight plan.
     * @param index The index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setCalculatingLeg(index, notify = true) {
        let previousLegIndex = -1;
        let previousSegmentIndex = -1;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        if (this.length > 0) {
            previousSegmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
            if (previousSegmentIndex > -1) {
                previousLegIndex = this._activeCalculatingLeg - this.getSegment(previousSegmentIndex).offset;
            }
            this._activeCalculatingLeg = Utils.Clamp(index, 0, this.length - 1);
            segmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
            if (segmentIndex > -1) {
                segmentLegIndex = this._activeCalculatingLeg - this.getSegment(segmentIndex).offset;
            }
        }
        else {
            this._activeCalculatingLeg = 0;
        }
        notify
            && this.events.onActiveLegChanged
            && this.events.onActiveLegChanged(this._activeCalculatingLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Calculating);
    }
    /**
     * Sets the flight plan procedure details.
     * @param details The details of the flight plan's procedures.
     * @param notify Whether or not to send notifications after the operation.
     */
    setProcedureDetails(details, notify = true) {
        Object.assign(this.procedureDetails, details);
        notify && this.events.onProcedureDetailsChanged && this.events.onProcedureDetailsChanged(this.procedureDetails);
    }
    /**
     * Gets the index of a flight plan leg in this flight plan.
     * @param leg A flight plan leg definition.
     * @returns the index of the leg, or -1 if the leg is not in this flight plan.
     */
    getLegIndexFromLeg(leg) {
        let index = 0;
        for (const toCompare of this.legs()) {
            if (toCompare === leg) {
                return index;
            }
            index++;
        }
        return -1;
    }
    /**
     * Gets the flight plan segment to which a leg belongs.
     * @param leg A flight plan leg definition.
     * @returns The segment to which the leg belongs, or null if the leg is not in this flight plan.
     */
    getSegmentFromLeg(leg) {
        for (const segment of this.segments()) {
            if (segment.legs.includes(leg)) {
                return segment;
            }
        }
        return null;
    }
    /**
     * Gets the segment index for a given global leg index.
     * @param legIndex The global leg index to get the segment index for.
     * @returns The segment index for the given leg index.
     */
    getSegmentIndex(legIndex) {
        for (const segment of this.segments()) {
            if (segment.offset <= legIndex && legIndex < segment.offset + segment.legs.length) {
                return segment.segmentIndex;
            }
        }
        return -1;
    }
    /**
     * Gets the leg immediately previous to a position in this flight plan specified by segment index and leg index.
     * @param segmentIndex A segment index.
     * @param legIndex A leg index.
     * @returns the leg immediately previous to the specified position, or null if there is no such leg.
     */
    getPrevLeg(segmentIndex, legIndex) {
        var _a, _b;
        if (segmentIndex < 0) {
            return null;
        }
        segmentIndex = Math.min(segmentIndex, this.planSegments.length);
        legIndex = Math.min(legIndex, (_b = (_a = this.planSegments[segmentIndex]) === null || _a === void 0 ? void 0 : _a.legs.length) !== null && _b !== void 0 ? _b : 0);
        let segment = this.planSegments[segmentIndex];
        let leg = segment === null || segment === void 0 ? void 0 : segment.legs[legIndex - 1];
        while (!leg && --segmentIndex >= 0) {
            segment = this.planSegments[segmentIndex];
            if (segment) {
                leg = segment.legs[segment.legs.length - 1];
            }
        }
        return leg !== null && leg !== void 0 ? leg : null;
    }
    /**
     * Gets the leg immediately after a position in this flight plan specified by segment index and leg index.
     * @param segmentIndex A segment index.
     * @param legIndex A leg index.
     * @returns the leg immediately after the specified position, or null if there is no such leg.
     */
    getNextLeg(segmentIndex, legIndex) {
        if (segmentIndex >= this.planSegments.length) {
            return null;
        }
        segmentIndex = Math.max(segmentIndex, -1);
        legIndex = Math.max(legIndex, -1);
        let segment = this.planSegments[segmentIndex];
        let leg = segment === null || segment === void 0 ? void 0 : segment.legs[legIndex + 1];
        while (!leg && ++segmentIndex < this.planSegments.length) {
            segment = this.planSegments[segmentIndex];
            if (segment) {
                leg = segment.legs[0];
            }
        }
        return leg !== null && leg !== void 0 ? leg : null;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setDirectToData(arg1, arg2, arg3) {
        if (typeof arg1 !== 'number') {
            // arg1 is a LegDefinition or null.
            arg1 = arg1 ? this.getLegIndexFromLeg(arg1) : -1;
        }
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        let notify = true;
        if (typeof arg2 !== 'number') {
            // arg1 is global leg index
            if (arg1 >= 0) {
                segmentIndex = this.getSegmentIndex(arg1);
                if (segmentIndex >= 0) {
                    segmentLegIndex = arg1 - this.getSegment(segmentIndex).offset;
                }
            }
            notify = arg2 !== null && arg2 !== void 0 ? arg2 : true;
        }
        else {
            segmentIndex = arg1;
            segmentLegIndex = arg2;
            notify = arg3 !== null && arg3 !== void 0 ? arg3 : true;
        }
        this.directToData.segmentIndex = segmentIndex;
        this.directToData.segmentLegIndex = segmentLegIndex;
        notify && this.events.onDirectDataChanged && this.events.onDirectDataChanged(this.directToData);
    }
    /**
     * Sets the airway for a segment.
     * @param segmentIndex A segment index.
     * @param airway The airway name.
     * @param notify is whether to send an event for this change
     */
    setAirway(segmentIndex, airway, notify = true) {
        const segment = this.getSegment(segmentIndex);
        if (!airway) {
            segment.airway = undefined;
        }
        else {
            segment.airway = airway;
        }
        this.events.onSegmentChanged && notify && this.events.onSegmentChanged(segmentIndex, PlanChangeType.Changed, segment);
    }
    /**
     * Sets user data in the flight plan.
     * @param key The key of the user data.
     * @param data The data to set.
     * @param notify Whether or not to notify subscribers.
     */
    setUserData(key, data, notify = true) {
        this.userData[key] = data;
        this.events.onUserDataSet && notify && this.events.onUserDataSet(key, data);
    }
    /**
     * Sets user data in the flight plan.
     * @param key The key of the user data.
     * @param notify Whether or not to notify subscribers.
     */
    deleteUserData(key, notify = true) {
        if (this.userData[key] !== undefined) {
            delete this.userData[key];
        }
        this.events.onUserDataDelete && notify && this.events.onUserDataDelete(key);
    }
    /**
     * Gets user data from the flight plan.
     * @param key The key of the user data.
     * @returns The user data, if found.
     */
    getUserData(key) {
        return this.userData[key];
    }
    /**
     * Reflows all flight plan segment offsets after a plan change.
     */
    reflowSegmentOffsets() {
        let nextOffset = undefined;
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment) {
                if (nextOffset === undefined) {
                    segment.offset = 0;
                }
                else {
                    segment.offset = nextOffset;
                }
                nextOffset = segment.legs.length + segment.offset;
            }
        }
    }
    /**
     * Builds leg names using default nomenclature.
     * @param leg The leg to build a name for.
     * @returns The name of the leg.
     */
    buildDefaultLegName(leg) {
        let legDistanceNM;
        switch (leg.type) {
            case LegType.CA:
            case LegType.FA:
            case LegType.VA:
                return `${UnitType.METER.convertTo(leg.altitude1, UnitType.FOOT).toFixed(0)}FT`;
            case LegType.FM:
            case LegType.VM:
                return 'MANSEQ';
            case LegType.FC:
                legDistanceNM = Math.round(UnitType.METER.convertTo(leg.distance, UnitType.NMILE));
                return `D${leg.course.toFixed(0).padStart(3, '0')}${String.fromCharCode(64 + Utils.Clamp(legDistanceNM, 1, 26))}`;
            case LegType.CD:
            case LegType.FD:
            case LegType.VD:
                legDistanceNM = UnitType.METER.convertTo(leg.distance, UnitType.NMILE);
                return `${ICAO.getIdent(leg.originIcao)}${legDistanceNM.toFixed(1)}`;
            case LegType.CR:
            case LegType.VR:
                return `${ICAO.getIdent(leg.originIcao)}${leg.theta.toFixed(0)}`;
            case LegType.CI:
            case LegType.VI:
                return 'INTRCPT';
            case LegType.PI:
                return 'PROC. TURN';
            case LegType.HA:
            case LegType.HM:
            case LegType.HF:
                return 'HOLD';
            default:
                return ICAO.getIdent(leg.fixIcao);
        }
    }
    /**
     * Sets the origin runway in procedure details.
     * @param runway The oneway runway to set as the origin, or undefined
     * @param notify Whether or not to notify subscribers.
     */
    setOriginRunway(runway = undefined, notify = true) {
        this.procedureDetails.originRunway = runway;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the destination runway in procedure details.
     * @param runway The oneway runway to set as the destination, or undefined
     * @param notify Whether or not to notify subscribers.
     */
    setDestinationRunway(runway = undefined, notify = true) {
        this.procedureDetails.destinationRunway = runway;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the departure procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param departureIndex The index of the departure in the origin airport information
     * @param departureTransitionIndex The index of the departure transition in the origin airport departure information
     * @param departureRunwayIndex The index of the selected runway in the original airport departure information
     * @param notify Whether or not to notify subscribers.
     */
    setDeparture(facilityIcao = undefined, departureIndex = -1, departureTransitionIndex = -1, departureRunwayIndex = -1, notify = true) {
        this.procedureDetails.departureIndex = departureIndex;
        if (departureIndex === -1) {
            facilityIcao = undefined;
            departureTransitionIndex = -1;
            departureRunwayIndex = -1;
        }
        this.procedureDetails.departureFacilityIcao = facilityIcao;
        this.procedureDetails.departureTransitionIndex = departureTransitionIndex;
        this.procedureDetails.departureRunwayIndex = departureRunwayIndex;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the arrival procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param arrivalIndex The index of the arrival in the destination airport information
     * @param arrivalTransitionIndex index of the arrival transition in the destination airport arrival information
     * @param arrivalRunwayTransitionIndex The index of the selected runway transition at the destination airport arrival information
     * @param notify Whether or not to notify subscribers
     */
    setArrival(facilityIcao = undefined, arrivalIndex = -1, arrivalTransitionIndex = -1, arrivalRunwayTransitionIndex = -1, notify = true) {
        this.procedureDetails.arrivalIndex = arrivalIndex;
        if (arrivalIndex === -1) {
            facilityIcao = undefined;
            arrivalTransitionIndex = -1;
            arrivalRunwayTransitionIndex = -1;
        }
        this.procedureDetails.arrivalFacilityIcao = facilityIcao;
        this.procedureDetails.arrivalTransitionIndex = arrivalTransitionIndex;
        this.procedureDetails.arrivalRunwayTransitionIndex = arrivalRunwayTransitionIndex;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the approach procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param approachIndex The index of the apporach in the destination airport information
     * @param approachTransitionIndex The index of the approach transition in the destination airport approach information
     * @param notify Whether or not to notify subscribers
     */
    setApproach(facilityIcao = undefined, approachIndex = -1, approachTransitionIndex = -1, notify = true) {
        this.procedureDetails.approachIndex = approachIndex;
        if (approachIndex === -1) {
            facilityIcao = undefined;
            approachTransitionIndex = -1;
        }
        this.procedureDetails.approachFacilityIcao = facilityIcao;
        this.procedureDetails.approachIndex = approachIndex;
        this.procedureDetails.approachTransitionIndex = approachTransitionIndex;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Copies the flight plan.
     * @param planIndex The flight plan index to assign to this plan, or the same plan
     * index if not provided.
     * @returns The copied flight plan.
     */
    copy(planIndex) {
        if (planIndex === undefined) {
            planIndex = this.planIndex;
        }
        const newPlan = new FlightPlan(planIndex, this.calculator);
        newPlan.setProcedureDetails(this.procedureDetails, false);
        newPlan.setDirectToData(this.directToData.segmentIndex, this.directToData.segmentLegIndex);
        for (const segment of this.segments()) {
            newPlan.addSegment(segment.segmentIndex, segment.segmentType, segment.airway, false);
            for (const leg of segment.legs) {
                newPlan.addLeg(segment.segmentIndex, leg.leg, undefined, leg.isInDirectToSequence, leg.isInMissedApproachSequence, false);
            }
        }
        if (this.originAirport !== undefined) {
            newPlan.setOriginAirport(this.originAirport, false);
        }
        if (this.destinationAirport !== undefined) {
            newPlan.setDestinationAirport(this.destinationAirport, false);
        }
        newPlan.setLateralLeg(this.activeLateralLeg);
        newPlan.setVerticalLeg(this.activeVerticalLeg);
        newPlan.setCalculatingLeg(this.activeCalculatingLeg);
        if (this.userData.size > 0) {
            for (const kv in this.userData) {
                newPlan.setUserData(kv[0], kv[1], false);
            }
        }
        return newPlan;
    }
}
/**
 * Creates a default instance of a flight plan leg.
 * @param partial A portion of leg options to apply.
 * @returns A default instance of a flight plan leg.
 */
FlightPlan.createLeg = (partial) => Object.assign({
    type: 0,
    fixIcao: ICAO.emptyIcao,
    arcCenterFixIcao: ICAO.emptyIcao,
    originIcao: ICAO.emptyIcao,
    flyOver: 0,
    turnDirection: 0,
    trueDegrees: 0,
    theta: 0,
    rho: 0,
    distance: 0,
    distanceMinutes: 0,
    speedRestriction: 0,
    altDesc: 0,
    altitude1: 0,
    altitude2: 0,
    course: 0,
    fixTypeFlags: 0
}, partial);

/**
 * Manages the active flightplans of the navigational systems.
 */
class FlightPlanner {
    /**
     * Creates an instance of the FlightPlanner.
     * @param bus The event bus instance to notify changes on.
     * @param calculator The flight path calculator to use with this planner.
     */
    constructor(bus, calculator) {
        this.bus = bus;
        this.calculator = calculator;
        /** The flight plans managed by this flight planner. */
        this.flightPlans = [];
        this.ignoreSync = false;
        /** The active flight plan index. */
        this._activePlanIndex = 0;
        this.flightPlanSynced = new SubEvent();
        this.publisher = bus.getPublisher();
        const subscriber = bus.getSubscriber();
        subscriber.on('fplsync_fplRequest').handle(() => !this.ignoreSync && this.onFlightPlanRequest());
        subscriber.on('fplsync_fplResponse').handle(data => !this.ignoreSync && this.onFlightPlanResponse(data));
        subscriber.on('fplsync_fplCreated').handle(data => !this.ignoreSync && this.onPlanCreated(data));
        subscriber.on('fplsync_fplDeleted').handle(data => !this.ignoreSync && this.onPlanDeleted(data));
        subscriber.on('fplsync_fplActiveLegChange').handle(data => !this.ignoreSync && this.onActiveLegChanged(data));
        subscriber.on('fplsync_fplLegChange').handle(data => !this.ignoreSync && this.onLegChanged(data));
        subscriber.on('fplsync_fplSegmentChange').handle(data => !this.ignoreSync && this.onSegmentChanged(data));
        subscriber.on('fplsync_fplCalculated').handle(data => !this.ignoreSync && this.onCalculated(data));
        subscriber.on('fplsync_fplOriginDestChanged').handle(data => !this.ignoreSync && this.onOriginDestChanged(data));
        subscriber.on('fplsync_fplProcDetailsChanged').handle(data => !this.ignoreSync && this.onProcedureDetailsChanged(data));
        subscriber.on('fplsync_fplIndexChanged').handle(data => !this.ignoreSync && this.onPlanIndexChanged(data));
        subscriber.on('fplsync_fplCopied').handle(data => !this.ignoreSync && this.onPlanCopied(data));
        subscriber.on('fplsync_fplUserDataSet').handle(data => !this.ignoreSync && this.onUserDataSet(data));
        subscriber.on('fplsync_fplUserDataDelete').handle(data => !this.ignoreSync && this.onUserDataDelete(data));
        subscriber.on('fplsync_fplDirectToDataChanged').handle(data => !this.ignoreSync && this.onDirectToDataChanged(data));
    }
    /**
     * Set a new active plan index.
     * @param planIndex The new active plan index.
     */
    set activePlanIndex(planIndex) {
        this._activePlanIndex = planIndex;
    }
    /**
     * Get the active plan index.
     * @returns The active plan index number.
     */
    get activePlanIndex() {
        return this._activePlanIndex;
    }
    /**
     * Requests synchronization from other FlightPlanner instances.
     */
    requestSync() {
        this.sendFlightPlanRequest();
    }
    /**
     * An event generated when a set of flight plans is requested.
     */
    onFlightPlanRequest() {
        this.ignoreSync = true;
        this.publisher.pub('fplsync_fplResponse', {
            flightPlans: this.flightPlans.map(plan => {
                const newPlan = Object.assign({}, plan);
                newPlan.calculator = undefined;
                return newPlan;
            }), planIndex: this.activePlanIndex
        }, true, false);
        this.ignoreSync = false;
    }
    /**
     * Sends a flight plan request event.
     */
    sendFlightPlanRequest() {
        this.ignoreSync = true;
        this.publisher.pub('fplsync_fplRequest', {}, true, false);
        this.ignoreSync = false;
    }
    /**
     * A callback which is called in response to flight plan request response sync events.
     * @param data The event data.
     */
    onFlightPlanResponse(data) {
        for (let i = 0; i < data.flightPlans.length; i++) {
            const newPlan = Object.assign(new FlightPlan(i, this.calculator), data.flightPlans[i]);
            newPlan.events = this.buildPlanEventHandlers(i);
            this.flightPlans[i] = newPlan;
            this.sendEvent('fplLoaded', { planIndex: i }, false);
        }
        this.setActivePlanIndex(data.planIndex);
        this.flightPlanSynced.notify(this, true);
    }
    /**
     * Checks whether a flight plan exists at a specified index.
     * @param planIndex The index to check.
     * @returns Whether a a flight plan exists at `planIndex`.
     */
    hasFlightPlan(planIndex) {
        return !!this.flightPlans[planIndex];
    }
    /**
     * Gets a flight plan from the flight planner.
     * @param planIndex The index of the flight plan.
     * @returns The requested flight plan.
     * @throws Error if a flight plan does not exist at `planIndex`.
     */
    getFlightPlan(planIndex) {
        const plan = this.flightPlans[planIndex];
        if (!plan) {
            throw new Error(`FlightPlanner: Flight plan does not exist at index ${planIndex}`);
        }
        return plan;
    }
    /**
     * Creates a new flight plan at a specified index if one does not already exist.
     * @param planIndex The index at which to create the new flight plan.
     * @param notify Whether to send an event notification. True by default.
     * @returns The new flight plan, or the existing flight plan at `planIndex`.
     */
    createFlightPlan(planIndex, notify = true) {
        if (this.flightPlans[planIndex]) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.flightPlans[planIndex];
        }
        const flightPlan = new FlightPlan(planIndex, this.calculator);
        flightPlan.events = this.buildPlanEventHandlers(planIndex);
        this.flightPlans[planIndex] = flightPlan;
        notify && this.sendPlanCreated(planIndex);
        return flightPlan;
    }
    /**
     * A callback which is called in response to flight plan request response sync events.
     * @param data The event data.
     */
    onPlanCreated(data) {
        this.createFlightPlan(data.planIndex, false);
        this.sendEvent('fplCreated', data, false);
    }
    /**
     * Sends a flight plan created event.
     * @param planIndex The index of the flight plan that was created.
     */
    sendPlanCreated(planIndex) {
        const data = { planIndex };
        this.sendEvent('fplCreated', data, true);
    }
    /**
     * Deletes a flight plan from the flight planner.
     * @param planIndex The index of the flight plan to delete.
     * @param notify Whether to send an event notification. True by default.
     */
    deleteFlightPlan(planIndex, notify = true) {
        const flightPlan = this.flightPlans[planIndex];
        if (flightPlan) {
            flightPlan.events = {};
            this.flightPlans[planIndex] = undefined;
            notify && this.sendPlanDeleted(planIndex);
        }
        if (planIndex === this.flightPlans.length - 1) {
            this.flightPlans.length--;
        }
    }
    /**
     * A callback which is called in response to flight plan deleted sync events.
     * @param data The event data.
     */
    onPlanDeleted(data) {
        this.deleteFlightPlan(data.planIndex, false);
        this.sendEvent('fplDeleted', data, false);
    }
    /**
     * Sends a flight plan deleted event.
     * @param planIndex The index of the flight plan that was created.
     */
    sendPlanDeleted(planIndex) {
        const data = { planIndex };
        this.sendEvent('fplDeleted', data, true);
    }
    /**
     * Builds the plan event handlers for the flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The plan event handlers.
     */
    buildPlanEventHandlers(planIndex) {
        return {
            onLegChanged: (segmentIndex, index, type, leg) => this.sendLegChanged(planIndex, segmentIndex, index, type, leg),
            onSegmentChanged: (segmentIndex, type, segment) => this.sendSegmentChanged(planIndex, segmentIndex, type, segment),
            onActiveLegChanged: (index, segmentIndex, legIndex, previousSegmentIndex, previousLegIndex, type) => this.sendActiveLegChange(planIndex, index, segmentIndex, legIndex, previousSegmentIndex, previousLegIndex, type),
            onCalculated: (index) => this.sendCalculated(planIndex, index),
            onOriginDestChanged: (type, airport) => this.sendOriginDestChanged(planIndex, type, airport),
            onProcedureDetailsChanged: (details) => this.sendProcedureDetailsChanged(planIndex, details),
            onUserDataSet: (key, data) => this.sendUserDataSet(planIndex, key, data),
            onUserDataDelete: (key) => this.sendUserDataDelete(planIndex, key),
            onDirectDataChanged: (directToData) => this.sendDirectToData(planIndex, directToData)
        };
    }
    /**
     * Checks whether an active flight plan exists.
     * @returns Whether an active flight plan exists.
     */
    hasActiveFlightPlan() {
        return this.hasFlightPlan(this.activePlanIndex);
    }
    /**
     * Gets the currently active flight plan from the flight planner.
     * @returns The currently active flight plan.
     * @throws Error if no active flight plan exists.
     */
    getActiveFlightPlan() {
        return this.getFlightPlan(this.activePlanIndex);
    }
    /**
     * Copies a flight plan to another flight plan slot.
     * @param sourcePlanIndex The source flight plan index.
     * @param targetPlanIndex The target flight plan index.
     * @param notify Whether or not to notify subscribers that the plan has been copied.
     */
    copyFlightPlan(sourcePlanIndex, targetPlanIndex, notify = true) {
        const sourcePlan = this.flightPlans[sourcePlanIndex];
        if (!sourcePlan) {
            return;
        }
        const newPlan = sourcePlan.copy(targetPlanIndex);
        newPlan.events = this.buildPlanEventHandlers(targetPlanIndex);
        this.flightPlans[targetPlanIndex] = newPlan;
        if (notify) {
            this.sendPlanCopied(sourcePlanIndex, targetPlanIndex);
        }
    }
    /**
     * A callback which is called in response to flight plan copied sync events.
     * @param data The event data.
     */
    onPlanCopied(data) {
        this.copyFlightPlan(data.planIndex, data.targetPlanIndex, false);
        this.sendEvent('fplCopied', data, false);
    }
    /**
     * Sends a leg change event.
     * @param planIndex The index of the flight plan that was the source of the copy.
     * @param targetPlanIndex The index of the copy.
     */
    sendPlanCopied(planIndex, targetPlanIndex) {
        const data = { planIndex, targetPlanIndex };
        this.sendEvent('fplCopied', data, true);
    }
    /**
     * A callback which is called in response to leg changed sync events.
     * @param data The event data.
     */
    onLegChanged(data) {
        const plan = this.getFlightPlan(data.planIndex);
        switch (data.type) {
            case PlanChangeType.Added:
                data.leg && plan.addLeg(data.segmentIndex, data.leg.leg, data.legIndex, data.leg.isInDirectToSequence, data.leg.isInMissedApproachSequence, false);
                break;
            case PlanChangeType.Removed:
                plan.removeLeg(data.segmentIndex, data.legIndex, false);
                break;
        }
        this.sendEvent('fplLegChange', data, false);
    }
    /**
     * Sends a leg change event.
     * @param planIndex The index of the flight plan.
     * @param segmentIndex The index of the segment.
     * @param index The index of the leg.
     * @param type The type of change.
     * @param leg The leg that was changed.
     */
    sendLegChanged(planIndex, segmentIndex, index, type, leg) {
        const data = {
            planIndex, segmentIndex, legIndex: index, type, leg
        };
        this.sendEvent('fplLegChange', data, true);
    }
    /**
     * A callback which is called in response to segment changed sync events.
     * @param data The event data.
     */
    onSegmentChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        switch (data.type) {
            case PlanChangeType.Added:
                data.segment && plan.addSegment(data.segmentIndex, data.segment.segmentType, data.segment.airway, false);
                break;
            case PlanChangeType.Inserted:
                data.segment && plan.insertSegment(data.segmentIndex, data.segment.segmentType, data.segment.airway, false);
                break;
            case PlanChangeType.Removed:
                plan.removeSegment(data.segmentIndex, false);
                break;
            case PlanChangeType.Changed:
                data.segment && plan.setAirway(data.segmentIndex, data.segment.airway, false);
                break;
        }
        this.sendEvent('fplSegmentChange', data, false);
    }
    /**
     * Sends a segment change event.
     * @param planIndex The index of the flight plan.
     * @param index The index of the segment.
     * @param type The type of change.
     * @param segment The segment that was changed.
     */
    sendSegmentChanged(planIndex, index, type, segment) {
        const data = {
            planIndex, segmentIndex: index, type, segment
        };
        this.sendEvent('fplSegmentChange', data, true);
    }
    /**
     * A callback which is called in response to active leg changed sync events.
     * @param data The event data.
     */
    onActiveLegChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        switch (data.type) {
            case ActiveLegType.Lateral:
                plan.setLateralLeg(data.index, false);
                break;
            case ActiveLegType.Vertical:
                plan.setVerticalLeg(data.index, false);
                break;
            case ActiveLegType.Calculating:
                plan.setCalculatingLeg(data.index, false);
                break;
        }
        this.sendEvent('fplActiveLegChange', data, false);
    }
    /**
     * Sends an active leg change event.
     * @param planIndex The index of the flight plan.
     * @param index The index of the leg.
     * @param segmentIndex The index of the plan segment.
     * @param legIndex The index of the leg within the segment.
     * @param previousSegmentIndex The index of the segment in which the previously active leg is.
     * @param previousLegIndex The index of the previously active leg within the previously active segment.
     * @param type The type of leg that was changed.
     */
    sendActiveLegChange(planIndex, index, segmentIndex, legIndex, previousSegmentIndex, previousLegIndex, type) {
        const data = {
            segmentIndex, legIndex, planIndex,
            index, previousSegmentIndex, previousLegIndex, type
        };
        this.sendEvent('fplActiveLegChange', data, true);
    }
    /**
     * A callback which is called in response to calculation sync events.
     * @param data The event data.
     */
    async onCalculated(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        await plan.calculate(data.index, false);
        this.sendEvent('fplCalculated', data, false);
    }
    /**
     * Sends a calculated event.
     * @param planIndex The index of the flight plan.
     * @param index The index that the path was generated from.
     */
    sendCalculated(planIndex, index) {
        const data = { planIndex, index };
        this.sendEvent('fplCalculated', data, true);
    }
    /**
     * A callback which is called in response to origin/destination changed sync events.
     * @param data The event data.
     */
    onOriginDestChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        switch (data.type) {
            case OriginDestChangeType.OriginAdded:
                data.airport && plan.setOriginAirport(data.airport, false);
                break;
            case OriginDestChangeType.OriginRemoved:
                plan.removeOriginAirport(false);
                break;
            case OriginDestChangeType.DestinationAdded:
                data.airport && plan.setDestinationAirport(data.airport, false);
                break;
            case OriginDestChangeType.DestinationRemoved:
                plan.removeDestinationAirport(false);
                break;
        }
        this.sendEvent('fplOriginDestChanged', data, false);
    }
    /**
     * Sends a origin/dest change event.
     * @param planIndex The index of the flight plan.
     * @param type The origin/destination change type.
     * @param airport The airport that was changed.
     */
    sendOriginDestChanged(planIndex, type, airport) {
        const data = { planIndex, type, airport };
        this.sendEvent('fplOriginDestChanged', data, true);
    }
    /**
     * A callback which is called in response to procedure changed sync events.
     * @param data The event data.
     */
    onProcedureDetailsChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.setProcedureDetails(data.details, false);
        this.sendEvent('fplProcDetailsChanged', data, false);
    }
    /**
     * Sends a procedure details change event.
     * @param planIndex The index of the flight plan.
     * @param details The details that were changed.
     */
    sendProcedureDetailsChanged(planIndex, details) {
        const data = { planIndex, details };
        this.sendEvent('fplProcDetailsChanged', data, true);
    }
    /**
     * A callback which is called in response to flight plan index changed sync events.
     * @param data The event data.
     */
    onPlanIndexChanged(data) {
        this.activePlanIndex = data.planIndex;
        this.sendEvent('fplIndexChanged', data, false);
    }
    /**
     * Sends an active plan index change event.
     * @param planIndex The index of the flight plan.
     */
    sendPlanIndexChanged(planIndex) {
        const data = { planIndex };
        this.sendEvent('fplIndexChanged', data, true);
    }
    /**
     * A callback which is called in response to user data set sync events.
     * @param data The event data.
     */
    onUserDataSet(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.setUserData(data.key, data.data, false);
        this.sendEvent('fplUserDataSet', data, false);
    }
    /**
     * A callback which is called in response to user data delete sync events.
     * @param data The event data.
     */
    onUserDataDelete(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.deleteUserData(data.key, false);
        this.sendEvent('fplUserDataDelete', data, false);
    }
    /**
     * Sends a user data set event.
     * @param planIndex The index of the flight plan.
     * @param key The key of the user data.
     * @param userData The data that was set.
     */
    sendUserDataSet(planIndex, key, userData) {
        const data = { planIndex, key, data: userData };
        this.sendEvent('fplUserDataSet', data, true);
    }
    /**
     * Sends a user data delete event.
     * @param planIndex The index of the flight plan.
     * @param key The key of the user data.
     */
    sendUserDataDelete(planIndex, key) {
        const data = { planIndex, key, data: undefined };
        this.sendEvent('fplUserDataDelete', data, true);
    }
    /**
     * A callback which is called in response to direct to data changed sync events.
     * @param data The event data.
     */
    onDirectToDataChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.setDirectToData(data.directToData.segmentIndex, data.directToData.segmentLegIndex, false);
        this.sendEvent('fplDirectToDataChanged', data, false);
    }
    /**
     * Sends a direct to data changed event.
     * @param planIndex The index of the flight plan.
     * @param directToData The direct to data.
     */
    sendDirectToData(planIndex, directToData) {
        const data = { planIndex, directToData: directToData };
        this.sendEvent('fplDirectToDataChanged', data, true);
    }
    /**
     * Method to set an active flight plan index.
     * @param planIndex The index of the flight plan to make active.
     */
    setActivePlanIndex(planIndex) {
        if (this.hasFlightPlan(planIndex)) {
            this.activePlanIndex = planIndex;
            this.sendPlanIndexChanged(planIndex);
        }
    }
    /**
     * Sends a local event and its sync counterpart.
     * @param topic The topic of the local event.
     * @param data The event data.
     * @param sync Whether to send the sync event.
     */
    sendEvent(topic, data, sync) {
        if (sync) {
            this.ignoreSync = true;
            this.publisher.pub(`fplsync_${topic}`, data, true, false);
            this.ignoreSync = false;
        }
        this.publisher.pub(topic, data, false, false);
    }
    /**
     * Gets an instance of FlightPlanner.
     * @param bus The event bus.
     * @param calculator A flight path calculator.
     * @returns An instance of FlightPlanner.
     */
    static getPlanner(bus, calculator) {
        var _a;
        return (_a = FlightPlanner.INSTANCE) !== null && _a !== void 0 ? _a : (FlightPlanner.INSTANCE = new FlightPlanner(bus, calculator));
    }
}

/**
 * TCAS operating modes.
 */
var TCASOperatingMode;
(function (TCASOperatingMode) {
    TCASOperatingMode[TCASOperatingMode["Standby"] = 0] = "Standby";
    TCASOperatingMode[TCASOperatingMode["TAOnly"] = 1] = "TAOnly";
    TCASOperatingMode[TCASOperatingMode["TA_RA"] = 2] = "TA_RA";
})(TCASOperatingMode || (TCASOperatingMode = {}));
/**
 * TCAS alert level.
 */
var TCASAlertLevel;
(function (TCASAlertLevel) {
    TCASAlertLevel[TCASAlertLevel["None"] = 0] = "None";
    TCASAlertLevel[TCASAlertLevel["ProximityAdvisory"] = 1] = "ProximityAdvisory";
    TCASAlertLevel[TCASAlertLevel["TrafficAdvisory"] = 2] = "TrafficAdvisory";
    TCASAlertLevel[TCASAlertLevel["ResolutionAdvisory"] = 3] = "ResolutionAdvisory";
})(TCASAlertLevel || (TCASAlertLevel = {}));
/**
 * A TCAS-II-like system.
 */
class TCAS {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param tfcInstrument The traffic instrument which provides traffic contacts for this TCAS.
     * @param maxIntruderCount The maximum number of intruders tracked at any one time by this TCAS.
     * @param realTimeUpdateFreq The maximum update frequency (Hz) in real time.
     * @param simTimeUpdateFreq The maximum update frequency (Hz) in sim time.
     */
    constructor(bus, tfcInstrument, maxIntruderCount, realTimeUpdateFreq, simTimeUpdateFreq) {
        this.bus = bus;
        this.tfcInstrument = tfcInstrument;
        this.maxIntruderCount = maxIntruderCount;
        this.realTimeUpdateFreq = realTimeUpdateFreq;
        this.simTimeUpdateFreq = simTimeUpdateFreq;
        this.operatingModeSub = Subject.create(TCASOperatingMode.Standby);
        this.intrudersSorted = [];
        this.intrudersFiltered = [];
        this.contactCreatedHandler = this.onContactAdded.bind(this);
        this.contactRemovedHandler = this.onContactRemoved.bind(this);
        this.ownAirplaneSubs = {
            position: GeoPointSubject.createFromGeoPoint(new GeoPoint(0, 0)),
            altitude: NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(0)),
            groundTrack: Subject.create(0),
            groundSpeed: NumberUnitSubject.createFromNumberUnit(UnitType.KNOT.createNumber(0)),
            verticalSpeed: NumberUnitSubject.createFromNumberUnit(UnitType.FPM.createNumber(0))
        };
        this.isOwnAirplaneOnGround = false;
        this.lastUpdateSimTime = 0;
        this.lastUpdateRealTime = 0;
        this.alertLevelHandlers = new Map();
        this.eventSubscriber = this.bus.getSubscriber();
        this.sensitivity = this.createSensitivity();
        this.ownAirplane = new OwnAirplane(this.ownAirplaneSubs);
    }
    /**
     * Gets this system's operating mode.
     * @returns This system's operating mode.
     */
    getOperatingMode() {
        return this.operatingModeSub.get();
    }
    /**
     * Sets this system's operating mode.
     * @param mode The new operating mode.
     */
    setOperatingMode(mode) {
        this.operatingModeSub.set(mode);
    }
    /**
     * Gets an array of all currently tracked intruders. The intruders are sorted in order of decreasing threat.
     * @returns an array of all currently tracked intruders.
     */
    getIntruders() {
        return this.intrudersFiltered;
    }
    /**
     * Gets an event bus subscriber for TCAS events.
     * @returns an event bus subscriber for TCAS events..
     */
    getEventSubscriber() {
        return this.eventSubscriber;
    }
    /**
     * Initializes this system.
     */
    init() {
        // init contact listeners
        const sub = this.bus.getSubscriber();
        this.contactCreatedConsumer = sub.on('traffic_contact_added');
        this.contactRemovedConsumer = sub.on('traffic_contact_removed');
        this.contactCreatedConsumer.handle(this.contactCreatedHandler);
        this.contactRemovedConsumer.handle(this.contactRemovedHandler);
        // add all existing contacts
        this.tfcInstrument.forEachContact(contact => { this.onContactAdded(contact.uid); });
        // own airplane listeners
        const gnssSub = this.bus.getSubscriber();
        gnssSub.on('gps-position').atFrequency(this.realTimeUpdateFreq).handle(lla => { this.ownAirplaneSubs.position.set(lla.lat, lla.long); });
        gnssSub.on('track_deg_true').whenChanged().atFrequency(this.realTimeUpdateFreq).handle(track => { this.ownAirplaneSubs.groundTrack.set(track); });
        gnssSub.on('ground_speed').whenChanged().atFrequency(this.realTimeUpdateFreq).handle(gs => { this.ownAirplaneSubs.groundSpeed.set(gs); });
        const adcSub = this.bus.getSubscriber();
        adcSub.on('alt').whenChanged().atFrequency(this.realTimeUpdateFreq).handle(alt => { this.ownAirplaneSubs.altitude.set(alt); });
        adcSub.on('vs').whenChanged().atFrequency(this.realTimeUpdateFreq).handle(vs => { this.ownAirplaneSubs.verticalSpeed.set(vs); });
        adcSub.on('on_ground').whenChanged().handle(isOnGround => { this.isOwnAirplaneOnGround = isOnGround; });
        // init operating mode notifier
        this.operatingModeSub.sub(mode => { this.bus.pub('tcas_operating_mode', mode, false, true); }, true);
        // init update loop
        this.bus.getSubscriber().on('simTime').whenChanged().handle(this.onSimTimeChanged.bind(this));
    }
    /**
     * Sorts two intruders.
     * @param a The first intruder.
     * @param b The second intruder.
     * @returns A negative number if `a` is to be sorted before `b`, a positive number if `b` is to be sorted before `a`,
     * and zero if the two are equal.
     */
    intruderComparator(a, b) {
        // always sort intruders with valid predictions first
        if (a.isPredictionValid && !b.isPredictionValid) {
            return -1;
        }
        else if (!a.isPredictionValid && b.isPredictionValid) {
            return 1;
        }
        else if (a.isPredictionValid) {
            // always sort intruders predicted to violate protected zone first
            if (a.tcaNorm <= 1 && b.tcaNorm > 1) {
                return -1;
            }
            else if (a.tcaNorm > 1 && b.tcaNorm <= 1) {
                return 1;
            }
            else {
                // if both are predicted to violate protected zone, sort by TCA.
                // Otherwise sort by how close they approach the protected zone at TCA.
                const tcaComparison = a.tca.compare(b.tca);
                const normComparison = a.tcaNorm - b.tcaNorm;
                let firstComparison;
                let secondComparison;
                if (a.tcaNorm <= 1) {
                    firstComparison = tcaComparison;
                    secondComparison = normComparison;
                }
                else {
                    firstComparison = normComparison;
                    secondComparison = tcaComparison;
                }
                if (firstComparison === 0) {
                    return secondComparison;
                }
                else {
                    return firstComparison;
                }
            }
        }
        else {
            return 0;
        }
    }
    /**
     * A callback which is called when a new traffic contact is added by this system's traffic instrument.
     * @param uid The ID number of the new contact.
     */
    onContactAdded(uid) {
        const contact = this.tfcInstrument.getContact(uid);
        const intruder = this.createIntruderEntry(contact);
        this.intrudersSorted.push(intruder);
    }
    /**
     * A callback which is called when a traffic contact is removed by this system's traffic instrument.
     * @param uid The ID number of the removed contact.
     */
    onContactRemoved(uid) {
        const sortedIndex = this.intrudersSorted.findIndex(intruder => intruder.contact.uid === uid);
        const culledIndex = this.intrudersFiltered.findIndex(intruder => intruder.contact.uid === uid);
        if (sortedIndex >= 0) {
            this.intrudersSorted.splice(sortedIndex, 1);
        }
        if (culledIndex >= 0) {
            const removed = this.intrudersFiltered[culledIndex];
            this.intrudersFiltered.splice(culledIndex, 1);
            this.cleanUpIntruder(removed);
        }
    }
    /**
     * A callback which is called when the sim time changes.
     * @param simTime The current sim time.
     */
    onSimTimeChanged(simTime) {
        if (this.operatingModeSub.get() === TCASOperatingMode.Standby) {
            return;
        }
        const realTime = Date.now();
        if (Math.abs(simTime - this.lastUpdateSimTime) < 1000 / this.simTimeUpdateFreq
            || Math.abs(realTime - this.lastUpdateRealTime) < 1000 / this.realTimeUpdateFreq) {
            return;
        }
        this.doUpdate(simTime);
        this.lastUpdateSimTime = simTime;
        this.lastUpdateRealTime = realTime;
    }
    /**
     * Executes an update.
     * @param simTime The current sim time.
     */
    doUpdate(simTime) {
        this.updateSensitivity();
        this.updateIntruderPredictions(simTime);
        this.updateIntruderArrays();
        this.updateFilteredIntruderAlertLevels(simTime);
    }
    /**
     * Updates the TCA predictions for all intruders tracked by this system.
     * @param simTime The current sim time.
     */
    updateIntruderPredictions(simTime) {
        this.ownAirplane.update(simTime);
        const lookaheadTime = this.sensitivity.lookaheadTime.get();
        const protectedRadius = this.sensitivity.protectedRadius.get();
        const protectedHeight = this.sensitivity.protectedHeight.get();
        const len = this.intrudersSorted.length;
        for (let i = 0; i < len; i++) {
            this.intrudersSorted[i].updatePrediction(simTime, this.ownAirplane, lookaheadTime, protectedRadius, protectedHeight);
        }
    }
    /**
     * Updates the arrays of intruders tracked by this system.
     */
    updateIntruderArrays() {
        this.intrudersSorted.sort(this.intruderComparator.bind(this));
        const oldCulled = this.intrudersFiltered;
        this.intrudersFiltered = [];
        const len = this.intrudersSorted.length;
        for (let i = 0; i < len; i++) {
            const intruder = this.intrudersSorted[i];
            if (i < this.maxIntruderCount && intruder.isPredictionValid) {
                this.intrudersFiltered.push(intruder);
                if (!oldCulled.includes(intruder)) {
                    this.initIntruder(intruder);
                }
            }
            else {
                if (oldCulled.includes(intruder)) {
                    this.cleanUpIntruder(intruder);
                }
            }
        }
    }
    /**
     * Updates the alert levels for all intruders tracked by this system that have not been filtered out.
     * @param simTime The current sim time.
     */
    updateFilteredIntruderAlertLevels(simTime) {
        const len = this.intrudersFiltered.length;
        for (let i = 0; i < len; i++) {
            this.updateIntruderAlertLevel(simTime, this.intrudersFiltered[i]);
        }
    }
    /**
     * Executes initialization code when an intruder is added.
     * @param intruder The newly added intruder.
     */
    initIntruder(intruder) {
        const handler = this.onAlertLevelChanged.bind(this, intruder);
        this.alertLevelHandlers.set(intruder, handler);
        intruder.alertLevel.sub(handler);
        this.bus.pub('tcas_intruder_added', intruder, false, false);
    }
    /**
     * Executes cleanup code when an intruder is removed.
     * @param intruder The intruder that was removed.
     */
    cleanUpIntruder(intruder) {
        const handler = this.alertLevelHandlers.get(intruder);
        handler && intruder.alertLevel.unsub(handler);
        this.bus.pub('tcas_intruder_removed', intruder, false, false);
    }
    /**
     * A callback which is called when an intruder's alert level changes.
     * @param intruder The intruder whose alert level changed.
     */
    onAlertLevelChanged(intruder) {
        this.bus.pub('tcas_intruder_alert_changed', intruder, false, false);
    }
}
/**
 * An airplane managed by TCAS.
 */
class TCASAirplane {
    constructor() {
        this._position = new GeoPoint(0, 0);
        /** The position of this airplane at the time of the most recent update. */
        this.position = this._position.readonly;
        /** The altitude of this airplane at the time of the most recent update. */
        this._altitude = UnitType.FOOT.createNumber(0);
        this.altitude = this._altitude.readonly;
        this._groundTrack = 0;
        /** The ground speed of this airplane at the time of the most recent update. */
        this._groundSpeed = UnitType.KNOT.createNumber(0);
        this.groundSpeed = this._groundSpeed.readonly;
        /** The vertical speed of this airplane at the time of the most recent update. */
        this._verticalSpeed = UnitType.FPM.createNumber(0);
        this.verticalSpeed = this._verticalSpeed.readonly;
        /**
         * The 3D position vector of this airplane at the time of the last update. Each component is expressed in units of
         * meters. The coordinate system is an Euclidean approximation of the geodetic space around the own airplane such
         * that the z-coordinate represents orthometric height and the x- and y-coordinates represent an east-
         * counterclockwise equirectangular projection of latitude and longitude, with the origin at the location of the own
         * airplane.
         */
        this.positionVec = new Float64Array(3);
        /**
         * The 3D velocity vector of this airplane at the time of the last update. Each component is expressed in units of
         * meters per second. The coordinate system is defined the same as for position vectors.
         */
        this.velocityVec = new Float64Array(3);
        this.lastUpdateTime = 0;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The true ground track of this airplane at the time of the most recent update. */
    get groundTrack() {
        return this._groundTrack;
    }
}
/**
 * The own airplane managed by TCAS.
 */
class OwnAirplane extends TCASAirplane {
    /**
     * Constructor.
     * @param subs Subscribables which provide data related to this airplane.
     */
    constructor(subs) {
        super();
        this.subs = subs;
    }
    /**
     * Updates this airplane's position, altitude, ground track, ground speed, and vertical speed.
     */
    updateParameters() {
        this._position.set(this.subs.position.get());
        this._altitude.set(this.subs.altitude.get());
        this._groundTrack = this.subs.groundTrack.get();
        this._groundSpeed.set(this.subs.groundSpeed.get());
        this._verticalSpeed.set(this.subs.verticalSpeed.get());
    }
    /**
     * Updates this airplane's position and velocity vectors.
     */
    updateVectors() {
        Vec2Math.setFromPolar(this._groundSpeed.asUnit(UnitType.MPS), (90 - this._groundTrack) * Avionics.Utils.DEG2RAD, this.velocityVec);
        const verticalVelocity = this._verticalSpeed.asUnit(UnitType.MPS);
        this.velocityVec[2] = verticalVelocity;
    }
    /**
     * Updates this airplane's position and velocity data.
     * @param simTime The current sim time, as a UNIX millisecond timestamp.
     */
    update(simTime) {
        this.updateParameters();
        this.updateVectors();
        this.lastUpdateTime = simTime;
    }
}
/**
 * An abstract implementation of TCASIntruder.
 */
class AbstractTCASIntruder extends TCASAirplane {
    /**
     * Constructor.
     * @param contact The traffic contact associated with this intruder.
     */
    constructor(contact) {
        super();
        this.contact = contact;
        this.alertLevel = Subject.create(TCASAlertLevel.None);
        /** The 3D position vector of this intruder relative to own airplane. */
        this.relativePositionVec = new Float64Array(3);
        /** The 3D velocity vector of this intruder relative to own airplane. */
        this.relativeVelocityVec = new Float64Array(3);
        this._isPredictionValid = false;
        this._tca = UnitType.SECOND.createNumber(NaN);
        /** Time to closest approach between this intruder and own airplane. */
        this.tca = this._tca.readonly;
        this._tcaNorm = NaN;
        /** The predicted 3D displacement vector from own airplane to this intruder at time of closest approach. */
        this.tcaDisplacement = new Float64Array(3);
        this._tcaHorizontalSep = UnitType.NMILE.createNumber(0);
        /** The predicted horizontal separation between this intruder and own airplane at time of closest approach. */
        this.tcaHorizontalSep = this._tcaHorizontalSep.readonly;
        this._tcaVerticalSep = UnitType.FOOT.createNumber(0);
        /** The predicted vertical separation between this intruder and own airplane at time of closest approach. */
        this.tcaVerticalSep = this._tcaVerticalSep.readonly;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether there is a valid prediction for time of closest approach between this intruder and own airplane. */
    get isPredictionValid() {
        return this._isPredictionValid;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The cylindrical norm of the predicted displacement vector between this intruder and own airplane at time of
     * closest approach. A value less than or equal to 1 indicates the intruder will be inside the protected zone.
     * Larger values correspond to greater separation.
     */
    get tcaNorm() {
        return this._tcaNorm;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    predictDisplacement(simTime, out) {
        if (!this._isPredictionValid) {
            return Vec3Math.set(NaN, NaN, NaN, out);
        }
        const dt = (simTime - this.contact.lastContactTime) / 1000;
        return Vec3Math.add(this.relativePositionVec, Vec3Math.multScalar(this.relativeVelocityVec, dt, out), out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    predictSeparation(simTime, horizontalOut, verticalOut) {
        if (!this._isPredictionValid) {
            horizontalOut.set(NaN);
            verticalOut.set(NaN);
            return;
        }
        const displacement = this.predictDisplacement(simTime, AbstractTCASIntruder.vec3Cache[0]);
        AbstractTCASIntruder.displacementToHorizontalSeparation(displacement, horizontalOut);
        AbstractTCASIntruder.displacementToVerticalSeparation(displacement, verticalOut);
    }
    /**
     * Updates this intruder's predicted TCA and related data.
     * @param simTime The current sim time.
     * @param ownAirplane Own airplane.
     * @param lookaheadTime The maximum lookahead time to calculate TCA.
     * @param protectedRadius The radius of the own airplane's protected zone.
     * @param protectedHeight The half-height of the own airplane's protected zone.
     */
    updatePrediction(simTime, ownAirplane, lookaheadTime, protectedRadius, protectedHeight) {
        this.updateParameters(simTime, ownAirplane);
        if (this.isPredictionValid) {
            this.updateTCA(ownAirplane, lookaheadTime, protectedRadius, protectedHeight);
        }
        else {
            this.invalidatePrediction();
        }
        this.lastUpdateTime = simTime;
    }
    /**
     * Updates this intruder's position and velocity data.
     * @param simTime The current sim time.
     * @param ownAirplane The own airplane.
     */
    updateParameters(simTime, ownAirplane) {
        if (isNaN(this.contact.groundTrack) || this.contact.groundSpeed.compare(AbstractTCASIntruder.MIN_GROUND_SPEED) < 0) {
            this._isPredictionValid = false;
            this._position.set(NaN, NaN);
            this._altitude.set(NaN);
            this._groundTrack = NaN;
            this._groundSpeed.set(NaN);
            this._verticalSpeed.set(NaN);
            Vec3Math.set(NaN, NaN, NaN, this.positionVec);
            Vec3Math.set(NaN, NaN, NaN, this.velocityVec);
        }
        else {
            this.updatePosition(simTime, ownAirplane);
            this.updateVelocity();
            this._groundSpeed.set(this.contact.groundSpeed);
            this._verticalSpeed.set(this.contact.verticalSpeed);
            this._isPredictionValid = true;
        }
    }
    /**
     * Updates this intruder's position.
     * @param simTime The current sim time.
     * @param ownAirplane The own airplane.
     */
    updatePosition(simTime, ownAirplane) {
        this.contact.predict(simTime, this._position, this._altitude);
        this._groundTrack = this._position.equals(this.contact.lastPosition) ? this.contact.groundTrack : this._position.bearingFrom(this.contact.lastPosition);
        const distance = UnitType.GA_RADIAN.convertTo(this._position.distance(ownAirplane.position), UnitType.METER);
        const bearing = ownAirplane.position.bearingTo(this._position);
        Vec2Math.setFromPolar(distance, (90 - bearing) * Avionics.Utils.DEG2RAD, this.positionVec);
        const verticalPosition = this._altitude.asUnit(UnitType.METER) - ownAirplane.altitude.asUnit(UnitType.METER);
        this.positionVec[2] = verticalPosition;
    }
    /**
     * Updates this intruder's velocity.
     */
    updateVelocity() {
        Vec2Math.setFromPolar(this.contact.groundSpeed.asUnit(UnitType.MPS), (90 - this.contact.groundTrack) * Avionics.Utils.DEG2RAD, this.velocityVec);
        const verticalVelocity = this.contact.verticalSpeed.asUnit(UnitType.MPS);
        this.velocityVec[2] = verticalVelocity;
    }
    /**
     * Updates the time-to-closest-approach (TCA) and related data of this intruder.
     * @param ownAirplane The own airplane.
     * @param lookaheadTime The maximum lookahead time.
     * @param protectedRadius The radius of the own airplane's protected zone.
     * @param protectedHeight The half-height of the own airplane's protected zone.
     */
    updateTCA(ownAirplane, lookaheadTime, protectedRadius, protectedHeight) {
        // Source: Munoz, CA and Narkawicz, AJ. "Time of Closest Approach in Three-Dimensional Airspace." 2010.
        // https://ntrs.nasa.gov/api/citations/20100037766/downloads/20100037766.pdf
        const s = Vec3Math.sub(this.positionVec, ownAirplane.positionVec, this.relativePositionVec);
        const v = Vec3Math.sub(this.velocityVec, ownAirplane.velocityVec, this.relativeVelocityVec);
        const sHoriz = Vec2Math.set(s[0], s[1], AbstractTCASIntruder.vec2Cache[0]);
        const vHoriz = Vec2Math.set(v[0], v[1], AbstractTCASIntruder.vec2Cache[0]);
        const h = protectedHeight.asUnit(UnitType.METER);
        const r = protectedRadius.asUnit(UnitType.METER);
        const vHorizSquared = Vec2Math.dot(vHoriz, vHoriz);
        const sHorizSquared = Vec2Math.dot(sHoriz, sHoriz);
        const hSquared = h * h;
        const rSquared = r * r;
        const a = (v[2] * v[2]) / hSquared - vHorizSquared / rSquared;
        const b = 2 * s[2] * v[2] / hSquared - 2 * Vec2Math.dot(sHoriz, vHoriz) / rSquared;
        const c = (s[2] * s[2]) / hSquared - sHorizSquared / rSquared;
        const solution = AbstractTCASIntruder.calculateSolution(0, s, v, r, h, AbstractTCASIntruder.solutionCache[0]);
        if (vHorizSquared !== 0) {
            const t = -Vec2Math.dot(sHoriz, vHoriz) / vHorizSquared;
            if (t > 0) {
                AbstractTCASIntruder.evaluateCandidate(t, s, v, r, h, solution, AbstractTCASIntruder.solutionCache[1]);
            }
        }
        if (v[2] !== 0) {
            const t = -s[2] / v[2];
            if (t > 0) {
                AbstractTCASIntruder.evaluateCandidate(t, s, v, r, h, solution, AbstractTCASIntruder.solutionCache[1]);
            }
        }
        const discriminant = b * b - 4 * a * c;
        if (a !== 0 && discriminant >= 0) {
            const sqrt = Math.sqrt(discriminant);
            let t = (-b + sqrt) / (2 * a);
            if (t > 0) {
                AbstractTCASIntruder.evaluateCandidate(t, s, v, r, h, solution, AbstractTCASIntruder.solutionCache[1]);
            }
            t = (-b - sqrt) / (2 * a);
            if (t > 0) {
                AbstractTCASIntruder.evaluateCandidate(t, s, v, r, h, solution, AbstractTCASIntruder.solutionCache[1]);
            }
        }
        else if (a === 0 && b !== 0) {
            const t = -c / b;
            if (t > 0) {
                AbstractTCASIntruder.evaluateCandidate(t, s, v, r, h, solution, AbstractTCASIntruder.solutionCache[1]);
            }
        }
        const lookaheadTimeSeconds = lookaheadTime.asUnit(UnitType.SECOND);
        if (solution.tca > lookaheadTimeSeconds) {
            AbstractTCASIntruder.calculateSolution(lookaheadTimeSeconds, s, v, r, h, solution);
        }
        this._tca.set(solution.tca);
        this._tcaNorm = solution.norm;
        AbstractTCASIntruder.displacementToHorizontalSeparation(solution.displacement, this._tcaHorizontalSep);
        AbstractTCASIntruder.displacementToVerticalSeparation(solution.displacement, this._tcaVerticalSep);
    }
    /**
     * Invalidates this intruder's predicted TCA and related data.
     */
    invalidatePrediction() {
        Vec3Math.set(NaN, NaN, NaN, this.relativePositionVec);
        Vec3Math.set(NaN, NaN, NaN, this.relativeVelocityVec);
        this._tca.set(NaN);
        this._tcaNorm = NaN;
        Vec3Math.set(NaN, NaN, NaN, this.tcaDisplacement);
        this._tcaHorizontalSep.set(NaN);
        this._tcaVerticalSep.set(NaN);
    }
    /**
     * Evaluates a TCA candidate against the best existing solution, and if the candidate produces a smaller cylindrical
     * norm, replaces the best existing solution with the candidate.
     * @param t The candidate TCA time, in seconds.
     * @param s The relative position vector of the intruder, in meters.
     * @param v The relative velocity vector of the intruder, in meters per second.
     * @param r The radius of the own airplane's protected zone, in meters.
     * @param h The half-height of the own airplane's protected zone, in meters.
     * @param best The best existing solution.
     * @param candidate A TcaSolution object to which to temporarily write the candidate solution.
     */
    static evaluateCandidate(t, s, v, r, h, best, candidate) {
        AbstractTCASIntruder.calculateSolution(t, s, v, r, h, candidate);
        if (candidate.norm < best.norm) {
            AbstractTCASIntruder.copySolution(candidate, best);
        }
    }
    /**
     * Calculates a TCA solution.
     * @param t The candidate TCA time, in seconds.
     * @param s The relative position vector of the intruder, in meters.
     * @param v The relative velocity vector of the intruder, in meters per second.
     * @param r The radius of the own airplane's protected zone, in meters.
     * @param h The half-height of the own airplane's protected zone, in meters.
     * @param out A TcaSolution object to which to write the result.
     * @returns A TCA solution.
     */
    static calculateSolution(t, s, v, r, h, out) {
        out.tca = t;
        AbstractTCASIntruder.calculateDisplacementVector(s, v, t, out.displacement);
        out.norm = AbstractTCASIntruder.calculateCylindricalNorm(out.displacement, r, h);
        return out;
    }
    /**
     * Copies a TCA solution.
     * @param from The solution from which to copy.
     * @param to The solution to which to copy.
     */
    static copySolution(from, to) {
        to.tca = from.tca;
        Vec3Math.copy(from.displacement, to.displacement);
        to.norm = from.norm;
    }
    /**
     * Calculates a time-offset displacement vector given an initial displacement, a velocity vector, and elapsed time.
     * @param initial The initial displacement vector.
     * @param velocity A velocity vector.
     * @param elapsedTime The elapsed time.
     * @param out A Float64Array object to which to write the result.
     * @returns The time-offset displacement vector.
     */
    static calculateDisplacementVector(initial, velocity, elapsedTime, out) {
        return Vec3Math.add(initial, Vec3Math.multScalar(velocity, elapsedTime, out), out);
    }
    /**
     * Calculates a cylindrical norm.
     * @param vector A displacement vector.
     * @param radius The radius of the protected zone.
     * @param halfHeight The half-height of the protected zone.
     * @returns A cylindrical norm.
     */
    static calculateCylindricalNorm(vector, radius, halfHeight) {
        const horizLength = Math.hypot(vector[0], vector[1]);
        return Math.max(Math.abs(vector[2]) / halfHeight, horizLength / radius);
    }
    /**
     * Converts a 3D displacement vector to a horizontal separation distance.
     * @param displacement A displacement vector, in meters.
     * @param out A NumberUnit object to which to write the result.
     * @returns The horizontal separation distance corresponding to the displacement vector.
     */
    static displacementToHorizontalSeparation(displacement, out) {
        return out.set(Math.hypot(displacement[0], displacement[1]), UnitType.METER);
    }
    /**
     * Converts a 3D displacement vector to a vertical separation distance.
     * @param displacement A displacement vector, in meters.
     * @param out A NumberUnit object to which to write the result.
     * @returns The vertical separation distance corresponding to the displacement vector.
     */
    static displacementToVerticalSeparation(displacement, out) {
        return out.set(Math.abs(displacement[2]), UnitType.METER);
    }
}
AbstractTCASIntruder.MIN_GROUND_SPEED = UnitType.KNOT.createNumber(30);
AbstractTCASIntruder.vec2Cache = [new Float64Array(2), new Float64Array(2)];
AbstractTCASIntruder.vec3Cache = [new Float64Array(3), new Float64Array(3)];
AbstractTCASIntruder.solutionCache = [
    {
        tca: 0,
        displacement: new Float64Array(3),
        norm: 0
    },
    {
        tca: 0,
        displacement: new Float64Array(3),
        norm: 0
    }
];
/**
 * An abstract implementation of TCASSensitivity.
 */
class AbstractTCASSensitivity {
    constructor() {
        this.lookaheadTime = NumberUnitSubject.createFromNumberUnit(UnitType.SECOND.createNumber(0));
        this.protectedRadius = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(0));
        this.protectedHeight = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(0));
    }
}

/**
 * The style of cursor to use on a circular gauge.
 * This is treated as though it may have multiple options in the original
 * source.  For the sake of future expansion we'll make this an enum even
 * though it currently only has one option.  Maybe it can be used for future
 * expansion.
 */
var XMLCircularGaugeCursor;
(function (XMLCircularGaugeCursor) {
    /** Starting the enum at 1 to match its value in the stock XMLEngineDisplay.js */
    XMLCircularGaugeCursor[XMLCircularGaugeCursor["Triangle"] = 1] = "Triangle";
})(XMLCircularGaugeCursor || (XMLCircularGaugeCursor = {}));
/**
 * The possible locations for value text.
 * This is treated as though it may have multiple options in the original
 * source.  For the sake of future expansion we'll make this an enum even
 * though it currently only has one option.  Maybe it can be used for future
 * expansion.
 */
var XMLCircularGaugeValuePos;
(function (XMLCircularGaugeValuePos) {
    /** Starting the enum at 1 to match its value in the stock XMLEngineDisplay.js */
    XMLCircularGaugeValuePos[XMLCircularGaugeValuePos["End"] = 1] = "End";
})(XMLCircularGaugeValuePos || (XMLCircularGaugeValuePos = {}));

/**
 * This provides the valid values for the ValuePos tag on a horizontal gauge.
 */
var XMLHorizontalGaugeValuePos;
(function (XMLHorizontalGaugeValuePos) {
    /** Starting the enum at 1 to match its value in the stock XMLEngineDisplay.js */
    XMLHorizontalGaugeValuePos[XMLHorizontalGaugeValuePos["End"] = 1] = "End";
    XMLHorizontalGaugeValuePos[XMLHorizontalGaugeValuePos["Right"] = 2] = "Right";
})(XMLHorizontalGaugeValuePos || (XMLHorizontalGaugeValuePos = {}));

/**
 * This provides the valid values for the ValuePos tag on a vertical gauge.
 */
var XMLVerticalGaugeValuePos;
(function (XMLVerticalGaugeValuePos) {
    /** Starting the enum at 1 to match its value in the stock XMLEngineDisplay.js */
    XMLVerticalGaugeValuePos[XMLVerticalGaugeValuePos["None"] = 1] = "None";
})(XMLVerticalGaugeValuePos || (XMLVerticalGaugeValuePos = {}));

/**
 * The possible locations for value text.
 * This is treated as though it may have multiple options in the original
 * source.  For the sake of future expansion we'll make this an enum even
 * though it currently only has one option.  Maybe it can be used for future
 * expansion.
 */
var XMLDoubleHorizontalGaugeValuePos;
(function (XMLDoubleHorizontalGaugeValuePos) {
    /** Starting the enum at 2 to match its value in the stock XMLEngineDisplay.js */
    XMLDoubleHorizontalGaugeValuePos[XMLDoubleHorizontalGaugeValuePos["Right"] = 2] = "Right";
})(XMLDoubleHorizontalGaugeValuePos || (XMLDoubleHorizontalGaugeValuePos = {}));

/// <reference types="msfstypes/Pages/VCockpit/Instruments/Shared/utils/XMLLogic" />
/**
 * The type of gauges available, as defined in XMLEngineDisplay.js.
 */
var XMLGaugeType;
(function (XMLGaugeType) {
    XMLGaugeType["Circular"] = "Circular";
    XMLGaugeType["Horizontal"] = "Horizontal";
    XMLGaugeType["DoubleHorizontal"] = "DoubleHorizontal";
    XMLGaugeType["Vertical"] = "Vertical";
    XMLGaugeType["DoubleVertical"] = "DoubleVertical";
    XMLGaugeType["Text"] = "Text";
    XMLGaugeType["ColumnGroup"] = "ColumnGroup";
    XMLGaugeType["Column"] = "Column";
    XMLGaugeType["Cylinder"] = "Cylinder";
    XMLGaugeType["TwinCylinder"] = "TwinCylinder";
})(XMLGaugeType || (XMLGaugeType = {}));
/**
 * Parse an XMLEngineDisplay configuration into an array of gauge specs.
 */
class XMLGaugeConfigFactory {
    /**
     * Create an XMLGaugeConfigFactory.
     * @param instrument The instrument that holds this engine display.
     * @param bus An event bus for gauges that need it.
     */
    constructor(instrument, bus) {
        this.instrument = instrument;
        this.bus = bus;
    }
    /**
     * Convenience method to take a full XML instrument config and parse out the display config
     * section. This will check first to see if we are using an enhanced, multi-page config by
     * looking for an EnginePage tag in the EngineDisplay element.   If it finds it, it will
     * assume we have an advanced config, and return the content along with that of LeanPage
     * and SystemPag, if present.  If no EnginePage exists, we assume we're dealing with a
     * legacy configuration and just return the content of EngineDisplay itself as our engine
     * page with everything else undefined.
     * @param document The XML configuation document.
     * @returns An XMLEnhancedGaugeConfig with the full gauge configuration.
     */
    parseConfig(document) {
        var _a;
        const gaugeSpecs = new Array();
        const functions = new Map();
        const displayConfig = document.getElementsByTagName('EngineDisplay');
        if (displayConfig.length == 0) {
            return { override: false, functions: functions, enginePage: gaugeSpecs };
        }
        else {
            for (const func of document.getElementsByTagName('Function')) {
                const funcSpec = this.makeFunction(func);
                if (funcSpec !== undefined) {
                    functions.set(funcSpec.name, funcSpec);
                }
            }
            const override = ((_a = displayConfig[0].getAttribute('override')) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'true';
            const enginePages = displayConfig[0].getElementsByTagName('EnginePage');
            if (enginePages.length == 0) {
                return { override: override, functions: functions, enginePage: this._parseConfig(displayConfig[0]) };
            }
            const leanPages = displayConfig[0].getElementsByTagName('LeanPage');
            const systemPages = displayConfig[0].getElementsByTagName('SystemPage');
            return {
                override: override,
                functions: functions,
                enginePage: this._parseConfig(enginePages[0]),
                leanPage: leanPages.length > 0 ? this._parseConfig(leanPages[0]) : undefined,
                systemPage: systemPages.length > 0 ? this._parseConfig(systemPages[0]) : undefined
            };
        }
    }
    /**
     * Parse an engine display setup.
     * @param config An instrument XML config document.
     * @returns An array of the gauges defined in the configuration.
     */
    _parseConfig(config) {
        var _a;
        const gaugeSpecs = new Array();
        if (config.children.length == 0) {
            return gaugeSpecs;
        }
        for (const gauge of config.children) {
            switch (gauge.tagName) {
                case 'Gauge':
                    switch ((_a = gauge.getElementsByTagName('Type')[0]) === null || _a === void 0 ? void 0 : _a.textContent) {
                        case 'Circular':
                            gaugeSpecs.push({
                                gaugeType: XMLGaugeType.Circular,
                                configuration: this.createCircularGauge(gauge)
                            });
                            break;
                        case 'Horizontal':
                            gaugeSpecs.push({
                                gaugeType: XMLGaugeType.Horizontal,
                                configuration: this.createHorizontalGauge(gauge)
                            });
                            break;
                        case 'DoubleHorizontal':
                            gaugeSpecs.push({
                                gaugeType: XMLGaugeType.DoubleHorizontal,
                                configuration: this.createDoubleHorizontalGauge(gauge)
                            });
                            break;
                        case 'DoubleVertical':
                            gaugeSpecs.push({
                                gaugeType: XMLGaugeType.DoubleVertical,
                                configuration: this.createDoubleVerticalGauge(gauge)
                            });
                            break;
                        case 'Cylinder':
                            gaugeSpecs.push({
                                gaugeType: XMLGaugeType.Cylinder,
                                configuration: this.createCylinderGauge(gauge)
                            });
                            break;
                        case 'TwinCylinder':
                            gaugeSpecs.push({
                                gaugeType: XMLGaugeType.TwinCylinder,
                                configuration: this.createCylinderGauge(gauge)
                            });
                            break;
                    }
                    break;
                case 'Text':
                    {
                        const textProps = {};
                        const className = gauge.getAttribute('id');
                        if (className !== null) {
                            textProps.class = className;
                        }
                        const leftElem = gauge.getElementsByTagName('Left');
                        if (leftElem.length > 0) {
                            textProps.left = this.makeTextColumn(leftElem[0]);
                        }
                        const centerElem = gauge.getElementsByTagName('Center');
                        if (centerElem.length > 0) {
                            textProps.center = this.makeTextColumn(centerElem[0]);
                        }
                        const rightElem = gauge.getElementsByTagName('Right');
                        if (rightElem.length > 0) {
                            textProps.right = this.makeTextColumn(rightElem[0]);
                        }
                        const style = XMLGaugeConfigFactory.parseStyleDefinition(gauge.getElementsByTagName('Style'));
                        if (style !== undefined) {
                            textProps.style = style;
                        }
                        gaugeSpecs.push({
                            gaugeType: XMLGaugeType.Text,
                            configuration: textProps
                        });
                    }
                    break;
                case 'ColumnGroup':
                    gaugeSpecs.push({
                        gaugeType: XMLGaugeType.ColumnGroup,
                        configuration: this.createColumnGroup(gauge)
                    });
                    break;
                case 'Column':
                    gaugeSpecs.push({
                        gaugeType: XMLGaugeType.Column,
                        configuration: this.createColumn(gauge)
                    });
                    break;
            }
        }
        return gaugeSpecs;
    }
    /**
     * Construct a single column of text for a text element.  This can be any
     * one of Left, Right, or Center.
     * @param columnDef The XML definition for the given column.
     * @returns an XMLTextColumn configuration.
     */
    makeTextColumn(columnDef) {
        const contentElem = columnDef.getElementsByTagName('Content');
        const config = {
            content: new CompositeLogicXMLElement(this.instrument, contentElem.length > 0 ? contentElem[0] : columnDef)
        };
        const colorElem = columnDef.getElementsByTagName('Color');
        if (colorElem.length > 0) {
            config.color = new CompositeLogicXMLElement(this.instrument, colorElem[0]);
        }
        const className = columnDef.getAttribute('id');
        if (className !== null) {
            config.class = className;
        }
        const fontSize = columnDef.getAttribute('fontsize');
        if (fontSize !== null) {
            config.fontSize = fontSize;
        }
        return config;
    }
    /**
     * Make a function.
     * @param functionDef The XML definition for the function.
     * @returns an XMLFunction type or undefined if there's an error
     */
    makeFunction(functionDef) {
        const name = functionDef.getAttribute('Name');
        if (!name || functionDef.children.length == 0) {
            return undefined;
        }
        return {
            name: name,
            logic: new CompositeLogicXMLElement(this.instrument, functionDef)
        };
    }
    /**
     * Create a base XMLGaugeProps definition.  This will be combined with the
     * props for a speciific gauge type to fully define the config interface.
     * @param gauge The gauge definition
     * @returns A set of XMLGaugeProps
     */
    parseGaugeDefinition(gauge) {
        var _a;
        // TODO Maybe make this use getAndAssign, too?
        const props = {};
        /**
         * A closure to make our variable assignments easier.
         * @param prop The property we want to assign.
         * @param tag The HTML tag to get the value from.
         * @param converter A converter function.
         */
        const assign = (prop, tag, converter = (v) => { return v; }) => {
            XMLGaugeConfigFactory.getAndAssign(props, gauge, prop, tag, converter);
        };
        const colorZones = this.makeColorZones(gauge.getElementsByTagName('ColorZone'));
        if (colorZones !== undefined) {
            props.colorZones = colorZones;
        }
        const colorLines = this.makeColorLines(gauge.getElementsByTagName('ColorLine'));
        if (colorLines !== undefined) {
            props.colorLines = colorLines;
        }
        props.minimum = new CompositeLogicXMLElement(this.instrument, gauge.getElementsByTagName('Minimum')[0]);
        props.maximum = new CompositeLogicXMLElement(this.instrument, gauge.getElementsByTagName('Maximum')[0]);
        props.value1 = new CompositeLogicXMLElement(this.instrument, gauge.getElementsByTagName('Value')[0]);
        props.value2 = new CompositeLogicXMLElement(this.instrument, gauge.getElementsByTagName('Value2')[0]);
        assign('title', 'Title', (v) => { return v ? v : ''; });
        assign('unit', 'Unit', (v) => { return v ? v : ''; });
        assign('graduationLength', 'GraduationLength', parseFloat);
        props.graduationHasText = ((_a = gauge.getElementsByTagName('GraduationLength')[0]) === null || _a === void 0 ? void 0 : _a.getAttribute('text')) == 'True';
        assign('beginText', 'BeginText');
        assign('endText', 'EndText');
        assign('cursorText1', 'CursorText', (v) => { return v ? v : ''; });
        assign('cursorText2', 'CursorText2', (v) => { return v ? v : ''; });
        assign('id', 'ID');
        props.redBlink = new CompositeLogicXMLElement(this.instrument, gauge.getElementsByTagName('RedBlink')[0]);
        return props;
    }
    // The logic for creating these gauges is a little intricate and repeats a number of times.
    // To avoid having redundant comments, here's the general plan for what's happening.
    //
    // First, we create an instance of the gauge's style interface in several steps. These
    // take advantage of the fact that almost all of the props on on the interfaces are optional
    // to allow us to compose the gauge-specific interface in pieces.
    //
    // 1) The gauge-specific create function passes the Style element to the generic
    //    parseStyleDefinition function, which returns an interface that has all of the
    //    universal style properties.
    // 2) The function then creates its own gauge-specific style interface using parsing logic
    //    unique to the gauge.
    // 3) The values of the generic interface are then assigned to the object-specific one so
    //    that we have one interface with all the styling information needed.
    //
    // Next, we repeat the same process with the rest of the gauge definitions.   At this point,
    // the primary way in which the shapes of the interfaces differ is in what their style
    // definitions look like, so the second phase is just another assignment compositing the
    // custom-derived style and the remainder of the generic definiton as retrieved from the
    // parseGaugeDefinition method.
    //
    // We play a bit fast and loose with properties here and don't really do any confirmation
    // that the gauge definitions we get are valid.  The user could, for example, provide a
    // <Value2> property to a gauge that only has one value and that would be populated in the
    // configuration.   It would be harmless, because it would be ignored by the gauge code,
    // but it's still kind of gross.
    //
    // This models how the standard XMLEngineDisplay.js works.  In the future we might want to
    // tighten this up with better type checking and error throwing, in which case we can expand
    // these functions to use a bit more logic in this second phase when they're composing
    // the final configuration instance.
    //
    // Ok, on with the show.
    /**
     * Create a circular gauge.
     * @param gaugeDef An XML element defining the gauge.
     * @returns The props for this gauge.
     */
    createCircularGauge(gaugeDef) {
        const styleElem = gaugeDef.getElementsByTagName('Style');
        const genericStyle = XMLGaugeConfigFactory.parseStyleDefinition(styleElem);
        let style = {};
        const innerElem = styleElem[0];
        if (innerElem !== undefined) {
            /**
             * A closure to make our variable assignments easier.
             * @param prop The property we want to assign.
             * @param tag The HTML tag to get the value from.
             * @param converter A converter function.
             */
            const assign = (prop, tag, converter = (v) => { return v; }) => {
                XMLGaugeConfigFactory.getAndAssign(style, innerElem, prop, tag, converter);
            };
            assign('forceTextColor', 'ForceTextColor');
            assign('textIncrement', 'TextIncrement', parseFloat);
            assign('beginAngle', 'BeginAngle', parseFloat);
            assign('endAngle', 'EndAngle', parseFloat);
            assign('cursorType', 'CursorType', (v) => { return v == 'Triangle' ? XMLCircularGaugeCursor.Triangle : undefined; });
            assign('valuePos', 'ValuePos', (v) => { return v == 'End' ? XMLCircularGaugeValuePos.End : undefined; });
            assign('valuePrecision', 'ValuePrecision', parseInt);
        }
        style = Object.assign(style, genericStyle);
        return Object.assign({ style: style }, this.parseGaugeDefinition(gaugeDef));
    }
    /**
     * Create a horizontal gauge.
     * @param gaugeDef An XML element defining the gauge.
     * @returns The props for this gauge.
     */
    createHorizontalGauge(gaugeDef) {
        const styleElem = gaugeDef.getElementsByTagName('Style');
        const genericStyle = XMLGaugeConfigFactory.parseStyleDefinition(styleElem);
        let style = {};
        const innerElem = styleElem[0];
        if (innerElem !== undefined) {
            /**
             * A closure to make our variable assignments easier.
             * @param prop The property we want to assign.
             * @param tag The HTML tag to get the value from.
             * @param converter A converter function.
             */
            const assign = (prop, tag, converter = (v) => { return v; }) => {
                XMLGaugeConfigFactory.getAndAssign(style, innerElem, prop, tag, converter);
            };
            assign('valuePos', 'ValuePos', (v) => {
                switch (v) {
                    case 'Right':
                        return XMLHorizontalGaugeValuePos.Right;
                    case 'End':
                        return XMLHorizontalGaugeValuePos.End;
                    default:
                        return undefined;
                }
            });
            assign('textIncrement', 'TextIncrement', parseFloat);
            assign('cursorColor', 'CursorColor');
            assign('width', 'Width', parseFloat);
            assign('reverseY', 'ReverseY', (v) => { return v == 'True'; });
            assign('valuePrecision', 'ValuePrecision', parseInt);
        }
        style = Object.assign(style, genericStyle);
        return Object.assign({ style: style }, this.parseGaugeDefinition(gaugeDef));
    }
    /**
     * Create a double horizontal gauge.
     * @param gaugeDef An XML element defining the gauge.
     * @returns The props for this gauge.
     */
    createDoubleHorizontalGauge(gaugeDef) {
        const styleElem = gaugeDef.getElementsByTagName('Style');
        const genericStyle = XMLGaugeConfigFactory.parseStyleDefinition(styleElem);
        let style = {};
        if (styleElem[0] !== undefined) {
            XMLGaugeConfigFactory.getAndAssign(style, styleElem[0], 'textIncrement', 'TextIncrement', parseFloat);
            XMLGaugeConfigFactory.getAndAssign(style, styleElem[0], 'valuePos', 'ValuePos', (v) => {
                v == 'Right' ? XMLDoubleHorizontalGaugeValuePos.Right : undefined;
            });
            XMLGaugeConfigFactory.getAndAssign(style, styleElem[0], 'pointerStyle', 'PointerStyle', (v) => {
            });
        }
        style = Object.assign(style, genericStyle);
        return Object.assign({ style: style }, this.parseGaugeDefinition(gaugeDef));
    }
    /**
     * Create a double vertical gauge.
     * @param gaugeDef An XML element defining the gauge.
     * @returns The props for this gauge.
     */
    createDoubleVerticalGauge(gaugeDef) {
        const styleElem = gaugeDef.getElementsByTagName('Style');
        const genericStyle = XMLGaugeConfigFactory.parseStyleDefinition(styleElem);
        let style = {};
        if (styleElem[0] !== undefined) {
            XMLGaugeConfigFactory.getAndAssign(style, styleElem[0], 'textIncrement', 'TextIncrement', parseFloat);
            XMLGaugeConfigFactory.getAndAssign(style, styleElem[0], 'height', 'Height', parseFloat);
        }
        style = Object.assign(style, genericStyle);
        return Object.assign({ style: style }, this.parseGaugeDefinition(gaugeDef));
    }
    /**
     * Create a cylinder gauge.
     * @param gaugeDef An XML element defining the gauge.
     * @returns The props for this gauge.
     */
    createCylinderGauge(gaugeDef) {
        const styleElem = gaugeDef.getElementsByTagName('Style');
        const genericStyle = XMLGaugeConfigFactory.parseStyleDefinition(styleElem);
        const columnElems = gaugeDef.getElementsByTagName('Columns');
        const rowElems = gaugeDef.getElementsByTagName('Rows');
        const config = this.parseGaugeDefinition(gaugeDef);
        config.bus = this.bus;
        let style = {};
        if (styleElem[0] !== undefined) {
            XMLGaugeConfigFactory.getAndAssign(style, styleElem[0], 'textIncrement', 'TextIncrement', parseFloat);
            XMLGaugeConfigFactory.getAndAssign(style, styleElem[0], 'redline', 'ShowRedline', (text) => { return text == 'True'; });
            XMLGaugeConfigFactory.getAndAssign(style, styleElem[0], 'peakTemps', 'ShowPeak', (text) => { return text == 'True'; });
        }
        style = Object.assign(style, genericStyle);
        config.style = style;
        if (columnElems.length > 0) {
            config.numColumns = new CompositeLogicXMLElement(this.instrument, columnElems[0]);
        }
        if (rowElems.length > 0) {
            config.numRows = new CompositeLogicXMLElement(this.instrument, rowElems[0]);
        }
        XMLGaugeConfigFactory.getAndAssign(config, gaugeDef, 'tempOrder', 'TempOrder', (text) => {
            const tempOrder = new Array();
            for (const item of text.split(',')) {
                tempOrder.push(parseInt(item));
            }
            return tempOrder;
        });
        return config;
    }
    /**
     * Create a column group.
     * @param gaugeDef AN XML element defining the group.
     * @returns The props for the group with all contained columns.
     */
    createColumnGroup(gaugeDef) {
        const columns = new Array();
        const children = gaugeDef.children;
        for (const child of children) {
            if (child.tagName == 'Column') {
                columns.push(this.createColumn(child));
            }
        }
        const group = {
            bus: this.bus,
            columns: columns
        };
        XMLGaugeConfigFactory.getAndAssign(group, gaugeDef, 'id', 'id');
        return group;
    }
    /**
     * Create a column of gauges.
     * @param gaugeDef An XML element defining the column.
     * @returns The props of the column with all contained gauges.
     */
    createColumn(gaugeDef) {
        const column = { gauges: this._parseConfig(gaugeDef) };
        XMLGaugeConfigFactory.getAndAssign(column, gaugeDef, 'id', 'id');
        XMLGaugeConfigFactory.getAndAssign(column, gaugeDef, 'width', 'width', parseFloat);
        return column;
    }
    // Utility functions.
    /**
     * Check the value of a setting and, if it's defined, assign it to the
     * property of an object with optional type conversion.
     * @param obj The object to manipulate.
     * @param elem The element to get the value from.
     * @param prop The name of the property to set.
     * @param tag The tag name to retrieve.
     * @param converter A type conversion used if the value is defined.
     */
    static getAndAssign(obj, elem, prop, tag, converter = (val) => { return val; }) {
        var _a;
        const value = (_a = elem.getElementsByTagName(tag)[0]) === null || _a === void 0 ? void 0 : _a.textContent;
        if (value === null || value === undefined) {
            return;
        }
        const newVal = converter(value);
        if (newVal !== undefined) {
            obj[prop] = newVal;
        }
    }
    /**
     * Create a basic XML style from a gauge definition.
     * @param styleDoc A style definition block
     * @returns An XMLGaugeStyle
     */
    static parseStyleDefinition(styleDoc) {
        var _a;
        const style = {};
        if (styleDoc.length > 0) {
            XMLGaugeConfigFactory.getAndAssign(style, styleDoc[0], 'sizePercent', 'SizePercent', parseFloat);
            const marginsElem = styleDoc[0].getElementsByTagName('Margins');
            if (marginsElem.length > 0 && ((_a = marginsElem[0]) === null || _a === void 0 ? void 0 : _a.textContent) !== null) {
                XMLGaugeConfigFactory.getAndAssign(style, marginsElem[0], 'marginLeft', 'Left', parseFloat);
                XMLGaugeConfigFactory.getAndAssign(style, marginsElem[0], 'marginRight', 'Right', parseFloat);
                XMLGaugeConfigFactory.getAndAssign(style, marginsElem[0], 'marginTop', 'Top', parseFloat);
                XMLGaugeConfigFactory.getAndAssign(style, marginsElem[0], 'marginBottom', 'Bottom', parseFloat);
            }
        }
        return style;
    }
    /**
     * Create an array of color zones if a definition exists.
     * @param zones An array of color zone definitions.
     * @returns An array of XMLGaugeColorZones
     */
    makeColorZones(zones) {
        var _a, _b;
        const zoneArray = new Array();
        for (let i = 0; i < zones.length; i++) {
            let color = 'white';
            const colorElem = zones[i].getElementsByTagName('Color');
            if (colorElem.length > 0) {
                color = ((_a = colorElem[0]) === null || _a === void 0 ? void 0 : _a.textContent) ? (_b = colorElem[0]) === null || _b === void 0 ? void 0 : _b.textContent : 'white';
            }
            zoneArray.push({
                color: color,
                begin: new CompositeLogicXMLElement(this.instrument, zones[i].getElementsByTagName('Begin')[0]),
                end: new CompositeLogicXMLElement(this.instrument, zones[i].getElementsByTagName('End')[0])
            });
        }
        return zoneArray.length > 0 ? zoneArray : undefined;
    }
    /**
     * Create an array of color lines if a definition exists.
     * @param lines An array of color line definitions.
     * @returns An array of XMLGaugeColorLines
     */
    makeColorLines(lines) {
        var _a, _b;
        const lineArray = new Array();
        for (let i = 0; i < lines.length; i++) {
            let color = 'white';
            const colorElem = lines[i].getElementsByTagName('Color');
            if (colorElem.length > 0) {
                color = ((_a = colorElem[0]) === null || _a === void 0 ? void 0 : _a.textContent) ? (_b = colorElem[0]) === null || _b === void 0 ? void 0 : _b.textContent : 'white';
            }
            lineArray.push({
                color: color,
                position: new CompositeLogicXMLElement(this.instrument, lines[i].getElementsByTagName('Position')[0]),
            });
        }
        return lineArray.length > 0 ? lineArray : undefined;
    }
}

/**
 * An abstract base gauge component containing the universal logic for scaling
 * and margin calculations so these don't need to be implemented in every
 * gauge type.
 */
class BaseGauge extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.theDiv = FSComponent.createRef();
    }
    /**
     * Perform scaling and margin adjustment then render and initialize the gauge.
     */
    onAfterRender() {
        var _a, _b, _c, _d, _e;
        if (((_a = this.props.style) === null || _a === void 0 ? void 0 : _a.sizePercent) && this.props.style.sizePercent !== 100) {
            const factor = this.props.style.sizePercent / 100;
            this.theDiv.instance.style.transform = `scale3d(${factor}, ${factor}, ${factor})`;
            this.theDiv.instance.style.transformOrigin = 'center';
            this.theDiv.instance.style.marginTop = `-${(1 - factor) * 50}%`;
            this.theDiv.instance.style.marginBottom = `-${(1 - factor) * 50}%`;
        }
        if ((_b = this.props.style) === null || _b === void 0 ? void 0 : _b.marginLeft) {
            this.theDiv.instance.style.marginLeft = `${this.props.style.marginLeft}px`;
        }
        if ((_c = this.props.style) === null || _c === void 0 ? void 0 : _c.marginTop) {
            this.theDiv.instance.style.marginTop = `${this.props.style.marginTop}px`;
        }
        if ((_d = this.props.style) === null || _d === void 0 ? void 0 : _d.marginRight) {
            this.theDiv.instance.style.marginRight = `${this.props.style.marginRight}px`;
        }
        if ((_e = this.props.style) === null || _e === void 0 ? void 0 : _e.marginBottom) {
            this.theDiv.instance.style.marginBottom = `${this.props.style.marginBottom}px`;
        }
        FSComponent.render(this.renderGauge(), this.theDiv.instance);
        this.initGauge();
    }
    /**
     * Render the gauge.
     * @returns A VNode
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "abstract_gauge_container", ref: this.theDiv }));
    }
}

/**
 * A class that manages the logic for drawing the colored arcs on a dial gauge.
 */
class CircleGaugeBands extends DisplayComponent {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.pathRefs = new Array();
        this.groupRef = FSComponent.createRef();
        this.pathValues = new Array();
        this.maxValue = 0;
        this.minValue = 0;
        this.beginAngle = ((_a = this.props.style) === null || _a === void 0 ? void 0 : _a.beginAngle) !== undefined ? this.props.style.beginAngle - 90 : -105;
        this.endAngle = ((_b = this.props.style) === null || _b === void 0 ? void 0 : _b.endAngle) !== undefined ? this.props.style.endAngle - 90 : 105;
        this.arcDegrees = this.endAngle - this.beginAngle;
    }
    /** Set initial values then define and draw our color zones. */
    onAfterRender() {
        var _a, _b, _c, _d;
        if (this.props.maximum) {
            this.updateMaxValue((_a = this.props.logicHost) === null || _a === void 0 ? void 0 : _a.addLogicAsNumber(this.props.maximum, (max) => { this.updateMaxValue(max); }, 0));
        }
        if (this.props.minimum) {
            this.updateMinValue((_b = this.props.logicHost) === null || _b === void 0 ? void 0 : _b.addLogicAsNumber(this.props.minimum, (min) => { this.updateMinValue(min); }, 0));
        }
        if (this.props.colorZones) {
            for (let i = 0; i < this.props.colorZones.length; i++) {
                const zone = this.props.colorZones[i];
                const path = FSComponent.createRef();
                FSComponent.render(FSComponent.buildComponent("g", null,
                    FSComponent.buildComponent("path", { ref: path })), this.groupRef.instance);
                this.pathRefs[i] = path;
                this.pathValues[i] = { min: 0, max: 0, color: zone.color !== undefined ? zone.color : 'white' };
                if (zone.begin !== undefined) {
                    this.pathValues[i].min = (_c = this.props.logicHost) === null || _c === void 0 ? void 0 : _c.addLogicAsNumber(zone.begin, (begin) => {
                        this.pathValues[i].min = begin;
                        this.redrawArcs();
                    }, 0);
                }
                if (zone.end !== undefined) {
                    this.pathValues[i].max = (_d = this.props.logicHost) === null || _d === void 0 ? void 0 : _d.addLogicAsNumber(zone.end, (end) => {
                        this.pathValues[i].max = end;
                        this.redrawArcs();
                    }, 0);
                }
            }
            this.redrawArcs();
        }
    }
    /** Draw all the arc in our color zones. */
    redrawArcs() {
        for (let i = 0; i < this.pathRefs.length; i++) {
            this.pathRefs[i].instance.setAttribute('stroke', this.pathValues[i].color);
            this.pathRefs[i].instance.setAttribute('stroke-width', `${this.props.stroke}px`);
            const startAngle = this.beginAngle +
                (((this.pathValues[i].min - this.minValue) / (this.maxValue - this.minValue)) * this.arcDegrees);
            const endAngle = this.beginAngle +
                (((this.pathValues[i].max - this.minValue) / (this.maxValue - this.minValue)) * this.arcDegrees);
            this.pathRefs[i].instance.setAttribute('d', XMLCircleGauge.describeArc(this.props.origin, this.props.radius, startAngle, endAngle));
        }
    }
    /**
     * Update the maximum value.
     * @param max The new max value.
     */
    updateMaxValue(max) {
        this.maxValue = max;
        this.redrawArcs();
    }
    /**
     * Update the minimum value.
     * @param min The new min value.
     */
    updateMinValue(min) {
        this.minValue = min;
        this.redrawArcs();
    }
    /**
     * Render the gauge.
     * @returns A VNode
     */
    render() {
        return (FSComponent.buildComponent("g", { ref: this.groupRef }));
    }
}
/** A new circular gauge */
class XMLCircleGauge extends BaseGauge {
    constructor() {
        var _a, _b, _c, _d, _e;
        super(...arguments);
        this.origin = { x: 70, y: 70 };
        this.arcRadius = 65.5;
        this.bandRadius = 60.5;
        this.titleRef = FSComponent.createRef();
        this.unitsRef = FSComponent.createRef();
        this.valueRef = FSComponent.createRef();
        this.startRef = FSComponent.createRef();
        this.endRef = FSComponent.createRef();
        this.arcRef = FSComponent.createRef();
        this.ticksRef = FSComponent.createRef();
        this.svgRef = FSComponent.createRef();
        this.needleRef = FSComponent.createRef();
        this.containerDiv = FSComponent.createRef();
        this.maxValue = 0;
        this.minValue = 0;
        this.beginAngle = ((_a = this.props.style) === null || _a === void 0 ? void 0 : _a.beginAngle) !== undefined ? this.props.style.beginAngle - 90 : -105;
        this.endAngle = ((_b = this.props.style) === null || _b === void 0 ? void 0 : _b.endAngle) !== undefined ? this.props.style.endAngle - 90 : 105;
        this.arcDegrees = this.endAngle - this.beginAngle;
        this.quantum = ((_c = this.props.style) === null || _c === void 0 ? void 0 : _c.textIncrement) !== undefined ? (_d = this.props.style) === null || _d === void 0 ? void 0 : _d.textIncrement : 1;
        this.precision = (_e = this.props.style) === null || _e === void 0 ? void 0 : _e.valuePrecision;
    }
    /** Draw our ticks. */
    drawTicks() {
        const ticks = new Array();
        ticks.push(this.beginAngle);
        if (this.props.graduationLength !== undefined) {
            const graduations = Math.trunc((this.maxValue - this.minValue) / this.props.graduationLength);
            if (graduations > 1) {
                const spacing = this.arcDegrees / graduations;
                for (let i = 1; i < graduations; i++) {
                    ticks.push(this.beginAngle + spacing * i);
                }
            }
        }
        ticks.push(this.endAngle);
        for (let i = 0; i < ticks.length; i++) {
            const pointA = XMLCircleGauge.polarToCartesian(this.origin, this.arcRadius - 11, ticks[i]);
            const pointB = XMLCircleGauge.polarToCartesian(this.origin, this.arcRadius, ticks[i]);
            FSComponent.render(FSComponent.buildComponent("g", null,
                FSComponent.buildComponent("line", { x1: pointA.x, y1: pointA.y, x2: pointB.x, y2: pointB.y, stroke: "white", "stroke-width": "1px", "shape-rendering": "crispEdges" })), this.ticksRef.instance);
        }
    }
    /**
     * Initialize the rendered gauge.
     */
    initGauge() {
        var _a, _b, _c, _d, _e, _f, _g;
        if (this.props.value1) {
            this.updateValue((_a = this.props.logicHost) === null || _a === void 0 ? void 0 : _a.addLogicAsNumber(this.props.value1, (value) => { this.updateValue(value); }, 2));
            if (this.props.maximum) {
                this.updateMaxValue((_b = this.props.logicHost) === null || _b === void 0 ? void 0 : _b.addLogicAsNumber(this.props.maximum, (max) => { this.updateMaxValue(max); }, 0));
            }
            if (this.props.minimum) {
                this.updateMinValue((_c = this.props.logicHost) === null || _c === void 0 ? void 0 : _c.addLogicAsNumber(this.props.minimum, (min) => { this.updateMinValue(min); }, 0));
            }
            if (this.props.redBlink) {
                (_d = this.props.logicHost) === null || _d === void 0 ? void 0 : _d.addLogicAsNumber(this.props.redBlink, (value) => {
                    this.setAlertState(value);
                }, 0);
            }
        }
        if (this.props.beginText !== undefined) {
            this.startRef.instance.textContent = this.props.beginText;
        }
        if (this.props.endText !== undefined) {
            this.endRef.instance.textContent = this.props.endText;
        }
        // TODO RCJ make the rest of this function less ugly
        if (((_e = this.props.style) === null || _e === void 0 ? void 0 : _e.valuePos) == XMLCircularGaugeValuePos.End) {
            this.valueRef.instance.classList.add('ValPosEnd');
            // TODO Improve the logic for positioning the value laterally when it's at the end position.
            const endanchor = XMLCircleGauge.polarToCartesian(this.origin, this.arcRadius + 10, this.endAngle + 10);
            this.valueRef.instance.style.right = `${148 - endanchor.x}px`;
            const endPxBelowLine = XMLCircleGauge.distanceFromYOrigin(this.origin, this.arcRadius, this.endAngle);
            this.valueRef.instance.style.top = `${65 - endPxBelowLine + 10}px`;
        }
        else {
            this.valueRef.instance.style.top = '0px';
        }
        if ((_f = this.props.style) === null || _f === void 0 ? void 0 : _f.forceTextColor) {
            this.valueRef.instance.style.color = this.props.style.forceTextColor;
        }
        const textBottom = parseFloat(this.valueRef.instance.style.top) + this.valueRef.instance.offsetHeight;
        this.arcRef.instance.setAttribute('d', XMLCircleGauge.describeArc(this.origin, this.arcRadius, this.beginAngle, this.endAngle));
        const pxBelowLine = Math.max(0, -1 * XMLCircleGauge.heightOfArc(this.origin, this.arcRadius, this.beginAngle, this.endAngle));
        if (((_g = this.props.style) === null || _g === void 0 ? void 0 : _g.valuePos) == XMLCircularGaugeValuePos.End) {
            // Add a little more to account for stroke width and not cut off the bottom.
            this.svgRef.instance.setAttribute('viewBox', `0 0 148 ${Math.max(this.arcRadius + pxBelowLine + 5, textBottom)}`);
        }
        else {
            this.svgRef.instance.setAttribute('viewBox', `0 0 148 ${this.arcRadius + pxBelowLine}`);
        }
        this.drawTicks();
    }
    /**
     * Update the value.
     * @param value The new value to set.
     */
    updateValue(value) {
        var _a;
        let textValue;
        Utils.Clamp(value, this.minValue, this.maxValue);
        const rotation = this.beginAngle + ((value / this.maxValue) * this.arcDegrees);
        if (this.needleRef.getOrDefault() && this.valueRef.getOrDefault()) {
            this.needleRef.instance.style.transform = `rotate(${rotation}deg)`;
            value = Math.round(value / this.quantum) * this.quantum;
            if (this.precision) {
                textValue = value.toFixed(this.precision);
            }
            else {
                // don't spend time on toFixed if a precision isn't required.
                // Unless there's a decimal quantum set, the number will be whole, anyway.
                textValue = value + '';
            }
            if (this.valueRef.instance.textContent !== `${textValue}`) {
                this.valueRef.instance.textContent = `${textValue}`;
            }
        }
        if (!((_a = this.props.style) === null || _a === void 0 ? void 0 : _a.forceTextColor) && this.props.colorZones) {
            let colorSet = false;
            for (const range of this.props.colorZones) {
                if (value >= range.begin.getValueAsNumber() && value <= range.end.getValueAsNumber()) {
                    this.valueRef.instance.style.color = range.color;
                    colorSet = true;
                    break;
                }
            }
            if (!colorSet) {
                this.valueRef.instance.style.color = 'white';
            }
        }
    }
    /**
     * Update the maximum value.
     * @param max The new max value.
     */
    updateMaxValue(max) {
        this.maxValue = max;
        if (this.props.endText == undefined) {
            this.endRef.instance.textContent = `${max}`;
        }
    }
    /**
     * Update the minimum value.
     * @param min The new min value.
     */
    updateMinValue(min) {
        if (this.props.beginText == undefined) {
            this.startRef.instance.textContent = `${min}`;
        }
        this.minValue = 0;
    }
    /**
     * Handle changes in the alert state.
     * @param alerting True if alerting.
     */
    setAlertState(alerting) {
        if (alerting !== 0) {
            this.titleRef.instance.style.animation = 'AlertBlink 1s infinite';
            this.unitsRef.instance.style.animation = 'AlertBlink 1s infinite';
            this.valueRef.instance.style.animation = 'AlertBlink 1s infinite';
        }
        else {
            this.titleRef.instance.style.animation = '';
            this.unitsRef.instance.style.animation = '';
            this.valueRef.instance.style.animation = '';
        }
    }
    /**
     * Given a cartesian origin and a set of polar coordinates, find the cartesian
     * point that represents the polar location in the cartesian grid.
     * @param center The cartesian center.
     * @param radius The radiun in pixels.
     * @param azimuth The angle coordinate in degrees.
     * @returns The cartesian point represented by the polar one.
     */
    // TODO See if there's common math for this.
    static polarToCartesian(center, radius, azimuth) {
        const azimuthRad = (azimuth - 90) * Math.PI / 180.0;
        return {
            x: center.x + (radius * Math.cos(azimuthRad)),
            y: center.y + (radius * Math.sin(azimuthRad))
        };
    }
    /**
     * Construct an SVG path string for a given arc based on its coordinates and radius.
       @param center The cartesian center of the arc.
     * @param radius The radius in pixels.
     * @param startAngle The starting azimuth of the arc in degrees.
     * @param endAngle The final azimuth of the arc in degrees.
     * @returns A string describing an SVG path.
     */
    static describeArc(center, radius, startAngle, endAngle) {
        const start = XMLCircleGauge.polarToCartesian(center, radius, startAngle);
        const end = XMLCircleGauge.polarToCartesian(center, radius, endAngle);
        const largeArcFlag = endAngle - startAngle <= 180 ? '0' : '1';
        const d = [
            'M', start.x, start.y,
            'A', radius, radius, 0, largeArcFlag, 1, end.x, end.y
        ].join(' ');
        return d;
    }
    /**
     * Determine the height "below the line" of the arc in pixels.
       @param center The cartesian center of the arc.
     * @param radius The radius in pixels.
     * @param startAngle The starting azimuth of the arc in degrees.
     * @param endAngle The final azimuth of the arc in degrees
     * @returns An integer with the pixels.
     */
    static heightOfArc(center, radius, startAngle, endAngle) {
        return XMLCircleGauge.distanceFromYOrigin(center, radius, Math.max(Math.abs(startAngle), Math.abs(endAngle)));
    }
    /**
     * Determine how far from the Y origin a cartesian point is.
     * @param center The cartesian center.
     * @param radius The radius in pixels.
     * @param angle The angle in degrees.
     * @returns The distance from the origin in pixels.
     */
    static distanceFromYOrigin(center, radius, angle) {
        const theta = Math.abs(angle);
        const cos = Math.cos(Units.Degrees.toRadians(theta));
        const dist = radius * cos;
        return dist;
    }
    /**
     * Render a circle gauge
     * @returns A VNode
     */
    renderGauge() {
        var _a;
        return (FSComponent.buildComponent("div", { class: 'dial_gauge_container', ref: this.containerDiv },
            FSComponent.buildComponent("svg", { viewBox: "0 0 148 0", ref: this.svgRef },
                FSComponent.buildComponent(CircleGaugeBands, Object.assign({}, this.props, { origin: this.origin, radius: this.bandRadius, stroke: 5 })),
                FSComponent.buildComponent("path", { ref: this.arcRef, fill: "none", stroke: "white", "stroke-width": "1px" }),
                FSComponent.buildComponent("path", { class: "inner_circle", d: "M 70 70 m -7 0 a 7 7 78 0 1 14 0", fill: "rgb(30,30,30)" }),
                FSComponent.buildComponent("g", { ref: this.ticksRef })),
            FSComponent.buildComponent("div", { class: "gauge_pointer", ref: this.needleRef },
                FSComponent.buildComponent("svg", null,
                    FSComponent.buildComponent("path", { d: ((_a = this.props.style) === null || _a === void 0 ? void 0 : _a.cursorType) === XMLCircularGaugeCursor.Triangle ?
                            'M 70 31 m 0 -11 l -9 0 l 9 -11 l 9 11 z' :
                            'M 70 70 m 0 -6 l -1 0 l 0 -38 l -4 -6 l 5 -11 l 5 11 l -4 6 l 0 38 l -1 0 z', fill: "white", stroke: "black", "stroke-width": ".4px" }))),
            FSComponent.buildComponent("div", { class: "gauge_title" },
                FSComponent.buildComponent("div", { class: "gauge_text_block", ref: this.titleRef }, this.props.title)),
            FSComponent.buildComponent("div", { class: "gauge_units" },
                FSComponent.buildComponent("div", { class: "gauge_text_block", ref: this.unitsRef }, this.props.unit)),
            FSComponent.buildComponent("div", { class: "gauge_minimum", ref: this.startRef }),
            FSComponent.buildComponent("div", { class: "gauge_value", ref: this.valueRef }),
            FSComponent.buildComponent("div", { class: "gauge_maximum", ref: this.endRef })));
    }
}

/** The dynamic color bands for a gauge. */
class HorizontalColorZone extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.theRect = FSComponent.createRef();
        this.gaugeMin = 0;
        this.gaugeMax = 0;
        this.zoneMin = 0;
        this.zoneMax = 0;
    }
    /** Do things after rendering. */
    onAfterRender() {
        var _a, _b, _c, _d;
        this.zoneMin = (_a = this.props.logicHost) === null || _a === void 0 ? void 0 : _a.addLogicAsNumber(this.props.values.begin, (min) => {
            this.zoneMin = min;
            this.redraw();
        }, 0);
        this.zoneMax = (_b = this.props.logicHost) === null || _b === void 0 ? void 0 : _b.addLogicAsNumber(this.props.values.end, (max) => {
            this.zoneMax = max;
            this.redraw();
        }, 0);
        if (this.props.gaugeMin) {
            this.gaugeMin = (_c = this.props.logicHost) === null || _c === void 0 ? void 0 : _c.addLogicAsNumber(this.props.gaugeMin, (min) => {
                this.gaugeMin = min;
                this.redraw();
            }, 0);
        }
        if (this.props.gaugeMax) {
            this.gaugeMax = (_d = this.props.logicHost) === null || _d === void 0 ? void 0 : _d.addLogicAsNumber(this.props.gaugeMax, (max) => {
                this.gaugeMax = max;
                this.redraw();
            }, 0);
        }
        this.theRect.instance.setAttribute('fill', this.props.values.color ? this.props.values.color : 'white');
    }
    /**
     * Redraw ourselves when something changes.  Since a lot of our values are
     * relative, we'll recompute our dimensions whenever one of them changes.
     */
    redraw() {
        // we shorten the maximum length of the bar by a couple pixels so colors don't cover the end ticks
        const startX = 12 + (((this.zoneMin - this.gaugeMin) / (this.gaugeMax - this.gaugeMin)) * 123);
        const width = ((this.zoneMax - this.zoneMin) / (this.gaugeMax - this.gaugeMin)) * 123;
        this.theRect.instance.setAttribute('x', `${startX}`);
        this.theRect.instance.setAttribute('width', `${width}`);
    }
    /**
     * Render a color zone.
     * @returns A VNode of the zone.
     */
    render() {
        return FSComponent.buildComponent("rect", { ref: this.theRect, x: 0, y: this.props.yPos, height: this.props.height, width: 0, fill: "white" });
    }
}
/** A graduated horizontal bar. */
// The type spec on this one is really ugly and could probably be improved with better
// use of generics.  I'm too tired to work on that now.
class GraduatedBar extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.tickRef = FSComponent.createRef();
        this.labelRef = FSComponent.createRef();
        this.gaugeMin = 0;
        this.gaugeMax = 0;
        this.tickRise = 35 - this.props.tickRise;
        this.tickFall = 35 + this.props.tickFall;
    }
    /** Do stuff after rendering. */
    onAfterRender() {
        var _a, _b;
        if (this.props.minimum) {
            this.gaugeMin = (_a = this.props.logicHost) === null || _a === void 0 ? void 0 : _a.addLogicAsNumber(this.props.minimum, (min) => { this.gaugeMin = min; }, 0);
        }
        if (this.props.maximum) {
            this.gaugeMax = (_b = this.props.logicHost) === null || _b === void 0 ? void 0 : _b.addLogicAsNumber(this.props.maximum, (max) => { this.gaugeMax = max; }, 0);
        }
        // Currently, the graduations are created as a static element, even though
        // the min and max could techincally change since they are logic elements.
        // This matches the default, stock functionality, but it would be cool to
        // enhance this so that you could fully redraw the entire gauge on demand.
        if (this.props.graduationLength !== undefined) {
            const graduations = Math.trunc((this.gaugeMax - this.gaugeMin) / this.props.graduationLength) + 1;
            const tickSpacing = 123 / (graduations - 1);
            for (let i = 0; i < graduations; i++) {
                const xPos = 11 + tickSpacing * i;
                // Only draw a tick if we're not at the start or end.
                if (i > 0 && i < graduations - 1) {
                    // TODO Add minor-tick support for our enhanced stuff.
                    FSComponent.render(FSComponent.buildComponent("g", null,
                        FSComponent.buildComponent("line", { x1: xPos, y1: this.tickRise, x2: xPos, y2: this.tickFall, stroke: "white", "stroke-width": "1px", "shape-rendering": "crispEdges" })), this.tickRef.instance);
                }
                let gradLabel = undefined;
                // TODO Streamline this logic a little.
                if (this.props.graduationHasText) {
                    gradLabel = `${this.props.graduationLength * i}`;
                }
                if (i == 0) {
                    if (this.props.beginText !== undefined) {
                        gradLabel = this.props.beginText;
                    }
                    else {
                        gradLabel = `${this.gaugeMin}`;
                    }
                }
                else if (i == graduations - 1) {
                    if (this.props.endText !== undefined) {
                        gradLabel = this.props.endText;
                    }
                    else {
                        gradLabel = `${this.gaugeMax}`;
                    }
                }
                if (gradLabel !== undefined) {
                    FSComponent.render(FSComponent.buildComponent("g", null,
                        FSComponent.buildComponent("text", { x: xPos, y: 55, fill: "white", "text-anchor": "middle", "font-size": '12' }, gradLabel)), this.labelRef.instance);
                }
            }
        }
    }
    /**
     * Render the bar.
     * @returns A VNode.
     */
    render() {
        return FSComponent.buildComponent("g", { id: "graduatedBar" },
            FSComponent.buildComponent("g", { id: "staticLineElements" },
                FSComponent.buildComponent("line", { x1: 11, y1: this.tickRise - 5, x2: 11, y2: this.tickFall, stroke: "white", "stroke-width": "1.2px" }),
                FSComponent.buildComponent("line", { x1: 134, y1: this.tickRise - 5, x2: 134, y2: this.tickFall, stroke: "white", "stroke-width": "1.2px" })),
            FSComponent.buildComponent("g", { id: "tickmarks", ref: this.tickRef }),
            FSComponent.buildComponent("g", { id: "ticklabels", ref: this.labelRef }));
    }
}
//
// Single and double sided pointers.
//
/** A single-sided pointer. */
class SinglePointer extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ptrDiv = FSComponent.createRef();
        this.ptrPath = FSComponent.createRef();
        this.ptrLabel = FSComponent.createRef();
        this.minimum = 0;
        this.maximum = 0;
        this.value1 = 0;
    }
    /** Do stuff after rendering. */
    onAfterRender() {
        var _a, _b, _c, _d;
        if (this.props.style !== undefined) {
            switch (this.props.style.pointerStyle) {
                case 'arrow':
                    // TODO Adapt this better from the double sided gauge.
                    this.ptrPath.instance.setAttribute('d', 'M 0 0 m 15 35 l 12 -15 l -24 0 z');
                    break;
                case 'standard':
                default:
                    this.ptrPath.instance.setAttribute('d', 'M 0 0 m 15 35 l 5 -5 l 0 -10 l -10 0 l 0 10 l 5 5 z');
                    break;
            }
        }
        this.ptrLabel.instance.textContent = this.props.cursorText1 !== undefined ? this.props.cursorText1 : '';
        if (this.props.minimum !== undefined) {
            this.minimum = (_a = this.props.logicHost) === null || _a === void 0 ? void 0 : _a.addLogicAsNumber(this.props.minimum, (min) => {
                this.minimum = min;
                this.updatePtr(this.value1);
            }, 0);
        }
        if (this.props.maximum !== undefined) {
            this.maximum = (_b = this.props.logicHost) === null || _b === void 0 ? void 0 : _b.addLogicAsNumber(this.props.maximum, (max) => {
                this.maximum = max;
                this.updatePtr(this.value1);
            }, 0);
        }
        if (this.props.value1 !== undefined) {
            this.value1 = (_c = this.props.logicHost) === null || _c === void 0 ? void 0 : _c.addLogicAsNumber(this.props.value1, (val) => {
                this.value1 = val;
                this.updatePtr(this.value1);
            }, 2);
        }
        if (this.props.redBlink) {
            (_d = this.props.logicHost) === null || _d === void 0 ? void 0 : _d.addLogicAsNumber(this.props.redBlink, (value) => {
                this.setAlertState(value);
            }, 0);
        }
    }
    /**
     * Update a needle value.
     * @param value The new value to set.
     */
    updatePtr(value) {
        value = Utils.Clamp(value, this.minimum, this.maximum);
        const translation = (value - this.minimum) / (this.maximum - this.minimum) * 123;
        this.ptrDiv.instance.style.transform = `translate3d(${translation}px, 0px, 0px)`;
    }
    /**
     * Handle changes in the alert state.
     * @param alerting True if alerting.
     */
    setAlertState(alerting) {
        if (alerting !== 0) {
            this.ptrPath.instance.setAttribute('fill', 'red');
        }
        else {
            this.ptrPath.instance.setAttribute('fill', 'white');
        }
    }
    /**
     * Render the pointer.
     * @returns A VNode
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "gauge_pointer", ref: this.ptrDiv },
            FSComponent.buildComponent("svg", null,
                FSComponent.buildComponent("path", { d: "", fill: "white", stroke: "black", "stroke-width": ".5px", ref: this.ptrPath }),
                FSComponent.buildComponent("text", { x: "12", y: "30", class: "gauge_pointer_text", ref: this.ptrLabel }))));
    }
}
/** A two-sided pointer. */
class DoublePointer$1 extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ptr1Div = FSComponent.createRef();
        this.ptr2Div = FSComponent.createRef();
        this.ptr1Path = FSComponent.createRef();
        this.ptr2Path = FSComponent.createRef();
        this.ptr1Label = FSComponent.createRef();
        this.ptr2Label = FSComponent.createRef();
        this.minimum = 0;
        this.maximum = 0;
        this.value1 = 0;
        this.value2 = 0;
    }
    /** Do stuff after rendering. */
    onAfterRender() {
        var _a, _b, _c, _d;
        if (this.props.style !== undefined) {
            switch (this.props.style.pointerStyle) {
                case 'arrow':
                    this.ptr1Path.instance.setAttribute('d', 'M 0 0 m 15 35 l 12 -15 l -24 0 z');
                    this.ptr2Path.instance.setAttribute('d', 'M 0 0 m 15 35 l 12 15 l -24 0 z');
                    break;
                case 'standard':
                default:
                    this.ptr1Path.instance.setAttribute('d', 'M 0 0 m 15 35 l 5 -5 l 0 -10 l -10 0 l 0 10 l 5 5 z');
                    this.ptr2Path.instance.setAttribute('d', 'M 0 0 m 15 35 l 5 5 l 0 10 l -10 0 l 0 -10 l 5 -5 z');
                    break;
            }
        }
        this.ptr1Label.instance.textContent = this.props.cursorText1 !== undefined ? this.props.cursorText1 : '';
        this.ptr2Label.instance.textContent = this.props.cursorText2 !== undefined ? this.props.cursorText2 : '';
        if (this.props.minimum !== undefined) {
            this.minimum = (_a = this.props.logicHost) === null || _a === void 0 ? void 0 : _a.addLogicAsNumber(this.props.minimum, (min) => {
                this.minimum = min;
                this.updatePtr(this.ptr1Div, this.value1);
                this.updatePtr(this.ptr2Div, this.value2);
            }, 0);
        }
        if (this.props.maximum !== undefined) {
            this.maximum = (_b = this.props.logicHost) === null || _b === void 0 ? void 0 : _b.addLogicAsNumber(this.props.maximum, (max) => {
                this.maximum = max;
                this.updatePtr(this.ptr1Div, this.value1);
                this.updatePtr(this.ptr2Div, this.value2);
            }, 0);
        }
        if (this.props.value1 !== undefined) {
            this.value1 = (_c = this.props.logicHost) === null || _c === void 0 ? void 0 : _c.addLogicAsNumber(this.props.value1, (val) => {
                this.value1 = val;
                this.updatePtr(this.ptr1Div, this.value1);
            }, 2);
        }
        if (this.props.value2 !== undefined) {
            this.value2 = (_d = this.props.logicHost) === null || _d === void 0 ? void 0 : _d.addLogicAsNumber(this.props.value2, (val) => {
                this.value2 = val;
                this.updatePtr(this.ptr2Div, this.value2);
            }, 2);
        }
    }
    /**
     * Update a needle value.
     * @param ptrRef A NodeReference to the needle div.
     * @param value The new value to set.
     */
    updatePtr(ptrRef, value) {
        value = Utils.Clamp(value, this.minimum, this.maximum);
        const translation = (value - this.minimum) / (this.maximum - this.minimum) * 123;
        ptrRef.instance.style.transform = `translate3d(${translation}px, 0px, 0px)`;
    }
    /**
     * Render the pointers.
     * @returns A VNode
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "gauge_pointers" },
            FSComponent.buildComponent("div", { class: "gauge_pointer_top", ref: this.ptr1Div },
                FSComponent.buildComponent("svg", null,
                    FSComponent.buildComponent("path", { d: "", fill: "white", stroke: "black", "stroke-width": ".5px", ref: this.ptr1Path }),
                    FSComponent.buildComponent("text", { x: "12", y: "30", class: "gauge_pointer_text", ref: this.ptr1Label }))),
            FSComponent.buildComponent("div", { class: "gauge_pointer_bottom", ref: this.ptr2Div },
                FSComponent.buildComponent("svg", null,
                    FSComponent.buildComponent("path", { d: "", fill: "white", stroke: "black", "stroke-width": ".5px", ref: this.ptr2Path }),
                    FSComponent.buildComponent("text", { x: "12", y: "48", class: "gauge_pointer_text", ref: this.ptr2Label })))));
    }
}
//
// I've reduced a lot of redundancy here, but there's still some repetition
// in the two class definitions below.   A future enhancment might be to
// streamline that a little more.
//
/** A horizontal bar gauge with a single set of values. */
class XMLHorizontalGauge extends BaseGauge {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
        this.titleRef = FSComponent.createRef();
        this.titleBgRef = FSComponent.createRef();
        this.zoneGroupRef = FSComponent.createRef();
    }
    /**
     * Initialize the rendered gauge.
     */
    initGauge() {
        var _a;
        if (this.props.title) {
            this.titleRef.instance.textContent = this.props.title;
        }
        if (this.props.unit) {
            this.titleRef.instance.textContent += ` ${this.props.unit}`;
        }
        if (this.props.colorZones) {
            for (let i = 0; i < this.props.colorZones.length; i++) {
                FSComponent.render(FSComponent.buildComponent(HorizontalColorZone, { logicHost: this.props.logicHost, height: 6, yPos: 27, values: this.props.colorZones[i], gaugeMin: this.props.minimum, gaugeMax: this.props.maximum }), this.zoneGroupRef.instance);
            }
        }
        if (this.props.redBlink) {
            (_a = this.props.logicHost) === null || _a === void 0 ? void 0 : _a.addLogicAsNumber(this.props.redBlink, (value) => {
                this.setAlertState(value);
            }, 0);
        }
        const bbox = this.titleRef.instance.getBBox();
        this.titleBgRef.instance.setAttribute('x', `${bbox.x - 1}`);
        this.titleBgRef.instance.setAttribute('y', `${bbox.y - 1}`);
        this.titleBgRef.instance.setAttribute('width', `${bbox.width + 2}`);
        this.titleBgRef.instance.setAttribute('height', `${bbox.height + 2}`);
    }
    /**
     * Handle changes in the alert state.
     * @param alerting True if alerting.
     */
    setAlertState(alerting) {
        if (alerting !== 0) {
            if (this.titleBgRef.instance.getBBox().x <= 0) {
                // I initially did this in initGauge, but would end up getting 0,0 as my origin
                // at times, presumbaly because the text element hadn't yet been rendered when
                // we got the data, so I moved it down here.   Then, for some reason, it started
                // being 0,0 even more consistently.  For now we do this both in the init and
                // here as a backstop.
                // TODO Figure out why this is happening and remove this redundancy.
                const bbox = this.titleRef.instance.getBBox();
                this.titleBgRef.instance.setAttribute('x', `${bbox.x - 1}`);
                this.titleBgRef.instance.setAttribute('y', `${bbox.y - 1}`);
                this.titleBgRef.instance.setAttribute('width', `${bbox.width + 2}`);
                this.titleBgRef.instance.setAttribute('height', `${bbox.height + 2}`);
            }
            this.titleBgRef.instance.setAttribute('fill-opacity', '100');
            this.titleBgRef.instance.style.animation = 'AlertBlinkBackground 1s infinite';
            this.titleRef.instance.style.animation = 'AlertBlink 1s infinite';
        }
        else {
            this.titleBgRef.instance.setAttribute('fill-opacity', '0');
            this.titleBgRef.instance.style.animation = '';
            this.titleRef.instance.style.animation = '';
        }
    }
    /**
     * Render a horizontal bar gauge
     * @returns A VNode
     */
    renderGauge() {
        return (FSComponent.buildComponent("div", { class: "single_horiz_container" },
            FSComponent.buildComponent("svg", { viewBox: "0 0 148 40", ref: this.svgRef },
                FSComponent.buildComponent("rect", { x: 74, y: 15, width: 0, height: 0, "fill-opacity": 0, ref: this.titleBgRef }),
                FSComponent.buildComponent("text", { x: 74, y: 15, fill: "white", "text-anchor": "middle", "font-size": "15", ref: this.titleRef }),
                FSComponent.buildComponent("line", { x1: 11, y1: 35, x2: 134, y2: 35, stroke: "white", "stroke-width": "1.2px" }),
                FSComponent.buildComponent("line", { x1: 11, y1: 34, x2: 134, y2: 34, stroke: "darkgrey", "stroke-width": ".5px" }),
                FSComponent.buildComponent("g", { id: "colorZones", ref: this.zoneGroupRef }),
                FSComponent.buildComponent(GraduatedBar, Object.assign({}, this.props, { tickRise: 11, tickFall: 0 })),
                ")"),
            FSComponent.buildComponent(SinglePointer, Object.assign({}, this.props))));
    }
}
/** A horizontal bar gauge with two sets of values. */
class XMLDoubleHorizontalGauge extends BaseGauge {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
        this.titleRef = FSComponent.createRef();
        this.zoneGroupRef = FSComponent.createRef();
    }
    /**
     * Initialize the rendered gauge.
     */
    initGauge() {
        if (this.props.title) {
            this.titleRef.instance.textContent = this.props.title;
        }
        if (this.props.unit) {
            this.titleRef.instance.textContent += ` ${this.props.unit}`;
        }
        if (this.props.colorZones) {
            for (let i = 0; i < this.props.colorZones.length; i++) {
                FSComponent.render(FSComponent.buildComponent(HorizontalColorZone, { logicHost: this.props.logicHost, height: 6, yPos: 32, values: this.props.colorZones[i], gaugeMin: this.props.minimum, gaugeMax: this.props.maximum }), this.zoneGroupRef.instance);
            }
        }
    }
    /**
     * Render a horizontal bar gauge
     * @returns A VNode
     */
    renderGauge() {
        return (FSComponent.buildComponent("div", { class: "double_horiz_container" },
            FSComponent.buildComponent("svg", { viewBox: "0 0 148 55", ref: this.svgRef },
                FSComponent.buildComponent("text", { x: 74, y: 15, fill: "white", "text-anchor": "middle", "font-size": "15", ref: this.titleRef }),
                FSComponent.buildComponent("line", { x1: 11, y1: 35, x2: 134, y2: 35, stroke: "white", "stroke-width": "1.2px" }),
                FSComponent.buildComponent("g", { id: "colorZones", ref: this.zoneGroupRef }),
                FSComponent.buildComponent(GraduatedBar, Object.assign({}, this.props, { tickRise: 6.5, tickFall: 6.5 }))),
            FSComponent.buildComponent(DoublePointer$1, Object.assign({}, this.props))));
    }
}

/** The dynamic color bands for a gauge. */
class VerticalColorZone extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.theRect = FSComponent.createRef();
        this.gaugeMin = 0;
        this.gaugeMax = 0;
        this.zoneMin = 0;
        this.zoneMax = 0;
    }
    /** Do things after rendering. */
    onAfterRender() {
        var _a, _b, _c, _d;
        this.zoneMin = (_a = this.props.logicHost) === null || _a === void 0 ? void 0 : _a.addLogicAsNumber(this.props.values.begin, (min) => {
            this.zoneMin = min;
            this.redraw();
        }, 0);
        this.zoneMax = (_b = this.props.logicHost) === null || _b === void 0 ? void 0 : _b.addLogicAsNumber(this.props.values.end, (max) => {
            this.zoneMax = max;
            this.redraw();
        }, 0);
        if (this.props.gaugeMin) {
            this.gaugeMin = (_c = this.props.logicHost) === null || _c === void 0 ? void 0 : _c.addLogicAsNumber(this.props.gaugeMin, (min) => {
                this.gaugeMin = min;
                this.redraw();
            }, 0);
        }
        if (this.props.gaugeMax) {
            this.gaugeMax = (_d = this.props.logicHost) === null || _d === void 0 ? void 0 : _d.addLogicAsNumber(this.props.gaugeMax, (max) => {
                this.gaugeMax = max;
                this.redraw();
            }, 0);
        }
        this.theRect.instance.setAttribute('fill', this.props.values.color ? this.props.values.color : 'white');
    }
    /**
     * Redraw ourselves when something changes.  Since a lot of our values are
     * relative, we'll recompute our dimensions whenever one of them changes.
     */
    redraw() {
        const baseY = this.props.origin.y + this.props.gaugeHeight;
        const height = ((this.zoneMax - this.zoneMin) / (this.gaugeMax - this.gaugeMin)) * this.props.gaugeHeight;
        const startY = baseY - height - (((this.zoneMin - this.gaugeMin) / (this.gaugeMax - this.gaugeMin)) * this.props.gaugeHeight);
        this.theRect.instance.setAttribute('y', `${startY}`);
        this.theRect.instance.setAttribute('height', `${height}`);
    }
    /**
     * Render a color zone.
     * @returns A VNode of the zone.
     */
    render() {
        return FSComponent.buildComponent("rect", { ref: this.theRect, x: this.props.origin.x, y: 0, height: 0, width: this.props.width, fill: "white" });
    }
}
/** A two-sided pointer. */
class DoublePointer extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ptr1Div = FSComponent.createRef();
        this.ptr2Div = FSComponent.createRef();
        this.ptr1Path = FSComponent.createRef();
        this.ptr2Path = FSComponent.createRef();
        this.ptr1Label = FSComponent.createRef();
        this.ptr2Label = FSComponent.createRef();
        this.minimum = 0;
        this.maximum = 0;
        this.value1 = 0;
        this.value2 = 0;
    }
    /** Do stuff after rendering. */
    onAfterRender() {
        var _a, _b, _c, _d;
        this.ptr1Path.instance.setAttribute('d', 'M 0 0 l 22 0 l -12 10 l 0 86 l -10 0 z');
        this.ptr2Path.instance.setAttribute('d', 'M 0 0 l 22 0 l 0 96 l -10 0 l 0 -86 z');
        this.ptr1Label.instance.textContent = this.props.cursorText1 !== undefined ? this.props.cursorText1 : '';
        this.ptr2Label.instance.textContent = this.props.cursorText2 !== undefined ? this.props.cursorText2 : '';
        if (this.props.minimum !== undefined) {
            this.minimum = (_a = this.props.logicHost) === null || _a === void 0 ? void 0 : _a.addLogicAsNumber(this.props.minimum, (min) => {
                this.minimum = min;
                this.updatePtr(this.ptr1Div, this.value1);
                this.updatePtr(this.ptr2Div, this.value2);
            }, 0);
        }
        if (this.props.maximum !== undefined) {
            this.maximum = (_b = this.props.logicHost) === null || _b === void 0 ? void 0 : _b.addLogicAsNumber(this.props.maximum, (max) => {
                this.maximum = max;
                this.updatePtr(this.ptr1Div, this.value1);
                this.updatePtr(this.ptr2Div, this.value2);
            }, 0);
        }
        if (this.props.value1 !== undefined) {
            this.value1 = (_c = this.props.logicHost) === null || _c === void 0 ? void 0 : _c.addLogicAsNumber(this.props.value1, (val) => {
                this.value1 = val;
                this.updatePtr(this.ptr1Div, this.value1);
            }, 2);
        }
        if (this.props.value2 !== undefined) {
            this.value2 = (_d = this.props.logicHost) === null || _d === void 0 ? void 0 : _d.addLogicAsNumber(this.props.value2, (val) => {
                this.value2 = val;
                this.updatePtr(this.ptr2Div, this.value2);
            }, 2);
        }
    }
    /**
     * Update a needle value.
     * @param ptrRef A NodeReference to the needle div.
     * @param value The new value to set.
     */
    updatePtr(ptrRef, value) {
        value = Utils.Clamp(value, this.minimum, this.maximum);
        const translation = 80 - ((value - this.minimum) / (this.maximum - this.minimum)) * 80;
        ptrRef.instance.style.transform = `translate3d(0px,${(translation)}px, 0px)`;
    }
    /**
     * Render the pointers.
     * @returns A VNode
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "gauge_pointers" },
            FSComponent.buildComponent("div", { class: "gauge_pointer_left", ref: this.ptr1Div },
                FSComponent.buildComponent("svg", null,
                    FSComponent.buildComponent("defs", null,
                        FSComponent.buildComponent("linearGradient", { id: "pointerGradientLeft", x1: "0%", y1: "0%", x2: "100%", y2: "0%" },
                            FSComponent.buildComponent("stop", { offset: "0%", style: "stop-color:rgb(80,80,80);stop-opacity:1" }),
                            FSComponent.buildComponent("stop", { offset: "30%", style: "stop-color:rgb(255,255,255);stop-opacity:1" }),
                            FSComponent.buildComponent("stop", { offset: "100%", style: "stop-color:rgb(80,80,80);stop-opacity:1" }))),
                    FSComponent.buildComponent("path", { d: "", fill: "url(#pointerGradientLeft)", ref: this.ptr1Path }),
                    FSComponent.buildComponent("text", { x: "12", y: "30", class: "gauge_pointer_text", ref: this.ptr1Label }))),
            FSComponent.buildComponent("div", { class: "gauge_pointer_right", ref: this.ptr2Div },
                FSComponent.buildComponent("svg", null,
                    FSComponent.buildComponent("defs", null,
                        FSComponent.buildComponent("linearGradient", { id: "pointerGradientRight", x1: "0%", y1: "0%", x2: "100%", y2: "0%" },
                            FSComponent.buildComponent("stop", { offset: "0%", style: "stop-color:rgb(80,80,80);stop-opacity:1" }),
                            FSComponent.buildComponent("stop", { offset: "70%", style: "stop-color:rgb(255,255,255);stop-opacity:1" }),
                            FSComponent.buildComponent("stop", { offset: "100%", style: "stop-color:rgb(80,80,80);stop-opacity:1" }))),
                    FSComponent.buildComponent("path", { d: "", fill: "url(#pointerGradientRight)", ref: this.ptr2Path }),
                    FSComponent.buildComponent("text", { x: "12", y: "48", class: "gauge_pointer_text", ref: this.ptr2Label })))));
    }
}
/** A single vertical bar. */
class VerticalBar extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.groupRef = FSComponent.createRef();
        this.baseLineRef = FSComponent.createRef();
        this.tickGroupRef = FSComponent.createRef();
        this.zoneGroupRef = FSComponent.createRef();
        this.x = this.props.origin.x;
        this.y = this.props.origin.y;
        this.height = this.props.height;
        this.maxValue = 0;
        this.minValue = 0;
        // Constants for tweaking layout.
        /** The length of the general minor ticks. */
        this.minTickLength = 9;
        /** The length of major ticks, like the baselines. */
        this.majTickLength = 9;
        /** The width of a color bar, in pixels. */
        this.zoneWidth = 6;
        this.minTickOffest = this.minTickLength * (this.props.tickSide == 'left' ? -1 : 1);
        this.majTickOffest = this.majTickLength * (this.props.tickSide == 'left' ? -1 : 1);
    }
    /** Draw our ticks. */
    drawTicks() {
        if (this.props.graduationLength !== undefined) {
            const valRange = this.maxValue - this.minValue;
            const graduations = Math.trunc(valRange / this.props.graduationLength);
            if (graduations > 1) {
                const spacing = this.props.height / graduations;
                for (let i = 1; i < graduations; i++) {
                    const y = this.y + spacing * i;
                    FSComponent.render(FSComponent.buildComponent("g", null,
                        FSComponent.buildComponent("line", { x1: this.x, y1: y, x2: this.x + this.minTickOffest, y2: y, stroke: "white", "stroke-width": "1px" })), this.tickGroupRef.instance);
                }
            }
        }
    }
    /** Do stuff after render */
    onAfterRender() {
        var _a, _b;
        if (this.props.maximum) {
            this.maxValue = (_a = this.props.logicHost) === null || _a === void 0 ? void 0 : _a.addLogicAsNumber(this.props.maximum, (max) => { this.maxValue = max; }, 2);
        }
        if (this.props.minimum) {
            this.minValue = (_b = this.props.logicHost) === null || _b === void 0 ? void 0 : _b.addLogicAsNumber(this.props.minimum, (min) => { this.minValue = min; }, 2);
        }
        if (this.props.colorZones) {
            // The width of our axis offset.  For some reason this is 1, even though the stroke
            // on the axis is 2.  Haven't figured out why yet.
            const axisWidth = 0;
            const zoneX = this.props.tickSide == 'left' ? this.x - this.zoneWidth : this.x + axisWidth;
            for (let i = 0; i < this.props.colorZones.length; i++) {
                FSComponent.render(FSComponent.buildComponent(VerticalColorZone, { logicHost: this.props.logicHost, width: 6, origin: { x: zoneX, y: this.props.origin.y }, values: this.props.colorZones[i], gaugeMin: this.props.minimum, gaugeMax: this.props.maximum, gaugeHeight: this.height }), this.zoneGroupRef.instance);
            }
        }
        this.drawTicks();
    }
    /**
     * Render our bar
     * @returns A VNode
     */
    render() {
        return FSComponent.buildComponent("g", { ref: this.groupRef },
            FSComponent.buildComponent("g", { ref: this.zoneGroupRef }),
            FSComponent.buildComponent("line", { x1: this.x, y1: this.y - 1, x2: this.x, y2: this.y + this.height, "stroke-width": "1px", stroke: "white", ref: this.baseLineRef, class: "baseline" }),
            FSComponent.buildComponent("line", { x1: this.x, y1: this.y, x2: this.x + this.majTickOffest, y2: this.y, "stroke-width": "1px", stroke: "white", class: "topBar" }),
            FSComponent.buildComponent("line", { x1: this.x, y1: this.y + this.height, x2: this.x + this.majTickOffest, y2: this.y + this.height, "stroke-width": "1px", stroke: "white", class: "bottomBar" }),
            FSComponent.buildComponent("g", { ref: this.tickGroupRef }));
    }
}
/** A horizontal bar gauge with two sets of values. */
class XMLDoubleVerticalGauge extends BaseGauge {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
        this.titleRef = FSComponent.createRef();
        this.value1Ref = FSComponent.createRef();
        this.value2Ref = FSComponent.createRef();
        this.labelRef = FSComponent.createRef();
        this.maxValue = 0;
        this.minValue = 0;
        // Constants for tweaking layoout.  Maybe these should be passed in as props?
        // Or maybe that's too much work for the benefit.
        /** The X location of the left column. */
        this.column1X = 39;
        /** The X location of the right column. */
        this.column2X = 109;
        /** The X location of the labels. */
        this.labelX = 74;
        /** The Y location of the base of the columns. */
        this.baseY = 5;
        /** The height of the columns, in pixels. */
        this.height = 80;
        /** The Y offset for the labels, for centering on the tickmarks */
        this.labelOffset = 4;
    }
    /**
     * Initialize the rendered gauge.
     */
    initGauge() {
        var _a, _b, _c, _d;
        if (this.props.title || this.props.unit) {
            this.titleRef.instance.textContent = `${this.props.title} ${this.props.unit}`;
            if (this.props.beginText !== undefined) {
                this.titleRef.instance.textContent += ` ${this.props.beginText}`;
            }
        }
        if (this.props.maximum) {
            this.maxValue = (_a = this.props.logicHost) === null || _a === void 0 ? void 0 : _a.addLogicAsNumber(this.props.maximum, (max) => { this.maxValue = max; }, 0);
        }
        if (this.props.minimum) {
            this.minValue = (_b = this.props.logicHost) === null || _b === void 0 ? void 0 : _b.addLogicAsNumber(this.props.minimum, (min) => { this.minValue = min; }, 0);
        }
        if (this.props.value1 !== undefined) {
            (_c = this.props.logicHost) === null || _c === void 0 ? void 0 : _c.addLogicAsNumber(this.props.value1, (val) => {
                this.value1Ref.instance.textContent = `${val}`;
            }, 0);
        }
        if (this.props.value2 !== undefined) {
            (_d = this.props.logicHost) === null || _d === void 0 ? void 0 : _d.addLogicAsNumber(this.props.value2, (val) => {
                this.value2Ref.instance.textContent = `${val}`;
            }, 0);
        }
        this.drawLabels();
    }
    /** Draw our labels */
    drawLabels() {
        const centeredY = this.baseY + this.labelOffset; // 2 px for centering
        // Draw the top label.
        FSComponent.render(FSComponent.buildComponent("g", null,
            FSComponent.buildComponent("text", { x: this.labelX, y: centeredY, fill: "white", "text-anchor": "middle", "font-size": "12" }, this.props.endText !== undefined ? this.props.endText : `${this.maxValue}`)), this.labelRef.instance);
        // Draw any graduation labels.
        if (this.props.graduationLength !== undefined) {
            const valRange = this.maxValue - this.minValue;
            const graduations = Math.trunc(valRange / this.props.graduationLength);
            const spacing = this.height / graduations;
            if (this.props.graduationHasText) {
                for (let i = 1; i < graduations; i++) {
                    const y = centeredY + spacing * i;
                    FSComponent.render(FSComponent.buildComponent("g", null,
                        FSComponent.buildComponent("text", { x: this.labelX, y: y, fill: "white", "text-anchor": "middle", "font-size": "12" }, `${this.maxValue - (i * this.props.graduationLength)}`)), this.labelRef.instance);
                }
            }
        }
    }
    /**
     * Render a horizontal bar gauge
     * @returns A VNode
     */
    renderGauge() {
        return (FSComponent.buildComponent("div", { class: "double_vert_container" },
            FSComponent.buildComponent("svg", { viewBox: "0 0 148 148", ref: this.svgRef },
                FSComponent.buildComponent("g", { ref: this.labelRef }),
                FSComponent.buildComponent(VerticalBar, Object.assign({ origin: { x: this.column1X, y: this.baseY }, height: this.height, tickSide: "left" }, this.props)),
                FSComponent.buildComponent(VerticalBar, Object.assign({ origin: { x: this.column2X, y: this.baseY }, height: this.height, tickSide: "right" }, this.props))),
            FSComponent.buildComponent(DoublePointer, Object.assign({}, this.props)),
            FSComponent.buildComponent("div", { class: "gauge_values" },
                FSComponent.buildComponent("span", { class: "gauge_value_left", ref: this.value1Ref }),
                FSComponent.buildComponent("span", { class: "gauge_title", ref: this.titleRef }),
                FSComponent.buildComponent("span", { class: "gauge_value_right", ref: this.value2Ref }))));
    }
}

/** Draw a single column of text. */
class XMLTextColumn extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.contentRef = FSComponent.createRef();
    }
    /** Do stuff after rendering. */
    onAfterRender() {
        if (this.props.content !== undefined) {
            this.contentRef.instance.textContent = this.props.logicHost.addLogicAsString(this.props.content, (content) => { this.contentRef.instance.textContent = content; });
        }
        else {
            // If a column has no content, we remove its flex weight to make room for the others.
            this.contentRef.instance.style.flex = '0';
        }
        if (this.props.color !== undefined) {
            this.contentRef.instance.style.color = this.props.logicHost.addLogicAsString(this.props.color, (content) => { this.contentRef.instance.style.color = content; });
        }
        if (this.props.fontSize !== undefined) {
            // The original code uses 10px for main text.  We're using 16.
            // In order to keep thigns proportional, font sizes that are
            // explicity set will be scaled up by the same factor.
            // TODO Sub-pixel rendering supported?
            this.contentRef.instance.style.fontSize = `${parseFloat(this.props.fontSize) * 1.6}px`;
        }
        if (this.props.class !== undefined) {
            this.contentRef.instance.classList.add(this.props.class);
        }
    }
    /**
     * Render the gauge.
     * @returns A VNode
     */
    render() {
        return FSComponent.buildComponent("div", { ref: this.contentRef, class: 'text_column_' + this.props.location });
    }
}
/** A text gauge display element. */
class XMLTextGauge extends BaseGauge {
    /**
     * Initialize the rendered gauge.
     */
    initGauge() {
        // Just satisfying the base class.
        return;
    }
    /**
     * Render a text gauge
     * @returns A VNode
     */
    renderGauge() {
        return (FSComponent.buildComponent("div", { class: "text_gauge_container" },
            FSComponent.buildComponent(XMLTextColumn, Object.assign({ location: 'left', logicHost: this.props.logicHost }, this.props.left)),
            FSComponent.buildComponent(XMLTextColumn, Object.assign({ location: 'center', logicHost: this.props.logicHost }, this.props.center)),
            FSComponent.buildComponent(XMLTextColumn, Object.assign({ location: 'right', logicHost: this.props.logicHost }, this.props.right))));
    }
}

/**
 * Logic for a single engine cylinder with temp randomization.
 *
 * Ideally, this would also have some fancy code in it to handle trending, so
 * that our simulated random temperatures didn't all rise and fall at the same
 * time, but it's hard to do that in this model since we only get the value
 * updates when they actually change; properly implementing delays would need
 * to have a more real-time view with hooks into the update loop and us
 * actually publishing new events when temps change.
 *
 * For now, the apparent "pulsing" caused by the blocks in the temp gauge bars
 * being "broken" at different times gives a pretty good visual effect, so
 * it doesn't feel necessary atm.  Would be cool in the future, though.
 * At that point, we could also have one class that controls both CGT and EGT.
 */
class Cylinder {
    /**
     * Create a cylinder.
     * @param min The minimum temp adjustment multiplier.
     * @param max The maximum temp adjustment multiplier.
     */
    constructor(min, max) {
        this._lastReading = 0;
        this._factor = Math.random() * (max - min) + min;
    }
    /**
     * Set a new target reading and get the adjusted one.
     * @param target The target temperature.
     * @returns An adjusted temperature.
     */
    setTarget(target) {
        this._lastReading = Math.round(target * this.factor);
        return this._lastReading;
    }
    /**
     * Get the base adjustment factor.
     * @returns The adjustment factor as a float.
     */
    get factor() {
        return this._factor;
    }
    /**
     * Get the last adjusted reading.
     * @returns Guess.
     */
    get lastReading() {
        return this._lastReading;
    }
}
/**
 * The Cylinder Temp Gauge component.
 *
 * Refactor suggestion:  I would like to see this component broken up so that each
 * cylinder has its own component, and the gauge itself just holds and manages
 * those.  Unfortunately, due to the iterative way in which the layout was created
 * and animated, the mask and peak elements are not in the same container as the
 * actual temperature bars, which means they can't be cleanly broken out
 * individually.  It's not worth the time now to fix that, but an ambitious soul
 * looking for something to optimize might want to think about it.
 */
class CylinderSet extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.container = FSComponent.createRef();
        this.maskContainer = FSComponent.createRef();
        this.peakContainer = FSComponent.createRef();
        this.columnMap = new Array();
        this.minimum = 0;
        this.maximum = 0;
        this.numColumns = 0;
        this.numRows = 0;
        this.redLine = FSComponent.createRef();
        this.leanAssist = false;
        this.selectedCyl = 0;
        this.tempOrder = new Array();
        this.leaningPeak = 0;
        this.leaningPriorTemp = 0;
        /**
         * Cycling through the cylinders
         * @param state Cylinder select state
         */
        this.changeCylSlct = (state) => {
            if (state && !this.leanAssist) {
                this.setSelectedCylinder((this.selectedCyl + 1) % this.numColumns);
            }
        };
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        var _a, _b, _c;
        if (!(this.props.numColumns && this.props.numRows && this.props.logicHost)) {
            return;
        }
        else {
            this.numRows = this.props.numRows.getValueAsNumber();
            this.numColumns = this.props.numColumns.getValueAsNumber();
        }
        if (this.props.value) {
            (_a = this.props.logicHost) === null || _a === void 0 ? void 0 : _a.addLogicAsNumber(this.props.value, (val) => { this.updateValue(val); }, 0);
        }
        if (this.props.minimum) {
            this.minimum = this.props.logicHost.addLogicAsNumber(this.props.minimum, (val) => { this.minimum = val; }, 0);
        }
        if (this.props.maximum) {
            this.maximum = this.props.logicHost.addLogicAsNumber(this.props.maximum, (val) => { this.maximum = val; }, 0);
        }
        this.tempOrder = this.getSafeTempOrder();
        const cylinders = new Array();
        const adjFactor = ((this.maximum - this.minimum) * 0.075) / this.maximum;
        for (let i = 0; i < this.numColumns; i++) {
            cylinders.push(new Cylinder(1 - adjFactor, 1 + adjFactor));
        }
        cylinders.sort((a, b) => b.factor - a.factor);
        for (let i = 0; i < this.numColumns; i++) {
            const cells = new Array();
            const colRef = FSComponent.createRef();
            const maskRef = FSComponent.createRef();
            const peakRef = FSComponent.createRef();
            const numRef = FSComponent.createRef();
            FSComponent.render(FSComponent.buildComponent("div", { class: "cyl-column", ref: colRef }, " "), this.container.instance);
            for (let j = 0; j <= this.numRows; j++) {
                const rowRef = FSComponent.createRef();
                cells[j] = rowRef;
                if (j == 0) {
                    FSComponent.render(FSComponent.buildComponent("div", { ref: rowRef },
                        FSComponent.buildComponent("span", { ref: numRef, class: 'cyl-number' }, (i + 1).toString())), colRef.instance);
                }
                else {
                    FSComponent.render(FSComponent.buildComponent("div", { class: "temp-unit", ref: rowRef }, " "), colRef.instance); // Space is needed to render without div wrapper so flex-grow works.
                }
            }
            FSComponent.render(FSComponent.buildComponent("div", { class: "temp-unit-mask-container", ref: maskRef },
                " ",
                FSComponent.buildComponent("div", { class: "temp-unit-mask" }),
                " "), this.maskContainer.instance);
            FSComponent.render(FSComponent.buildComponent("div", { class: "temp-unit-mask-container" },
                FSComponent.buildComponent("div", { class: "temp-unit-peak", ref: peakRef }),
                " "), this.peakContainer.instance);
            this.columnMap[i] = { ref: colRef, cells: cells, mask: maskRef, peak: peakRef, num: numRef, cylinder: cylinders[this.tempOrder.indexOf(i + 1)] };
        }
        if (!((_b = this.props.style) === null || _b === void 0 ? void 0 : _b.redline)) {
            this.redLine.instance.style.display = 'none';
        }
        else {
            this.redLine.instance.style.display = '';
            for (const column of this.columnMap) {
                column.peak.instance.style.display = 'none';
            }
        }
        for (const column of this.columnMap) {
            column.peak.instance.style.display = 'none';
        }
        const sub = (_c = this.props.bus) === null || _c === void 0 ? void 0 : _c.getSubscriber();
        if (sub) {
            sub.on('eis_lean_assist').handle(state => {
                var _a;
                this.leanAssist = state;
                if (state) {
                    this.setSelectedCylinder(this.getHottestCylinder());
                }
                else {
                    this.leaningPeak = 0;
                    this.leaningPriorTemp = 0;
                    (_a = this.props.peakDeltaSubject) === null || _a === void 0 ? void 0 : _a.set(0);
                    for (const column of this.columnMap) {
                        column.peak.instance.style.display = 'none';
                    }
                }
            });
            sub.on('eis_cyl_slct').handle(this.changeCylSlct);
        }
    }
    /**
     * Turn our temp order prop into a safe list to use.
     * @returns An array of cylinder numbers matching our cylinder count.
     */
    getSafeTempOrder() {
        const tempOrder = new Array();
        if (this.props.tempOrder) {
            for (const num of this.props.tempOrder) {
                if (num > 0 && num <= this.numColumns && tempOrder.indexOf(num) == -1) {
                    tempOrder.push(num);
                }
            }
        }
        // Any columns not specified tack on the end.
        for (let i = 1; i <= this.numColumns; i++) {
            if (tempOrder.indexOf(i) == -1) {
                tempOrder.push(i);
            }
        }
        return tempOrder;
    }
    /**
     * Get the hottest cylinder.
     * @returns The hottest cylinder's index.
     */
    getHottestCylinder() {
        // If we start changing which cylinder may be hottest, this can get fancier.
        // Right now, we just pick the first cylinder in the temp order, and this
        // function exists for easy future enhancement.
        return this.tempOrder[0] - 1;
    }
    /**
     * Set the selected cylinder.
     * @param num The index of the cylinder to select.
     */
    setSelectedCylinder(num) {
        var _a;
        this.columnMap[this.selectedCyl].num.instance.className = 'cyl-number';
        this.columnMap[num].num.instance.className = 'cyl-number-highlight';
        this.selectedCyl = num;
        (_a = this.props.peakTempSubject) === null || _a === void 0 ? void 0 : _a.set(this.columnMap[num].cylinder.lastReading);
    }
    /**
     * Update the value of the gauge.
     * @param value The new value.
     */
    updateValue(value) {
        var _a, _b, _c;
        if (this.leanAssist && ((_a = this.props.style) === null || _a === void 0 ? void 0 : _a.peakTemps)) {
            if (this.leaningPeak == 0) {
                if (this.leaningPriorTemp > value) {
                    this.leaningPeak = this.leaningPriorTemp;
                }
                else {
                    this.leaningPriorTemp = value;
                }
            }
            else {
                (_b = this.props.peakDeltaSubject) === null || _b === void 0 ? void 0 : _b.set(value - this.leaningPeak);
            }
        }
        for (let i = 0; i < this.numColumns; i++) {
            const column = this.columnMap[i];
            const newTemp = MathUtils.clamp(column.cylinder.setTarget(value), this.minimum, this.maximum);
            const translation = (this.maximum - newTemp) * (66 / (this.maximum - this.minimum));
            column.mask.instance.style.transform = `translate3d(0px, ${translation}px, 0px)`;
            if (this.leaningPeak && column.peak.instance.style.display !== '') {
                column.peak.instance.style.display = '';
            }
            else if (newTemp >= this.leaningPeak) {
                column.peak.instance.style.transform = `translate3d(0px, ${translation}px, 0px)`;
            }
            if (i == this.selectedCyl) {
                // console.log(`selected cylinder: ${i}`);
                // console.log(`last reading: ${column.cylinder.lastReading}`);
                column.num.instance.className = 'cyl-number-highlight';
                (_c = this.props.peakTempSubject) === null || _c === void 0 ? void 0 : _c.set(column.cylinder.lastReading);
            }
            else {
                column.num.instance.className = 'cyl-number';
            }
        }
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "cylinderset" },
            FSComponent.buildComponent("div", { class: "temp-array", ref: this.container },
                FSComponent.buildComponent("hr", { class: "cht-red-temp-line", ref: this.redLine })),
            FSComponent.buildComponent("div", { class: "mask-container" },
                FSComponent.buildComponent("div", { class: "temp-array", ref: this.maskContainer })),
            FSComponent.buildComponent("div", { class: "mask-container" },
                FSComponent.buildComponent("div", { class: "temp-array", ref: this.peakContainer }))));
    }
}
/**
 * A temp gauge.
 */
class CylinderTempGauge extends BaseGauge {
    constructor() {
        var _a;
        super(...arguments);
        this.peakRef = FSComponent.createRef();
        this.quantum = ((_a = this.props.style) === null || _a === void 0 ? void 0 : _a.textIncrement) !== undefined ? this.props.style.textIncrement : 1;
        this.leanAssist = false;
        this.peakTemp = ComputedSubject.create(0, (v) => {
            return '' + Math.round(v / this.quantum) * this.quantum;
        });
        this.peakDelta = ComputedSubject.create(0, (v) => {
            if (v == 0 && !this.leanAssist) {
                return `_ _ _ _ _ ${this.props.unit}`;
            }
            else {
                return `${v.toFixed(0)} ${this.props.unit}`;
            }
        });
    }
    /**
     * Initialize the rendered gauge.
     */
    initGauge() {
        var _a;
        this.peakRef.instance.style.display = 'none';
        const sub = (_a = this.props.bus) === null || _a === void 0 ? void 0 : _a.getSubscriber();
        if (sub) {
            sub.on('eis_lean_assist').handle(state => {
                var _a;
                state && ((_a = this.props.style) === null || _a === void 0 ? void 0 : _a.peakTemps) ? this.peakRef.instance.style.display = '' : this.peakRef.instance.style.display = 'none';
                this.leanAssist = state;
            });
        }
    }
    /**
     * Render the gauge.
     * @returns a VNode
     */
    renderGauge() {
        return (FSComponent.buildComponent("div", { class: "chtegt-container" },
            FSComponent.buildComponent(CylinderSet, { numRows: this.props.numRows, numColumns: this.props.numColumns, minimum: this.props.minimum, maximum: this.props.maximum, value: this.props.value1, bus: this.props.bus, logicHost: this.props.logicHost, peakTempSubject: this.peakTemp, peakDeltaSubject: this.peakDelta, tempOrder: this.props.tempOrder, style: this.props.style }),
            FSComponent.buildComponent("div", { class: "temp-value" },
                FSComponent.buildComponent("div", null,
                    this.props.title,
                    " ",
                    this.props.unit),
                FSComponent.buildComponent("div", { class: "size20" }, this.peakTemp)),
            FSComponent.buildComponent("div", { class: "peak-egt", ref: this.peakRef },
                FSComponent.buildComponent("div", { class: "peak-label" }, "\u0394PEAK"),
                FSComponent.buildComponent("div", { class: "peak-temp" }, this.peakDelta))));
    }
}
/**
 * A temp gauge.
 */
class CylinderTempGaugeTwin extends BaseGauge {
    constructor() {
        var _a;
        super(...arguments);
        this.peakRef = FSComponent.createRef();
        this.quantum = ((_a = this.props.style) === null || _a === void 0 ? void 0 : _a.textIncrement) !== undefined ? this.props.style.textIncrement : 1;
        this.leanAssist = false;
        this.peakTemp1 = ComputedSubject.create(0, (v) => {
            return '' + Math.round(v / this.quantum) * this.quantum;
        });
        this.peakDelta1 = ComputedSubject.create(0, (v) => {
            if (v == 0 && !this.leanAssist) {
                return '_ _ _';
            }
            else {
                return `${v.toFixed(0)}`;
            }
        });
        this.peakTemp2 = ComputedSubject.create(0, (v) => {
            return '' + Math.round(v / this.quantum) * this.quantum;
        });
        this.peakDelta2 = ComputedSubject.create(0, (v) => {
            if (v == 0 && !this.leanAssist) {
                return '_ _ _';
            }
            else {
                return `${v.toFixed(0)}`;
            }
        });
    }
    /**
     * Initialize the rendered gauge.
     */
    initGauge() {
        var _a;
        this.peakRef.instance.style.visibility = 'hidden';
        const sub = (_a = this.props.bus) === null || _a === void 0 ? void 0 : _a.getSubscriber();
        if (sub) {
            sub.on('eis_lean_assist').handle(state => {
                var _a;
                state && ((_a = this.props.style) === null || _a === void 0 ? void 0 : _a.peakTemps) ? this.peakRef.instance.style.visibility = 'visible' : this.peakRef.instance.style.visibility = 'hidden';
                this.leanAssist = state;
            });
        }
    }
    /**
     * Render the gauge.
     * @returns a VNode
     */
    renderGauge() {
        return (FSComponent.buildComponent("div", { class: "chtegt-container" },
            FSComponent.buildComponent("div", { ref: this.peakRef },
                FSComponent.buildComponent("div", { class: "twin-temp-title" },
                    "\u0394PEAK ",
                    this.props.unit),
                FSComponent.buildComponent("div", { class: "twin-temp-values" },
                    FSComponent.buildComponent("div", null, this.peakDelta1),
                    FSComponent.buildComponent("div", null, this.peakDelta2))),
            FSComponent.buildComponent("div", { class: "column-group" },
                FSComponent.buildComponent(CylinderSet, { numRows: this.props.numRows, numColumns: this.props.numColumns, minimum: this.props.minimum, maximum: this.props.maximum, value: this.props.value1, bus: this.props.bus, logicHost: this.props.logicHost, peakTempSubject: this.peakTemp1, peakDeltaSubject: this.peakDelta1, tempOrder: this.props.tempOrder, style: this.props.style }),
                FSComponent.buildComponent(CylinderSet, { numRows: this.props.numRows, numColumns: this.props.numColumns, minimum: this.props.minimum, maximum: this.props.maximum, value: this.props.value2, bus: this.props.bus, logicHost: this.props.logicHost, peakTempSubject: this.peakTemp2, peakDeltaSubject: this.peakDelta2, tempOrder: this.props.tempOrder, style: this.props.style })),
            FSComponent.buildComponent("div", { class: "twin-temp-title" },
                this.props.title,
                " ",
                this.props.unit),
            FSComponent.buildComponent("div", { class: "twin-temp-values" },
                FSComponent.buildComponent("div", null, this.peakTemp1),
                FSComponent.buildComponent("div", null, this.peakTemp2))));
    }
}

/**
 * The XMLColumnGroup is the fundamental container for an EIS.  It will always be present to at least
 * contain all the gauges defined in panel.xml.  There may be additional groups present if there were
 * more column groups explicitly defined in the XML configuration.
 */
class XMLColumnGroup extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.theDiv = FSComponent.createRef();
        this.theRow = FSComponent.createRef();
    }
    /** Do things after rendering. */
    onAfterRender() {
        let columnsWithoutWidth = 0;
        let widthPercentUsed = 0;
        const columns = new Array();
        if (this.props.id !== undefined) {
            this.theDiv.instance.classList.add(this.props.id);
        }
        for (const column of this.props.columns) {
            const ref = FSComponent.createRef();
            FSComponent.render(FSComponent.buildComponent(XMLGaugeColumn, { bus: this.props.bus, ref: ref, logicHandler: this.props.logicHost, gaugeConfig: column.gauges }), this.theRow.instance);
            columns.push(ref);
            if (column.width !== undefined && column.width > 0) {
                widthPercentUsed += column.width;
            }
            else {
                columnsWithoutWidth++;
            }
        }
        for (let i = 0; i < columns.length; i++) {
            const width = this.props.columns[i].width;
            if (width !== undefined && width > 0) {
                columns[i].instance.style.width = `${width}%`;
            }
            else {
                columns[i].instance.style.width = `${(100 - widthPercentUsed) / columnsWithoutWidth}%`;
            }
            columns[i].instance.classList.add(`Column${this.props.columns[i].id !== undefined ? this.props.columns[i].id : ''}`);
        }
    }
    /**
     * Render a column group.
     * @returns A VNode of the group.
     */
    render() {
        return FSComponent.buildComponent("table", { class: 'gauge_column_table', ref: this.theDiv },
            FSComponent.buildComponent("tr", { class: 'gauge_column_row', ref: this.theRow }));
    }
}
/** A single column of gauges. */
class XMLGaugeColumn extends DisplayComponent {
    /** Draw all our gauges after rendering. */
    onAfterRender() {
        for (const gauge of this.props.gaugeConfig) {
            switch (gauge.gaugeType) {
                case XMLGaugeType.Circular:
                    FSComponent.render(FSComponent.buildComponent(XMLCircleGauge, Object.assign({ logicHost: this.props.logicHandler }, gauge.configuration)), this.props.ref.instance);
                    break;
                case XMLGaugeType.Horizontal:
                    FSComponent.render(FSComponent.buildComponent(XMLHorizontalGauge, Object.assign({ logicHost: this.props.logicHandler }, gauge.configuration)), this.props.ref.instance);
                    break;
                case XMLGaugeType.DoubleHorizontal:
                    FSComponent.render(FSComponent.buildComponent(XMLDoubleHorizontalGauge, Object.assign({ logicHost: this.props.logicHandler }, gauge.configuration)), this.props.ref.instance);
                    break;
                case XMLGaugeType.DoubleVertical:
                    FSComponent.render(FSComponent.buildComponent(XMLDoubleVerticalGauge, Object.assign({ logicHost: this.props.logicHandler }, gauge.configuration)), this.props.ref.instance);
                    break;
                case XMLGaugeType.Cylinder:
                    FSComponent.render(FSComponent.buildComponent(CylinderTempGauge, Object.assign({ bus: this.props.bus, logicHost: this.props.logicHandler }, gauge.configuration)), this.props.ref.instance);
                    break;
                case XMLGaugeType.TwinCylinder:
                    FSComponent.render(FSComponent.buildComponent(CylinderTempGaugeTwin, Object.assign({ bus: this.props.bus, logicHost: this.props.logicHandler }, gauge.configuration)), this.props.ref.instance);
                    break;
                case XMLGaugeType.Text:
                    FSComponent.render(FSComponent.buildComponent(XMLTextGauge, Object.assign({ logicHost: this.props.logicHandler }, gauge.configuration)), this.props.ref.instance);
                    break;
                case XMLGaugeType.ColumnGroup:
                    console.log('creating a column group');
                    console.log(gauge.configuration);
                    FSComponent.render(FSComponent.buildComponent(XMLColumnGroup, Object.assign({ logicHost: this.props.logicHandler }, gauge.configuration)), this.props.ref.instance);
                    break;
            }
        }
    }
    /**
     * Render the column.
     * @returns a VSNode
     */
    render() {
        return FSComponent.buildComponent("td", { ref: this.props.ref });
    }
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
var EISPageTypes;
(function (EISPageTypes) {
    EISPageTypes[EISPageTypes["Engine"] = 0] = "Engine";
    EISPageTypes[EISPageTypes["Lean"] = 1] = "Lean";
    EISPageTypes[EISPageTypes["System"] = 2] = "System";
})(EISPageTypes || (EISPageTypes = {}));
/**
 * This EIS is a shorcut for creating the base EIS display on the plane.  All the actual rendering and
 * management is hadled within an XMLGaugeColumn, but that's a litter more tedious to create.  This
 * component instantiates the EIS as a simple XMLColumnGroup with a single column that consists in
 * its entiretly of all the top-level gauges in the EIS.   Further nesting is handed by the internal
 * columns logic.
 */
class EIS extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.enginePage = FSComponent.createRef();
        this.leanPage = FSComponent.createRef();
        this.systemPage = FSComponent.createRef();
    }
    /**
     * Initial config after rendering.
     */
    onAfterRender() {
        console.log('EIS props');
        console.log(this.props.gaugeConfig);
        this.enginePage.instance.style.display = '';
        this.setDisplay(this.leanPage, 'none');
        this.setDisplay(this.systemPage, 'none');
        for (const func of this.props.gaugeConfig.functions.values()) {
            this.props.logicHandler.addFunction(func);
        }
        const sub = this.props.bus.getSubscriber();
        sub.on('eis_page_select').handle(page => {
            switch (page) {
                case EISPageTypes.Engine:
                    this.enginePage.instance.style.display = '';
                    this.setDisplay(this.leanPage, 'none');
                    this.setDisplay(this.systemPage, 'none');
                    break;
                case EISPageTypes.Lean:
                    if (this.leanPage.getOrDefault()) {
                        this.enginePage.instance.style.display = 'none';
                        this.leanPage.instance.style.display = '';
                        this.setDisplay(this.systemPage, 'none');
                    }
                    break;
                case EISPageTypes.System:
                    if (this.systemPage.getOrDefault()) {
                        this.enginePage.instance.style.display = 'none';
                        this.setDisplay(this.leanPage, 'none');
                        this.systemPage.instance.style.display = '';
                    }
                    break;
            }
        });
    }
    /**
     * Shortcut for changing the display of an EIS data page, if it exists.
     * @param page The reference to the div containing the page.
     * @param display A string to set as the display style parameter.
     */
    setDisplay(page, display) {
        if (page.getOrDefault() !== null) {
            page.instance.style.display = display;
        }
    }
    /**
     * Render an EIS as a single XMLColumnGroup.
     * @returns a VNode
     */
    render() {
        return (FSComponent.buildComponent("div", null,
            FSComponent.buildComponent("div", { ref: this.enginePage },
                FSComponent.buildComponent(XMLColumnGroup, { bus: this.props.bus, logicHost: this.props.logicHandler, columns: [{ gauges: this.props.gaugeConfig.enginePage }] })),
            this.props.gaugeConfig.leanPage &&
                FSComponent.buildComponent("div", { ref: this.leanPage },
                    FSComponent.buildComponent(XMLColumnGroup, { bus: this.props.bus, logicHost: this.props.logicHandler, columns: [{ gauges: this.props.gaugeConfig.leanPage }] })),
            this.props.gaugeConfig.systemPage &&
                FSComponent.buildComponent("div", { ref: this.systemPage },
                    FSComponent.buildComponent(XMLColumnGroup, { bus: this.props.bus, logicHost: this.props.logicHandler, columns: [{ gauges: this.props.gaugeConfig.systemPage }] }))));
    }
}

/**
 * The PFD airspeed indicator with speed tape.
 */
class NavDataBar extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.gsElement = FSComponent.createRef();
        this.magneticTrackElement = FSComponent.createRef();
        this.dtkRef = FSComponent.createRef();
        this.eteRef = FSComponent.createRef();
        this.groundSpeed = 0;
        this.titleTextSub = Subject.create('');
        this.oldPage = null;
        this.titleHandler = (title) => { this.titleTextSub.set(title); };
        /**
         * A callback called when the GS updates from the event bus.
         * @param gs The current GS value.
         */
        this.onUpdateGS = (gs) => {
            if (this.gsElement.instance !== null) {
                this.gsElement.instance.textContent = `${(gs)}`;
                this.groundSpeed = gs;
            }
        };
        /**
         * A callback called when the magnetic track updates from the event bus.
         * @param trk The current trk value.
         */
        this.onUpdateTrack = (trk) => {
            if (this.magneticTrackElement.instance !== null && this.groundSpeed > 1) {
                this.magneticTrackElement.instance.textContent = `${(trk)}`.padStart(3, '0') + '°';
            }
        };
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        const lnav = this.props.bus.getSubscriber();
        const gnss = this.props.bus.getSubscriber();
        gnss.on('ground_speed')
            .withPrecision(0)
            .handle(this.onUpdateGS);
        gnss.on('track_deg_magnetic')
            .withPrecision(0)
            .handle(this.onUpdateTrack);
        lnav.on('lnavDtkMag').whenChangedBy(1).handle((dtk) => {
            if (this.dtkRef.instance !== null) {
                const dtkRounded = Math.round(dtk);
                const dtkValue = dtkRounded == 0 ? 360 : dtkRounded;
                this.dtkRef.instance.textContent = `${dtkValue}`.padStart(3, '0') + '°';
            }
        });
        lnav.on('lnavDis').whenChangedBy(0.1).handle((dis) => {
            if (this.eteRef.instance !== null) {
                if (this.groundSpeed < 30) {
                    this.eteRef.instance.textContent = '_ _:_ _';
                }
                else {
                    const eteHours = Math.floor(dis / this.groundSpeed);
                    const eteMinutes = Math.round(60 * (dis / this.groundSpeed) % 60);
                    const textHours = `${eteHours}`.padStart(2, '0');
                    const textMinutes = `${eteMinutes}`.padStart(2, '0');
                    this.eteRef.instance.textContent = textHours + ':' + textMinutes;
                }
            }
        });
        this.props.openPage.sub(this.onOpenPageChanged.bind(this), true);
    }
    /**
     * A callback which is called when the currently open page changes.
     * @param page The new open page.
     */
    onOpenPageChanged(page) {
        var _a;
        (_a = this.oldPage) === null || _a === void 0 ? void 0 : _a.title.unsub(this.titleHandler);
        page && page.title.sub(this.titleHandler, true);
        this.oldPage = page;
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { id: "Center" },
            FSComponent.buildComponent("table", null,
                FSComponent.buildComponent("tr", null,
                    FSComponent.buildComponent("td", { class: "smallText fieldTitle" }, "GS"),
                    FSComponent.buildComponent("td", { class: "magenta fieldData" },
                        FSComponent.buildComponent("span", { ref: this.gsElement }, "0"),
                        FSComponent.buildComponent("span", { class: "smallText magenta" }, "KT")),
                    FSComponent.buildComponent("td", { class: "smallText fieldTitle" }, "DTK"),
                    FSComponent.buildComponent("td", { ref: this.dtkRef, class: "magenta fieldData" }, "_ _ _\u00B0"),
                    FSComponent.buildComponent("td", { class: "smallText fieldTitle" }, "TRK"),
                    FSComponent.buildComponent("td", { ref: this.magneticTrackElement, class: "magenta fieldData" }),
                    FSComponent.buildComponent("td", { class: "smallText fieldTitle" }, "ETE"),
                    FSComponent.buildComponent("td", { ref: this.eteRef, class: "magenta fieldData" }, "_ _:_ _"))),
            FSComponent.buildComponent("span", { id: "mapTitle" }, this.titleTextSub)));
    }
}

/* eslint-disable max-len */
/**
 * Representation of the active and standby frequencies of a nav or com radio.
 */
class NavComFrequencyElement extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.selectorBorderElement = FSComponent.createRef();
        this.selectorArrowElement = FSComponent.createRef();
        this.activeFreq = FSComponent.createRef();
        this.standbyFreq = FSComponent.createRef();
        this.ident = FSComponent.createRef();
        /**
         * Handle a radioo state update event.
         * @param radio The Radio that was updated.
         */
        this.onUpdateState = (radio) => {
            if (!(radio.radioType == this.props.type && radio.index == this.props.index)) {
                return;
            }
            if (this.activeFreq.instance !== null) {
                this.activeFreq.instance.textContent = radio.activeFrequency.toFixed(radio.radioType == RadioType.Nav ? 2 : 3);
            }
            if (this.standbyFreq.instance !== null) {
                this.standbyFreq.instance.textContent = radio.standbyFrequency.toFixed(radio.radioType == RadioType.Nav ? 2 : 3);
            }
            if (this.selectorBorderElement.instance !== null && this.selectorArrowElement.instance !== null) {
                this.selectorBorderElement.instance.style.display = radio.selected ? '' : 'none';
                this.selectorArrowElement.instance.style.visibility = radio.selected ? 'visible' : 'hidden';
            }
            if (this.ident.getOrDefault() !== null) {
                this.ident.instance.textContent = radio.ident;
            }
        };
        /**
         * Handle a frequency change event.
         * @param change The FrequencyChangeEvent to process.
         */
        this.onUpdateFrequency = (change) => {
            if (!(change.radio.radioType == this.props.type && change.radio.index == this.props.index)) {
                return;
            }
            switch (change.bank) {
                case FrequencyBank.Active:
                    if (this.activeFreq.instance !== null) {
                        this.activeFreq.instance.textContent = change.frequency.toFixed(change.radio.radioType == RadioType.Nav ? 2 : 3);
                    }
                    break;
                case FrequencyBank.Standby:
                    if (this.standbyFreq.instance !== null) {
                        this.standbyFreq.instance.textContent = change.frequency.toFixed(change.radio.radioType == RadioType.Nav ? 2 : 3);
                    }
                    break;
            }
        };
        /**
         * Handle an ident set event.
         * @param change The IdentChangeEvent to process.
         */
        this.onUpdateIdent = (change) => {
            if (change.index == this.props.index && this.ident.getOrDefault() !== null) {
                this.ident.instance.textContent = change.ident;
            }
        };
        /**
         * A callback called when the CDI Source Changes.
         * @param source The current selected CDI Source.
         */
        this.onUpdateCdiSelect = (source) => {
            if (source.type === NavSourceType.Nav && source.index == this.props.index) {
                this.activeFreq.instance.classList.add('navcom-green');
                this.ident.instance.classList.add('navcom-green');
            }
            else {
                this.activeFreq.instance.classList.remove('navcom-green');
                this.ident.instance.classList.remove('navcom-green');
            }
        };
    }
    /**
     * Set this frequency as the active selection visually.
     * @param isSelected Indicates if the frequency should show as selected or not.
     */
    setSelected(isSelected) {
        if (this.selectorBorderElement.instance !== null && this.selectorArrowElement.instance !== null) {
            this.selectorBorderElement.instance.style.display = isSelected ? '' : 'none';
            this.selectorArrowElement.instance.style.visibility = isSelected ? 'visible' : 'hidden';
        }
    }
    /**
     * Stuff to do after rendering.
     */
    onAfterRender() {
        const nav = this.props.bus.getSubscriber();
        nav.on('setRadioState').handle(this.onUpdateState);
        nav.on('setFrequency').handle(this.onUpdateFrequency);
        nav.on('setIdent').handle(this.onUpdateIdent);
        if (this.props.position === 'left') {
            const navproc = this.props.bus.getSubscriber();
            navproc.on('cdi_select').handle(this.onUpdateCdiSelect);
        }
    }
    /**
     * Render NavCom Freq Element.
     * @returns Vnode containing the element.
     */
    render() {
        if (this.props.position === 'left') {
            return (FSComponent.buildComponent("div", { class: "navcom-frequencyelement-container" },
                FSComponent.buildComponent("div", { ref: this.selectorBorderElement, id: "navcomselect", class: "navcom-selector left" }),
                FSComponent.buildComponent("span", { class: "navcom-freqstandby", ref: this.standbyFreq }),
                FSComponent.buildComponent("span", { ref: this.selectorArrowElement, class: "navcom-arrows" },
                    FSComponent.buildComponent("svg", { width: "22", height: "16" },
                        FSComponent.buildComponent("path", { d: "M 12 8 m 0 0.75 l -5 0 l 1 3.25 l 0 1 l -4.5 -5 l 4.5 -5 l 0 1 l -1 3.25 l 10 0 l -1 -3.25 l 0 -1 l 4.5 5 l -4.5 5 l 0 -1 l 1 -3.25 l -5 0 z", fill: "cyan" }))),
                FSComponent.buildComponent("span", { class: "navcom-freqactive", ref: this.activeFreq }),
                FSComponent.buildComponent("div", { class: "navcom-ident", ref: this.ident })));
        }
        else {
            return (FSComponent.buildComponent("div", { class: "navcom-frequencyelement-container" },
                FSComponent.buildComponent("div", { ref: this.selectorBorderElement, id: "navcomselect", class: "navcom-selector right" }),
                FSComponent.buildComponent("span", { class: "navcom-freqactive", ref: this.activeFreq }),
                FSComponent.buildComponent("span", { ref: this.selectorArrowElement, class: "navcom-arrows" },
                    FSComponent.buildComponent("svg", { width: "25", height: "16" },
                        FSComponent.buildComponent("path", { d: "M 12 8 m 0 0.75 l -5 0 l 1 3.25 l 0 1 l -4.5 -5 l 4.5 -5 l 0 1 l -1 3.25 l 10 0 l -1 -3.25 l 0 -1 l 4.5 5 l -4.5 5 l 0 -1 l 1 -3.25 l -5 0 z", fill: "cyan" }))),
                FSComponent.buildComponent("span", { class: "navcom-freqstandby", ref: this.standbyFreq })));
        }
    }
}

/* eslint-disable max-len */
/**
 *
 */
class NavComRadio extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.frequency1Element = FSComponent.createRef();
        this.frequency2Element = FSComponent.createRef();
    }
    /**
     * Stuff to do after render.
     */
    onAfterRender() {
        // Nothing to do at the moment.
        return;
    }
    /**
     * Render NavCom Element
     * @returns Vnode containing the element
     */
    render() {
        if (this.props.position === 'left') {
            return (FSComponent.buildComponent("div", null,
                FSComponent.buildComponent("div", { class: "navcom-title left" }, this.props.title),
                FSComponent.buildComponent("div", { class: "navcom-title-numbers left" }, "12"),
                FSComponent.buildComponent("div", { class: "navcom-frequencies left" },
                    FSComponent.buildComponent(NavComFrequencyElement, { ref: this.frequency1Element, bus: this.props.bus, position: this.props.position, type: RadioType.Nav, index: 1 }),
                    FSComponent.buildComponent(NavComFrequencyElement, { ref: this.frequency2Element, bus: this.props.bus, position: this.props.position, type: RadioType.Nav, index: 2 }))));
        }
        else {
            return (FSComponent.buildComponent("div", null,
                FSComponent.buildComponent("div", { class: "navcom-frequencies right" },
                    FSComponent.buildComponent(NavComFrequencyElement, { ref: this.frequency1Element, bus: this.props.bus, position: this.props.position, type: RadioType.Com, index: 1 }),
                    FSComponent.buildComponent(NavComFrequencyElement, { ref: this.frequency2Element, bus: this.props.bus, position: this.props.position, type: RadioType.Com, index: 2 })),
                FSComponent.buildComponent("div", { class: "navcom-title-numbers right" }, "12"),
                FSComponent.buildComponent("div", { class: "navcom-title right" }, this.props.title)));
        }
    }
}

/**
 * A softkey menu instance.
 */
class SoftKeyMenu {
    /**
     * Creates an instance of a SoftKeyMenu.
     * @param menuSystem The menu system that will manage this menu.
     */
    constructor(menuSystem) {
        this.menuSystem = menuSystem;
        /** The menu items in this menu. */
        this.menuItems = [];
    }
    /**
     * Adds a menu item to the softkey menu.
     * @param index The softkey index to add the menu item to.
     * @param label The label of the menu item.
     * @param handler The handler to call when the menu item is selected.
     * @param value The value of the menu item, if any.
     * @param disabled Whether or not the menu item is disabled.
     */
    addItem(index, label, handler, value, disabled = false) {
        this.menuItems[index] = { label: Subject.create(label), handler, value: Subject.create(value), disabled: Subject.create(handler === undefined || disabled) };
    }
    /**
     * Removes a menu item from the menu.
     * @param index The softkey index to remove the menu item from.
     */
    removeItem(index) {
        this.menuItems[index] = SoftKeyMenu.EmptyMenuItem;
    }
    /**
     * Gets a menu item.
     * @param index The index of the menu item.
     * @returns The requested menu item.
     */
    getItem(index) {
        return this.menuItems[index];
    }
    /**
     * Handles a back menu action.
     */
    handleBack() {
        this.menuSystem.back();
    }
    /**
     * Iterates over the menu items.
     * @param each The function to run over each menu item.
     */
    forEach(each) {
        for (let i = 0; i < 12; i++) {
            const item = this.menuItems[i];
            each(item !== null && item !== void 0 ? item : SoftKeyMenu.EmptyMenuItem, i);
        }
    }
    /**
     * Handles when a menu item is pressed.
     * @param index The index of the menu item that was pressed.
     */
    handleItemPressed(index) {
        const menuItem = this.menuItems[index];
        if (menuItem && menuItem.handler && !menuItem.disabled.get()) {
            menuItem.handler(this);
        }
    }
}
/** An empty menu item. */
SoftKeyMenu.EmptyMenuItem = {
    label: Subject.create(''),
    handler: undefined,
    disabled: Subject.create(true),
    value: Subject.create(undefined)
};

/**
 * A system that manages the Garmin softkey menus.
 */
class MenuSystem {
    /**
     * Creates an instance of the MenuSystem.
     * @param bus The event bus to use with this instance.
     * @param hEventPrefix The event prefix to use for the softkey H Events.
     */
    constructor(bus, hEventPrefix) {
        this.bus = bus;
        /** The current menu stack. */
        this.menuStack = [new SoftKeyMenu(this)];
        /**The currently registered menus. */
        this.registeredMenus = {};
        this.subscriber = bus.getSubscriber();
        this.subscriber.on('hEvent').handle(hEvent => {
            if (hEvent.startsWith(hEventPrefix)) {
                this.handleSoftKey(hEvent);
            }
        });
        this.hEventPrefix = hEventPrefix;
    }
    /**
     * The current menu on the stack.
     * @returns The current menu.
     */
    get currentMenu() {
        return this.menuStack[this.menuStack.length - 1];
    }
    /**
     * Adds a menu to the menu system.
     * @param name The route to the menu to add this menu entry to.
     * @param entry The menu entry to add.
     */
    addMenu(name, entry) {
        this.registeredMenus[name] = entry;
    }
    /**
     * Pushes a menu onto the menu system stack.
     * @param name The name of the menu to push.
     */
    pushMenu(name) {
        this.menuStack.push(this.registeredMenus[name]);
        this.renderToSoftKeys();
    }
    /**
     * Replaces one menu with another on top of the stack.
     * @param name The name of the menu to activate.
     */
    replaceMenu(name) {
        if (this.menuStack.length > 1) {
            this.menuStack.pop();
        }
        this.menuStack.push(this.registeredMenus[name]);
        this.renderToSoftKeys();
    }
    /**
     * Pops a menu off the stack and returns to the previous menu.
     */
    back() {
        if (this.menuStack.length === 1) {
            // do not pop the base empty menu.
            return;
        }
        this.menuStack.pop();
        this.renderToSoftKeys();
    }
    /**
     * Clears the menu stack.
     */
    clear() {
        this.menuStack.length = 1;
        this.renderToSoftKeys();
    }
    /**
     * Attaches the softkeys display component to the menu system.
     * @param softKeys The softkeys display component instance.
     */
    attachSoftKeys(softKeys) {
        this.softKeys = softKeys;
        this.renderToSoftKeys();
    }
    /**
     * Renders the current menu to the softkeys.
     */
    renderToSoftKeys() {
        this.currentMenu.forEach((item, index) => {
            var _a;
            (_a = this.softKeys) === null || _a === void 0 ? void 0 : _a.setMenuItem(index, item);
        });
    }
    /**
     * Handles a softkey HEvent and delgates to the handler.
     * @param hEvent The HEvent to handle.
     */
    handleSoftKey(hEvent) {
        const softKeyIndex = parseInt(hEvent.replace(this.hEventPrefix, '')) - 1;
        this.currentMenu.handleItemPressed(softKeyIndex);
    }
}

/**
 * A softkey tab in the soft key bar interface.
 */
class SoftKey extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.menuItem = SoftKeyMenu.EmptyMenuItem;
        this.rootEl = new NodeReference();
        this.labelEl = new NodeReference();
        this.indicatorEl = new NodeReference();
        this.valueEl = new NodeReference();
        /**
         * Menu item value changed handler.
         * @param v the new value
         */
        this.menuItemValueChangedHandler = (v) => {
            if (typeof v === 'string') {
                this.showIndicator(false);
                this.indicate(false);
                this.valueEl.instance.style.display = '';
                this.valueEl.instance.textContent = v;
                this.labelEl.instance.classList.add('text-value');
            }
            else if (typeof v === 'boolean') {
                this.showIndicator(true);
                this.valueEl.instance.style.display = 'none';
                this.labelEl.instance.classList.remove('text-value');
                this.valueEl.instance.textContent = '';
                this.indicate(v);
            }
            else {
                this.showIndicator(false);
                this.valueEl.instance.textContent = '';
                this.valueEl.instance.style.display = 'none';
                this.labelEl.instance.classList.remove('text-value');
            }
        };
        /**
         * Sets the css class to make the soft key look disabled.
         * @param isDisabled Whether or not the soft key is disabled.
         */
        this.setDisabled = (isDisabled) => {
            if (isDisabled) {
                this.rootEl.instance.classList.add('text-disabled');
            }
            else {
                this.rootEl.instance.classList.remove('text-disabled');
            }
        };
        /**
         * Sets the text of this soft key.
         * @param text the text
         */
        this.setLabel = (text) => {
            this.labelEl.instance.textContent = text;
        };
    }
    /** @inheritdoc */
    onAfterRender() {
        super.onAfterRender();
        this.setMenuItem(this.props.menuItem);
    }
    /**
     * Sets and binds a menu item to this soft key.
     * @param item the menu item
     */
    setMenuItem(item) {
        // remove former subs
        this.unsubscribeFromMenuItem(this.menuItem);
        this.menuItem = item;
        const value = item.value.get();
        this.menuItemValueChangedHandler(value);
        item.value.sub(this.menuItemValueChangedHandler);
        this.setDisabled(item.disabled.get() === true);
        item.disabled.sub(this.setDisabled);
        this.setLabel(item.label.get());
        item.label.sub(this.setLabel);
    }
    /**
     * Unsubscribes from change events on the menu item.
     * @param item the menu item
     */
    unsubscribeFromMenuItem(item) {
        item.value.unsub(this.menuItemValueChangedHandler);
        item.disabled.unsub(this.setDisabled);
        item.label.unsub(this.setLabel);
    }
    /**
     * Shows or hides the active/inactive indicator.
     * @param isShown Whether or not the indicator is shown.
     */
    showIndicator(isShown) {
        if (isShown) {
            this.indicatorEl.instance.classList.add('shown');
        }
        else {
            this.indicatorEl.instance.classList.remove('shown');
        }
    }
    /**
     * Activates or inactivates the indicator.
     * @param isIndicating Whether or not the indicator is indicating.
     */
    indicate(isIndicating) {
        if (isIndicating) {
            this.showIndicator(true);
            this.indicatorEl.instance.classList.add('indicating');
        }
        else {
            this.indicatorEl.instance.classList.remove('indicating');
        }
    }
    /**
     * Renders the component.
     * @returns The rendered component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: 'softkey-tab', ref: this.rootEl },
            FSComponent.buildComponent("div", { class: 'softkey-tab-borders' }),
            FSComponent.buildComponent("label", { class: 'softkey-tab-label', ref: this.labelEl }),
            FSComponent.buildComponent("span", { class: 'softkey-tab-value', ref: this.valueEl, style: 'display: none' }),
            FSComponent.buildComponent("div", { class: 'softkey-tab-indicator', ref: this.indicatorEl })));
    }
}

/**
 * The Garmin softkeys tab display for the PFD and MFD.
 */
class SoftKeyBar extends DisplayComponent {
    /**
     * Creates an instance of SoftKeys.
     * @param props The properties to use.
     */
    constructor(props) {
        super(props);
        /** References to the softkey div nodes. */
        this.refs = [];
        this.menuSystem = this.props.menuSystem;
    }
    /**
     * Builds the softkeys tab elements.
     * @returns A collection of soft key div elements.
     */
    buildSoftKeys() {
        const softKeys = [];
        for (let i = 0; i < 12; i++) {
            const ref = FSComponent.createRef();
            softKeys.push(FSComponent.buildComponent(SoftKey, { ref: ref, menuItem: SoftKeyMenu.EmptyMenuItem }));
            this.refs[i] = ref;
        }
        return softKeys;
    }
    /**
     * Starts the softkey HEvent listener after render.
     */
    onAfterRender() {
        this.menuSystem.attachSoftKeys(this);
    }
    /**
     * Binds a menu item to a soft key.
     * @param index  the index of the softkey
     * @param menuItem the menu item to set
     */
    setMenuItem(index, menuItem) {
        this.refs[index].instance.setMenuItem(menuItem);
    }
    /**
     * Renders the component.
     * @returns The rendered component.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: 'softkeys-container' }, this.buildSoftKeys()));
    }
}

/**
 * A manager for user settings. Provides settings using their names as keys, publishes value change events on the
 * event bus, and keeps setting values up to date when receiving change events across the bus.
 */
class DefaultUserSettingManager {
    /**
     * Constructor.
     * @param bus The bus used by this manager to publish setting change events.
     * @param settingDefs The setting definitions used to initialize manager's settings.
     */
    constructor(bus, settingDefs) {
        this.bus = bus;
        this.publisher = bus.getPublisher();
        this.subscriber = bus.getSubscriber();
        this.settings = new Map(settingDefs.map(def => {
            const syncTopic = `${DefaultUserSettingManager.SYNC_TOPIC_PREFIX}${def.name}`;
            const entry = {
                syncTopic,
                syncTime: 0
            };
            entry.setting = new SyncableUserSetting(def, this.onSettingValueChanged.bind(this, entry));
            this.subscriber.on(syncTopic).handle(this.onSettingValueSynced.bind(this, entry));
            this.onSettingValueChanged(entry, entry.setting.value);
            return [def.name, entry];
        }));
    }
    /**
     * Gets a setting from this manager.
     * @param name The name of the setting to get.
     * @returns a setting.
     * @throws Error if no setting with the specified name exists.
     */
    getSetting(name) {
        const entry = this.settings.get(name);
        if (!entry) {
            throw new Error(`Could not find setting with name ${name}`);
        }
        return entry.setting;
    }
    /**
     * Gets an array of all settings of this manager.
     * @returns an array of all settings of this manager.
     */
    getAllSettings() {
        return Array.from(this.settings.values(), entry => entry.setting);
    }
    /**
     * Gets a consumer which notifies handlers when the value of a setting changes.
     * @param name The name of a setting.
     * @returns a consumer which notifies handlers when the value of the setting changes.
     * @throws Error if no setting with the specified name exists.
     */
    whenSettingChanged(name) {
        const setting = this.settings.get(name);
        if (!setting) {
            throw new Error(`Could not find setting with name ${name}`);
        }
        return this.subscriber.on(name).whenChanged();
    }
    /**
     * Maps a user setting manager to abstracted settings keys.
     * @param map The map of key abstractions to apply.
     * @returns A new mapped user setting manager.
     */
    mapTo(map) {
        return new MappedUserSettingManager(this, map);
    }
    /**
     * A callback which is called when one of this manager's settings has its value changed locally.
     * @param entry The entry for the setting that was changed.
     * @param value The new value of the setting.
     */
    onSettingValueChanged(entry, value) {
        entry.syncTime = Date.now();
        this.publisher.pub(entry.syncTopic, { value, syncTime: entry.syncTime }, true, true);
    }
    /**
     * A callback which is called when a setting changed event is received over the event bus.
     * @param entry The entry for the setting that was changed.
     * @param data The sync data.
     */
    onSettingValueSynced(entry, data) {
        // protect against race conditions by not responding to sync events older than the last time this manager synced
        // the setting
        if (data.syncTime < entry.syncTime) {
            return;
        }
        entry.syncTime = data.syncTime;
        entry.setting.syncValue(data.value);
        // publish the public setting change event. Do NOT sync across the bus because doing so can result in older events
        // being received after newer events.
        this.publisher.pub(entry.setting.definition.name, data.value, false, true);
    }
}
DefaultUserSettingManager.SYNC_TOPIC_PREFIX = 'usersetting.';
/**
 * A manager for user settings. Provides settings using their names as keys, publishes value change events on the
 * event bus, and keeps setting values up to date when receiving change events across the bus, using a mapping from
 * abstracted settings keys to true underlying settings keys.
 */
class MappedUserSettingManager {
    /**
     * Creates an instance of a MappedUserSettingManager.
     * @param parent The parent setting manager.
     * @param map The map of abstracted keys to true underlying keys.
     */
    constructor(parent, map) {
        this.parent = parent;
        this.map = map;
    }
    /** @inheritdoc */
    getSetting(name) {
        var _a;
        const mappedName = ((_a = this.map[name]) !== null && _a !== void 0 ? _a : name);
        return this.parent.getSetting(mappedName);
    }
    /** @inheritdoc */
    whenSettingChanged(name) {
        var _a;
        const mappedName = ((_a = this.map[name]) !== null && _a !== void 0 ? _a : name);
        return this.parent.whenSettingChanged(mappedName);
    }
}
/**
 * An implementation of a user setting which can be synced across multiple instances.
 */
class SyncableUserSetting {
    /**
     * Constructor.
     * @param definition This setting's definition.
     * @param valueChangedCallback A function to be called whenever the value of this setting changes.
     */
    constructor(definition, valueChangedCallback) {
        this.definition = definition;
        this.valueChangedCallback = valueChangedCallback;
        this.isSyncing = false;
        this.valueSub = Subject.create(definition.defaultValue);
        this.valueSub.sub(v => {
            !this.isSyncing && valueChangedCallback(v);
        });
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This setting's current value. */
    get value() {
        return this.valueSub.get();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set value(v) {
        this.valueSub.set(v);
    }
    /**
     * Syncs this setting to a value. This will not trigger a call to valueChangedCallback.
     * @param value The value to which to sync.
     */
    syncValue(value) {
        this.isSyncing = true;
        this.valueSub.set(value);
        this.isSyncing = false;
    }
}

/**
 * A manager for user settings that are saved and persistent across flight sessions. The manager facilitates saving
 * and loading setting values to and from multiple keyed save slots and also supports auto-saving. Uses Data Store to
 * store saved setting values.
 */
class UserSettingSaveManager {
    /**
     * Constructor.
     * @param settings This manager's managed settings.
     * @param bus The event bus.
     */
    constructor(settings, bus) {
        this.autoSaveKeys = new Set();
        const subscriber = bus.getSubscriber();
        this.entries = Array.from(settings, setting => {
            const autoSaveDataStoreKeys = [];
            return {
                setting,
                consumer: subscriber.on(setting.definition.name).whenChanged(),
                eventHandler: this.onSettingChanged.bind(this, autoSaveDataStoreKeys),
                autoSaveDataStoreKeys
            };
        });
    }
    /**
     * A callback which is called when a setting's value changes.
     * @param autoSaveDataStoreKeys The data store keys to which the setting's value should be automatically saved.
     * @param value The new value of the setting.
     */
    onSettingChanged(autoSaveDataStoreKeys, value) {
        const len = autoSaveDataStoreKeys.length;
        for (let i = 0; i < len; i++) {
            DataStore.set(autoSaveDataStoreKeys[i], value);
        }
    }
    /**
     * Loads the saved values of this manager's settings.
     * @param key The key from which to load the values.
     */
    load(key) {
        const len = this.entries.length;
        for (let i = 0; i < len; i++) {
            const entry = this.entries[i];
            const dataStoreKey = UserSettingSaveManager.getDataStoreKey(entry.setting, key);
            const storedValue = DataStore.get(dataStoreKey);
            if (storedValue !== undefined) {
                entry.setting.value = storedValue;
            }
        }
    }
    /**
     * Saves the current values of this manager's settings.
     * @param key The key to which to save the values.
     */
    save(key) {
        const len = this.entries.length;
        for (let i = 0; i < len; i++) {
            const entry = this.entries[i];
            const dataStoreKey = UserSettingSaveManager.getDataStoreKey(entry.setting, key);
            DataStore.set(dataStoreKey, entry.setting.value);
        }
    }
    /**
     * Starts automatically saving this manager's settings when their values change.
     * @param key The key to which to save the values.
     */
    startAutoSave(key) {
        if (this.autoSaveKeys.has(key)) {
            return;
        }
        const len = this.entries.length;
        for (let i = 0; i < len; i++) {
            const entry = this.entries[i];
            entry.autoSaveDataStoreKeys.push(UserSettingSaveManager.getDataStoreKey(entry.setting, key));
            if (entry.autoSaveDataStoreKeys.length === 1) {
                entry.consumer.handle(entry.eventHandler);
            }
        }
    }
    /**
     * Stops automatically saving this manager's settings when their values change.
     * @param key The key to which to stop saving the values.
     */
    stopAutoSave(key) {
        if (!this.autoSaveKeys.has(key)) {
            return;
        }
        const len = this.entries.length;
        for (let i = 0; i < len; i++) {
            const entry = this.entries[i];
            entry.autoSaveDataStoreKeys.splice(entry.autoSaveDataStoreKeys.indexOf(UserSettingSaveManager.getDataStoreKey(entry.setting, key)), 1);
            if (entry.autoSaveDataStoreKeys.length === 0) {
                entry.consumer.off(entry.eventHandler);
            }
        }
    }
    /**
     * Gets a data store key for a specific setting and save key.
     * @param setting A user setting.
     * @param saveKey The save key.
     * @returns the data store key for the setting and save key.
     */
    static getDataStoreKey(setting, saveKey) {
        return `${UserSettingSaveManager.DATASTORE_PREFIX}.${saveKey}.${setting.definition.name}`;
    }
}
UserSettingSaveManager.DATASTORE_PREFIX = 'persistent-setting';

/**
 * Traffic alert level modes.
 */
var MapTrafficAlertLevelMode;
(function (MapTrafficAlertLevelMode) {
    MapTrafficAlertLevelMode[MapTrafficAlertLevelMode["All"] = 0] = "All";
    MapTrafficAlertLevelMode[MapTrafficAlertLevelMode["Advisories"] = 1] = "Advisories";
    MapTrafficAlertLevelMode[MapTrafficAlertLevelMode["TA_RA"] = 2] = "TA_RA";
    MapTrafficAlertLevelMode[MapTrafficAlertLevelMode["RA"] = 3] = "RA";
})(MapTrafficAlertLevelMode || (MapTrafficAlertLevelMode = {}));
/**
 * Traffic motion vector modes.
 */
var MapTrafficMotionVectorMode;
(function (MapTrafficMotionVectorMode) {
    MapTrafficMotionVectorMode[MapTrafficMotionVectorMode["Off"] = 0] = "Off";
    MapTrafficMotionVectorMode[MapTrafficMotionVectorMode["Absolute"] = 1] = "Absolute";
    MapTrafficMotionVectorMode[MapTrafficMotionVectorMode["Relative"] = 2] = "Relative";
})(MapTrafficMotionVectorMode || (MapTrafficMotionVectorMode = {}));
/**
 * Traffic display altitude restriction modes.
 */
var MapTrafficAltitudeRestrictionMode;
(function (MapTrafficAltitudeRestrictionMode) {
    MapTrafficAltitudeRestrictionMode[MapTrafficAltitudeRestrictionMode["Unrestricted"] = 0] = "Unrestricted";
    MapTrafficAltitudeRestrictionMode[MapTrafficAltitudeRestrictionMode["Above"] = 1] = "Above";
    MapTrafficAltitudeRestrictionMode[MapTrafficAltitudeRestrictionMode["Normal"] = 2] = "Normal";
    MapTrafficAltitudeRestrictionMode[MapTrafficAltitudeRestrictionMode["Below"] = 3] = "Below";
})(MapTrafficAltitudeRestrictionMode || (MapTrafficAltitudeRestrictionMode = {}));
/**
 * A module describing the display of traffic.
 */
class MapTrafficModule {
    /**
     * Constructor.
     * @param tcas This module's associated TCAS.
     */
    constructor(tcas) {
        this.tcas = tcas;
        /** Whether to show traffic information. */
        this.show = Subject.create(true);
        /** The TCAS operating mode. */
        this.operatingMode = Subject.create(TCASOperatingMode.Standby);
        /** Whether to show intruder labels. */
        this.showIntruderLabel = Subject.create(true);
        /** The index of the outer ring range. */
        this.outerRangeIndex = Subject.create(0);
        /** The index of the inner ring range. */
        this.innerRangeIndex = Subject.create(0);
        /** The alert level mode. */
        this.alertLevelMode = Subject.create(MapTrafficAlertLevelMode.All);
        /** The altitude restriction mode. */
        this.altitudeRestrictionMode = Subject.create(MapTrafficAltitudeRestrictionMode.Unrestricted);
        /** The motion vector mode. */
        this.altitudeRestrictionAbove = ComputedSubject.create(MapTrafficAltitudeRestrictionMode.Unrestricted, mode => {
            return mode === MapTrafficAltitudeRestrictionMode.Unrestricted || mode === MapTrafficAltitudeRestrictionMode.Above
                ? MapTrafficModule.ALTITUDE_RESTRICTION_UNRES
                : MapTrafficModule.ALTITUDE_RESTRICTION_NORMAL;
        });
        /** The motion vector mode. */
        this.altitudeRestrictionBelow = ComputedSubject.create(MapTrafficAltitudeRestrictionMode.Unrestricted, mode => {
            return mode === MapTrafficAltitudeRestrictionMode.Unrestricted || mode === MapTrafficAltitudeRestrictionMode.Below
                ? MapTrafficModule.ALTITUDE_RESTRICTION_UNRES
                : MapTrafficModule.ALTITUDE_RESTRICTION_NORMAL;
        });
        /** Whether displayed intruder altitude is relative. */
        this.isAltitudeRelative = Subject.create(true);
        /** The motion vector mode. */
        this.motionVectorMode = Subject.create(MapTrafficMotionVectorMode.Off);
        /** The motion vector mode. */
        this.motionVectorLookahead = NumberUnitSubject.createFromNumberUnit(UnitType.SECOND.createNumber(60));
        this.altitudeRestrictionMode.sub(mode => {
            this.altitudeRestrictionAbove.set(mode);
            this.altitudeRestrictionBelow.set(mode);
        });
        tcas.getEventSubscriber().on('tcas_operating_mode').whenChanged().handle(mode => {
            this.operatingMode.set(mode);
        });
    }
}
MapTrafficModule.ALTITUDE_RESTRICTION_UNRES = UnitType.FOOT.createNumber(9900);
MapTrafficModule.ALTITUDE_RESTRICTION_NORMAL = UnitType.FOOT.createNumber(2700);

/**
 * Setting modes for map orientation.
 */
var MapOrientationSettingMode;
(function (MapOrientationSettingMode) {
    MapOrientationSettingMode[MapOrientationSettingMode["NorthUp"] = 0] = "NorthUp";
    MapOrientationSettingMode[MapOrientationSettingMode["TrackUp"] = 1] = "TrackUp";
    MapOrientationSettingMode[MapOrientationSettingMode["HeadingUp"] = 2] = "HeadingUp";
})(MapOrientationSettingMode || (MapOrientationSettingMode = {}));
/**
 * Setting modes for map terrain display.
 */
var MapTerrainSettingMode;
(function (MapTerrainSettingMode) {
    MapTerrainSettingMode[MapTerrainSettingMode["None"] = 0] = "None";
    MapTerrainSettingMode[MapTerrainSettingMode["Absolute"] = 1] = "Absolute";
    MapTerrainSettingMode[MapTerrainSettingMode["Relative"] = 2] = "Relative";
})(MapTerrainSettingMode || (MapTerrainSettingMode = {}));
/**
 * Setting modes for map declutter.
 */
var MapDeclutterSettingMode;
(function (MapDeclutterSettingMode) {
    MapDeclutterSettingMode[MapDeclutterSettingMode["All"] = 0] = "All";
    MapDeclutterSettingMode[MapDeclutterSettingMode["Level3"] = 1] = "Level3";
    MapDeclutterSettingMode[MapDeclutterSettingMode["Level2"] = 2] = "Level2";
    MapDeclutterSettingMode[MapDeclutterSettingMode["Level1"] = 3] = "Level1";
})(MapDeclutterSettingMode || (MapDeclutterSettingMode = {}));
/**
 * Utility class for retrieving map user setting managers.
 */
class MapUserSettings {
    /**
     * Retrieves a manager for map user settings.
     * @param bus The event bus.
     * @returns a manager for map user settings.
     */
    static getManager(bus) {
        var _a;
        return (_a = MapUserSettings.INSTANCE) !== null && _a !== void 0 ? _a : (MapUserSettings.INSTANCE = new DefaultUserSettingManager(bus, [
            {
                name: 'mapOrientation',
                defaultValue: MapOrientationSettingMode.HeadingUp
            },
            {
                name: 'mapAutoNorthUpActive',
                defaultValue: true
            },
            {
                name: 'mapAutoNorthUpRangeIndex',
                defaultValue: 27
            },
            {
                name: 'mapPfdDeclutter',
                defaultValue: MapDeclutterSettingMode.All
            },
            {
                name: 'mapMfdDeclutter',
                defaultValue: MapDeclutterSettingMode.All
            },
            {
                name: 'mapPfdTerrainMode',
                defaultValue: MapTerrainSettingMode.Absolute
            },
            {
                name: 'mapMfdTerrainMode',
                defaultValue: MapTerrainSettingMode.Absolute
            },
            {
                name: 'mapTerrainRangeIndex',
                defaultValue: 27
            },
            {
                name: 'mapTerrainScaleShow',
                defaultValue: false
            },
            {
                name: 'mapAirportLargeShow',
                defaultValue: true
            },
            {
                name: 'mapAirportLargeRangeIndex',
                defaultValue: 21
            },
            {
                name: 'mapAirportMediumShow',
                defaultValue: true
            },
            {
                name: 'mapAirportMediumRangeIndex',
                defaultValue: 19
            },
            {
                name: 'mapAirportSmallShow',
                defaultValue: true
            },
            {
                name: 'mapAirportSmallRangeIndex',
                defaultValue: 17
            },
            {
                name: 'mapVorShow',
                defaultValue: true
            },
            {
                name: 'mapVorRangeIndex',
                defaultValue: 19
            },
            {
                name: 'mapNdbShow',
                defaultValue: true
            },
            {
                name: 'mapNdbRangeIndex',
                defaultValue: 17
            },
            {
                name: 'mapIntersectionShow',
                defaultValue: true
            },
            {
                name: 'mapIntersectionRangeIndex',
                defaultValue: 17
            },
            {
                name: 'mapPfdTrafficShow',
                defaultValue: false
            },
            {
                name: 'mapMfdTrafficShow',
                defaultValue: false
            },
            {
                name: 'mapTrafficRangeIndex',
                defaultValue: 17
            },
            {
                name: 'mapTrafficLabelShow',
                defaultValue: true
            },
            {
                name: 'mapTrafficLabelRangeIndex',
                defaultValue: 17
            },
            {
                name: 'mapTrafficAlertLevelMode',
                defaultValue: MapTrafficAlertLevelMode.All
            },
            {
                name: 'mapPfdNexradShow',
                defaultValue: false
            },
            {
                name: 'mapMfdNexradShow',
                defaultValue: false
            },
            {
                name: 'mapNexradRangeIndex',
                defaultValue: 27
            }
        ]));
    }
    /**
     * Retrieves a manager for PFD map user settings.
     * @param bus The event bus.
     * @returns a manager for PFD map user settings.
     */
    static getPfdManager(bus) {
        var _a;
        return (_a = MapUserSettings.PFD_INSTANCE) !== null && _a !== void 0 ? _a : MapUserSettings.getManager(bus).mapTo({
            mapDeclutter: 'mapPfdDeclutter',
            mapNexradShow: 'mapPfdNexradShow',
            mapTerrainMode: 'mapPfdTerrainMode',
            mapTrafficShow: 'mapPfdTrafficShow'
        });
    }
    /**
     * Retrieves a manager for MFD map user settings.
     * @param bus The event bus.
     * @returns a manager for PFD map user settings.
     */
    static getMfdManager(bus) {
        var _a;
        return (_a = MapUserSettings.MFD_INSTANCE) !== null && _a !== void 0 ? _a : MapUserSettings.getManager(bus).mapTo({
            mapDeclutter: 'mapMfdDeclutter',
            mapNexradShow: 'mapMfdNexradShow',
            mapTerrainMode: 'mapMfdTerrainMode',
            mapTrafficShow: 'mapMfdTrafficShow'
        });
    }
}

/**
 * An MFD page root softkey menu.
 */
class MFDRootMenu extends SoftKeyMenu {
    /**
     * Creates an instance of an MFD page root softkey menu.
     * @param menuSystem The menu system.
     */
    constructor(menuSystem) {
        super(menuSystem);
        this.addItem(0, 'Engine', () => menuSystem.pushMenu('engine-menu'));
    }
}

/**
 * The MFD Navigation Map page root softkey menu.
 */
class MFDNavMapRootMenu extends MFDRootMenu {
    /**
     * Creates an instance of the MFD Navigation Map page root softkey menu.
     * @param menuSystem The menu system.
     */
    constructor(menuSystem) {
        super(menuSystem);
        this.mapSettings = MapUserSettings.getMfdManager(this.menuSystem.bus);
        this.addItem(2, 'Map Opt', () => menuSystem.pushMenu('map-opt'));
        this.addItem(9, 'Detail', this.cycleDeclutterSetting.bind(this), '', false);
        this.addItem(10, 'Charts');
        this.addItem(11, 'Checklist');
        this.initSettings();
    }
    /**
     * Sets the map model to use for these options.
     */
    initSettings() {
        this.mapSettings.whenSettingChanged('mapDeclutter').handle(v => this.getItem(9).value.set(MFDNavMapRootMenu.DECLUTTER_TEXT[v]));
    }
    /**
     * Cycles the map declutter setting.
     */
    cycleDeclutterSetting() {
        const setting = this.mapSettings.getSetting('mapDeclutter');
        switch (setting.value) {
            case MapDeclutterSettingMode.All:
                setting.value = MapDeclutterSettingMode.Level3;
                break;
            case MapDeclutterSettingMode.Level3:
                setting.value = MapDeclutterSettingMode.Level2;
                break;
            case MapDeclutterSettingMode.Level2:
                setting.value = MapDeclutterSettingMode.Level1;
                break;
            case MapDeclutterSettingMode.Level1:
                setting.value = MapDeclutterSettingMode.All;
                break;
        }
    }
}
MFDNavMapRootMenu.DECLUTTER_TEXT = {
    [MapDeclutterSettingMode.All]: 'All',
    [MapDeclutterSettingMode.Level3]: '3',
    [MapDeclutterSettingMode.Level2]: '2',
    [MapDeclutterSettingMode.Level1]: '1',
};

/**
 * The MFD Engine softkey menu.
 */
class EngineMenu extends SoftKeyMenu {
    /**
     * Creates an instance of the MFD engine menu.
     * @param menuSystem The engine menu system.
     * @param config The EIS gauge configuration.
     * @param publisher A publisher to use for sending control events
     */
    constructor(menuSystem, config, publisher) {
        super(menuSystem);
        this.publisher = publisher;
        this.addItem(0, 'Engine', () => { }, true);
        this.addItem(1, 'Lean', () => this.selectPage(EISPageTypes.Lean), false, config.leanPage ? false : true);
        this.addItem(2, 'System', () => this.selectPage(EISPageTypes.System), false, config.systemPage ? false : true);
        this.addItem(10, 'Back', () => {
            this.selectPage(EISPageTypes.Engine);
            menuSystem.back();
        });
    }
    /**
     * Handle a menu item being selected.
     * @param selectedPage The selected item.
     */
    selectPage(selectedPage) {
        this.publisher.publishEvent('eis_page_select', selectedPage);
        switch (selectedPage) {
            case EISPageTypes.Lean:
                this.menuSystem.replaceMenu('lean-menu');
                break;
            case EISPageTypes.System:
                this.menuSystem.replaceMenu('system-menu');
                break;
        }
    }
}

/**
 * The MFD Engine lean  menu.
 */
class LeanMenu extends SoftKeyMenu {
    /**
     * Creates an instance of the MFD engine lean menu.
     * @param menuSystem The engine lean menu system.
     * @param config The EIS gauge configuration.
     * @param publisher A publisher to use for sending control events
     */
    constructor(menuSystem, config, publisher) {
        super(menuSystem);
        this.leanAssistActive = false;
        this.cylSlctActive = false;
        this.publisher = publisher;
        this.addItem(0, 'Engine', () => this.selectPage(EISPageTypes.Engine), false);
        this.addItem(1, 'Lean', () => { }, true);
        this.addItem(2, 'System', () => this.selectPage(EISPageTypes.System), false, config.systemPage ? false : true);
        this.addItem(4, 'CYL SLCT', () => { this.toggleLeanCylSlct(); });
        this.addItem(5, 'Assist', () => { this.toggleLeanAssist(); }, false);
        this.addItem(10, 'Back', () => {
            this.selectPage(EISPageTypes.Engine);
            menuSystem.back();
        });
    }
    /**
     * Handle a menu item being selected.
     * @param selectedPage The selected item.
     */
    selectPage(selectedPage) {
        this.publisher.publishEvent('eis_page_select', selectedPage);
        switch (selectedPage) {
            case EISPageTypes.Engine:
                this.menuSystem.replaceMenu('engine-menu');
                break;
            case EISPageTypes.System:
                this.menuSystem.replaceMenu('system-menu');
                break;
        }
    }
    /**
     * Turn lean assist mode on and off.
     */
    toggleLeanAssist() {
        this.leanAssistActive = !this.leanAssistActive;
        this.publisher.publishEvent('eis_lean_assist', this.leanAssistActive);
        this.getItem(5).value.set(this.leanAssistActive);
        this.getItem(4).disabled.set(this.leanAssistActive);
    }
    /**
     * Cycles cylinder select.
     */
    toggleLeanCylSlct() {
        if (this.leanAssistActive) {
            return;
        }
        this.publisher.publishEvent('eis_cyl_slct', true);
    }
}

/**
 * The MFD Engine system  menu.
 */
class SystemMenu extends SoftKeyMenu {
    /**
     * Creates an instance of the MFD engine lean menu.
     * @param menuSystem The engine lean menu system.
     * @param config The EIS gauge configuration.
     * @param publisher A publisher to use for sending control events
     */
    constructor(menuSystem, config, publisher) {
        super(menuSystem);
        this.publisher = publisher;
        this.addItem(0, 'Engine', () => this.selectPage(EISPageTypes.Engine), false);
        this.addItem(1, 'Lean', () => this.selectPage(EISPageTypes.Lean), false, config.leanPage ? false : true);
        this.addItem(2, 'System', () => { }, true);
        this.addItem(6, 'RST Fuel', () => { this.publisher.publishEvent('fuel_comp_reset', true); });
        this.addItem(7, 'GAL REM', () => { this.menuSystem.pushMenu('fuel-rem-menu'); });
        this.addItem(10, 'Back', () => {
            this.selectPage(EISPageTypes.Engine);
            menuSystem.back();
        });
    }
    /**
     * Handle a menu item being selected.
     * @param selectedPage The selected item.
     */
    selectPage(selectedPage) {
        this.publisher.publishEvent('eis_page_select', selectedPage);
        switch (selectedPage) {
            case EISPageTypes.Engine:
                this.menuSystem.replaceMenu('engine-menu');
                break;
            case EISPageTypes.Lean:
                this.menuSystem.replaceMenu('lean-menu');
                break;
        }
    }
}

/**
 * The MFD Engine system  menu.
 */
class FuelRemMenu extends SoftKeyMenu {
    /**
     * Creates an instance of the MFD engine lean menu.
     * @param menuSystem The engine lean menu system.
     * @param config The EIS gauge configuration.
     * @param publisher A publisher to use for sending control events
     */
    constructor(menuSystem, config, publisher) {
        super(menuSystem);
        this.publisher = publisher;
        this.addItem(0, 'Engine', () => this.selectPage(EISPageTypes.Engine), false);
        this.addItem(1, 'Lean', () => this.selectPage(EISPageTypes.Lean), false, config.leanPage ? false : true);
        this.addItem(2, 'System', () => { }, true);
        this.addItem(3, '-10 GAL', () => { this.publisher.publishEvent('fuel_adjustment', { direction: 'remove', amount: 10 }); });
        this.addItem(4, '-1 GAL', () => { this.publisher.publishEvent('fuel_adjustment', { direction: 'remove', amount: 1 }); });
        this.addItem(5, '+1 GAL', () => { this.publisher.publishEvent('fuel_adjustment', { direction: 'add', amount: 1 }); });
        this.addItem(6, '+10 GAL', () => { this.publisher.publishEvent('fuel_adjustment', { direction: 'add', amount: 10 }); });
        this.addItem(7, '35 GAL', () => { this.publisher.publishEvent('fuel_adjustment', { direction: 'set', amount: 35 }); });
        this.addItem(8, '53 GAL', () => { this.publisher.publishEvent('fuel_adjustment', { direction: 'set', amount: 53 }); });
        this.addItem(10, 'Back', () => {
            this.selectPage(EISPageTypes.System);
            menuSystem.back();
        });
    }
    /**
     * Handle a menu item being selected.
     * @param selectedPage The selected item.
     */
    selectPage(selectedPage) {
        this.publisher.publishEvent('eis_page_select', selectedPage);
        switch (selectedPage) {
            case EISPageTypes.Engine:
                this.menuSystem.replaceMenu('engine-menu');
                break;
            case EISPageTypes.Lean:
                this.menuSystem.replaceMenu('lean-menu');
                break;
        }
    }
}

/**
 * The MFD Map options system  menu.
 */
class MapOptMenu extends SoftKeyMenu {
    /**
     * Creates an instance of the MFD map options menu.
     * @param menuSystem The map options menu system.
     * @param publisher A publisher to use for sending control events
     */
    constructor(menuSystem, publisher) {
        super(menuSystem);
        this.publisher = publisher;
        this.addItem(0, 'Traffic', this.toggleBooleanSetting.bind(this, 'mapTrafficShow'), false, false);
        this.addItem(2, 'Inset', () => menuSystem.pushMenu('inset-menu'), undefined, true);
        this.addItem(3, 'TER', this.toggleTerrain.bind(this), 'Topo', false);
        this.addItem(4, 'AWY Off', () => { }, false, true);
        this.addItem(6, 'NEXRAD', this.toggleBooleanSetting.bind(this, 'mapNexradShow'), false, false);
        this.addItem(7, 'XM LTNG', () => { }, false, true);
        this.addItem(8, 'METAR', () => { }, false, true);
        this.addItem(9, 'Legend', this.toggleBooleanSetting.bind(this, 'mapTerrainScaleShow'), false, false);
        this.addItem(10, 'Back', () => menuSystem.back());
        this.settings = MapUserSettings.getMfdManager(this.menuSystem.bus);
        this.initSettings();
    }
    /**
     * Sets the map model to use for these options.
     */
    initSettings() {
        this.settings.whenSettingChanged('mapTrafficShow').handle(v => this.getItem(0).value.set(v));
        this.settings.whenSettingChanged('mapTerrainMode').handle(v => this.getItem(3).value.set(this.getTerrainModeString(v)));
        this.settings.whenSettingChanged('mapTerrainScaleShow').handle(v => this.getItem(9).value.set(v));
        this.settings.whenSettingChanged('mapNexradShow').handle(v => this.getItem(6).value.set(v));
    }
    /**
     * Toggles terrain on and off.
     */
    toggleTerrain() {
        const setting = this.settings.getSetting('mapTerrainMode');
        switch (setting.value) {
            case MapTerrainSettingMode.None:
                setting.value = MapTerrainSettingMode.Absolute;
                break;
            case MapTerrainSettingMode.Absolute:
                setting.value = MapTerrainSettingMode.Relative;
                break;
            default:
                setting.value = MapTerrainSettingMode.None;
                break;
        }
    }
    /**
     * Toggles a boolean map setting on or off.
     * @param setting The setting to toggle.
     */
    toggleBooleanSetting(setting) {
        const mapSetting = this.settings.getSetting(setting);
        mapSetting.value = !mapSetting.value;
    }
    /**
     * Gets a terrain mode value string from a mode enum.
     * @param mode The mode to get the string for.
     * @returns A terrain mode string.
     */
    getTerrainModeString(mode) {
        switch (mode) {
            case MapTerrainSettingMode.None:
                return 'Off';
            case MapTerrainSettingMode.Absolute:
                return 'Topo';
            case MapTerrainSettingMode.Relative:
                return 'Rel';
        }
    }
}

/**
 * The MFD Map options system  menu.
 */
class InsetMenu extends SoftKeyMenu {
    /**
     * Creates an instance of the MFD map options menu.
     * @param menuSystem The map options menu system.
     * @param publisher A publisher to use for sending control events
     */
    constructor(menuSystem, publisher) {
        super(menuSystem);
        this.publisher = publisher;
        this.addItem(0, 'Off', () => { }, false, true);
        this.addItem(2, 'VSD', () => { }, false, true);
        this.addItem(4, 'VSD Auto', () => { }, false, true);
        this.addItem(10, 'Back', () => menuSystem.back());
    }
}

/**
 * Utility Methods for the FMS.
 */
class FmsUtils {
    /**
     * Utility method to return a one-way runway leg
     * @param airport The runway's parent airport.
     * @param oneWayRunway is the one wway runway object
     * @param isOriginRunway is a bool whether this is the origin or destination (origin = true, dest = false)
     * @returns a leg object for the runway
     */
    static buildRunwayLeg(airport, oneWayRunway, isOriginRunway) {
        const leg = FlightPlan.createLeg({
            lat: oneWayRunway.latitude,
            lon: oneWayRunway.longitude,
            type: isOriginRunway ? LegType.IF : LegType.TF,
            fixIcao: RunwayUtils.getRunwayFacilityIcao(airport, oneWayRunway),
            altitude1: oneWayRunway.elevation
        });
        return leg;
    }
    /**
     * Utility method to return a one-way runway leg from an approach runway leg definition
     * @param airport is the facility associated with the arrival
     * @param runwayIcao is the icao string for the runway waypoint in the final legs
     * @returns a leg object for the runway
     */
    static buildRunwayLegForApproach(airport, runwayIcao) {
        for (let i = 0; i < airport.runways.length; i++) {
            const match = RunwayUtils.getOneWayRunways(airport.runways[i], i).find((r) => {
                return (r.designation == ICAO.getIdent(runwayIcao));
            });
            if (match) {
                const leg = FlightPlan.createLeg({
                    lat: match.latitude,
                    lon: match.longitude,
                    type: LegType.TF,
                    fixIcao: runwayIcao
                });
                return leg;
            }
        }
        return undefined;
    }
    /**
     * Utility method to return a visual approach for a runway.
     * @param airport is the airport facility for the visual approach.
     * @param runway is the runway to build the visual approach for.
     * @param finalLegDistance is the distance from the runway to place the faf leg in NM.
     * @param initialLegDistance is the distance from the final leg to place the iaf leg in NM.
     * @param name is the optional name for the approach.
     * @param finalLegIdent is the optional name for the faf leg.
     * @param initialLegIdent is the optional name for the iaf leg.
     * @returns an approach procedure.
     */
    static buildVisualApproach(airport, runway, finalLegDistance, initialLegDistance, name, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    finalLegIdent, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    initialLegIdent) {
        const iafLatLon = FmsUtils.tempGeoPoint
            .set(runway.latitude, runway.longitude)
            .offset(NavMath.normalizeHeading(runway.course + 180), UnitType.NMILE.convertTo(initialLegDistance + finalLegDistance, UnitType.GA_RADIAN));
        const runwayCode = RunwayUtils.getRunwayCode(parseInt(runway.designation.substr(2)));
        const runwayLetter = isNaN(parseInt(runway.designation.substr(-1))) ? runway.designation.substr(-1) : ' ';
        if (initialLegIdent === undefined) {
            initialLegIdent = 'STRGHT';
        }
        const iafLeg = FlightPlan.createLeg({
            type: LegType.IF,
            fixIcao: `S${ICAO.getIdent(airport.icao).padStart(4, ' ')}${runwayCode}${runwayLetter}${initialLegIdent}`,
            course: runway.course,
            fixTypeFlags: FixTypeFlags.IAF,
            lat: iafLatLon.lat,
            lon: iafLatLon.lon,
        });
        const fafLatLon = FmsUtils.tempGeoPoint
            .set(runway.latitude, runway.longitude)
            .offset(NavMath.normalizeHeading(runway.course + 180), UnitType.NMILE.convertTo(finalLegDistance, UnitType.GA_RADIAN));
        if (finalLegIdent === undefined) {
            finalLegIdent = ' FINAL';
        }
        const fafLeg = FlightPlan.createLeg({
            type: LegType.TF,
            fixIcao: `S${ICAO.getIdent(airport.icao).padStart(4, ' ')}${runwayCode}${runwayLetter}${finalLegIdent}`,
            course: runway.course,
            fixTypeFlags: FixTypeFlags.FAF,
            lat: fafLatLon.lat,
            lon: fafLatLon.lon,
            altDesc: AltitudeRestrictionType.AtOrAbove,
            altitude1: runway.elevation + 110,
        });
        const runwayLeg = FmsUtils.buildRunwayLeg(airport, runway, false);
        runwayLeg.fixTypeFlags = FixTypeFlags.MAP;
        const finalLegs = [];
        finalLegs.push(iafLeg);
        finalLegs.push(fafLeg);
        finalLegs.push(runwayLeg);
        const missedLegLatLon = FmsUtils.tempGeoPoint
            .set(runway.latitude, runway.longitude)
            .offset(NavMath.normalizeHeading(runway.course), UnitType.NMILE.convertTo(5, UnitType.GA_RADIAN));
        const missedLeg = FlightPlan.createLeg({
            type: LegType.TF,
            fixIcao: `S${ICAO.getIdent(airport.icao).padStart(4, ' ')}${runwayCode}${runwayLetter}MANSEQ`,
            lat: missedLegLatLon.lat,
            lon: missedLegLatLon.lon,
        });
        const missedLegs = [];
        missedLegs.push(missedLeg);
        const proc = {
            name: name !== null && name !== void 0 ? name : `Visual RW${runway.designation}`,
            runway: runway.designation,
            icaos: [],
            transitions: [],
            finalLegs: finalLegs,
            missedLegs: missedLegs,
            approachType: AdditionalApproachType.APPROACH_TYPE_VISUAL,
            approachSuffix: '',
            runwayDesignator: runway.runwayDesignator,
            runwayNumber: runway.direction,
            rnavTypeFlags: RnavTypeFlags.None
        };
        return proc;
    }
    /**
     * Utility method to return all offset transitions from a transition.
     * @param approach is the facility approach
     * @param transitionIndex is the transition index to search.
     * @returns an array of TransitionListItems
     */
    static getOffsetTransitions(approach, transitionIndex) {
        const outputTransitions = [];
        const transition = approach.transitions[transitionIndex];
        outputTransitions.push({ name: ICAO.getIdent(transition.legs[0].fixIcao), transitionIndex: transitionIndex });
        for (let j = 1; j < transition.legs.length; j++) {
            const leg = transition.legs[j];
            if (leg.fixTypeFlags === FixTypeFlags.IAF) {
                const offsetTrans = { name: ICAO.getIdent(leg.fixIcao) + ' iaf', transitionIndex: transitionIndex, startIndex: j };
                outputTransitions.push(offsetTrans);
            }
        }
        return outputTransitions;
    }
    /**
     * Utility method to return a single RnavTypeFlag from multiple possible flags.
     * @param rnavTypeFlags The input RnavTypeFlags.
     * @returns A single RnavTypeFlag
     */
    static getBestRnavType(rnavTypeFlags) {
        if (rnavTypeFlags & RnavTypeFlags.LPV) {
            return RnavTypeFlags.LPV;
        }
        if (rnavTypeFlags & RnavTypeFlags.LNAVVNAV) {
            return RnavTypeFlags.LNAVVNAV;
        }
        if (rnavTypeFlags & RnavTypeFlags.LP) {
            return RnavTypeFlags.LP;
        }
        if (rnavTypeFlags & RnavTypeFlags.LNAV) {
            return RnavTypeFlags.LNAV;
        }
        return RnavTypeFlags.None;
    }
    /**
     * Utility method to check whether an approach is authorized for GPS guidance.
     * @param approach The approach procedure
     * @returns True if GPS guidance is authorized, false otherwise.
     */
    static isGpsApproach(approach) {
        switch (approach.approachType) {
            case ApproachType.APPROACH_TYPE_GPS:
            case ApproachType.APPROACH_TYPE_RNAV:
                return true;
        }
        return false;
    }
    /**
     * Utility method to check for an approach with a a tunable localizer.
     * @param approach The approach procedure
     * @returns True if a localizer needs to be tuned, otherwise false.
     */
    static isLocalizerApproach(approach) {
        switch (approach.approachType) {
            case ApproachType.APPROACH_TYPE_ILS:
            case ApproachType.APPROACH_TYPE_LDA:
            case ApproachType.APPROACH_TYPE_LOCALIZER:
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
            case ApproachType.APPROACH_TYPE_SDF:
                return true;
        }
        return false;
    }
    /**
     * Gets an approach procedure from a flight plan.
     * @param plan A flight plan.
     * @param destination The detsination airport of the flight plan.
     * @returns The approach procedure from the flight plan, or undefined if the plan has no approach.
     */
    static getApproachFromPlan(plan, destination) {
        let approach = destination.approaches[plan.procedureDetails.approachIndex];
        if (!approach) {
            const visualRwyDesignation = plan.getUserData('visual_approach');
            if (visualRwyDesignation && plan.destinationAirport) {
                const runway = RunwayUtils.matchOneWayRunwayFromDesignation(destination, visualRwyDesignation);
                if (runway) {
                    approach = {
                        name: `VISUAL ${visualRwyDesignation}`,
                        runway: runway.designation,
                        icaos: [],
                        transitions: [],
                        finalLegs: [],
                        missedLegs: [],
                        approachType: AdditionalApproachType.APPROACH_TYPE_VISUAL,
                        approachSuffix: '',
                        runwayDesignator: runway.runwayDesignator,
                        runwayNumber: runway.direction,
                        rnavTypeFlags: RnavTypeFlags.None
                    };
                }
            }
        }
        return approach;
    }
    /**
     * Gets the name of a departure procedure as a string.
     * @param airport The airport to which the departure belongs.
     * @param departure A departure procedure definition.
     * @param transitionIndex The index of the departure enroute transition.
     * @param runway The runway of the departure, if any.
     * @returns The name of the departure procedure.
     */
    static getDepartureNameAsString(airport, departure, transitionIndex, runway) {
        let name = `${ICAO.getIdent(airport.icao)}–`;
        if (runway) {
            name += `RW${runway.designation}.`;
        }
        const transition = departure.enRouteTransitions[transitionIndex];
        if (transition !== undefined && transitionIndex > -1 && transition.legs.length > 0) {
            name += `${departure.name}.${ICAO.getIdent(transition.legs[transition.legs.length - 1].fixIcao)}`;
        }
        else if (departure.commonLegs.length > 0) {
            name += `${departure.name}.${ICAO.getIdent(departure.commonLegs[departure.commonLegs.length - 1].fixIcao)}`;
        }
        else {
            name += `${departure.name}`;
        }
        return name;
    }
    /**
     * Gets the name of a arrival procedure as a string.
     * @param airport The airport to which the departure belongs.
     * @param arrival An arrival procedure definition.
     * @param transitionIndex The index of the arrival enroute transition.
     * @param runway The runway of the arrival, if any.
     * @returns The name of the arrival procedure.
     */
    static getArrivalNameAsString(airport, arrival, transitionIndex, runway) {
        let name = `${ICAO.getIdent(airport.icao)}–`;
        const transition = arrival.enRouteTransitions[transitionIndex];
        if (transition !== undefined && transitionIndex > -1 && transition.legs.length > 0) {
            name += `${ICAO.getIdent(transition.legs[0].fixIcao)}.${arrival === null || arrival === void 0 ? void 0 : arrival.name}`;
        }
        else if (arrival.commonLegs.length > 0) {
            name += `${ICAO.getIdent(arrival.commonLegs[0].fixIcao)}.${arrival === null || arrival === void 0 ? void 0 : arrival.name}`;
        }
        else {
            name += `${arrival === null || arrival === void 0 ? void 0 : arrival.name}`;
        }
        if (runway) {
            name += `.RW${runway.designation}`;
        }
        return name;
    }
    /**
     * Utility method to analyze an approach for its name components and
     * pack them into a custom type.
     * @param proc The approach procedure.
     * @returns The name as an ApproachNameParts
     */
    static getApproachNameAsParts(proc) {
        let type;
        let subtype;
        let rnavType;
        switch (proc.approachType) {
            case ApproachType.APPROACH_TYPE_GPS:
                type = 'GPS';
                break;
            case ApproachType.APPROACH_TYPE_VOR:
                type = 'VOR';
                break;
            case ApproachType.APPROACH_TYPE_NDB:
                type = 'NDB';
                break;
            case ApproachType.APPROACH_TYPE_ILS:
                type = 'ILS';
                break;
            case ApproachType.APPROACH_TYPE_LOCALIZER:
                type = 'LOC';
                break;
            case ApproachType.APPROACH_TYPE_SDF:
                type = 'SDF';
                break;
            case ApproachType.APPROACH_TYPE_LDA:
                type = 'LDA';
                break;
            case ApproachType.APPROACH_TYPE_VORDME:
                type = 'VOR/DME';
                break;
            case ApproachType.APPROACH_TYPE_NDBDME:
                type = 'NDB/DME';
                break;
            case ApproachType.APPROACH_TYPE_RNAV:
                type = 'RNAV';
                subtype = 'GPS';
                break;
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
                type = 'LOC BC';
                break;
            case AdditionalApproachType.APPROACH_TYPE_VISUAL:
                type = 'VISUAL';
                break;
            default:
                type = '???';
                break;
        }
        if (proc.approachType === ApproachType.APPROACH_TYPE_RNAV) {
            switch (FmsUtils.getBestRnavType(proc.rnavTypeFlags)) {
                case RnavTypeFlags.LNAV:
                    rnavType = 'LNAV+V';
                    break;
                case RnavTypeFlags.LP:
                    rnavType = 'LP+V';
                    break;
                case RnavTypeFlags.LNAVVNAV:
                    rnavType = 'LNAV/VNAV';
                    break;
                case RnavTypeFlags.LPV:
                    rnavType = 'LPV';
                    break;
            }
        }
        return {
            type: type,
            subtype: subtype,
            suffix: proc.approachSuffix ? proc.approachSuffix : undefined,
            runway: proc.runwayNumber === 0 ? undefined : RunwayUtils.getRunwayNameString(proc.runwayNumber, proc.runwayDesignator, true),
            flags: rnavType
        };
    }
    /**
     * Utility method that takes an approach and returns its name as a flat
     * string suitable for use in embedded text content.
     * @param approach The approach as an ApproaceProcedure
     * @returns The formatted name as a string.
     */
    static getApproachNameAsString(approach) {
        const parts = FmsUtils.getApproachNameAsParts(approach);
        let name = parts.type;
        parts.subtype && (name += `${parts.subtype}`);
        parts.suffix && (name += `${parts.runway ? ' ' : '–'}${parts.suffix}`);
        parts.runway && (name += ` ${parts.runway}`);
        parts.flags && (name += ` ${parts.flags}`);
        return name;
    }
    /**
     * Gets an approach frequency from the facility record.
     * @param facility The airport facility.
     * @param approachIndex The approach Index.
     * @returns The FacilityFrequency or undefined
     */
    static getApproachFrequency(facility, approachIndex) {
        const approach = facility === null || facility === void 0 ? void 0 : facility.approaches[approachIndex !== null && approachIndex !== void 0 ? approachIndex : -1];
        if (approach && (approach.approachType === ApproachType.APPROACH_TYPE_ILS
            || approach.approachType === ApproachType.APPROACH_TYPE_LOCALIZER
            || approach.approachType === ApproachType.APPROACH_TYPE_LDA
            || approach.approachType === ApproachType.APPROACH_TYPE_SDF)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const freq = RunwayUtils.getLocFrequency(facility, approach.runway);
            return freq;
        }
        else {
            return undefined;
        }
    }
}
FmsUtils.tempGeoPoint = new GeoPoint(0, 0);

var DirectToState;
(function (DirectToState) {
    DirectToState[DirectToState["NONE"] = 0] = "NONE";
    DirectToState[DirectToState["TOEXISTING"] = 1] = "TOEXISTING";
    DirectToState[DirectToState["TORANDOM"] = 2] = "TORANDOM";
})(DirectToState || (DirectToState = {}));
var ProcedureType;
(function (ProcedureType) {
    ProcedureType[ProcedureType["DEPARTURE"] = 0] = "DEPARTURE";
    ProcedureType[ProcedureType["ARRIVAL"] = 1] = "ARRIVAL";
    ProcedureType[ProcedureType["APPROACH"] = 2] = "APPROACH";
    ProcedureType[ProcedureType["VISUALAPPROACH"] = 3] = "VISUALAPPROACH";
})(ProcedureType || (ProcedureType = {}));
var AirwayLegType;
(function (AirwayLegType) {
    AirwayLegType[AirwayLegType["NONE"] = 0] = "NONE";
    AirwayLegType[AirwayLegType["ENTRY"] = 1] = "ENTRY";
    AirwayLegType[AirwayLegType["EXIT"] = 2] = "EXIT";
    AirwayLegType[AirwayLegType["ONROUTE"] = 3] = "ONROUTE";
    AirwayLegType[AirwayLegType["EXIT_ENTRY"] = 4] = "EXIT_ENTRY";
})(AirwayLegType || (AirwayLegType = {}));
/**
 * A fms menu system tracker.
 */
class Fms {
    /**
     * Initialize an instance of the FMS.
     * @param bus is the event bus
     * @param flightPlanner is the flight planner
     * @param viewService the popout menu service
     * @param g1000EvtPub is the G1000 Control Publisher
     * @param autopilot is the optional autopilot.
     */
    constructor(bus, flightPlanner, viewService, g1000EvtPub, autopilot) {
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.autopilot = autopilot;
        this.ppos = new GeoPoint(0, 0);
        this.facRepo = FacilityRespository.getRepository(this.bus);
        this.facLoader = new FacilityLoader(this.facRepo);
        this.calculator = new FlightPathCalculator(this.facLoader, { defaultClimbRate: 300, defaultSpeed: 85, bankAngle: 15 });
        this.approachDetails = {
            approachLoaded: false,
            approachType: ApproachType.APPROACH_TYPE_UNKNOWN,
            approachRnavType: RnavTypeFlags.None,
            approachIsActive: false
        };
        this.approachFrequency = Subject.create(undefined);
        this._lastApproachFrequencyEventValue = undefined;
        this.cdiSource = { type: NavSourceType.Gps, index: 1 };
        this.missedApproachActive = false;
        /**
         * Sets the approach details when an approach_details_set event is received from the bus.
         * @param approachDetails The approachDetails received from the bus.
         */
        this.onApproachDetailsSet = (approachDetails) => {
            if (approachDetails !== this.approachDetails) {
                this.approachDetails = approachDetails;
            }
        };
        if (viewService) {
            Fms.viewService = viewService;
        }
        if (g1000EvtPub) {
            Fms.g1000EvtPub = g1000EvtPub;
        }
        this.bus.getSubscriber().on('gps-position').atFrequency(1).handle(pos => this.ppos.set(pos.lat, pos.long));
        this.bus.getSubscriber().on('cdi_select').handle(source => this.cdiSource = source);
        const planEvents = this.bus.getSubscriber();
        planEvents.on('fplActiveLegChange').handle(data => this.onActiveLegChanged(data.type, data.planIndex));
        planEvents.on('fplLoaded').handle(() => this.checkApproachState());
        this.approachFrequency.sub((v) => {
            if (v !== this._lastApproachFrequencyEventValue) {
                g1000EvtPub.publishEvent('approach_freq_set', v);
            }
        });
        const g1000Events = this.bus.getSubscriber();
        g1000Events.on('approach_freq_set').handle((v) => {
            this._lastApproachFrequencyEventValue = v;
            this.approachFrequency.set(v);
        });
        g1000Events.on('activate_missed_approach').handle(v => {
            this.missedApproachActive = v;
            if (this.missedApproachActive) {
                Fms.g1000EvtPub.publishEvent('suspend', false);
                this.setApproachDetails(undefined, undefined, undefined, false);
            }
        });
        g1000Events.on('approach_details_set').handle(this.onApproachDetailsSet);
    }
    /**
     * Initializes the primary flight plan. Does nothing if the primary flight plan already exists.
     */
    async initPrimaryFlightPlan() {
        if (this.flightPlanner.hasFlightPlan(Fms.PRIMARY_PLAN_INDEX)) {
            return;
        }
        this.flightPlanner.createFlightPlan(Fms.PRIMARY_PLAN_INDEX);
        await this.emptyPrimaryFlightPlan();
    }
    /**
     * Gets a specified flightplan, or by default the primary flight plan.
     * @param index The index of the flight plan.
     * @returns the requested flight plan
     * @throws Error if no flight plan exists at the specified index.
     */
    getFlightPlan(index = Fms.PRIMARY_PLAN_INDEX) {
        return this.flightPlanner.getFlightPlan(index);
    }
    /**
     * Checks whether the primary flight plan exists.
     * @returns Whether the primary flight plan exists.
     */
    hasPrimaryFlightPlan() {
        return this.flightPlanner.hasFlightPlan(Fms.PRIMARY_PLAN_INDEX);
    }
    /**
     * Gets the primary flight plan.
     * @returns The primary flight plan.
     * @throws Error if the primary flight plan does not exist.
     */
    getPrimaryFlightPlan() {
        return this.flightPlanner.getFlightPlan(Fms.PRIMARY_PLAN_INDEX);
    }
    /**
     * Checks whether the Direct To Random flight plan exists.
     * @returns Whether the Direct To Random flight plan exists.
     */
    hasDirectToFlightPlan() {
        return this.flightPlanner.hasFlightPlan(Fms.DTO_RANDOM_PLAN_INDEX);
    }
    /**
     * Gets the Direct To Random flight plan.
     * @returns The Direct To Random flight plan.
     * @throws Error if the Direct To Random flight plan does not exist.
     */
    getDirectToFlightPlan() {
        return this.flightPlanner.getFlightPlan(Fms.DTO_RANDOM_PLAN_INDEX);
    }
    /**
     * Gets the procedure preview flight plan.
     * @returns The procedure preview flight plan.
     * @throws Error if the procedure preview flight plan does not exist.
     */
    getProcPreviewFlightPlan() {
        return this.flightPlanner.getFlightPlan(Fms.PROC_PREVIEW_PLAN_INDEX);
    }
    /**
     * Handles when a flight plan active leg changes.
     * @param legType The type of flight plan active leg change.
     * @param planIndex The index of the plan whose active leg changed.
     */
    onActiveLegChanged(legType, planIndex) {
        if (legType === ActiveLegType.Lateral && planIndex === 0) {
            const activePlan = this.flightPlanner.getActiveFlightPlan();
            if (activePlan.length > 0 && !this.missedApproachActive) {
                const activeSegment = activePlan.getSegment(activePlan.getSegmentIndex(Math.max(0, activePlan.activeLateralLeg)));
                if (activeSegment.segmentType === FlightPlanSegmentType.Approach && activePlan.activeLateralLeg - activeSegment.offset > 0) {
                    this.setApproachDetails(undefined, undefined, undefined, true);
                }
                else {
                    this.setApproachDetails(undefined, undefined, undefined, false);
                }
            }
            else {
                this.setApproachDetails(undefined, undefined, undefined, false);
            }
            if (!this.missedApproachActive && activePlan.activeLateralLeg < activePlan.length - 1 && activePlan.getLeg(activePlan.activeLateralLeg).isInMissedApproachSequence) {
                Fms.g1000EvtPub.publishEvent('activate_missed_approach', true);
            }
        }
    }
    /**
     * A method to check the current approach state.
     */
    async checkApproachState() {
        const plan = this.getFlightPlan();
        let approachLoaded = false;
        let approachIsActive = false;
        let approachType;
        let approachRnavType;
        if (plan.destinationAirport && (plan.procedureDetails.approachIndex > -1 || plan.getUserData('visual_approach') !== undefined)) {
            approachLoaded = true;
            if (plan.length > 0 && plan.activeLateralLeg < plan.length && plan.activeLateralLeg > 0) {
                const segment = plan.getSegment(plan.getSegmentIndex(plan.activeLateralLeg));
                approachIsActive = segment.segmentType === FlightPlanSegmentType.Approach;
            }
            if (plan.procedureDetails.approachIndex > -1) {
                const facility = await this.facLoader.getFacility(FacilityType.Airport, plan.destinationAirport);
                const approach = facility.approaches[plan.procedureDetails.approachIndex];
                if (approach) {
                    approachType = approach.approachType;
                    approachRnavType = FmsUtils.getBestRnavType(approach.rnavTypeFlags);
                }
            }
            else {
                approachType = AdditionalApproachType.APPROACH_TYPE_VISUAL;
                approachRnavType = RnavTypeFlags.None;
            }
        }
        this.setApproachDetails(approachLoaded, approachType, approachRnavType, approachIsActive);
    }
    /**
     * Removes the direct to existing legs from the primary flight plan. If a direct to existing is currently active,
     * this will effectively cancel it.
     * @param lateralLegIndex The index of the leg to set as the active lateral leg after the removal operation. Defaults
     * to the index of the current active primary flight plan leg.
     */
    removeDirectToExisting(lateralLegIndex) {
        const plan = this.getFlightPlan();
        const directToData = plan.directToData;
        if (directToData && directToData.segmentIndex > -1) {
            plan.removeLeg(directToData.segmentIndex, directToData.segmentLegIndex + 1, true);
            plan.removeLeg(directToData.segmentIndex, directToData.segmentLegIndex + 1, true);
            plan.removeLeg(directToData.segmentIndex, directToData.segmentLegIndex + 1, true);
            const activateIndex = lateralLegIndex !== null && lateralLegIndex !== void 0 ? lateralLegIndex : plan.activeLateralLeg;
            const adjustedActivateIndex = activateIndex - Utils.Clamp(activateIndex - (plan.getSegment(directToData.segmentIndex).offset + directToData.segmentLegIndex), 0, 3);
            plan.setDirectToData(-1, true);
            plan.setLateralLeg(adjustedActivateIndex);
            plan.calculate(Math.min(0, plan.activeLateralLeg));
        }
    }
    /**
     * Checks whether a leg in the primary flight plan is a valid direct to target.
     * @param segmentIndex The index of the segment in which the leg resides.
     * @param segmentLegIndex The index of the leg in its segment.
     * @returns Whether the leg is a valid direct to target.
     */
    canDirectTo(segmentIndex, segmentLegIndex) {
        const plan = this.getFlightPlan();
        const segment = plan.getSegment(segmentIndex);
        const leg = segment.legs[segmentLegIndex];
        if (leg.leg.fixIcao === '' || leg.leg.fixIcao === ICAO.emptyIcao) {
            return false;
        }
        switch (leg.leg.type) {
            case LegType.IF:
            case LegType.TF:
            case LegType.DF:
            case LegType.CF:
            case LegType.AF:
            case LegType.RF:
                return true;
        }
        return false;
    }
    /**
     * Gets the current Direct To State.
     * @returns the DirectToState.
     */
    getDirectToState() {
        if (this.flightPlanner.activePlanIndex == 1 && this.getFlightPlan(1).getSegment(0).segmentType === FlightPlanSegmentType.RandomDirectTo) {
            return DirectToState.TORANDOM;
        }
        else {
            const plan = this.getFlightPlan();
            const directDataExists = plan.directToData.segmentIndex > -1 && plan.directToData.segmentLegIndex > -1;
            if (directDataExists && plan.segmentCount >= plan.directToData.segmentIndex
                && plan.getLegIndexFromLeg(plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex]) === plan.activeLateralLeg - 3) {
                return DirectToState.TOEXISTING;
            }
        }
        return DirectToState.NONE;
    }
    /**
     * Gets the ICAO string of the current Direct To target.
     * @returns The ICAO string of the current Direct To target, or undefined if Direct To is not active.
     */
    getDirectToTargetIcao() {
        var _a;
        return (_a = this.getDirectToLeg()) === null || _a === void 0 ? void 0 : _a.fixIcao;
    }
    /**
     * Gets the current DTO Target Flight Plan Leg.
     * @returns the FlightPlanLeg.
     */
    getDirectToLeg() {
        switch (this.getDirectToState()) {
            case DirectToState.TORANDOM: {
                const plan = this.getDirectToFlightPlan();
                return plan.getSegment(0).legs[2].leg;
            }
            case DirectToState.TOEXISTING: {
                const plan = this.getFlightPlan();
                return plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex + 3].leg;
            }
        }
        return undefined;
    }
    /**
     * Checks if a segment is the first enroute segment that is not an airway.
     * @param segmentIndex is the segment index of the segment to check
     * @returns whether or not the segment is the first enroute segment that is not an airway.
     */
    isFirstEnrouteSegment(segmentIndex) {
        const plan = this.getFlightPlan();
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            if (segment.segmentType === FlightPlanSegmentType.Enroute && !segment.airway) {
                return i === segmentIndex;
            }
        }
        return false;
    }
    /**
     * Adds a user facility.
     * @param userFacility the facility to add.
     */
    addUserFacility(userFacility) {
        this.facRepo.add(userFacility);
    }
    /**
     * Removes a user facility.
     * @param userFacility the facility to remove.
     */
    removeUserFacility(userFacility) {
        this.facRepo.remove(userFacility);
    }
    /**
     * Adds a visual or runway facility from the FlightPlanLeg.
     * @param leg the leg to build the facility from.
     * @param visualRunwayDesignation is the visual runway this facility belongs to.
     */
    addVisualFacilityFromLeg(leg, visualRunwayDesignation) {
        const fac = {
            icao: leg.fixIcao,
            lat: leg.lat !== undefined ? leg.lat : 0,
            lon: leg.lon !== undefined ? leg.lon : 0,
            approach: `VISUAL ${visualRunwayDesignation}`,
            city: '',
            name: `${visualRunwayDesignation} - ${ICAO.getIdent(leg.fixIcao)}`,
            region: '',
            magvar: 0
        };
        this.facRepo.add(fac);
    }
    /**
     * Method to insert a waypoint to the flightplan.
     * @param segmentIndex is index of the segment to add the waypoint to
     * @param facility is the new facility to add a leg to.
     * @param legIndex is the index to insert the waypoint (if none, append)
     * @returns whether the waypoint was successfully inserted.
     */
    insertWaypoint(segmentIndex, facility, legIndex) {
        var _a;
        const leg = FlightPlan.createLeg({
            type: LegType.TF,
            fixIcao: facility.icao
        });
        const plan = this.getFlightPlan();
        const segment = plan.getSegment(segmentIndex);
        const prevLeg = plan.getPrevLeg(segmentIndex, legIndex !== null && legIndex !== void 0 ? legIndex : Infinity);
        const nextLeg = plan.getNextLeg(segmentIndex, legIndex === undefined ? Infinity : legIndex - 1);
        // Make sure we are not inserting a duplicate leg
        if ((prevLeg && this.isDuplicateLeg(prevLeg.leg, leg)) || (nextLeg && this.isDuplicateLeg(leg, nextLeg.leg))) {
            return false;
        }
        // Deal with whether this insert is in an airway segment
        if (segment.airway) {
            //check to see if this insert will leave more than 1 airway leg
            if (!legIndex || segment.legs.length - legIndex < 3) {
                // we don't need another airway segment,
                // we just need to add the inserted segment, the remaining airway segments into the next enroute segment
                const nextSegment = plan.getSegment(segmentIndex + 1);
                if (nextSegment.airway || nextSegment.segmentType !== FlightPlanSegmentType.Enroute) {
                    //the next segment is an airway, arrival, approach or destination, so we need to add an enroute segment
                    this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                }
                //now we can add the new leg into the next enroute segment
                this.planAddLeg(segmentIndex + 1, leg);
                //get the legs after the insert index from the first airway segment, if any, and move them to the second airway segment
                legIndex = legIndex ? legIndex : segment.legs.length - 1;
                const legsToMove = [];
                const legsLength = segment.legs.length;
                for (let i = legIndex; i < legsLength; i++) {
                    legsToMove.push(segment.legs[i].leg);
                }
                for (let j = legsLength - 1; j >= legIndex; j--) {
                    this.planRemoveLeg(segmentIndex, j, true, true);
                }
                for (let k = 0; k < legsToMove.length; k++) {
                    this.planAddLeg(segmentIndex + 1, legsToMove[k]);
                }
            }
            else {
                //we need to create a new airway segment
                //split the segment into three
                this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                const newAirwaySegment = plan.getSegment(segmentIndex + 2);
                //add the leg to the new enroute segment (between the old and new airway segments)
                this.planAddLeg(segmentIndex + 1, leg);
                //get the legs after the insert index from the first airway segment, if any, and move them to the second airway segment
                legIndex = legIndex ? legIndex : segment.legs.length - 1;
                const legsToMove = [];
                const legsLength = segment.legs.length;
                for (let i = legIndex; i < legsLength; i++) {
                    legsToMove.push(segment.legs[i].leg);
                }
                for (let j = legsLength - 1; j >= legIndex; j--) {
                    this.planRemoveLeg(segmentIndex, j, true, true);
                }
                this.planAddLeg(segmentIndex + 1, legsToMove[0]);
                for (let k = 1; k < legsToMove.length; k++) {
                    this.planAddLeg(segmentIndex + 2, legsToMove[k]);
                }
                const airway = (_a = segment.airway) === null || _a === void 0 ? void 0 : _a.split('.');
                segment.airway = airway && airway[0] ? airway[0] + '.' + segment.legs[legIndex - 1].name : segment.airway;
                plan.setAirway(segmentIndex, segment.airway);
                newAirwaySegment.airway = airway && airway[0] ? airway[0] + '.' + newAirwaySegment.legs[newAirwaySegment.legs.length - 1].name : segment.airway;
                plan.setAirway(segmentIndex + 2, newAirwaySegment.airway);
            }
            return true;
        }
        this.planAddLeg(segmentIndex, leg, legIndex);
        return true;
    }
    /**
     * Method to delete a waypoint from the flightplan.
     * @param segmentIndex is the index of the segment containing the leg to delete.
     * @param legIndex is the index of the leg to delete in the segment.
     * @returns whether the waypoint was successfully deleted.
     */
    deleteWaypoint(segmentIndex, legIndex) {
        return this.planRemoveLeg(segmentIndex, legIndex);
    }
    /**
     * Gets the airway leg type of a flight plan leg.
     * @param plan The flight plan containing the query leg.
     * @param segmentIndex The index of the flight plan segment containing the query leg.
     * @param segmentLegIndex The index of the query leg in its segment.
     * @returns The airway leg type of the query leg.
     */
    getAirwayLegType(plan, segmentIndex, segmentLegIndex) {
        const segment = plan.getSegment(segmentIndex);
        const segmentIsAirway = segment.airway !== undefined;
        const nextSegmentIsAirway = segmentIndex + 1 < plan.segmentCount && plan.getSegment(segmentIndex + 1).airway !== undefined;
        const legIsLast = segmentLegIndex == segment.legs.length - 1;
        if ((segmentIsAirway && legIsLast && nextSegmentIsAirway)) {
            return AirwayLegType.EXIT_ENTRY;
        }
        if ((legIsLast && nextSegmentIsAirway)) {
            return AirwayLegType.ENTRY;
        }
        if (segmentIsAirway) {
            if (legIsLast) {
                return AirwayLegType.EXIT;
            }
            return AirwayLegType.ONROUTE;
        }
        return AirwayLegType.NONE;
    }
    /**
     * Method to get the distance of an airway segment.
     * @param segmentIndex is the index of the segment of the airway.
     * @returns the cumulative distance for the airway segment.
     */
    getAirwayDistance(segmentIndex) {
        var _a, _b, _c, _d;
        const plan = this.getFlightPlan();
        const segment = plan.getSegment(segmentIndex);
        const entrySegment = plan.getSegment(segmentIndex - 1);
        const entryCumulativeDistance = (_b = (_a = entrySegment.legs[entrySegment.legs.length - 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistance;
        const exitCumulativeDistance = (_d = (_c = segment.legs[segment.legs.length - 1]) === null || _c === void 0 ? void 0 : _c.calculated) === null || _d === void 0 ? void 0 : _d.cumulativeDistance;
        return exitCumulativeDistance && entryCumulativeDistance ? exitCumulativeDistance - entryCumulativeDistance : -1;
    }
    /**
     * Method to add a new origin airport and runway to the flight plan.
     * @param airport is the facility of the origin airport.
     * @param runway is the onewayrunway
     */
    setOrigin(airport, runway) {
        const plan = this.getFlightPlan();
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Departure);
        if (airport) {
            plan.setOriginAirport(airport.icao);
            plan.setOriginRunway(runway);
            this.planClearSegment(segmentIndex, FlightPlanSegmentType.Departure);
            this.planAddOriginDestinationLeg(true, segmentIndex, airport, runway);
            const prevLeg = plan.getPrevLeg(segmentIndex, 1);
            const nextLeg = plan.getNextLeg(segmentIndex, 0);
            if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
                this.planRemoveDuplicateLeg(prevLeg, nextLeg);
            }
        }
        else {
            plan.removeOriginAirport();
            this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, RnavTypeFlags.None, false);
            this.planClearSegment(segmentIndex, FlightPlanSegmentType.Departure);
        }
        plan.calculate(0);
    }
    /**
     * Method to add a new destination airport and runway to the flight plan.
     * @param airport is the facility of the destination airport.
     * @param runway is the selected runway at the destination facility.
     */
    setDestination(airport, runway) {
        const plan = this.getFlightPlan();
        const destSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Destination);
        if (airport) {
            plan.setDestinationAirport(airport.icao);
            plan.setDestinationRunway(runway);
            this.planClearSegment(destSegmentIndex, FlightPlanSegmentType.Destination);
            const hasArrival = plan.procedureDetails.arrivalIndex > -1;
            const hasApproach = plan.procedureDetails.approachIndex > -1;
            if (!hasArrival && !hasApproach) {
                this.planAddOriginDestinationLeg(false, destSegmentIndex, airport, runway);
            }
        }
        else {
            plan.removeDestinationAirport();
            this.planClearSegment(destSegmentIndex, FlightPlanSegmentType.Destination);
        }
        plan.calculate(0);
    }
    /**
     * Method to remove runway or airport legs from segments where they shouldn't exist.
     */
    removeDestLegFromSegments() {
        const plan = this.getFlightPlan();
        const destination = plan.destinationAirport;
        const hasArrival = plan.procedureDetails.arrivalIndex > -1;
        const hasApproach = plan.procedureDetails.approachIndex > -1 || plan.getUserData('visual_approach');
        const destinationSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Destination);
        const destinationSegment = plan.getSegment(destinationSegmentIndex);
        if (hasApproach && destination) {
            if (hasArrival) {
                const arrivalSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Arrival);
                const arrival = plan.getSegment(arrivalSegmentIndex);
                const lastArrivalLegIcao = arrival.legs[arrival.legs.length - 1].leg.fixIcao;
                if (lastArrivalLegIcao === destination || lastArrivalLegIcao.search('R') === 0) {
                    this.planRemoveLeg(arrivalSegmentIndex, arrival.legs.length - 1);
                }
            }
            if (destinationSegment.legs.length > 0) {
                this.planClearSegment(destinationSegmentIndex, FlightPlanSegmentType.Destination);
            }
        }
        else if (hasArrival && destination) {
            if (destinationSegment.legs.length > 0) {
                this.planClearSegment(destinationSegmentIndex, FlightPlanSegmentType.Destination);
            }
        }
    }
    /**
     * Method to ensure only one segment of a specific type exists in the flight plan and optionally insert it if needed.
     * @param segmentType is the segment type we want to evaluate.
     * @param insert is whether to insert the segment if missing
     * @returns segmentIndex of the only segment of this type in the flight plan.
     */
    ensureOnlyOneSegmentOfType(segmentType, insert = true) {
        const plan = this.getFlightPlan();
        let segmentIndex;
        const selectedSegments = plan.segmentsOfType(segmentType);
        const segmentIndexArray = [];
        for (const element of selectedSegments) {
            segmentIndexArray.push(element.segmentIndex);
        }
        if (segmentIndexArray.length === 0) {
            if (insert) {
                segmentIndex = this.planInsertSegmentOfType(segmentType);
            }
            else {
                segmentIndex = -1;
            }
        }
        else if (segmentIndexArray.length > 1) {
            for (let i = 0; i < segmentIndexArray.length; i++) {
                this.planRemoveSegment(segmentIndexArray[i]);
            }
            segmentIndex = this.planInsertSegmentOfType(segmentType);
        }
        else {
            segmentIndex = segmentIndexArray[0];
        }
        return segmentIndex;
    }
    /**
     * Method to invert the flightplan.
     */
    invertFlightplan() {
        var _a;
        const plan = this.getFlightPlan();
        const activeLegIcao = plan.getLeg(plan.activeLateralLeg).leg.fixIcao;
        if (plan.directToData.segmentIndex >= 0 && plan.directToData.segmentLegIndex >= 0) {
            this.removeDirectToExisting();
        }
        if (!Simplane.getIsGrounded() && activeLegIcao) {
            this.buildRandomDirectTo(activeLegIcao);
        }
        const newOriginIcao = plan.destinationAirport;
        const newDestinationIcao = plan.originAirport;
        const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
        if (lastEnrouteSegmentIndex === 1 && plan.getSegment(1).legs.length > 0) {
            //case for when there is only 1 enroute segment and it has at least 1 waypoint, a simple reversal is all that's required.
            const segment = Object.assign({}, plan.getSegment(1));
            this.emptyPrimaryFlightPlan();
            for (let l = segment.legs.length - 1; l >= 0; l--) {
                plan.addLeg(1, segment.legs[l].leg);
            }
        }
        else if (lastEnrouteSegmentIndex > 1) {
            //case for when there is more than 1 enroute segment we know we have to deal with airways
            const legs = [];
            for (let i = 1; i <= lastEnrouteSegmentIndex; i++) {
                //create a temporary list of legs that looks like what a flight plan import looks like with ICAO and the airway
                //we fly FROM the leg on.
                const oldSegment = plan.getSegment(i);
                const airway = oldSegment.airway ? (_a = oldSegment.airway) === null || _a === void 0 ? void 0 : _a.split('.')[0] : undefined;
                for (const leg of oldSegment.legs) {
                    const legListItem = { icao: leg.leg.fixIcao, airway: airway };
                    legs.push(legListItem);
                }
            }
            //after the array of legs is complete, we just reverse it
            legs.reverse();
            this.emptyPrimaryFlightPlan();
            let currentSegment = 1;
            let lastLegWasAirway = false;
            //last we go through each leg and use the same logic we use for the flight plan import to go through each leg and create airway
            //segments as appropriate for these legs.
            for (let i = 0; i < legs.length; i++) {
                const wpt = legs[i];
                const segment = plan.getSegment(currentSegment);
                if (wpt.airway) {
                    const leg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: wpt.icao
                    });
                    plan.addLeg(currentSegment, leg);
                    if (!lastLegWasAirway) {
                        plan.insertSegment(currentSegment + 1, FlightPlanSegmentType.Enroute, wpt.airway);
                        currentSegment += 1;
                    }
                    for (let j = i + 1; j < legs.length; j++) {
                        i++;
                        const airwayLeg = FlightPlan.createLeg({
                            type: LegType.TF,
                            fixIcao: legs[j].icao
                        });
                        plan.addLeg(currentSegment, airwayLeg);
                        if (legs[j].airway !== wpt.airway) {
                            lastLegWasAirway = legs[j].airway ? true : false;
                            break;
                        }
                    }
                    plan.setAirway(currentSegment, wpt.airway + '.' + ICAO.getIdent(legs[i].icao));
                    currentSegment += 1;
                    plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute, lastLegWasAirway ? legs[i].airway : undefined);
                }
                else {
                    let leg = undefined;
                    leg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: wpt.icao
                    });
                    if (leg) {
                        plan.addLeg(currentSegment, leg);
                        if (lastLegWasAirway) {
                            plan.setAirway(currentSegment, segment.airway + '.' + ICAO.getIdent(wpt.icao));
                            currentSegment += 1;
                            plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute);
                        }
                        lastLegWasAirway = false;
                    }
                }
            }
            if (plan.getSegment(currentSegment).airway) {
                currentSegment += 1;
                plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute);
            }
        }
        else {
            this.emptyPrimaryFlightPlan();
        }
        if (newOriginIcao) {
            this.facLoader.getFacility(FacilityType.Airport, newOriginIcao).then((facility) => {
                this.setOrigin(facility);
            });
        }
        if (newDestinationIcao) {
            this.facLoader.getFacility(FacilityType.Airport, newDestinationIcao).then((facility) => {
                this.setDestination(facility);
            });
        }
        this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, RnavTypeFlags.None, false);
        plan.calculate(0);
    }
    /**
     * Method to add or replace a departure procedure in the flight plan.
     * @param facility is the facility that contains the procedure to add.
     * @param departureIndex is the index of the departure
     * @param departureRunwayIndex is the index of the runway transition
     * @param enrouteTransitionIndex is the index of the enroute transition
     * @param oneWayRunway is the one way runway to set as the origin leg.
     */
    insertDeparture(facility, departureIndex, departureRunwayIndex, enrouteTransitionIndex, oneWayRunway) {
        const plan = this.getFlightPlan();
        plan.setDeparture(facility.icao, departureIndex, enrouteTransitionIndex, departureRunwayIndex);
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Departure);
        this.planClearSegment(segmentIndex, FlightPlanSegmentType.Departure);
        const insertProcedureObject = this.buildDepartureLegs(facility, departureIndex, enrouteTransitionIndex, departureRunwayIndex, oneWayRunway);
        if (oneWayRunway) {
            plan.setOriginAirport(facility.icao);
            plan.setOriginRunway(oneWayRunway);
        }
        else if (plan.originAirport == facility.icao && plan.procedureDetails.originRunway) {
            const originLeg = FmsUtils.buildRunwayLeg(facility, plan.procedureDetails.originRunway, true);
            insertProcedureObject.procedureLegs.splice(0, 1, originLeg);
        }
        else {
            plan.setOriginAirport(facility.icao);
        }
        insertProcedureObject.procedureLegs.forEach(l => this.planAddLeg(segmentIndex, l));
        const nextLeg = plan.getNextLeg(segmentIndex, Infinity);
        const depSegment = plan.getSegment(segmentIndex);
        const lastDepLeg = depSegment.legs[depSegment.legs.length - 1];
        if (nextLeg && lastDepLeg && this.isDuplicateLeg(lastDepLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(lastDepLeg, nextLeg);
        }
        plan.calculate(0);
    }
    /**
     * Method to insert the arrival legs.
     * @param facility is the facility to build legs from.
     * @param procedureIndex is the procedure index to build legs from.
     * @param enrouteTransitionIndex is the enroute transition index to build legs from.
     * @param runwayTransitionIndex is the runway transition index to build legs from.
     * @param oneWayRunway is the one way runway, if one is specified in the procedure.
     * @returns InsertProcedureObject to insert into the flight plan.
     */
    buildDepartureLegs(facility, procedureIndex, enrouteTransitionIndex, runwayTransitionIndex, oneWayRunway) {
        const departure = facility.departures[procedureIndex];
        const enRouteTransition = departure.enRouteTransitions[enrouteTransitionIndex];
        const runwayTransition = departure.runwayTransitions[runwayTransitionIndex];
        const insertProcedureObject = { procedureLegs: [] };
        let originLeg;
        if (oneWayRunway) {
            originLeg = FmsUtils.buildRunwayLeg(facility, oneWayRunway, true);
        }
        else {
            originLeg = FlightPlan.createLeg({
                lat: facility.lat,
                lon: facility.lon,
                type: LegType.IF,
                fixIcao: facility.icao
            });
        }
        insertProcedureObject.procedureLegs.push(originLeg);
        if (runwayTransition !== undefined && runwayTransition.legs.length > 0) {
            runwayTransition.legs.forEach((leg) => {
                insertProcedureObject.procedureLegs.push(FlightPlan.createLeg(leg));
            });
        }
        for (let i = 0; i < departure.commonLegs.length; i++) {
            const leg = FlightPlan.createLeg(departure.commonLegs[i]);
            if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                    this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                continue;
            }
            insertProcedureObject.procedureLegs.push(leg);
        }
        if (enRouteTransition) {
            for (let i = 0; i < enRouteTransition.legs.length; i++) {
                const leg = FlightPlan.createLeg(enRouteTransition.legs[i]);
                if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                    this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                    insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                        this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                    continue;
                }
                insertProcedureObject.procedureLegs.push(enRouteTransition.legs[i]);
            }
        }
        return insertProcedureObject;
    }
    /**
     * Method to add or replace an arrival procedure in the flight plan.
     * @param facility is the facility that contains the procedure to add.
     * @param arrivalIndex is the index of the arrival procedure.
     * @param arrivalRunwayTransitionIndex is the index of the arrival runway transition.
     * @param enrouteTransitionIndex is the index of the enroute transition.
     * @param oneWayRunway is the one way runway to set as the destination leg.
     */
    insertArrival(facility, arrivalIndex, arrivalRunwayTransitionIndex, enrouteTransitionIndex, oneWayRunway) {
        const plan = this.getFlightPlan();
        plan.setArrival(facility.icao, arrivalIndex, enrouteTransitionIndex, arrivalRunwayTransitionIndex);
        if (plan.length > 0 && plan.procedureDetails.approachIndex < 0 && plan.destinationAirport) {
            if (!this.moveDirectToDestinationLeg(plan, FlightPlanSegmentType.Enroute)) {
                if (plan.getLeg(plan.activeLateralLeg).leg.fixIcao === plan.destinationAirport && plan.destinationAirport !== facility.icao && plan.activeLateralLeg === plan.length - 1) {
                    const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
                    const newDestinationLeg = FlightPlan.createLeg({ fixIcao: plan.destinationAirport, type: LegType.TF });
                    this.planAddLeg(lastEnrouteSegmentIndex, newDestinationLeg);
                }
            }
        }
        if (plan.procedureDetails.approachIndex < 0) {
            plan.setDestinationAirport(facility.icao);
            plan.setDestinationRunway(oneWayRunway);
        }
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Arrival);
        if (plan.getSegment(segmentIndex).legs.length > 0) {
            this.planClearSegment(segmentIndex, FlightPlanSegmentType.Arrival);
        }
        const insertProcedureObject = this.buildArrivalLegs(facility, arrivalIndex, enrouteTransitionIndex, arrivalRunwayTransitionIndex, oneWayRunway);
        let directTargetLeg;
        let handleDirectToDestination = false;
        const directToState = this.getDirectToState();
        if (plan.procedureDetails.approachIndex > -1) {
            insertProcedureObject.procedureLegs.pop();
        }
        else if (directToState === DirectToState.TOEXISTING) {
            directTargetLeg = this.getDirectToLeg();
            if ((directTargetLeg === null || directTargetLeg === void 0 ? void 0 : directTargetLeg.fixIcao) === plan.destinationAirport &&
                (directTargetLeg === null || directTargetLeg === void 0 ? void 0 : directTargetLeg.fixIcao) === insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1].fixIcao) {
                insertProcedureObject.procedureLegs.pop();
                handleDirectToDestination = true;
            }
        }
        insertProcedureObject.procedureLegs.forEach(l => this.planAddLeg(segmentIndex, l));
        const arrSegment = plan.getSegment(segmentIndex);
        const prevLeg = plan.getPrevLeg(segmentIndex, 0);
        const firstArrLeg = arrSegment.legs[0];
        if (prevLeg && firstArrLeg && this.isDuplicateLeg(prevLeg.leg, firstArrLeg.leg)) {
            this.planRemoveDuplicateLeg(prevLeg, firstArrLeg);
        }
        this.removeDestLegFromSegments();
        const nextLeg = plan.getNextLeg(segmentIndex, Infinity);
        const lastArrLeg = arrSegment.legs[arrSegment.legs.length - 1];
        if (nextLeg && lastArrLeg && this.isDuplicateLeg(lastArrLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(lastArrLeg, nextLeg);
        }
        if (handleDirectToDestination) {
            this.moveDirectToDestinationLeg(plan, FlightPlanSegmentType.Arrival, segmentIndex);
            this.activateLeg(segmentIndex, arrSegment.legs.length - 1);
        }
        else if (directToState === DirectToState.TOEXISTING && directTargetLeg && directTargetLeg.fixIcao === plan.destinationAirport) {
            this.removeDirectToExisting();
            this.buildRandomDirectTo(plan.destinationAirport);
        }
        plan.calculate(0);
    }
    /**
     * Method to insert the arrival legs.
     * @param facility is the facility to build legs from.
     * @param procedureIndex is the procedure index to build legs from.
     * @param enrouteTransitionIndex is the enroute transition index to build legs from.
     * @param runwayTransitionIndex is the runway transition index to build legs from.
     * @param oneWayRunway is the one way runway, if one is specified in the procedure.
     * @returns InsertProcedureObject to insert into the flight plan.
     */
    buildArrivalLegs(facility, procedureIndex, enrouteTransitionIndex, runwayTransitionIndex, oneWayRunway) {
        const arrival = facility.arrivals[procedureIndex];
        const enRouteTransition = arrival.enRouteTransitions[enrouteTransitionIndex];
        const runwayTransition = arrival.runwayTransitions[runwayTransitionIndex];
        const insertProcedureObject = { procedureLegs: [] };
        if (enRouteTransition !== undefined && enRouteTransition.legs.length > 0) {
            enRouteTransition.legs.forEach((leg) => {
                insertProcedureObject.procedureLegs.push(FlightPlan.createLeg(leg));
            });
        }
        for (let i = 0; i < arrival.commonLegs.length; i++) {
            const leg = FlightPlan.createLeg(arrival.commonLegs[i]);
            if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                    this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                continue;
            }
            insertProcedureObject.procedureLegs.push(leg);
        }
        if (runwayTransition) {
            for (let i = 0; i < runwayTransition.legs.length; i++) {
                const leg = FlightPlan.createLeg(runwayTransition.legs[i]);
                if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                    this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                    insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                        this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                    continue;
                }
                insertProcedureObject.procedureLegs.push(leg);
            }
        }
        const destinationLeg = oneWayRunway
            ? FmsUtils.buildRunwayLeg(facility, oneWayRunway, false)
            : FlightPlan.createLeg({
                lat: facility.lat,
                lon: facility.lon,
                type: LegType.TF,
                fixIcao: facility.icao
            });
        insertProcedureObject.procedureLegs.push(destinationLeg);
        this.tryInsertIFLeg(insertProcedureObject);
        return insertProcedureObject;
    }
    /**
     * Method to move a direct to destination to a specified target segment.
     * @param plan is the primary flight plan.
     * @param targetSegmentType is the target segment type.
     * @param arrivalSegmentIndex is the arrival segment index
     * @returns whether a direct to destination was moved.
     */
    moveDirectToDestinationLeg(plan, targetSegmentType, arrivalSegmentIndex) {
        if (this.getDirectToState() === DirectToState.TOEXISTING) {
            const directTargetSegmentIndex = targetSegmentType === FlightPlanSegmentType.Arrival ? arrivalSegmentIndex : this.findLastEnrouteSegmentIndex(plan);
            if (directTargetSegmentIndex !== undefined && directTargetSegmentIndex > 0 && plan.getLeg(plan.activeLateralLeg).leg.fixIcao === plan.destinationAirport) {
                const destinationLeg = Object.assign({}, plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex].leg);
                const directTargetLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg).leg);
                const directOriginLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg - 1).leg);
                const discoLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg - 2).leg);
                const newDirectLegIndex = plan.getSegment(directTargetSegmentIndex).legs.length;
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
                plan.setDirectToData(directTargetSegmentIndex, newDirectLegIndex);
                plan.addLeg(directTargetSegmentIndex, destinationLeg);
                plan.addLeg(directTargetSegmentIndex, discoLeg, undefined, true);
                plan.addLeg(directTargetSegmentIndex, directOriginLeg, undefined, true);
                const newActiveLeg = plan.addLeg(directTargetSegmentIndex, directTargetLeg, undefined, true);
                plan.setLateralLeg(plan.getLegIndexFromLeg(newActiveLeg));
                plan.calculate(plan.activeLateralLeg);
                return true;
            }
        }
        return false;
    }
    /**
     * Method to find the last enroute segment of the supplied flight plan.
     * @param plan is the flight plan to find the last enroute segment in.
     * @returns a segment index.
     */
    findLastEnrouteSegmentIndex(plan) {
        let enrouteSegmentFound = 0;
        for (let i = 1; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            if (segment.segmentType === FlightPlanSegmentType.Enroute) {
                enrouteSegmentFound = i;
            }
        }
        return enrouteSegmentFound;
    }
    /**
     * Method manage the destination leg in the last enroute segment.
     * @param plan is the flight plan.
     * @param currentDestination is the currently set destination airport icao.
     */
    manageAirportLeg(plan, currentDestination) {
        if (plan.procedureDetails.arrivalIndex > -1 || !currentDestination || Simplane.getIsGrounded()) {
            //if we don't have a destination set, or an arrival is selected, don't add the airport to enroute
            return;
        }
        const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
        const segment = plan.getSegment(lastEnrouteSegmentIndex);
        const lastLegIndex = segment.legs.length - 1;
        if (currentDestination && (lastLegIndex < 0 || segment.legs[lastLegIndex].leg.fixIcao !== currentDestination)) {
            //if a destination is set, AND either (a) the last enroute segment is empty OR (b) the last enroute segment isn't empty and
            //the last leg of the last enroute segment is not already the current destination
            this.planAddLeg(lastEnrouteSegmentIndex, FlightPlan.createLeg({ fixIcao: currentDestination, type: LegType.TF }));
        }
    }
    /**
     * Method to check whether an approach can load, or only activate.
     * @returns true if the approach can be loaded and not activated, otherwise the approach can only be immediatly activated.
     */
    canApproachLoad() {
        const plan = this.getFlightPlan();
        if (plan.length > 0) {
            const activeSegment = plan.getSegment(plan.getSegmentIndex(plan.activeLateralLeg));
            if (activeSegment.segmentType !== FlightPlanSegmentType.Approach && plan.length > 1) {
                return true;
            }
        }
        return false;
    }
    /**
     * Method to add or replace an approach procedure in the flight plan.
     * @param facility is the facility that contains the procedure to add.
     * @param approachIndex is the index of the approach procedure.
     * @param approachTransitionIndex is the index of the approach transition.
     * @param visualRunwayNumber is the visual runway number, if any.
     * @param visualRunwayDesignator is the visual runway designator, if any.
     * @param transStartIndex is the starting leg index for the transition, if any.
     * @param skipCourseReversal Whether to skip the course reversal.
     */
    insertApproach(facility, approachIndex, approachTransitionIndex, visualRunwayNumber, visualRunwayDesignator, transStartIndex, skipCourseReversal) {
        var _a, _b;
        const plan = this.getFlightPlan();
        let visualRunway;
        if (visualRunwayNumber !== undefined && visualRunwayDesignator !== undefined) {
            visualRunway = RunwayUtils.matchOneWayRunway(facility, visualRunwayNumber, visualRunwayDesignator);
            plan.setUserData('visual_approach', `${visualRunway === null || visualRunway === void 0 ? void 0 : visualRunway.designation}`);
        }
        if (!visualRunway && plan.getUserData('visual_approach')) {
            plan.deleteUserData('visual_approach');
        }
        plan.setApproach(facility.icao, approachIndex, approachTransitionIndex);
        if (plan.procedureDetails.arrivalIndex < 0) {
            if (!this.moveDirectToDestinationLeg(plan, FlightPlanSegmentType.Enroute)) {
                this.manageAirportLeg(plan, plan.destinationAirport);
            }
        }
        plan.setDestinationAirport(facility.icao);
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Approach);
        if (plan.getSegment(segmentIndex).legs.length > 0) {
            this.planClearSegment(segmentIndex, FlightPlanSegmentType.Approach);
        }
        const insertProcedureObject = this.buildApproachLegs(facility, approachIndex, approachTransitionIndex, visualRunway, transStartIndex, skipCourseReversal);
        if (insertProcedureObject.runway) {
            plan.setDestinationRunway(insertProcedureObject.runway);
        }
        let haveAddedMap = false;
        insertProcedureObject.procedureLegs.forEach((l) => {
            let isMissedLeg = false;
            if (visualRunway !== undefined) {
                this.addVisualFacilityFromLeg(l, visualRunway.designation);
                if (haveAddedMap) {
                    isMissedLeg = true;
                }
                if (l.fixTypeFlags & FixTypeFlags.MAP) {
                    haveAddedMap = true;
                }
            }
            this.planAddLeg(segmentIndex, l, undefined, false, isMissedLeg);
        });
        let skipDestinationLegCheck = false;
        if (this.getDirectToState() === DirectToState.TOEXISTING) {
            if (((_a = this.getDirectToLeg()) === null || _a === void 0 ? void 0 : _a.fixIcao) === plan.destinationAirport) {
                skipDestinationLegCheck = true;
            }
        }
        if (!skipDestinationLegCheck) {
            this.removeDestLegFromSegments();
        }
        const prevLeg = plan.getPrevLeg(segmentIndex, 0);
        const firstAppLeg = plan.getSegment(segmentIndex).legs[0];
        if (prevLeg && firstAppLeg && this.isDuplicateLeg(prevLeg.leg, firstAppLeg.leg)) {
            this.planRemoveDuplicateLeg(prevLeg, firstAppLeg);
        }
        // Adds missed approach legs
        if (!visualRunway && insertProcedureObject.procedureLegs.length > 0) {
            const missedLegs = (_b = facility.approaches[approachIndex].missedLegs) !== null && _b !== void 0 ? _b : [];
            if (missedLegs.length > 0) {
                let maphIndex = -1;
                for (let m = missedLegs.length - 1; m >= 0; m--) {
                    switch (missedLegs[m].type) {
                        case LegType.HA:
                        case LegType.HF:
                        case LegType.HM:
                            maphIndex = m - 1;
                            break;
                    }
                }
                for (let n = 0; n < missedLegs.length; n++) {
                    const newLeg = FlightPlan.createLeg(missedLegs[n]);
                    if (maphIndex >= 0 && n === maphIndex) {
                        newLeg.fixTypeFlags |= FixTypeFlags.MAHP;
                        this.planAddLeg(segmentIndex, newLeg, undefined, false, true);
                    }
                    else {
                        this.planAddLeg(segmentIndex, newLeg, undefined, false, true);
                    }
                }
            }
        }
        const approachType = visualRunway ? AdditionalApproachType.APPROACH_TYPE_VISUAL : facility.approaches[approachIndex].approachType;
        const rnavTypeFlag = visualRunway ? RnavTypeFlags.None : FmsUtils.getBestRnavType(facility.approaches[approachIndex].rnavTypeFlags);
        this.setApproachDetails(true, approachType, rnavTypeFlag, false);
        plan.calculate();
        this.loadApproachFrequency(facility, approachIndex);
        this.setLocFrequency(1);
        this.setLocFrequency(2);
    }
    /**
     * Method to insert the approach legs.
     * @param facility The facility to build legs from.
     * @param approachIndex The approach procedure index to build legs from.
     * @param approachTransitionIndex The transition index to build legs from.
     * @param visualRunway If this is a visual approach, the visual approach one way runway object.
     * @param transStartIndex The starting leg index for the transition, if any.
     * @param skipCourseReversal Whether to skip the course reversal.
     * @returns procedurelegs array to insert into the flight plan.
     */
    buildApproachLegs(facility, approachIndex, approachTransitionIndex, visualRunway, transStartIndex, skipCourseReversal) {
        const isVisual = visualRunway ? true : false;
        const approach = isVisual && visualRunway !== undefined ? FmsUtils.buildVisualApproach(facility, visualRunway, 1, 2.5) : facility.approaches[approachIndex];
        const transition = !isVisual ? approach.transitions[approachTransitionIndex] : undefined;
        const insertProcedureObject = { procedureLegs: [] };
        if (transition !== undefined && transition.legs.length > 0) {
            const startIndex = transStartIndex !== undefined ? transStartIndex : 0;
            for (let t = startIndex; t < transition.legs.length; t++) {
                insertProcedureObject.procedureLegs.push(FlightPlan.createLeg(transition.legs[t]));
            }
        }
        const finalLegs = approach.finalLegs;
        for (let i = 0; i < finalLegs.length; i++) {
            const leg = FlightPlan.createLeg(finalLegs[i]);
            if (i === 0 && insertProcedureObject.procedureLegs.length > 0 &&
                this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                    this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                continue;
            }
            if (!isVisual && leg.fixIcao.search('R') === 0) {
                const approachRunway = RunwayUtils.matchOneWayRunway(facility, approach.runwayNumber, approach.runwayDesignator);
                if (approachRunway) {
                    insertProcedureObject.runway = approachRunway;
                    const runwayLeg = FmsUtils.buildRunwayLeg(facility, approachRunway, false);
                    insertProcedureObject.procedureLegs.push(runwayLeg);
                }
            }
            else if (isVisual && i === finalLegs.length - 1) {
                insertProcedureObject.runway = visualRunway;
                insertProcedureObject.procedureLegs.push(leg);
                if (approach.missedLegs.length > 0) {
                    insertProcedureObject.procedureLegs.push(approach.missedLegs[0]);
                }
            }
            else {
                insertProcedureObject.procedureLegs.push(leg);
            }
        }
        if (!isVisual) {
            this.tryInsertIFLeg(insertProcedureObject);
            this.tryReconcileIAFLeg(insertProcedureObject);
            this.manageVerticalAngleInfo(insertProcedureObject);
            this.tryCleanupHold(insertProcedureObject);
            if (skipCourseReversal) {
                this.tryRemoveCourseReversal(insertProcedureObject);
            }
            this.tryInsertMap(insertProcedureObject);
            if (!insertProcedureObject.runway && approach.runway) {
                insertProcedureObject.runway = RunwayUtils.matchOneWayRunway(facility, approach.runwayNumber, approach.runwayDesignator);
            }
            return insertProcedureObject;
        }
        return insertProcedureObject;
    }
    /**
     * Manages the altitude constraints for FAF legs where vertical angle info is also provided.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    manageVerticalAngleInfo(proc) {
        proc.procedureLegs.forEach(leg => {
            if (leg.fixTypeFlags === FixTypeFlags.FAF && leg.altitude2 > 0) {
                const alt = leg.altitude1 <= leg.altitude2 ? leg.altitude1 : leg.altitude2;
                leg.altDesc = AltitudeRestrictionType.AtOrAbove;
                leg.altitude1 = alt;
                leg.altitude2 = 0;
            }
        });
        return proc;
    }
    /**
     * Inserts an IF leg at the beginning of a procedure if it begins with a leg type which defines a fixed origin.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryInsertIFLeg(proc) {
        const firstLeg = proc.procedureLegs[0];
        let icao;
        switch (firstLeg === null || firstLeg === void 0 ? void 0 : firstLeg.type) {
            case LegType.HA:
            case LegType.HF:
            case LegType.HM:
            case LegType.PI:
            case LegType.FD:
            case LegType.FC:
                icao = firstLeg.fixIcao;
                break;
            case LegType.FM:
            case LegType.VM:
                icao = firstLeg.originIcao;
                break;
        }
        if (icao && icao !== ICAO.emptyIcao) {
            proc.procedureLegs.unshift(FlightPlan.createLeg({
                type: LegType.IF,
                fixIcao: icao,
                fixTypeFlags: firstLeg.fixTypeFlags & (FixTypeFlags.IF | FixTypeFlags.IAF)
            }));
            if ((firstLeg === null || firstLeg === void 0 ? void 0 : firstLeg.type) === LegType.HF || (firstLeg === null || firstLeg === void 0 ? void 0 : firstLeg.type) === LegType.PI) {
                proc.procedureLegs[0].altDesc = firstLeg.altDesc;
                proc.procedureLegs[0].altitude1 = firstLeg.altitude1;
                proc.procedureLegs[0].altitude2 = firstLeg.altitude2;
            }
            // need to remove IF/IAF flags from the original first leg (now the second leg)
            const replacementLeg = FlightPlan.createLeg(proc.procedureLegs[1]);
            replacementLeg.fixTypeFlags = replacementLeg.fixTypeFlags & ~(FixTypeFlags.IF | FixTypeFlags.IAF);
            proc.procedureLegs[1] = replacementLeg;
        }
        return proc;
    }
    /**
     * Checks the approach legs for an IAF fix type flag, and if one exists, amend the approach to ensure that
     * the IAF is not on a hold/pt leg and that we do not add legs prior to the IAF except in cases where we needed to add
     * an IF leg type.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryReconcileIAFLeg(proc) {
        let iafIndex = -1;
        for (let i = 0; i < proc.procedureLegs.length; i++) {
            const leg = proc.procedureLegs[i];
            if (leg.fixTypeFlags === FixTypeFlags.IAF) {
                iafIndex = i;
                switch (leg.type) {
                    case LegType.HA:
                    case LegType.HF:
                    case LegType.HM:
                    case LegType.PI:
                    case LegType.FD:
                    case LegType.FC:
                        if (iafIndex > 0) {
                            leg.fixTypeFlags &= ~FixTypeFlags.IAF;
                            proc.procedureLegs[iafIndex - 1].fixTypeFlags |= FixTypeFlags.IAF;
                            iafIndex--;
                        }
                }
                break;
            }
        }
        return proc;
    }
    /**
     * Inserts a MAP fix type flag if none exists on the approach.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryInsertMap(proc) {
        let addMap = true;
        let runwayIndex = -1;
        for (let i = 0; i < proc.procedureLegs.length; i++) {
            const leg = proc.procedureLegs[i];
            if (leg.fixTypeFlags === FixTypeFlags.MAP) {
                addMap = false;
                break;
            }
            if (leg.fixIcao.search('R') === 0) {
                runwayIndex = i;
                break;
            }
        }
        if (addMap && runwayIndex > -1) {
            proc.procedureLegs[runwayIndex].fixTypeFlags = FixTypeFlags.MAP;
        }
        return proc;
    }
    /**
     * Method to remove the duplicate leg after the hold leg.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryCleanupHold(proc) {
        for (let i = 0; i < proc.procedureLegs.length; i++) {
            const leg = proc.procedureLegs[i];
            if (leg.type === LegType.HF) {
                const next = proc.procedureLegs[i + 1];
                if (leg.fixIcao === next.fixIcao && next.type === LegType.IF) {
                    proc.procedureLegs.splice(i + 1, 1);
                }
            }
        }
        return proc;
    }
    /**
     * Method to remove a course reversal in an approach procedure.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryRemoveCourseReversal(proc) {
        let canRemove = false;
        if (proc.procedureLegs.length > 2) {
            const leg = proc.procedureLegs[1];
            switch (leg.type) {
                case LegType.HA:
                case LegType.HF:
                case LegType.HM:
                case LegType.PI:
                    canRemove = true;
            }
        }
        if (canRemove) {
            proc.procedureLegs.splice(1, 1);
        }
        return proc;
    }
    /**
     * Method to remove the departure from the flight plan.
     */
    async removeDeparture() {
        const plan = this.getFlightPlan();
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Departure);
        plan.setDeparture();
        this.planClearSegment(segmentIndex, FlightPlanSegmentType.Departure);
        if (plan.originAirport) {
            const airport = await this.facLoader.getFacility(FacilityType.Airport, plan.originAirport);
            const updatedSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Departure);
            this.planAddOriginDestinationLeg(true, updatedSegmentIndex, airport, plan.procedureDetails.originRunway);
            const prevLeg = plan.getPrevLeg(updatedSegmentIndex, 1);
            const nextLeg = plan.getNextLeg(updatedSegmentIndex, 0);
            if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
                this.planRemoveDuplicateLeg(prevLeg, nextLeg);
            }
        }
        plan.calculate(0);
    }
    /**
     * Method to remove the arrival from the flight plan.
     */
    async removeArrival() {
        const plan = this.getFlightPlan();
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Arrival);
        plan.setArrival();
        this.planRemoveSegment(segmentIndex);
        if (plan.procedureDetails.approachIndex < 0 && plan.destinationAirport) {
            const airport = await this.facLoader.getFacility(FacilityType.Airport, plan.destinationAirport);
            const destSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Destination);
            this.planAddOriginDestinationLeg(false, destSegmentIndex, airport, plan.procedureDetails.destinationRunway);
        }
        const prevLeg = plan.getPrevLeg(segmentIndex, 0);
        const nextLeg = plan.getNextLeg(segmentIndex, -1);
        if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(prevLeg, nextLeg);
        }
        plan.calculate(0);
    }
    /**
     * Method to remove the approach from the flight plan.
     */
    async removeApproach() {
        this.loadApproachFrequency();
        this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, RnavTypeFlags.None, false);
        const plan = this.getFlightPlan();
        const hasArrival = plan.procedureDetails.arrivalIndex >= 0;
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Approach);
        if (hasArrival) {
            const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
            const segment = plan.getSegment(lastEnrouteSegmentIndex);
            const lastLegIndex = segment && segment.legs.length > 0 ? segment.legs.length - 1 : 0;
            if (plan.destinationAirport && segment.legs[lastLegIndex] && segment.legs[lastLegIndex].leg.fixIcao === plan.destinationAirport) {
                this.planRemoveLeg(lastEnrouteSegmentIndex, lastLegIndex);
            }
            plan.setDestinationRunway();
            if (plan.procedureDetails.arrivalFacilityIcao && plan.procedureDetails.arrivalFacilityIcao !== plan.destinationAirport) {
                const arrivalFacility = await this.facLoader.getFacility(FacilityType.Airport, plan.procedureDetails.arrivalFacilityIcao);
                this.setDestination(arrivalFacility);
            }
        }
        plan.setApproach();
        this.planRemoveSegment(segmentIndex);
        if (plan.destinationAirport) {
            const airport = await this.facLoader.getFacility(FacilityType.Airport, plan.destinationAirport);
            const destLegSegmentIndex = hasArrival
                ? this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Arrival)
                : this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Destination);
            this.planAddOriginDestinationLeg(false, destLegSegmentIndex, airport, plan.procedureDetails.destinationRunway);
        }
        const prevLeg = plan.getPrevLeg(segmentIndex, 0);
        const nextLeg = plan.getNextLeg(segmentIndex, -1);
        if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(prevLeg, nextLeg);
        }
        if (plan.getUserData('visual_approach')) {
            plan.deleteUserData('visual_approach');
        }
        plan.calculate(0);
    }
    /**
     * Method to activate a leg in the flight plan.
     * @param segmentIndex is the index of the segment containing the leg to activate.
     * @param legIndex is the index of the leg in the selected segment activate.
     * @param fplnIndex is the index of the flight plan in which to activate the leg.
     */
    activateLeg(segmentIndex, legIndex, fplnIndex = 0) {
        const plan = this.getFlightPlan(fplnIndex);
        const indexInFlightplan = plan.getSegment(segmentIndex).offset + legIndex;
        if (fplnIndex === 0 && this.flightPlanner.activePlanIndex > 0) {
            this.flightPlanner.setActivePlanIndex(0);
        }
        if (this.missedApproachActive) {
            const segment = plan.getSegment(segmentIndex);
            if (segment.legs[legIndex] && !segment.legs[legIndex].isInMissedApproachSequence) {
                Fms.g1000EvtPub.publishEvent('activate_missed_approach', false);
            }
        }
        if ((fplnIndex !== 0 && this.getDirectToState() === DirectToState.TOEXISTING)
            || (fplnIndex === 0 && (segmentIndex < plan.directToData.segmentIndex || (segmentIndex === plan.directToData.segmentIndex && legIndex <= plan.directToData.segmentLegIndex)))) {
            this.removeDirectToExisting(indexInFlightplan);
            if (fplnIndex !== 0) {
                plan.setLateralLeg(indexInFlightplan);
                plan.calculate(Math.max(0, indexInFlightplan - 1));
            }
        }
        else {
            plan.setLateralLeg(indexInFlightplan);
            plan.calculate(Math.max(0, indexInFlightplan - 1));
        }
        Fms.g1000EvtPub.publishEvent('suspend', false);
    }
    /**
     * Method to check if there is a currently loaded approach to be activated.
     * @returns whether the approach can activate
     */
    canApproachActivate() {
        const plan = this.getFlightPlan();
        if (plan.destinationAirport !== undefined && plan.procedureDetails.approachIndex > -1) {
            return true;
        }
        else if (plan.destinationAirport !== undefined) {
            const approachSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Approach, false);
            if (approachSegmentIndex > 0 && plan.getSegment(approachSegmentIndex).legs.length > 0) {
                return true;
            }
        }
        return false;
    }
    /**
     * Method to activate the approach.
     */
    activateApproach() {
        if (this.canApproachActivate()) {
            const approachSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Approach, false);
            this.createDirectToExisting(approachSegmentIndex, 0);
        }
        this.setLocFrequency(1, true);
        this.setLocFrequency(2, true);
    }
    /**
     * Method to check if there is a currently loaded missed approach to be activated.
     * @returns whether the approach can activate
     */
    canMissedApproachActivate() {
        const plan = this.getFlightPlan();
        if (this.cdiSource.type === NavSourceType.Gps && plan && plan.activeLateralLeg < plan.length - 1 && plan.segmentCount > 0) {
            const segmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
            if (segmentIndex > 0) {
                const segment = plan.getSegment(segmentIndex);
                if (segment.segmentType === FlightPlanSegmentType.Approach && segment.legs[segment.legs.length - 1].isInMissedApproachSequence) {
                    for (let i = 0; i < segment.legs.length; i++) {
                        const leg = segment.legs[i];
                        if (leg.leg.fixTypeFlags === FixTypeFlags.FAF) {
                            if (plan.activeLateralLeg - segment.offset >= i) {
                                return true;
                            }
                        }
                    }
                }
            }
        }
        return false;
    }
    /**
     * Method to activate the missed approach.
     */
    activateMissedApproach() {
        if (this.canMissedApproachActivate()) {
            Fms.g1000EvtPub.publishEvent('activate_missed_approach', true);
        }
    }
    /**
     * Method to create a direct to a random waypoint just from the fixIcao.
     * @param icao is the desired fixIcao.
     */
    async buildRandomDirectTo(icao) {
        if (ICAO.isFacility(icao)) {
            const type = ICAO.getFacilityType(icao);
            const fac = await this.facLoader.getFacility(type, icao);
            this.createDirectToRandom(fac);
        }
    }
    /**
     * Method to create a direct to a waypoint. This method will also then call activateLeg.
     * @param waypoint is the facility for the DTO destination to be added.
     * @param course is the course for this direct to, if specified.
     */
    createDirectToRandom(waypoint, course) {
        const plan = this.flightPlanner.createFlightPlan(1);
        plan.setLateralLeg(0);
        for (let i = plan.segmentCount - 1; i >= 0; i--) {
            if (plan.getSegment(i) !== undefined) {
                plan.removeSegment(i);
            }
        }
        plan.insertSegment(0, FlightPlanSegmentType.RandomDirectTo, undefined, true);
        const segment = plan.getSegment(0);
        if (segment) {
            const discoLeg = FlightPlan.createLeg({ type: LegType.Discontinuity });
            const dtoOriginLeg = this.createDTOOriginLeg(this.ppos);
            const dtoTargetLeg = this.createDTODirectLeg(waypoint.icao);
            plan.addLeg(0, discoLeg, 0, true);
            plan.addLeg(0, dtoOriginLeg, 1, true);
            plan.addLeg(0, dtoTargetLeg, 2, true);
            plan.calculate(0);
            if (this.flightPlanner.activePlanIndex !== 1) {
                this.flightPlanner.setActivePlanIndex(1);
            }
            Fms.g1000EvtPub.publishEvent('suspend', false);
        }
    }
    /**
     * Method to create a direct to an existing waypoint in the plan. This method will also then call activateLeg.
     * @param segmentIndex is the index of the segment containing the leg to activate as direct to.
     * @param legIndex is the index of the leg in the specified segment to activate as direct to.
     * @param course is the course for this direct to, if specified.
     */
    createDirectToExisting(segmentIndex, legIndex, course) {
        const plan = this.getFlightPlan();
        const segment = plan.getSegment(segmentIndex);
        const leg = segment.legs[legIndex];
        let legIndexDelta = 0;
        if (plan.directToData.segmentIndex > -1 && plan.directToData.segmentLegIndex > -1) {
            legIndexDelta -= plan.directToData.segmentIndex === segmentIndex && legIndex > plan.directToData.segmentLegIndex ? 3 : 0;
            if (this.getDirectToState() === DirectToState.TOEXISTING) {
                this.removeDirectToExisting();
            }
            else {
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
            }
        }
        plan.setDirectToData(segmentIndex, legIndex + legIndexDelta);
        if (segment && leg) {
            const discoLeg = FlightPlan.createLeg({ type: LegType.Discontinuity });
            const dtoOriginLeg = this.createDTOOriginLeg(this.ppos);
            const dtoTargetLeg = this.createDTODirectLeg(leg.leg.fixIcao, leg.leg);
            plan.addLeg(segmentIndex, discoLeg, legIndex + legIndexDelta + 1, true);
            plan.addLeg(segmentIndex, dtoOriginLeg, legIndex + legIndexDelta + 2, true);
            plan.addLeg(segmentIndex, dtoTargetLeg, legIndex + legIndexDelta + 3, true);
            this.activateLeg(segmentIndex, legIndex + legIndexDelta + 3);
        }
    }
    /**
     * Creates a Direct-To origin IF leg.
     * @param ppos The current plane position.
     * @returns a Direct-To origin IF leg.
     */
    createDTOOriginLeg(ppos) {
        return FlightPlan.createLeg({
            type: LegType.IF,
            lat: ppos.lat,
            lon: ppos.lon
        });
    }
    /**
     * Creates a Direct-To DF leg.
     * @param icao is the icao.
     * @param leg The FlightPlanLeg.
     * @returns a Direct-To DF leg.
     */
    createDTODirectLeg(icao, leg) {
        const planeHeading = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', 'degrees');
        if (leg) {
            const directLeg = Object.assign({}, leg);
            directLeg.type = LegType.DF;
            directLeg.course = planeHeading === 0 ? 360 : planeHeading;
            return directLeg;
        }
        else {
            return FlightPlan.createLeg({
                type: LegType.DF,
                fixIcao: icao,
                course: planeHeading === 0 ? 360 : planeHeading
            });
        }
    }
    /**
     * Empties the primary flight plan.
     */
    async emptyPrimaryFlightPlan() {
        if (!this.flightPlanner.hasFlightPlan(Fms.PRIMARY_PLAN_INDEX)) {
            return;
        }
        const plan = this.flightPlanner.getFlightPlan(Fms.PRIMARY_PLAN_INDEX);
        const directToState = this.getDirectToState();
        if (directToState === DirectToState.TOEXISTING || (directToState !== DirectToState.TORANDOM && !Simplane.getIsGrounded() && plan.activeLateralLeg > 0)) {
            const directToIcao = plan.getLeg(plan.activeLateralLeg).leg.fixIcao;
            if (directToIcao) {
                const facType = ICAO.getFacilityType(directToIcao);
                const fac = await this.facLoader.getFacility(facType, directToIcao);
                this.createDirectToRandom(fac);
            }
        }
        for (let i = plan.segmentCount - 1; i >= 0; i--) {
            this.planRemoveSegment(i);
        }
        plan.addSegment(0, FlightPlanSegmentType.Departure);
        plan.addSegment(1, FlightPlanSegmentType.Enroute);
        plan.addSegment(2, FlightPlanSegmentType.Destination);
        this.setOrigin(undefined, undefined);
        this.setDestination(undefined, undefined);
        plan.setDirectToData(-1);
        this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, RnavTypeFlags.None, false);
        plan.setLateralLeg(0);
        plan.setVerticalLeg(0);
        plan.setCalculatingLeg(0);
        plan.calculate(0);
    }
    /**
     * Builds a temporary flight plan to preview the approach in the MFD Select Procedure pages.
     * @param facility The airport facility to load the approach from
     * @param procType The type of procedure to preview.
     * @param procIndex The procedure index selected.
     * @param transIndex The transition index selected.
     * @param oneWayRunway The one way runway to build the preview with, if any.
     * @param rwyTransIndex The runway transition index selected, if any.
     * @param visualRunwayNumber is the visual runway number, if any.
     * @param visualRunwayDesignator is the visual runway designator, if any.
     * @param transStartIndex The transition start offset, if any.
     * @returns the index of the temporary flight plan.
     */
    buildProcedurePreviewPlan(facility, procType, procIndex, transIndex, oneWayRunway, rwyTransIndex, visualRunwayNumber, visualRunwayDesignator, transStartIndex) {
        var _a;
        this.flightPlanner.deleteFlightPlan(Fms.PROC_PREVIEW_PLAN_INDEX);
        const plan = this.flightPlanner.createFlightPlan(Fms.PROC_PREVIEW_PLAN_INDEX);
        let procedureLegObject;
        switch (procType) {
            case ProcedureType.APPROACH:
                procedureLegObject = this.buildApproachLegs(facility, procIndex, transIndex, undefined, transStartIndex !== undefined ? transStartIndex : 0);
                plan.addSegment(0, FlightPlanSegmentType.Approach, undefined, false);
                break;
            case ProcedureType.ARRIVAL:
                {
                    const runwayIndex = rwyTransIndex !== null && rwyTransIndex !== void 0 ? rwyTransIndex : -1;
                    procedureLegObject = this.buildArrivalLegs(facility, procIndex, transIndex, runwayIndex, oneWayRunway);
                    plan.addSegment(0, FlightPlanSegmentType.Arrival, undefined, false);
                }
                break;
            case ProcedureType.DEPARTURE:
                {
                    const runwayIndex = rwyTransIndex !== null && rwyTransIndex !== void 0 ? rwyTransIndex : -1;
                    procedureLegObject = this.buildDepartureLegs(facility, procIndex, transIndex, runwayIndex, oneWayRunway);
                    plan.addSegment(0, FlightPlanSegmentType.Departure, undefined, false);
                }
                break;
            case ProcedureType.VISUALAPPROACH:
                if (visualRunwayNumber !== undefined && visualRunwayDesignator !== undefined) {
                    const visualRunway = RunwayUtils.matchOneWayRunway(facility, visualRunwayNumber, visualRunwayDesignator);
                    procedureLegObject = this.buildApproachLegs(facility, -1, -1, visualRunway);
                    plan.addSegment(0, FlightPlanSegmentType.Approach, undefined, false);
                }
                break;
        }
        if (procedureLegObject && procedureLegObject.procedureLegs.length > 0) {
            if (procedureLegObject.procedureLegs[0].type !== LegType.IF) {
                const replacementLeg = FlightPlan.createLeg({
                    type: LegType.IF,
                    fixIcao: procedureLegObject.procedureLegs[0].fixIcao,
                    fixTypeFlags: procedureLegObject.procedureLegs[0].fixTypeFlags,
                });
                procedureLegObject.procedureLegs.splice(0, 1, replacementLeg);
            }
            procedureLegObject.procedureLegs.forEach((l) => {
                plan.addLeg(0, l, undefined, undefined, undefined, false);
            });
            if (procType === ProcedureType.APPROACH) {
                // Adds missed approach legs
                if (!visualRunwayNumber && !visualRunwayDesignator && procedureLegObject.procedureLegs.length > 0) {
                    const missedLegs = (_a = facility.approaches[procIndex].missedLegs) !== null && _a !== void 0 ? _a : [];
                    if (missedLegs && missedLegs.length > 0) {
                        let maphIndex = -1;
                        for (let m = missedLegs.length - 1; m >= 0; m--) {
                            switch (missedLegs[m].type) {
                                case LegType.HA:
                                case LegType.HF:
                                case LegType.HM:
                                    maphIndex = m - 1;
                                    break;
                            }
                        }
                        for (let n = 0; n < missedLegs.length; n++) {
                            const newLeg = FlightPlan.createLeg(missedLegs[n]);
                            if (maphIndex > 0 && n === maphIndex) {
                                newLeg.fixTypeFlags |= FixTypeFlags.MAHP;
                                plan.addLeg(0, newLeg, undefined, false, true, false);
                            }
                            else {
                                plan.addLeg(0, newLeg, undefined, false, true, false);
                            }
                        }
                    }
                }
            }
            plan.calculate(0);
            return 2;
        }
        else {
            return -1;
        }
    }
    /**
     * Builds a temporary flight plan to preview an airway entry.
     * @param airway The airway object.
     * @param entry The entry intersection facility.
     * @param exit The exit intersection facility.
     * @returns the index of the temporary flight plan.
     */
    buildAirwayPreviewSegment(airway, entry, exit) {
        this.flightPlanner.deleteFlightPlan(Fms.PROC_PREVIEW_PLAN_INDEX);
        const plan = this.flightPlanner.createFlightPlan(Fms.PROC_PREVIEW_PLAN_INDEX);
        const airwayLegObject = this.buildAirwayLegs(airway, entry, exit);
        plan.insertSegment(0, FlightPlanSegmentType.Enroute, airway.name, false);
        if (airwayLegObject.procedureLegs.length > 0) {
            airwayLegObject.procedureLegs.forEach((l) => {
                plan.addLeg(0, l, undefined, undefined, undefined, false);
            });
            plan.calculate(0, true);
        }
        return Fms.PROC_PREVIEW_PLAN_INDEX;
    }
    /**
     * Adds an airway and airway segment to the flight plan.
     * @param airway The airway object.
     * @param entry The entry intersection facility.
     * @param exit The exit intersection facility.
     * @param segmentIndex Is the segment index for the entry leg.
     * @param legIndex Is the leg index of the entry leg in the segment of the
     */
    insertAirwaySegment(airway, entry, exit, segmentIndex, legIndex) {
        const plan = this.getFlightPlan();
        const airwaySegmentIndex = this.prepareAirwaySegment(`${airway.name}.${ICAO.getIdent(exit.icao)}`, segmentIndex, legIndex);
        const airwayLegObject = this.buildAirwayLegs(airway, entry, exit);
        const airwayLegs = airwayLegObject.procedureLegs;
        for (let i = 1; i < airwayLegs.length; i++) {
            this.planAddLeg(airwaySegmentIndex, airwayLegs[i]);
        }
        // handle duplicates
        const airwaySegment = plan.getSegment(airwaySegmentIndex);
        const lastLeg = airwaySegment.legs[airwaySegment.legs.length - 1];
        const nextLeg = plan.getNextLeg(airwaySegmentIndex + 1, -1);
        if (lastLeg && nextLeg && this.isDuplicateLeg(lastLeg.leg, nextLeg.leg)) {
            const nextLegIndex = plan.getLegIndexFromLeg(nextLeg);
            const nextLegSegmentIndex = plan.getSegmentIndex(nextLegIndex);
            const nextLegSegment = plan.getSegment(nextLegSegmentIndex);
            if (this.getAirwayLegType(plan, nextLegSegmentIndex, nextLegIndex - nextLegSegment.offset) === AirwayLegType.ENTRY) {
                // the duplicated leg is an airway entry -> remove the segment containing it (the segment is guaranteed to
                // contain just the one leg)
                this.planRemoveSegment(nextLegSegmentIndex);
            }
            else {
                this.planRemoveDuplicateLeg(lastLeg, nextLeg);
            }
        }
        plan.calculate(0, true);
    }
    /**
     * Prepares a new, empty airway segment in the primary flight plan which is ready to accept airway legs. Also
     * modifies the segment containing the entry leg, if necessary, either splitting it following the entry leg if it is
     * a non-airway enroute segment, or removing all legs following the entry leg if it is an airway segment. If the
     * entry leg is the last leg in its segment, a new non-airway enroute segment will be inserted after the entry leg
     * segment if the entry leg segment is the last segment in the flight plan or if the following segment is not an
     * enroute segment. If the entry leg is the entry for an existing airway segment, the existing airway segment will be
     * removed.
     * @param airwayName The name of the airway.
     * @param entrySegmentIndex The index of the segment containing the airway entry leg.
     * @param entrySegmentLegIndex The index of the airway entry leg in its segment.
     * @returns The index of the new airway segment.
     */
    prepareAirwaySegment(airwayName, entrySegmentIndex, entrySegmentLegIndex) {
        const plan = this.getPrimaryFlightPlan();
        const entrySegment = plan.getSegment(entrySegmentIndex);
        const nextSegment = entrySegmentIndex + 1 < plan.segmentCount ? plan.getSegment(entrySegmentIndex + 1) : undefined;
        let airwaySegmentIndex = entrySegmentIndex + 1;
        let removeLegsSegmentIndex = -1;
        let removeLegsFromIndex = -1;
        if (entrySegment.airway !== undefined) {
            // the entry leg is within an existing airway segment -> remove all legs in the same segment after the entry leg
            removeLegsSegmentIndex = entrySegmentIndex;
            removeLegsFromIndex = entrySegmentLegIndex + 1;
        }
        else if (entrySegmentLegIndex === entrySegment.legs.length - 1 && (nextSegment === null || nextSegment === void 0 ? void 0 : nextSegment.airway) !== undefined) {
            // the entry leg is the entry leg for an existing airway segment -> remove all legs from the existing airway segment
            removeLegsSegmentIndex = entrySegmentIndex + 1;
            removeLegsFromIndex = 0;
        }
        // remove legs as required
        if (removeLegsSegmentIndex >= 0) {
            const removeLegsSegment = plan.getSegment(removeLegsSegmentIndex);
            if (plan.directToData.segmentIndex === removeLegsSegmentIndex && plan.directToData.segmentLegIndex >= removeLegsFromIndex) {
                this.removeDirectToExisting();
            }
            if (this.getAirwayLegType(plan, removeLegsSegmentIndex, removeLegsSegment.legs.length - 1) === AirwayLegType.EXIT_ENTRY) {
                // preserve the airway entry leg
                const lastLeg = removeLegsSegment.legs[removeLegsSegment.legs.length - 1];
                this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, removeLegsSegmentIndex + 1);
                this.planAddLeg(removeLegsSegmentIndex + 1, lastLeg.leg, 0);
            }
            if (removeLegsFromIndex > 0) {
                while (removeLegsSegment.legs.length > removeLegsFromIndex) {
                    this.planRemoveLeg(removeLegsSegmentIndex, entrySegment.legs.length - 1, true, true);
                }
            }
            else {
                this.planRemoveSegment(removeLegsSegmentIndex);
            }
        }
        if (entrySegment.legs.length - 1 > entrySegmentLegIndex) {
            // entry leg is not the last leg in its segment -> split the segment after the entry leg
            airwaySegmentIndex = this.splitSegment(plan, entrySegmentIndex, entrySegmentLegIndex);
        }
        else if (plan.getSegment(entrySegmentIndex).segmentType === FlightPlanSegmentType.Enroute
            && ((nextSegment === null || nextSegment === void 0 ? void 0 : nextSegment.segmentType) !== FlightPlanSegmentType.Enroute)) {
            // entry leg is the last leg in its segment and the following segment doesn't exist or is not an enroute segment
            plan.insertSegment(airwaySegmentIndex, FlightPlanSegmentType.Enroute);
        }
        plan.insertSegment(airwaySegmentIndex, FlightPlanSegmentType.Enroute, airwayName);
        return airwaySegmentIndex;
    }
    /**
     * Splits a segment into two segments if type is enroute; if departure, remove legs after the legIndex, else do nothing.
     * @param plan is the flight plan to edit.
     * @param segmentIndex Is the segment index for the entry leg.
     * @param legIndex Is the leg index of the entry leg in the segment of the
     * @returns the segment number of the new airway segment if one was created, else the current segment or if no action was taken.
     */
    splitSegment(plan, segmentIndex, legIndex) {
        const segment = plan.getSegment(segmentIndex);
        if (segment.segmentType === FlightPlanSegmentType.Enroute) {
            const nextSegmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
            for (let i = legIndex + 1; i < segment.legs.length; i++) {
                const leg = segment.legs[i].leg;
                this.planRemoveLeg(segmentIndex, i);
                this.planAddLeg(nextSegmentIndex, leg);
            }
            return nextSegmentIndex;
        }
        else if (segment.segmentType === FlightPlanSegmentType.Departure) {
            for (let i = legIndex + 1; i < segment.legs.length; i++) {
                this.planRemoveLeg(segmentIndex, i);
            }
        }
        return segmentIndex;
    }
    /**
     * Builds a legs for an airway.
     * @param airway The airway object.
     * @param entry The entry intersection facility.
     * @param exit The exit intersection facility.
     * @returns the InsertProcedureObject.
     */
    buildAirwayLegs(airway, entry, exit) {
        const insertAirwayObject = { procedureLegs: [] };
        const waypoints = airway.waypoints;
        const entryIndex = waypoints.findIndex((w) => w.icao === entry.icao);
        const exitIndex = waypoints.findIndex((w) => w.icao === exit.icao);
        const ascending = exitIndex > entryIndex;
        if (ascending) {
            for (let i = entryIndex; i <= exitIndex; i++) {
                const leg = FlightPlan.createLeg({
                    fixIcao: waypoints[i].icao,
                    type: i === entryIndex ? LegType.IF : LegType.TF
                });
                insertAirwayObject.procedureLegs.push(leg);
            }
        }
        else {
            for (let i = entryIndex; i >= exitIndex; i--) {
                const leg = FlightPlan.createLeg({
                    fixIcao: waypoints[i].icao,
                    type: i === entryIndex ? LegType.IF : LegType.TF
                });
                insertAirwayObject.procedureLegs.push(leg);
            }
        }
        return insertAirwayObject;
    }
    /**
     * Method to remove an airway from the flight plan.
     * @param segmentIndex is the segment index of the airway to remove.
     */
    removeAirway(segmentIndex) {
        const plan = this.getFlightPlan();
        let combineSegments = false;
        const nextSegmentIsAirway = plan.getSegment(segmentIndex + 1).airway;
        if (segmentIndex > 0) {
            const priorSegmentEnrouteNonAirway = plan.getSegment(segmentIndex - 1).segmentType === FlightPlanSegmentType.Enroute
                && plan.getSegment(segmentIndex - 1).airway === undefined;
            const nextSegmentEnrouteNonAirway = plan.getSegment(segmentIndex + 1).segmentType === FlightPlanSegmentType.Enroute
                && plan.getSegment(segmentIndex + 1).airway === undefined;
            if (priorSegmentEnrouteNonAirway && nextSegmentEnrouteNonAirway) {
                combineSegments = true;
            }
            let entryLeg = undefined;
            if (nextSegmentIsAirway) {
                const segment = plan.getSegment(segmentIndex);
                entryLeg = segment.legs[segment.legs.length - 1].leg;
            }
            this.planRemoveSegment(segmentIndex);
            if (combineSegments) {
                this.mergeSegments(plan, segmentIndex - 1);
            }
            if (priorSegmentEnrouteNonAirway && entryLeg !== undefined) {
                this.planAddLeg(segmentIndex - 1, entryLeg);
            }
            else if (entryLeg !== undefined) {
                const newSegmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex);
                this.planAddLeg(newSegmentIndex, entryLeg);
            }
        }
        plan.calculate(0, true);
    }
    /**
     * Merges the legs of two consecutive segments into a single segment. All legs in the second segment are moved to the
     * first, and the second segment is removed from the flight plan.
     * @param plan The flight plan to modify.
     * @param segmentIndex The index of the first segment to merge.
     */
    mergeSegments(plan, segmentIndex) {
        const segmentToGrow = plan.getSegment(segmentIndex);
        const segmentToRemove = plan.getSegment(segmentIndex + 1);
        const segmentToGrowOrigLength = segmentToGrow.legs.length;
        segmentToRemove.legs.forEach((l) => {
            plan.addLeg(segmentIndex, l.leg, undefined, l.isInDirectToSequence);
        });
        if (plan.directToData.segmentIndex === segmentIndex + 1) {
            plan.setDirectToData(segmentIndex, segmentToGrowOrigLength + plan.directToData.segmentLegIndex);
        }
        this.planRemoveSegment(segmentIndex + 1);
    }
    /**
     * Adds a hold leg to a segment.
     * @param segmentIndex The segment to add to.
     * @param legIndex The index of the leg.
     * @param holdLeg The hold leg to add.
     */
    addHold(segmentIndex, legIndex, holdLeg) {
        this.planAddLeg(segmentIndex, holdLeg, legIndex + 1);
    }
    /**
     * Returns the index of the last element in the array where predicate is true, and -1
     * otherwise.
     * @param array The source array to search in
     * @param predicate find calls predicate once for each element of the array, in descending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.
     * @param defaultReturn is the default value
     * @returns either the index or the default if the predicate criteria is not met
     */
    findLastSegmentIndex(array, predicate, defaultReturn = -1) {
        let l = array.length;
        while (l--) {
            if (predicate(array[l], l, array)) {
                return array[l].segmentIndex;
            }
        }
        return defaultReturn;
    }
    /**
     * Adds a leg to the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param leg The leg to add to the plan.
     * @param index The index of the leg in the segment to insert. Will add to the end of the segment if ommitted.
     * @param isInDirectToSequence Whether the new leg is in a direct to sequence.
     * @param isInMissedSequence Whether the new leg is in a missed approach sequence.
     * @param notify Whether or not to send notifications after the operation.
     */
    planAddLeg(segmentIndex, leg, index, isInDirectToSequence = false, isInMissedSequence = false, notify = true) {
        const plan = this.getFlightPlan();
        const dtoLegIndex = plan.directToData.segmentLegIndex;
        const dtoSegmentIndex = plan.directToData.segmentIndex;
        if (dtoSegmentIndex >= 0
            && (segmentIndex < dtoSegmentIndex
                || (segmentIndex === dtoSegmentIndex && index !== undefined && index <= dtoLegIndex))) {
            this.removeDirectToExisting();
        }
        const segment = plan.getSegment(segmentIndex);
        const addIndex = index ? index : Math.max(segment.legs.length - 1, 0);
        if (segment.segmentType === FlightPlanSegmentType.Approach && (addIndex > 0) && segment.legs[addIndex - 1].isInMissedApproachSequence) {
            isInMissedSequence = true;
        }
        plan.addLeg(segmentIndex, leg, index, isInDirectToSequence, isInMissedSequence, notify);
        plan.calculate(plan.activeLateralLeg - 1);
        const activeSegmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
        if (activeSegmentIndex !== -1) {
            const activeLegIndex = plan.activeLateralLeg - plan.getSegment(activeSegmentIndex).offset;
            if (segmentIndex < activeSegmentIndex || (index && segmentIndex == activeSegmentIndex && index < activeLegIndex)) {
                plan.setLateralLeg(plan.activeLateralLeg + 1);
            }
        }
        else {
            console.error('planAddLeg: activeSegmentIndex was -1');
        }
    }
    /**
     * Removes a leg from the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param index The index of the leg in the segment to remove.
     * @param notify Whether or not to send notifications after the operation. True by default.
     * @param skipDupCheck Whether to skip checking for duplicates. False by default.
     * @param skipCancelDirectTo Whether to skip canceling a direct to existing if the removed leg is equal to or is
     * located before the direct to target. False by default.
     * @returns whether a leg was removed.
     */
    planRemoveLeg(segmentIndex, index, notify = true, skipDupCheck = false, skipCancelDirectTo = false) {
        const plan = this.getFlightPlan();
        const removeLegGlobalIndex = plan.getSegment(segmentIndex).offset + index;
        const prevLeg = plan.getPrevLeg(segmentIndex, index);
        const nextLeg = plan.getNextLeg(segmentIndex, index);
        const isDirectToExistingActive = this.getDirectToState() === DirectToState.TOEXISTING;
        let removed = false;
        const airwayLegType = this.getAirwayLegType(plan, segmentIndex, index);
        if (airwayLegType !== AirwayLegType.NONE) {
            removed = this.removeLegAirwayHandler(plan, airwayLegType, segmentIndex, index);
        }
        else {
            removed = plan.removeLeg(segmentIndex, index, notify) !== null ? true : false;
        }
        if (!removed) {
            return false;
        }
        const dtoLegIndex = plan.directToData.segmentLegIndex;
        const dtoSegmentIndex = plan.directToData.segmentIndex;
        if (!skipCancelDirectTo
            && dtoSegmentIndex >= 0
            && (segmentIndex < dtoSegmentIndex
                || (segmentIndex === dtoSegmentIndex && index <= dtoLegIndex))) {
            // Need to adjust direct to data to compensate for removed leg.
            if (segmentIndex === dtoSegmentIndex) {
                plan.directToData.segmentLegIndex--;
            }
            if (isDirectToExistingActive && segmentIndex === dtoSegmentIndex && index === dtoLegIndex) {
                const directIcao = plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex + 3].leg.fixIcao;
                this.buildRandomDirectTo(directIcao);
            }
            this.removeDirectToExisting(plan.activeLateralLeg - 1);
        }
        else if (removeLegGlobalIndex < plan.activeLateralLeg || plan.activeLateralLeg >= plan.length) {
            plan.setLateralLeg(plan.activeLateralLeg - 1);
        }
        // Detect if we have created consecutive duplicate legs. If we have, we need to delete one of them.
        if (!skipDupCheck && prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(prevLeg, nextLeg);
        }
        if (!skipDupCheck && this.checkIfRemoveLeftEmptySegmentToDelete(plan, segmentIndex)) {
            this.planRemoveSegment(segmentIndex);
        }
        plan.calculate(plan.activeLateralLeg - 1);
        return true;
    }
    /**
     * Method to handle a remove leg request t.
     * @param plan is the flight plan.
     * @param airwayLegType is the airwayLegType returned from the checkIfAirwayLeg method.
     * @param segmentIndex The segment we are removing from.
     * @param index is the leg index in the segment we are removing.
     * @returns whether this handler processed the remove request.
     */
    removeLegAirwayHandler(plan, airwayLegType, segmentIndex, index) {
        var _a, _b;
        switch (airwayLegType) {
            case AirwayLegType.ONROUTE:
                if (plan.getSegment(segmentIndex + 1).airway) {
                    const segment = plan.getSegment(segmentIndex);
                    const leg = segment.legs[segment.legs.length - 1].leg;
                    this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                    this.planAddLeg(segmentIndex + 1, leg);
                }
                this.removeAirway(segmentIndex);
                return true;
            case AirwayLegType.ENTRY:
                if (plan.getSegment(segmentIndex).segmentType === FlightPlanSegmentType.Enroute) {
                    const segment = plan.getSegment(segmentIndex + 1);
                    const leg = segment.legs[0].leg;
                    plan.removeLeg(segmentIndex + 1, 0);
                    this.planAddLeg(segmentIndex, leg);
                }
                else if (plan.getSegment(segmentIndex).segmentType === FlightPlanSegmentType.Departure) {
                    this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                    const segment = plan.getSegment(segmentIndex + 2);
                    const leg = segment.legs[0].leg;
                    plan.removeLeg(segmentIndex + 2, 0);
                    this.planAddLeg(segmentIndex + 1, leg);
                }
                return plan.removeLeg(segmentIndex, index) !== null ? true : false;
            case AirwayLegType.EXIT: {
                if (index < 1) {
                    this.removeAirway(segmentIndex);
                    return true;
                }
                else {
                    const segment = plan.getSegment(segmentIndex);
                    const airway = (_a = segment.airway) === null || _a === void 0 ? void 0 : _a.split('.');
                    segment.airway = airway && airway[0] ? airway[0] + '.' + segment.legs[index - 1].name : segment.airway;
                    plan.setAirway(segmentIndex, segment.airway);
                    return plan.removeLeg(segmentIndex, index) !== null ? true : false;
                }
            }
            case AirwayLegType.EXIT_ENTRY: {
                const segment = plan.getSegment(segmentIndex + 1);
                const leg = segment.legs[0].leg;
                this.planRemoveLeg(segmentIndex + 1, 0);
                if (index < 1) {
                    this.removeAirway(segmentIndex);
                }
                else {
                    plan.removeLeg(segmentIndex, index);
                    this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                    const firstAirwaySegment = plan.getSegment(segmentIndex);
                    const airway = (_b = firstAirwaySegment.airway) === null || _b === void 0 ? void 0 : _b.split('.');
                    firstAirwaySegment.airway = airway && airway[0] ? airway[0] + '.' + firstAirwaySegment.legs[index - 1].name : firstAirwaySegment.airway;
                    plan.setAirway(segmentIndex, firstAirwaySegment.airway);
                }
                this.planAddLeg(segmentIndex + 1, leg);
                return true;
            }
        }
        return false;
    }
    /**
     * Checks if a remove left an empty segment that also needs to be removed.
     * @param plan is the flight plan
     * @param segmentIndex The segment to add the leg to.
     * @returns whether to remove the segment.
     */
    checkIfRemoveLeftEmptySegmentToDelete(plan, segmentIndex) {
        const segment = plan.getSegment(segmentIndex);
        let nextSegment;
        if (segmentIndex < plan.segmentCount - 1) {
            nextSegment = plan.getSegment(segmentIndex + 1);
        }
        if (segment.legs.length < 1) {
            switch (segment.segmentType) {
                case FlightPlanSegmentType.Enroute:
                    if (nextSegment && nextSegment.segmentType === FlightPlanSegmentType.Enroute) {
                        return true;
                    }
                    break;
                //TODO: Add more cases as appropriate
            }
        }
        return false;
    }
    /**
     * Adds an appropriate origin or destination leg (either an airport or runway fix) to the primary flight plan. Origin
     * legs are added to the beginning of the specified segment. Destination legs are added to the end of the specified
     * segment.
     * @param isOrigin Whether to add an origin leg.
     * @param segmentIndex The index of the segment to which to add the leg.
     * @param airport The origin airport.
     * @param runway The origin runway.
     */
    planAddOriginDestinationLeg(isOrigin, segmentIndex, airport, runway) {
        let leg;
        if (runway) {
            leg = FmsUtils.buildRunwayLeg(airport, runway, isOrigin);
        }
        else {
            leg = FlightPlan.createLeg({
                lat: airport.lat,
                lon: airport.lon,
                type: isOrigin ? LegType.IF : LegType.TF,
                fixIcao: airport.icao,
                altitude1: airport.runways[0].elevation + UnitType.FOOT.convertTo(50, UnitType.METER)
            });
        }
        if (leg) {
            this.planAddLeg(segmentIndex, leg, isOrigin ? 0 : undefined);
            if (!isOrigin) {
                const plan = this.getFlightPlan();
                const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
                const lastEnrouteSegment = plan.getSegment(lastEnrouteSegmentIndex);
                for (let i = lastEnrouteSegment.legs.length - 1; i >= 0; i--) {
                    if (lastEnrouteSegment.legs[i].leg.fixIcao === airport.icao) {
                        this.planRemoveLeg(lastEnrouteSegmentIndex, i, true, true);
                    }
                }
            }
        }
    }
    /**
     * Method to add a segment to the flightplan.
     * @param segmentType is the FlightPlanSegmentType.
     * @param index is the optional segment index to insert the segment.
     * @returns the segment index of the inserted segment.
     */
    planInsertSegmentOfType(segmentType, index) {
        const plan = this.getFlightPlan();
        let segmentIndex = -1;
        if (index) {
            segmentIndex = index - 1;
        }
        else {
            const segments = [];
            for (const segment of plan.segments()) {
                segments.push(segment);
            }
            switch (segmentType) {
                case FlightPlanSegmentType.Origin:
                    break;
                case FlightPlanSegmentType.Departure:
                    segmentIndex = 0;
                    break;
                case FlightPlanSegmentType.Arrival:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Enroute;
                    }, 2);
                    break;
                case FlightPlanSegmentType.Approach:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Enroute || v.segmentType === FlightPlanSegmentType.Arrival;
                    }, 2);
                    break;
                case FlightPlanSegmentType.MissedApproach:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Approach;
                    }, 2);
                    break;
                case FlightPlanSegmentType.Destination:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Enroute || v.segmentType === FlightPlanSegmentType.Arrival
                            || v.segmentType === FlightPlanSegmentType.Approach;
                    }, 5);
                    break;
                default:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Enroute || v.segmentType === FlightPlanSegmentType.Arrival
                            || v.segmentType === FlightPlanSegmentType.Approach || v.segmentType === FlightPlanSegmentType.Destination;
                    }, 1);
                    segmentIndex--;
                    break;
            }
        }
        return this.planInsertSegment(segmentIndex + 1, segmentType).segmentIndex;
    }
    /**
     * Method to remove all legs from a segment.
     * @param segmentIndex is the index of the segment to delete all legs from.
     * @param segmentType is the type if segment to delete all legs from, if known.
     */
    planClearSegment(segmentIndex, segmentType) {
        this.planRemoveSegment(segmentIndex);
        this.planInsertSegment(segmentIndex, segmentType);
    }
    /**
     * Inserts a segment into the flight plan at the specified index and
     * reflows the subsequent segments.
     * @param segmentIndex The index to insert the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    planInsertSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
        const plan = this.getFlightPlan();
        const segment = plan.insertSegment(segmentIndex, segmentType, airway, notify);
        plan.calculate(plan.activeLateralLeg - 1);
        if (plan.directToData.segmentIndex >= 0 && segmentIndex <= plan.directToData.segmentIndex) {
            plan.setDirectToData(plan.directToData.segmentIndex + 1, plan.directToData.segmentLegIndex);
        }
        return segment;
    }
    /**
     * Removes a segment from the flight plan and reflows the segments following
     * the removed segment, not leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    planRemoveSegment(segmentIndex, notify = true) {
        const plan = this.getFlightPlan();
        const segment = plan.getSegment(segmentIndex);
        const activeSegmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
        if (plan.directToData.segmentIndex >= 0) {
            if (segmentIndex < plan.directToData.segmentIndex) {
                plan.setDirectToData(plan.directToData.segmentIndex - 1, plan.directToData.segmentLegIndex);
            }
            else if (segmentIndex === plan.directToData.segmentIndex) {
                plan.setDirectToData(-1);
            }
        }
        if (activeSegmentIndex === segmentIndex && !Simplane.getIsGrounded() && plan.length > 1) {
            const directIcao = plan.getLeg(plan.activeLateralLeg).leg.fixIcao;
            this.removeDirectToExisting();
            if (this.getDirectToState() !== DirectToState.TORANDOM) {
                this.buildRandomDirectTo(directIcao);
            }
        }
        plan.setLateralLeg(plan.activeLateralLeg - Utils.Clamp(plan.activeLateralLeg - segment.offset, 0, segment.legs.length));
        plan.removeSegment(segmentIndex, notify);
        plan.calculate(plan.activeLateralLeg - 1);
    }
    /**
     * Checks whether of two consecutive flight plan legs, the second is a duplicate of the first. The second leg is
     * considered a duplicate if and only if it is an IF, TF, or DF leg with the same terminator fix as the first leg,
     * which is also an IF, TF, or DF leg.
     * @param leg1 The first leg.
     * @param leg2 The second leg.
     * @returns whether the second leg is a duplicate of the first.
     */
    isDuplicateLeg(leg1, leg2) {
        if (leg2.type !== LegType.IF
            && leg2.type !== LegType.DF
            && leg2.type !== LegType.TF) {
            return false;
        }
        return (leg1.type === LegType.IF
            || leg1.type === LegType.TF
            || leg1.type === LegType.DF)
            && leg1.fixIcao === leg2.fixIcao;
    }
    /**
     * Checks whether of two consecutive flight plan legs, the second is an IF leg and is a duplicate of the first. The
     * IF leg is considered a duplicate if and only if its fix is the same as the fix at which the first leg terminates.
     * @param leg1 The first leg.
     * @param leg2 The second leg.
     * @returns whether the second leg is an duplicate IF leg of the first.
     */
    isDuplicateIFLeg(leg1, leg2) {
        if (leg2.type !== LegType.IF) {
            return false;
        }
        if (leg1.type !== LegType.TF
            && leg1.type !== LegType.DF
            && leg1.type !== LegType.RF
            && leg1.type !== LegType.CF
            && leg1.type !== LegType.AF
            && leg1.type !== LegType.IF) {
            return false;
        }
        return leg1.fixIcao === leg2.fixIcao;
    }
    /**
     * Merges two duplicate legs such that the new merged leg contains the fix type and altitude data from the source leg
     * and all other data is derived from the target leg.
     * @param target The target leg.
     * @param source The source leg.
     * @returns the merged leg.
     */
    mergeDuplicateLegData(target, source) {
        const merged = FlightPlan.createLeg(target);
        merged.fixTypeFlags |= source.fixTypeFlags;
        merged.altDesc = source.altDesc;
        merged.altitude1 = source.altitude1;
        merged.altitude2 = source.altitude2;
        return merged;
    }
    /**
     * Deletes one of two consecutive duplicate legs. If one leg is in a procedure and the other is not, the leg that is
     * not in a procedure will be deleted. If the legs are in different procedures, the earlier leg will be deleted.
     * Otherwise, the later leg will be deleted. If the deleted leg is the target leg of a direct to, the legs in the
     * direct to sequence will be copied and moved to immediately follow the duplicate leg that was not deleted.
     * @param leg1 The first duplicate leg.
     * @param leg2 The second duplicate leg.
     * @returns the leg that was deleted, or null if neither leg was deleted.
     * @throws Error if direct to legs could not be updated.
     */
    planRemoveDuplicateLeg(leg1, leg2) {
        const plan = this.getFlightPlan();
        const leg1Segment = plan.getSegmentFromLeg(leg1);
        const leg1Index = plan.getLegIndexFromLeg(leg1);
        const leg2Segment = plan.getSegmentFromLeg(leg2);
        const leg2Index = plan.getLegIndexFromLeg(leg2);
        if (!leg1Segment || !leg2Segment) {
            return null;
        }
        const isLeg1DirectToLeg = leg1.isInDirectToSequence;
        const isLeg2DirectToLeg = leg2.isInDirectToSequence;
        const dupDirectToLeg = isLeg1DirectToLeg ? leg1
            : isLeg2DirectToLeg ? leg2
                : null;
        if (dupDirectToLeg) {
            if (dupDirectToLeg.leg.type === LegType.IF) {
                // Technically this should never happen.
                return null;
            }
            else {
                // If one of the duplicates is the second leg in a direct to sequence, then the true duplicated leg is the
                // target leg of the DTO. In this case, we call this method with the DTO target leg replacing the DTO leg.
                const dtoTargetLeg = plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex];
                return isLeg1DirectToLeg ? this.planRemoveDuplicateLeg(dtoTargetLeg, leg2) : this.planRemoveDuplicateLeg(leg1, dtoTargetLeg);
            }
        }
        const isLeg1InProc = leg1Segment.segmentType !== FlightPlanSegmentType.Enroute;
        const isLeg2InProc = leg2Segment.segmentType !== FlightPlanSegmentType.Enroute;
        let toDeleteSegment;
        let toDeleteIndex;
        let toDeleteLeg;
        if (!isLeg1InProc && isLeg2InProc || (isLeg1InProc && isLeg2InProc && leg1Segment !== leg2Segment)) {
            toDeleteSegment = leg1Segment;
            toDeleteIndex = leg1Index - leg1Segment.offset;
            toDeleteLeg = leg1;
        }
        else {
            toDeleteSegment = leg2Segment;
            toDeleteIndex = leg2Index - leg2Segment.offset;
            leg1.leg = this.mergeDuplicateLegData(leg1.leg, leg2.leg);
            toDeleteLeg = leg2;
        }
        if (toDeleteIndex >= 0) {
            const dtoTargetLeg = plan.directToData.segmentIndex < 0 ? null : plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex];
            const needMoveDtoLegs = toDeleteLeg === dtoTargetLeg;
            if (needMoveDtoLegs) {
                const isDtoExistingActive = this.getDirectToState() === DirectToState.TOEXISTING;
                // If the removed leg was the target leg of a DTO existing, we need to shift the DTO legs to target the leg
                // that was not removed.
                const oldDiscoLeg = plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                const oldDtoLeg1 = plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                const oldDtoLeg2 = plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                if (!oldDtoLeg1 || !oldDtoLeg2 || !oldDiscoLeg) {
                    throw new Error(`Fms: Could not remove direct to legs starting at segment index ${plan.directToData.segmentIndex}, leg index ${plan.directToData.segmentLegIndex} during duplicate leg resolution.`);
                }
                const preservedLeg = toDeleteLeg === leg1 ? leg2 : leg1;
                const preservedLegIndex = plan.getLegIndexFromLeg(preservedLeg);
                const newTargetSegmentIndex = plan.getSegmentIndex(preservedLegIndex);
                const newTargetSegmentLegIndex = preservedLegIndex - plan.getSegment(newTargetSegmentIndex).offset;
                plan.setDirectToData(newTargetSegmentIndex, newTargetSegmentLegIndex);
                plan.addLeg(newTargetSegmentIndex, FlightPlan.createLeg(oldDiscoLeg.leg), newTargetSegmentLegIndex + 1, true);
                plan.addLeg(newTargetSegmentIndex, FlightPlan.createLeg(oldDtoLeg1.leg), newTargetSegmentLegIndex + 2, true);
                plan.addLeg(newTargetSegmentIndex, FlightPlan.createLeg(oldDtoLeg2.leg), newTargetSegmentLegIndex + 3, true);
                if (isDtoExistingActive) {
                    plan.setLateralLeg(preservedLegIndex + 3);
                }
            }
            const success = this.planRemoveLeg(toDeleteSegment.segmentIndex, toDeleteIndex, true, false, needMoveDtoLegs);
            if (success) {
                return toDeleteLeg;
            }
        }
        return null;
    }
    /**
     * Loads an approach frequency into the fms.
     * @param facility The airport facility.
     * @param approachIndex The approach Index.
     */
    loadApproachFrequency(facility, approachIndex) {
        this.approachFrequency.set(FmsUtils.getApproachFrequency(facility, approachIndex));
    }
    /**
     * Loads an approach frequency into the fms.
     * @param radioIndex The radio index to set (1 or 2).
     * @param forceNotify resets the subject to force a cross-instrument notification.
     */
    setLocFrequency(radioIndex, forceNotify = false) {
        const setActive = this.cdiSource.type === NavSourceType.Gps || this.cdiSource.index !== radioIndex;
        const approachFrequency = this.approachFrequency.get();
        if (forceNotify) {
            this.approachFrequency.set(undefined);
            this.approachFrequency.set(approachFrequency);
        }
        if (approachFrequency !== undefined && radioIndex > 0 && radioIndex < 3) {
            SimVar.SetSimVarValue(`K:NAV${radioIndex}_STBY_SET_HZ`, 'Hz', approachFrequency.freqMHz * 1000000);
            if (setActive) {
                SimVar.SetSimVarValue(`K:NAV${radioIndex}_RADIO_SWAP`, 'Bool', 1);
            }
        }
    }
    /**
     * Sets the approach details for the loaded approach and sends an event across the bus.
     * @param approachLoaded Whether an approach is loaded.
     * @param approachType The approach type.
     * @param approachRnavType The approach RNAV type.
     * @param approachIsActive Whether the approach is active.
     */
    setApproachDetails(approachLoaded, approachType, approachRnavType, approachIsActive) {
        const approachDetails = {
            approachLoaded: approachLoaded !== undefined ? approachLoaded : this.approachDetails.approachLoaded,
            approachType: approachType !== undefined ? approachType : this.approachDetails.approachType,
            approachRnavType: approachRnavType !== undefined ? approachRnavType : this.approachDetails.approachRnavType,
            approachIsActive: approachIsActive !== undefined ? approachIsActive : this.approachDetails.approachIsActive
        };
        if (approachDetails.approachIsActive && !approachDetails.approachLoaded) {
            this.checkApproachState();
            return;
        }
        if (approachDetails !== this.approachDetails) {
            this.approachDetails = approachDetails;
            Fms.g1000EvtPub.publishEvent('approach_details_set', this.approachDetails);
        }
    }
}
Fms.PRIMARY_PLAN_INDEX = 0;
Fms.DTO_RANDOM_PLAN_INDEX = 1;
Fms.PROC_PREVIEW_PLAN_INDEX = 2;

var LNavVars;
(function (LNavVars) {
    /** The name of the LVar used to publish the current dtk (magnetic). */
    LNavVars["DTK"] = "L:WT1000_LNav_DTK_Mag";
    /** The name of the LVar used to publish the current xtk. */
    LNavVars["XTK"] = "L:WT1000_LNav_XTK";
    /** The name of the LVar used to publish the next dtk (magnetic). */
    LNavVars["NextDTK"] = "L:WT1000_LNav_Next_DTK_Mag";
    /** The name of the LVar used to publish the next xtk. */
    LNavVars["NextXTK"] = "L:WT1000_LNav_Next_XTK";
    /** The name of the LVar used to publish the bearing (magnetic) to the current waypoint. */
    LNavVars["Bearing"] = "L:WT1000_LNav_BRG_Mag";
    /** The name of the LVar used to publish the distance to the current waypoint. */
    LNavVars["Distance"] = "L:WT1000_LNav_DIS";
    /** The name of the LVar used to publish the distance to the current waypoint. */
    LNavVars["DistanceToTurn"] = "L:WT1000_LNav_DIS_Turn";
    /** Whether or not the LNAV is in a leg-to-leg turn. */
    LNavVars["IsTurning"] = "L:WT1000_LNav_IsTurning";
    /** The current max CDI deflection, in NM. */
    LNavVars["CDIScale"] = "L:WT1000_CDI_Scale";
    /** The current value of the CDI scale label enum. */
    LNavVars["CDIScaleLabel"] = "L:WT1000_CDI_Scale_Label";
    /** The current index of the vector LNAV is tracking. */
    LNavVars["CurrentVector"] = "L:WT1000_LNav_Current_Vector";
    /** The current calculated Distance to the Destination. */
    LNavVars["DistanceToDestination"] = "L:WT1000_LNav_Destination_Dis";
})(LNavVars || (LNavVars = {}));
/**
 * Valid CDI scale labels for the LVar scale enum.
 */
var CDIScaleLabel;
(function (CDIScaleLabel) {
    CDIScaleLabel[CDIScaleLabel["Departure"] = 0] = "Departure";
    CDIScaleLabel[CDIScaleLabel["Terminal"] = 1] = "Terminal";
    CDIScaleLabel[CDIScaleLabel["Enroute"] = 2] = "Enroute";
    CDIScaleLabel[CDIScaleLabel["Oceanic"] = 3] = "Oceanic";
    CDIScaleLabel[CDIScaleLabel["LNav"] = 4] = "LNav";
    CDIScaleLabel[CDIScaleLabel["LNavPlusV"] = 5] = "LNavPlusV";
    CDIScaleLabel[CDIScaleLabel["Visual"] = 6] = "Visual";
    CDIScaleLabel[CDIScaleLabel["LNavVNav"] = 7] = "LNavVNav";
    CDIScaleLabel[CDIScaleLabel["LP"] = 8] = "LP";
    CDIScaleLabel[CDIScaleLabel["LPPlusV"] = 9] = "LPPlusV";
    CDIScaleLabel[CDIScaleLabel["LPV"] = 10] = "LPV";
    CDIScaleLabel[CDIScaleLabel["MissedApproach"] = 11] = "MissedApproach";
})(CDIScaleLabel || (CDIScaleLabel = {}));
/** A publisher to poll and publish nav/com simvars. */
class LNavSimVarPublisher extends SimVarPublisher {
    /**
     * Create a NavComSimVarPublisher
     * @param bus The EventBus to publish to
     */
    constructor(bus) {
        super(LNavSimVarPublisher.simvars, bus);
    }
}
LNavSimVarPublisher.simvars = new Map([
    ['lnavBrgMag', { name: LNavVars.Bearing, type: SimVarValueType.Degree }],
    ['lnavDis', { name: LNavVars.Distance, type: SimVarValueType.NM }],
    ['lnavDisTurn', { name: LNavVars.DistanceToTurn, type: SimVarValueType.NM }],
    ['lnavDtkMag', { name: LNavVars.DTK, type: SimVarValueType.Degree }],
    ['lnavXtk', { name: LNavVars.XTK, type: SimVarValueType.NM }],
    ['lnavNextDtkMag', { name: LNavVars.NextDTK, type: SimVarValueType.Degree }],
    ['lnavNextXtkMag', { name: LNavVars.NextXTK, type: SimVarValueType.NM }],
    ['lnavCdiScaling', { name: LNavVars.CDIScale, type: SimVarValueType.NM }],
    ['lnavCdiScalingLabel', { name: LNavVars.CDIScaleLabel, type: SimVarValueType.Number }],
    ['lnavCurrentVector', { name: LNavVars.CurrentVector, type: SimVarValueType.Number }],
    ['lnavDistanceToDestination', { name: LNavVars.DistanceToDestination, type: SimVarValueType.NM }],
]);

/**
 * Events published by the VNAV system on the bus.
 */
var VNavSimVars;
(function (VNavSimVars) {
    /** The vertical deviation. */
    VNavSimVars["VerticalDeviation"] = "L:WT1000_VNav_Vertical_Deviation";
    /** The VNAV target altitude. */
    VNavSimVars["TargetAltitude"] = "L:WT1000_VNav_Target_Altitude";
    /** The VNAV path mode. */
    VNavSimVars["PathMode"] = "L:WT1000_VNav_Path_Mode";
    /** The VNAV mode. */
    VNavSimVars["VNAVMode"] = "L:WT1000_VNav_Mode";
    /** The VNAV approach guidance mode. */
    VNavSimVars["ApproachMode"] = "L:WT1000_VNav_Approach_Mode";
    /** The distance to the next TOD, or -1 if one does not exist. */
    VNavSimVars["TODDistance"] = "L:WT1000_VNav_Distance_To_TOD";
    /** The index of the leg for the next TOD. */
    VNavSimVars["TODLegIndex"] = "L:WT1000_VNav_TOD_Leg_Index";
    /** The distance from the end of the TOD leg that the TOD is. */
    VNavSimVars["TODDistanceInLeg"] = "L:WT1000_VNav_TOD_Distance_In_Leg";
    /** The index of the leg for the next BOD. */
    VNavSimVars["BODLegIndex"] = "L:WT1000_VNav_BOD_Leg_Index";
    /** The index of the leg for the next constraint. */
    VNavSimVars["CurrentConstraintLegIndex"] = "L:WT1000_VNav_Constraint_Leg_Index";
    /** The current constraint altitude. */
    VNavSimVars["CurrentConstraintAltitude"] = "L:WT1000_VNav_Constraint_Altitude";
    /** The distance to the next BOD, or -1 if one does not exist. */
    VNavSimVars["BODDistance"] = "L:WT1000_VNav_Distance_To_BOD";
    /** The VNAV current altitude capture type. */
    VNavSimVars["CaptureType"] = "L:WT1000_VNav_Alt_Capture_Type";
    /** The current required flight path angle. */
    VNavSimVars["FPA"] = "L:WT1000_VNav_FPA";
    /** The current LPV vertical deviation. */
    VNavSimVars["LPVVerticalDeviation"] = "L:WT1000_LPV_Vertical_Deviation";
    /** The current remaining LPV distance. */
    VNavSimVars["LPVDistance"] = "L:WT1000_LPV_Distance";
    /** The required VS to the current constraint. */
    VNavSimVars["RequiredVS"] = "L:WT1000_VNAV_Required_VS";
})(VNavSimVars || (VNavSimVars = {}));
/** A publisher to poll and publish nav/com simvars. */
class VNavSimVarPublisher extends SimVarPublisher {
    /**
     * Create a NavComSimVarPublisher
     * @param bus The EventBus to publish to
     */
    constructor(bus) {
        super(VNavSimVarPublisher.simvars, bus);
    }
}
VNavSimVarPublisher.simvars = new Map([
    ['vnavVDev', { name: VNavSimVars.VerticalDeviation, type: SimVarValueType.Feet }],
    ['vnavTargetAlt', { name: VNavSimVars.TargetAltitude, type: SimVarValueType.Feet }],
    ['vnavPathMode', { name: VNavSimVars.PathMode, type: SimVarValueType.Number }],
    ['vnavMode', { name: VNavSimVars.VNAVMode, type: SimVarValueType.Number }],
    ['vnavApproachMode', { name: VNavSimVars.ApproachMode, type: SimVarValueType.Number }],
    ['vnavTodDistance', { name: VNavSimVars.TODDistance, type: SimVarValueType.Number }],
    ['vnavTodLegDistance', { name: VNavSimVars.TODDistanceInLeg, type: SimVarValueType.Number }],
    ['vnavTodLegIndex', { name: VNavSimVars.TODLegIndex, type: SimVarValueType.Number }],
    ['vnavBodLegIndex', { name: VNavSimVars.BODLegIndex, type: SimVarValueType.Number }],
    ['vnavConstraintLegIndex', { name: VNavSimVars.CurrentConstraintLegIndex, type: SimVarValueType.Number }],
    ['vnavConstraintAltitude', { name: VNavSimVars.CurrentConstraintAltitude, type: SimVarValueType.Feet }],
    ['vnavBodDistance', { name: VNavSimVars.BODDistance, type: SimVarValueType.Number }],
    ['vnavAltCaptureType', { name: VNavSimVars.CaptureType, type: SimVarValueType.Number }],
    ['vnavFpa', { name: VNavSimVars.FPA, type: SimVarValueType.FPM }],
    ['vnavLpvVDev', { name: VNavSimVars.LPVVerticalDeviation, type: SimVarValueType.Feet }],
    ['vnavLpvDistance', { name: VNavSimVars.LPVDistance, type: SimVarValueType.Number }],
    ['vnavRequiredVs', { name: VNavSimVars.RequiredVS, type: SimVarValueType.Number }]
]);

var APVerticalModes;
(function (APVerticalModes) {
    APVerticalModes[APVerticalModes["NONE"] = 0] = "NONE";
    APVerticalModes[APVerticalModes["PITCH"] = 1] = "PITCH";
    APVerticalModes[APVerticalModes["VS"] = 2] = "VS";
    APVerticalModes[APVerticalModes["FLC"] = 3] = "FLC";
    APVerticalModes[APVerticalModes["ALT"] = 4] = "ALT";
    APVerticalModes[APVerticalModes["VNAV"] = 5] = "VNAV";
    APVerticalModes[APVerticalModes["GP"] = 6] = "GP";
    APVerticalModes[APVerticalModes["GS"] = 7] = "GS";
    APVerticalModes[APVerticalModes["CAP"] = 8] = "CAP";
})(APVerticalModes || (APVerticalModes = {}));
var APLateralModes;
(function (APLateralModes) {
    APLateralModes[APLateralModes["NONE"] = 0] = "NONE";
    APLateralModes[APLateralModes["ROLL"] = 1] = "ROLL";
    APLateralModes[APLateralModes["LEVEL"] = 2] = "LEVEL";
    APLateralModes[APLateralModes["GPSS"] = 3] = "GPSS";
    APLateralModes[APLateralModes["HEADING"] = 4] = "HEADING";
    APLateralModes[APLateralModes["VOR"] = 5] = "VOR";
    APLateralModes[APLateralModes["LOC"] = 6] = "LOC";
    APLateralModes[APLateralModes["BC"] = 7] = "BC";
    APLateralModes[APLateralModes["NAV"] = 8] = "NAV";
})(APLateralModes || (APLateralModes = {}));
var APAltitudeModes;
(function (APAltitudeModes) {
    APAltitudeModes[APAltitudeModes["NONE"] = 0] = "NONE";
    APAltitudeModes[APAltitudeModes["ALTS"] = 1] = "ALTS";
    APAltitudeModes[APAltitudeModes["ALTV"] = 2] = "ALTV";
})(APAltitudeModes || (APAltitudeModes = {}));

/** AP Mode Types */
var APModeType;
(function (APModeType) {
    APModeType[APModeType["LATERAL"] = 0] = "LATERAL";
    APModeType[APModeType["VERTICAL"] = 1] = "VERTICAL";
    APModeType[APModeType["APPROACH"] = 2] = "APPROACH";
})(APModeType || (APModeType = {}));
/**
 * A class that manages the autopilot modes and autopilot mode states.
 */
class APStateManager {
    /**
     * Creates an instance of the APStateManager.
     * @param bus An instance of the event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.apListenerRegistered = Subject.create(false);
        this.isBound = Subject.create(false);
        this.managedModeSet = false;
        this.stateManagerInitialized = Subject.create(false);
        this.lateralPressed = new SubEvent();
        this.verticalPressed = new SubEvent();
        this.approachPressed = new SubEvent();
        this.vnavPressed = new SubEvent();
        this.apMasterOn = Subject.create(false);
        this.fdMasterOn = Subject.create(false);
        // HINT: we do this purely to try avoid the weird CTD
        setTimeout(() => {
            this.keyListener = RegisterViewListener('JS_LISTENER_KEYEVENT', () => {
                if (this.isBound.get()) {
                    return;
                }
                this.setupKeyIntercepts();
                this.isBound.set(true);
                Coherent.on('keyIntercepted', this.handleKeyIntercepted.bind(this));
            });
        }, 3000);
        this.apListener = RegisterViewListener('JS_LISTENER_AUTOPILOT', () => {
            this.onAPListenerRegistered();
            this.apListenerRegistered.set(true);
        });
    }
    /**
     * A callback which is called when the autopilot listener has been registered.
     */
    onAPListenerRegistered() {
        const ap = this.bus.getSubscriber();
        ap.on('ap_lock_set').handle(lock => {
            if (lock === APLockType.VNav) {
                this.vnavPressed.notify(this, true);
            }
        });
        ap.on('ap_lock_release').handle(lock => {
            if (lock === APLockType.VNav) {
                this.vnavPressed.notify(this, false);
            }
        });
        ap.on('ap_master_disengage').handle(() => {
            this.apMasterOn.set(false);
        });
        ap.on('ap_master_engage').handle(() => {
            this.apMasterOn.set(true);
        });
        ap.on('flight_director_state').whenChanged().handle((fd) => {
            this.fdMasterOn.set(fd);
        });
    }
    /**
     * Checks whether the AP State Manager has completed listerner steps,
     * and if so, finishes initializing and then notifies Autopilot of the same.
     * @param force forces the initialize
     */
    initialize(force = false) {
        this.onBeforeInitialize();
        if (force || (this.isBound.get() && this.apListenerRegistered.get())) {
            this.setManagedMode(true).then(() => {
                SimVar.SetSimVarValue('AUTOPILOT ALTITUDE LOCK VAR', SimVarValueType.Feet, 0);
                if (this.fdMasterOn.get()) {
                    this.setFlightDirector(false);
                }
                this.stateManagerInitialized.set(true);
            });
        }
    }
    /**
     * Sets the Flight Director State
     * @param on is wheter to set the FD On.
     */
    setFlightDirector(on) {
        if (on !== this.fdMasterOn.get()) {
            SimVar.SetSimVarValue('K:TOGGLE_FLIGHT_DIRECTOR', 'number', 0);
        }
    }
    /**
     * Sets Managed Mode.
     * @param set is wheter to set or unset managed mode.
     */
    async setManagedMode(set) {
        return new Promise(resolve => {
            setTimeout(() => {
                if (set) {
                    Coherent.call('apSetAutopilotMode', MSFSAPStates.AvionicsManaged, 1).then(() => resolve());
                }
                else {
                    Coherent.call('apSetAutopilotMode', MSFSAPStates.AvionicsManaged, 0).then(() => resolve());
                }
                this.managedModeSet = set;
            }, 1000);
        });
    }
    /**
     * Toggles VNAV L Var value.
     */
    toggleVnav() {
        const vnavXmlVarValue = SimVar.GetSimVarValue('L:XMLVAR_VNAVButtonValue', 'Bool');
        SimVar.SetSimVarValue('L:XMLVAR_VNAVButtonValue', 'Bool', vnavXmlVarValue ? 0 : 1);
    }
    /**
     * Sends AP Mode Events from the Intercept to the Autopilot.
     * @param type is the AP Mode Type for this event
     * @param mode is the mode to set/unset.
     * @param set is whether to actively set or unset this mode.
     */
    sendApModeEvent(type, mode, set) {
        switch (type) {
            case APModeType.LATERAL:
                if (mode !== undefined) {
                    this.lateralPressed.notify(this, { mode: mode, set: set });
                }
                break;
            case APModeType.VERTICAL:
                if (mode !== undefined) {
                    this.verticalPressed.notify(this, { mode: mode, set: set });
                }
                break;
            case APModeType.APPROACH:
                this.approachPressed.notify(this, set);
                break;
        }
    }
    /**
     * Method to override with steps to run before initialze method is run.
     */
    onBeforeInitialize() {
        //noop
    }
}

var APStates;
(function (APStates) {
    APStates[APStates["None"] = 0] = "None";
    APStates[APStates["APActive"] = 1] = "APActive";
    APStates[APStates["YawDamper"] = 2] = "YawDamper";
    APStates[APStates["Heading"] = 4] = "Heading";
    APStates[APStates["Nav"] = 8] = "Nav";
    APStates[APStates["NavArmed"] = 16] = "NavArmed";
    APStates[APStates["Approach"] = 32] = "Approach";
    APStates[APStates["ApproachArmed"] = 64] = "ApproachArmed";
    APStates[APStates["Backcourse"] = 128] = "Backcourse";
    APStates[APStates["BackcourseArmed"] = 256] = "BackcourseArmed";
    APStates[APStates["Alt"] = 512] = "Alt";
    APStates[APStates["AltS"] = 1024] = "AltS";
    APStates[APStates["AltV"] = 2048] = "AltV";
    APStates[APStates["VS"] = 4096] = "VS";
    APStates[APStates["FLC"] = 8192] = "FLC";
    APStates[APStates["GP"] = 16384] = "GP";
    APStates[APStates["GPArmed"] = 32768] = "GPArmed";
    APStates[APStates["GS"] = 65536] = "GS";
    APStates[APStates["GSArmed"] = 131072] = "GSArmed";
    APStates[APStates["Path"] = 262144] = "Path";
    APStates[APStates["PathArmed"] = 524288] = "PathArmed";
    APStates[APStates["PathInvalid"] = 1048576] = "PathInvalid";
    APStates[APStates["Pitch"] = 2097152] = "Pitch";
    APStates[APStates["Roll"] = 4194304] = "Roll";
    APStates[APStates["VNAV"] = 8388608] = "VNAV";
    APStates[APStates["ATSpeed"] = 16777216] = "ATSpeed";
    APStates[APStates["ATMach"] = 33554432] = "ATMach";
    APStates[APStates["ATArmed"] = 67108864] = "ATArmed";
    APStates[APStates["FD"] = 134217728] = "FD";
})(APStates || (APStates = {}));

/**
 * A bank angle controller that maintains a constant radius turn.
 */
class ArcTurnController {
    constructor() {
        this.bankController = new PidController(1.5, 0, 0, 15, -15);
        this.precessionController = new PidController(0.025, 0, 0, 300, -300);
        this.previousTime = new Date().appTime();
        this.filter = new ExpSmoother(500);
    }
    /**
     * Gets the bank angle output for a given radius error.
     * @param radiusError The radius error.
     * @returns The bank angle output.
     */
    getOutput(radiusError) {
        var _a;
        const currentTime = new Date().appTime();
        const dTime = currentTime - this.previousTime;
        let bankAngle = 0;
        if (this.previousRadiusError !== undefined) {
            const input = ((radiusError - this.previousRadiusError) / dTime) * 1000;
            const precessionRate = isNaN((_a = this.filter.last()) !== null && _a !== void 0 ? _a : NaN)
                ? this.filter.reset(input)
                : this.filter.next(input, dTime);
            const targetPrecessionRate = -this.precessionController.getOutput(dTime, radiusError);
            const precessionError = targetPrecessionRate - precessionRate;
            bankAngle = this.bankController.getOutput(dTime, precessionError);
            SimVar.SetSimVarValue('L:AP_RADUIS_ERROR', 'number', radiusError);
            SimVar.SetSimVarValue('L:AP_PRECESSION_RATE', 'number', precessionRate);
            SimVar.SetSimVarValue('L:AP_TARGET_PRECESSION_RATE', 'number', targetPrecessionRate);
            SimVar.SetSimVarValue('L:AP_BANK_ADJUSTMENT', 'number', bankAngle);
        }
        this.previousTime = currentTime;
        this.previousRadiusError = radiusError;
        return -bankAngle;
    }
    /**
     * Resets the controller.
     */
    reset() {
        this.previousTime = Date.now();
        this.previousRadiusError = undefined;
        this.precessionController.reset();
        this.bankController.reset();
    }
}

/**
 * The state of a given plane director.
 */
var DirectorState;
(function (DirectorState) {
    /** The plane director is not currently armed or active. */
    DirectorState["Inactive"] = "Inactive";
    /** The plane director is currently armed. */
    DirectorState["Armed"] = "Armed";
    /** The plane director is currently active. */
    DirectorState["Active"] = "Active";
})(DirectorState || (DirectorState = {}));

/**
 * The current vertical navigation mode.
 */
var VNavMode;
(function (VNavMode) {
    /** No vertical navigation mode is selected. */
    VNavMode[VNavMode["None"] = 0] = "None";
    /** VNAV is following the VNAV profile. */
    VNavMode[VNavMode["VNAV"] = 1] = "VNAV";
    /** VNAV is following an RNAV approach profile. */
    VNavMode[VNavMode["RNAV"] = 2] = "RNAV";
    /** VNAV is following ILS beacon guidance. */
    VNavMode[VNavMode["ILS"] = 3] = "ILS";
})(VNavMode || (VNavMode = {}));
/**
 * The current VNAV path mode.
 */
var VNavPathMode;
(function (VNavPathMode) {
    /** VNAV path is not active. */
    VNavPathMode[VNavPathMode["None"] = 0] = "None";
    /** VNAV path is armed for capture. */
    VNavPathMode[VNavPathMode["PathArmed"] = 1] = "PathArmed";
    /** VNAV path is actively navigating. */
    VNavPathMode[VNavPathMode["PathActive"] = 2] = "PathActive";
    /** The current VNAV path is not valid. */
    VNavPathMode[VNavPathMode["PathInvalid"] = 3] = "PathInvalid";
})(VNavPathMode || (VNavPathMode = {}));
/**
 * The current VNAV approach guidance mode.
 */
var VNavApproachGuidanceMode;
(function (VNavApproachGuidanceMode) {
    /** VNAV is not currently following approach guidance. */
    VNavApproachGuidanceMode[VNavApproachGuidanceMode["None"] = 0] = "None";
    /** VNAV has armed ILS glideslope guidance for capture. */
    VNavApproachGuidanceMode[VNavApproachGuidanceMode["GSArmed"] = 1] = "GSArmed";
    /** VNAV is actively following ILS glideslope guidance. */
    VNavApproachGuidanceMode[VNavApproachGuidanceMode["GSActive"] = 2] = "GSActive";
    /** VNAV RNAV glidepath guidance is armed for capture. */
    VNavApproachGuidanceMode[VNavApproachGuidanceMode["GPArmed"] = 3] = "GPArmed";
    /** VNAV is actively follow RNAV glidepath guidance. */
    VNavApproachGuidanceMode[VNavApproachGuidanceMode["GPActive"] = 4] = "GPActive";
})(VNavApproachGuidanceMode || (VNavApproachGuidanceMode = {}));
/**
 * The current VNAV altitude capture type.
 */
var VNavAltCaptureType;
(function (VNavAltCaptureType) {
    /** Altitude capture is not armed. */
    VNavAltCaptureType[VNavAltCaptureType["None"] = 0] = "None";
    /** Altitude will capture the selected altitude. */
    VNavAltCaptureType[VNavAltCaptureType["Selected"] = 1] = "Selected";
    /** Altitude will capture the VANV target altitude. */
    VNavAltCaptureType[VNavAltCaptureType["VNAV"] = 2] = "VNAV";
})(VNavAltCaptureType || (VNavAltCaptureType = {}));

/**
 * An Autopilot.
 */
class Autopilot {
    /**
     * Creates an instance of the Autopilot.
     * @param bus The event bus.
     * @param flightPlanner This autopilot's associated flight planner.
     * @param config This autopilot's configuration.
     * @param stateManager This autopilot's state manager.
     */
    constructor(bus, flightPlanner, config, stateManager) {
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.config = config;
        this.stateManager = stateManager;
        this.cdiSource = { type: NavSourceType.Nav, index: 0 };
        this.lateralModes = new Map();
        this.lateralActive = APLateralModes.NONE;
        this.lateralArmed = APLateralModes.NONE;
        this.verticalModes = new Map();
        this.verticalActive = APVerticalModes.NONE;
        this.verticalArmed = APVerticalModes.NONE;
        this.verticalAltitudeArmed = APAltitudeModes.NONE;
        this.verticalApproachArmed = APVerticalModes.NONE;
        this.altCapArmed = false;
        this.lateralModeFailed = false;
        this.inClimb = false;
        this.currentAltitude = 0;
        this.vnavCaptureType = VNavAltCaptureType.None;
        this.apValues = {
            selectedAltitude: Subject.create(0),
            selectedVerticalSpeed: Subject.create(0),
            selectedIas: Subject.create(0),
            selectedPitch: Subject.create(0),
            selectedHeading: Subject.create(0),
            capturedAltitude: Subject.create(0),
            approachIsActive: Subject.create(false),
            approachHasGP: Subject.create(false),
            nav1HasGs: Subject.create(false),
            nav2HasGs: Subject.create(false),
            lateralActive: Subject.create(APLateralModes.NONE),
            verticalActive: Subject.create(APVerticalModes.NONE),
            navToNavLocArm: false
        };
        this.autopilotInitialized = false;
        this.directors = this.createDirectors(config);
        this.navToNavManager = config.createNavToNavManager(this.apValues);
        this.stateManager.stateManagerInitialized.sub((v) => {
            if (v) {
                this.autopilotInitialized = true;
            }
            else {
                this.autopilotInitialized = false;
            }
            this.onInitialized();
        });
        this.flightPlanner.flightPlanSynced.on((sender, v) => {
            if (v) {
                this.stateManager.stateManagerInitialized.set(false);
                this.stateManager.initialize(true);
            }
        });
        this.initLateralModes();
        this.initVerticalModes();
        this.initNavToNavManager();
        this.monitorEvents();
    }
    /**
     * Creates this autopilot's directors.
     * @param config This autopilot's configuration.
     * @returns This autopilot's directors.
     */
    createDirectors(config) {
        return {
            headingDirector: config.createHeadingDirector(this.apValues),
            rollDirector: config.createRollDirector(this.apValues),
            wingLevelerDirector: config.createWingLevelerDirector(this.apValues),
            gpssDirector: config.createGpssDirector(this.apValues),
            vorDirector: config.createVorDirector(this.apValues),
            locDirector: config.createLocDirector(this.apValues),
            bcDirector: config.createBcDirector(this.apValues),
            pitchDirector: config.createPitchDirector(this.apValues),
            vsDirector: config.createVsDirector(this.apValues),
            flcDirector: config.createFlcDirector(this.apValues),
            altHoldDirector: config.createAltHoldDirector(this.apValues),
            altCapDirector: config.createAltCapDirector(this.apValues),
            vnavDirector: config.createVNavDirector(this.apValues),
            gpDirector: config.createGpDirector(this.apValues),
            gsDirector: config.createGsDirector(this.apValues)
        };
    }
    /**
     * Update method for the Autopilot.
     */
    update() {
        if (this.autopilotInitialized) {
            this.onBeforeUpdate();
            this.checkModes();
            this.manageAltitudeCapture();
            this.updateModes();
            this.onAfterUpdate();
        }
    }
    /**
     * This method runs each update cycle before the update occurs.
     */
    onBeforeUpdate() {
        // noop
    }
    /**
     * This method runs each update cycle after the update occurs.
     */
    onAfterUpdate() {
        // noop
    }
    /**
     * This method runs whenever the initialized state of the Autopilot changes.
     */
    onInitialized() {
        // noop
    }
    /**
     * Handles input from the State Manager when a lateral mode button is pressed.
     * @param data is the AP Lateral Mode Event Data
     */
    lateralPressed(data) {
        var _a, _b, _c, _d;
        const mode = data.mode;
        if (mode !== APLateralModes.NAV && !this.lateralModes.has(mode)) {
            return;
        }
        const set = data.set;
        if (set === undefined || set === false) {
            if (this.isLateralModeActivatedOrArmed(mode)) {
                return;
            }
        }
        if (set === undefined || set === true) {
            if (!this.stateManager.fdMasterOn.get()) {
                this.stateManager.setFlightDirector(true);
            }
            switch (mode) {
                case APLateralModes.NONE:
                    break;
                case APLateralModes.LEVEL:
                case APLateralModes.ROLL:
                case APLateralModes.HEADING:
                case APLateralModes.LOC:
                case APLateralModes.BC:
                    (_a = this.lateralModes.get(mode)) === null || _a === void 0 ? void 0 : _a.arm();
                    break;
                case APLateralModes.NAV:
                    if (this.cdiSource.type === NavSourceType.Gps) {
                        (_b = this.lateralModes.get(APLateralModes.GPSS)) === null || _b === void 0 ? void 0 : _b.arm();
                    }
                    else {
                        (_c = this.lateralModes.get(APLateralModes.VOR)) === null || _c === void 0 ? void 0 : _c.arm();
                        (_d = this.lateralModes.get(APLateralModes.LOC)) === null || _d === void 0 ? void 0 : _d.arm();
                    }
                    break;
            }
        }
    }
    /**
     * Handles input from the State Manager when a vertical mode button is pressed.
     * @param data is the AP Vertical Mode Event Data
     */
    verticalPressed(data) {
        var _a;
        const mode = data.mode;
        if (!this.verticalModes.has(mode)) {
            return;
        }
        const set = data.set;
        if (set === undefined || set === false) {
            if (this.isVerticalModeActivatedOrArmed(mode)) {
                return;
            }
        }
        if (set === undefined || set === true) {
            if (!this.stateManager.fdMasterOn.get()) {
                this.stateManager.setFlightDirector(true);
            }
            switch (mode) {
                case APVerticalModes.NONE:
                case APVerticalModes.VNAV:
                    break;
                case APVerticalModes.ALT:
                    this.setAltHold();
                    break;
                case APVerticalModes.PITCH:
                case APVerticalModes.VS:
                case APVerticalModes.FLC:
                case APVerticalModes.GP:
                case APVerticalModes.GS:
                    (_a = this.verticalModes.get(mode)) === null || _a === void 0 ? void 0 : _a.arm();
            }
        }
    }
    /**
     * Checks if a mode is active or armed and optionally deactivates it.
     * @param mode is the AP Mode to check.
     * @returns whether this mode was active or armed and subsequently disabled.
     */
    isLateralModeActivatedOrArmed(mode) {
        var _a, _b, _c, _d, _e, _f;
        switch (mode) {
            case this.lateralActive:
                (_a = this.lateralModes.get(mode)) === null || _a === void 0 ? void 0 : _a.deactivate();
                (_b = this.lateralModes.get(this.config.defaultLateralMode)) === null || _b === void 0 ? void 0 : _b.arm();
                return true;
            case this.lateralArmed:
                (_c = this.lateralModes.get(mode)) === null || _c === void 0 ? void 0 : _c.deactivate();
                this.lateralArmed = APLateralModes.NONE;
                return true;
            case APLateralModes.NAV: {
                const activeNavMode = this.lateralActive === APLateralModes.LOC ? APLateralModes.LOC
                    : this.lateralActive === APLateralModes.VOR ? APLateralModes.VOR
                        : this.lateralActive === APLateralModes.GPSS ? APLateralModes.GPSS
                            : APLateralModes.NONE;
                if (activeNavMode !== APLateralModes.NONE) {
                    (_d = this.lateralModes.get(activeNavMode)) === null || _d === void 0 ? void 0 : _d.deactivate();
                    (_e = this.lateralModes.get(this.config.defaultLateralMode)) === null || _e === void 0 ? void 0 : _e.arm();
                    this.lateralActive = this.config.defaultLateralMode;
                }
                const armedNavMode = this.lateralArmed === APLateralModes.LOC ? APLateralModes.LOC
                    : this.lateralArmed === APLateralModes.VOR ? APLateralModes.VOR
                        : this.lateralArmed === APLateralModes.GPSS ? APLateralModes.GPSS
                            : APLateralModes.NONE;
                if (armedNavMode !== APLateralModes.NONE) {
                    (_f = this.lateralModes.get(armedNavMode)) === null || _f === void 0 ? void 0 : _f.deactivate();
                    this.lateralArmed = APLateralModes.NONE;
                }
                if (armedNavMode !== APLateralModes.NONE || activeNavMode !== APLateralModes.NONE) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Checks if a mode is active or armed and deactivates it.
     * @param mode is the AP Mode to check.
     * @returns whether this mode was active or armed and subsequently disabled.
     */
    isVerticalModeActivatedOrArmed(mode) {
        var _a, _b, _c, _d;
        switch (mode) {
            case this.verticalActive:
                (_a = this.verticalModes.get(mode)) === null || _a === void 0 ? void 0 : _a.deactivate();
                this.verticalActive = this.config.defaultVerticalMode;
                (_b = this.verticalModes.get(this.verticalActive)) === null || _b === void 0 ? void 0 : _b.arm();
                return true;
            case this.verticalArmed:
                if (mode !== APVerticalModes.ALT) {
                    (_c = this.verticalModes.get(mode)) === null || _c === void 0 ? void 0 : _c.deactivate();
                    this.verticalArmed = APVerticalModes.NONE;
                    return true;
                }
                break;
            case this.verticalApproachArmed:
                (_d = this.verticalModes.get(mode)) === null || _d === void 0 ? void 0 : _d.deactivate();
                this.verticalApproachArmed = APVerticalModes.NONE;
                return true;
        }
        return false;
    }
    /**
     * Handles input from the State Manager when the APPR button is pressed.
     * @param set is whether this event commands a specific set
     */
    approachPressed(set) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if ((set === undefined || set === false) && this.isVerticalModeActivatedOrArmed(APVerticalModes.GP)) {
            (_a = this.lateralModes.get(APLateralModes.GPSS)) === null || _a === void 0 ? void 0 : _a.deactivate();
            this.apValues.navToNavLocArm = false;
            return;
        }
        if ((set === undefined || set === false) && this.isVerticalModeActivatedOrArmed(APVerticalModes.GS)) {
            (_b = this.lateralModes.get(APLateralModes.LOC)) === null || _b === void 0 ? void 0 : _b.deactivate();
            this.apValues.navToNavLocArm = false;
            return;
        }
        if (set === undefined || set === true) {
            switch (this.canApproachArm()) {
                case APLateralModes.LOC:
                    if (((_c = this.lateralModes.get(APLateralModes.LOC)) === null || _c === void 0 ? void 0 : _c.state) === DirectorState.Inactive) {
                        (_d = this.lateralModes.get(APLateralModes.LOC)) === null || _d === void 0 ? void 0 : _d.arm();
                    }
                    (_e = this.verticalModes.get(APVerticalModes.GS)) === null || _e === void 0 ? void 0 : _e.arm();
                    break;
                case APLateralModes.GPSS:
                    if (((_f = this.lateralModes.get(APLateralModes.GPSS)) === null || _f === void 0 ? void 0 : _f.state) === DirectorState.Inactive) {
                        (_g = this.lateralModes.get(APLateralModes.GPSS)) === null || _g === void 0 ? void 0 : _g.arm();
                    }
                    (_h = this.verticalModes.get(APVerticalModes.GP)) === null || _h === void 0 ? void 0 : _h.arm();
                    break;
            }
        }
    }
    /**
     * A method to check whether an approach can arm.
     * @returns The AP Lateral Mode that can be armed.
     */
    canApproachArm() {
        switch (this.cdiSource.type) {
            case NavSourceType.Nav:
                if (this.cdiSource.index === 1 && this.apValues.nav1HasGs.get()) {
                    return APLateralModes.LOC;
                }
                else if (this.cdiSource.index === 2 && this.apValues.nav2HasGs.get()) {
                    return APLateralModes.LOC;
                }
                break;
            case NavSourceType.Gps:
                if (this.apValues.approachIsActive.get() && this.apValues.approachHasGP.get()) {
                    return APLateralModes.GPSS;
                }
                else if (this.navToNavManager) {
                    if (this.navToNavManager.canLocArm() && this.apValues.approachIsActive.get()) {
                        this.apValues.navToNavLocArm = true;
                        return APLateralModes.LOC;
                    }
                }
        }
        return APLateralModes.NONE;
    }
    /**
     * Callback to set the lateral active mode.
     * @param mode is the mode being set.
     */
    setLateralActive(mode) {
        this.checkRollModeActive();
        if (mode !== this.lateralActive) {
            const currentMode = this.lateralModes.get(this.lateralActive);
            currentMode === null || currentMode === void 0 ? void 0 : currentMode.deactivate();
            this.lateralActive = mode;
        }
        if (this.lateralArmed === mode) {
            this.lateralArmed = APLateralModes.NONE;
        }
        this.apValues.lateralActive.set(this.lateralActive);
    }
    /**
     * Callback to set the lateral armed mode.
     * @param mode is the mode being set.
     */
    setLateralArmed(mode) {
        const currentMode = this.lateralModes.get(this.lateralArmed);
        currentMode === null || currentMode === void 0 ? void 0 : currentMode.deactivate();
        this.lateralArmed = mode;
    }
    /**
     * Callback to set the vertical active mode.
     * @param mode is the mode being set.
     */
    setVerticalActive(mode) {
        this.checkPitchModeActive();
        if (mode !== this.verticalActive) {
            const currentMode = this.verticalModes.get(this.verticalActive);
            if ((currentMode === null || currentMode === void 0 ? void 0 : currentMode.state) !== DirectorState.Inactive) {
                currentMode === null || currentMode === void 0 ? void 0 : currentMode.deactivate();
            }
            this.verticalActive = mode;
        }
        if (this.verticalArmed === mode) {
            this.verticalArmed = APVerticalModes.NONE;
        }
        else if (this.verticalApproachArmed === mode) {
            this.verticalApproachArmed = APVerticalModes.NONE;
        }
        this.apValues.verticalActive.set(this.verticalActive);
    }
    /**
     * Callback to set the vertical armed mode.
     * @param mode is the mode being set.
     */
    setVerticalArmed(mode) {
        if (mode !== this.verticalArmed) {
            const currentMode = this.verticalModes.get(this.verticalArmed);
            if ((currentMode === null || currentMode === void 0 ? void 0 : currentMode.state) !== DirectorState.Inactive) {
                currentMode === null || currentMode === void 0 ? void 0 : currentMode.deactivate();
            }
        }
        this.verticalArmed = mode;
    }
    /**
     * Callback to set the vertical approach armed mode.
     * @param mode is the mode being set.
     */
    setVerticalApproachArmed(mode) {
        const currentMode = this.verticalModes.get(this.verticalApproachArmed);
        currentMode === null || currentMode === void 0 ? void 0 : currentMode.deactivate();
        this.verticalApproachArmed = mode;
    }
    /**
     * Method called when the ALT button is pressed.
     */
    setAltHold() {
        var _a;
        if (this.verticalModes.has(APVerticalModes.ALT)) {
            const currentAlt = 10 * (this.inClimb ? Math.ceil(this.currentAltitude / 10) : Math.floor(this.currentAltitude / 10));
            this.apValues.capturedAltitude.set(currentAlt);
            (_a = this.verticalModes.get(APVerticalModes.ALT)) === null || _a === void 0 ? void 0 : _a.activate();
        }
    }
    /**
     * Initializes the Autopilot with the available lateral modes from the config.
     */
    initLateralModes() {
        if (this.directors.rollDirector) {
            this.lateralModes.set(APLateralModes.ROLL, this.directors.rollDirector);
            this.directors.rollDirector.onActivate = () => {
                this.setLateralActive(APLateralModes.ROLL);
            };
        }
        if (this.directors.wingLevelerDirector) {
            this.lateralModes.set(APLateralModes.LEVEL, this.directors.wingLevelerDirector);
            this.directors.wingLevelerDirector.onActivate = () => {
                this.setLateralActive(APLateralModes.LEVEL);
            };
        }
        if (this.directors.headingDirector) {
            this.lateralModes.set(APLateralModes.HEADING, this.directors.headingDirector);
            this.directors.headingDirector.onActivate = () => {
                this.setLateralActive(APLateralModes.HEADING);
            };
        }
        if (this.directors.gpssDirector) {
            this.lateralModes.set(APLateralModes.GPSS, this.directors.gpssDirector);
            this.directors.gpssDirector.onArm = () => {
                this.setLateralArmed(APLateralModes.GPSS);
            };
            this.directors.gpssDirector.onActivate = () => {
                this.setLateralActive(APLateralModes.GPSS);
            };
        }
        if (this.directors.vorDirector) {
            this.lateralModes.set(APLateralModes.VOR, this.directors.vorDirector);
            this.directors.vorDirector.onArm = () => {
                this.setLateralArmed(APLateralModes.VOR);
            };
            this.directors.vorDirector.onActivate = () => {
                this.setLateralActive(APLateralModes.VOR);
            };
        }
        if (this.directors.locDirector) {
            this.lateralModes.set(APLateralModes.LOC, this.directors.locDirector);
            this.directors.locDirector.onArm = () => {
                this.setLateralArmed(APLateralModes.LOC);
            };
            this.directors.locDirector.onActivate = () => {
                this.setLateralActive(APLateralModes.LOC);
            };
        }
    }
    /**
     * Initializes the Autopilot with the available Nav To Nav Manager.
     */
    initNavToNavManager() {
        if (this.navToNavManager) {
            this.navToNavManager.onTransferred = () => {
                var _a;
                if (this.lateralActive === APLateralModes.GPSS) {
                    (_a = this.lateralModes.get(APLateralModes.LOC)) === null || _a === void 0 ? void 0 : _a.activate();
                }
                this.apValues.navToNavLocArm = false;
            };
        }
    }
    /**
     * Initializes the Autopilot with the available vertical modes from the config.
     */
    initVerticalModes() {
        if (this.directors.pitchDirector) {
            this.verticalModes.set(APVerticalModes.PITCH, this.directors.pitchDirector);
            this.directors.pitchDirector.onActivate = () => {
                this.setVerticalActive(APVerticalModes.PITCH);
            };
        }
        if (this.directors.vsDirector) {
            this.verticalModes.set(APVerticalModes.VS, this.directors.vsDirector);
            this.directors.vsDirector.onActivate = () => {
                this.setVerticalActive(APVerticalModes.VS);
            };
        }
        if (this.directors.flcDirector) {
            this.verticalModes.set(APVerticalModes.FLC, this.directors.flcDirector);
            this.directors.flcDirector.onActivate = () => {
                this.setVerticalActive(APVerticalModes.FLC);
            };
        }
        if (this.directors.altHoldDirector) {
            this.verticalModes.set(APVerticalModes.ALT, this.directors.altHoldDirector);
            this.directors.altHoldDirector.onArm = () => {
                this.setVerticalArmed(APVerticalModes.ALT);
            };
            this.directors.altHoldDirector.onActivate = () => {
                this.altCapArmed = false;
                this.setVerticalActive(APVerticalModes.ALT);
            };
        }
        if (this.directors.altCapDirector) {
            this.verticalModes.set(APVerticalModes.CAP, this.directors.altCapDirector);
            this.directors.altCapDirector.onArm = () => {
                var _a;
                this.altCapArmed = true;
                if (this.verticalArmed === APVerticalModes.ALT) {
                    (_a = this.verticalModes.get(this.verticalArmed)) === null || _a === void 0 ? void 0 : _a.deactivate();
                }
            };
            this.directors.altCapDirector.onActivate = () => {
                var _a;
                this.altCapArmed = false;
                this.setVerticalActive(APVerticalModes.CAP);
                (_a = this.verticalModes.get(APVerticalModes.ALT)) === null || _a === void 0 ? void 0 : _a.arm();
            };
        }
        if (this.directors.vnavDirector) {
            this.verticalModes.set(APVerticalModes.VNAV, this.directors.vnavDirector);
            this.directors.vnavDirector.onArm = () => {
                this.setVerticalArmed(APVerticalModes.VNAV);
            };
            this.directors.vnavDirector.onActivate = () => {
                this.setVerticalActive(APVerticalModes.VNAV);
            };
            this.directors.vnavDirector.onDeactivate = () => {
                var _a;
                (_a = this.verticalModes.get(APVerticalModes.CAP)) === null || _a === void 0 ? void 0 : _a.activate();
            };
        }
        if (this.directors.gpDirector) {
            this.verticalModes.set(APVerticalModes.GP, this.directors.gpDirector);
            this.directors.gpDirector.onArm = () => {
                this.setVerticalApproachArmed(APVerticalModes.GP);
            };
            this.directors.gpDirector.onActivate = () => {
                var _a;
                this.setVerticalActive(APVerticalModes.GP);
                (_a = this.verticalModes.get(APVerticalModes.VNAV)) === null || _a === void 0 ? void 0 : _a.deactivate();
                this.setVerticalArmed(APVerticalModes.NONE);
                this.setVerticalApproachArmed(APVerticalModes.NONE);
            };
        }
        if (this.directors.gsDirector) {
            this.verticalModes.set(APVerticalModes.GS, this.directors.gsDirector);
            this.directors.gsDirector.onArm = () => {
                this.setVerticalApproachArmed(APVerticalModes.GS);
            };
            this.directors.gsDirector.onActivate = () => {
                var _a;
                this.setVerticalActive(APVerticalModes.GS);
                (_a = this.verticalModes.get(APVerticalModes.VNAV)) === null || _a === void 0 ? void 0 : _a.deactivate();
                this.setVerticalArmed(APVerticalModes.NONE);
                this.setVerticalApproachArmed(APVerticalModes.NONE);
            };
        }
    }
    /**
     * Checks if all the active and armed modes are still in their proper state
     * and takes corrective action if not.
     */
    checkModes() {
        var _a, _b, _c, _d, _e, _f, _g;
        if (this.lateralModeFailed) {
            this.lateralModeFailed = false;
        }
        if (!this.stateManager.apMasterOn.get() && !this.stateManager.fdMasterOn.get()) {
            return;
        }
        if (!this.lateralModes.has(this.lateralActive) || ((_a = this.lateralModes.get(this.lateralActive)) === null || _a === void 0 ? void 0 : _a.state) !== DirectorState.Active) {
            if (this.lateralActive !== APLateralModes.NONE) {
                this.lateralModeFailed = true;
            }
            (_b = this.lateralModes.get(this.config.defaultLateralMode)) === null || _b === void 0 ? void 0 : _b.arm();
        }
        if (this.lateralArmed !== APLateralModes.NONE && (!this.lateralModes.has(this.lateralArmed) || ((_c = this.lateralModes.get(this.lateralArmed)) === null || _c === void 0 ? void 0 : _c.state) !== DirectorState.Armed)) {
            this.setLateralArmed(APLateralModes.NONE);
        }
        if (!this.verticalModes.has(this.verticalActive) || ((_d = this.verticalModes.get(this.verticalActive)) === null || _d === void 0 ? void 0 : _d.state) !== DirectorState.Active) {
            (_e = this.verticalModes.get(APVerticalModes.PITCH)) === null || _e === void 0 ? void 0 : _e.arm();
        }
        if (this.verticalArmed !== APVerticalModes.NONE && (!this.verticalModes.has(this.verticalArmed) || ((_f = this.verticalModes.get(this.verticalArmed)) === null || _f === void 0 ? void 0 : _f.state) !== DirectorState.Armed)) {
            this.setVerticalArmed(APVerticalModes.NONE);
        }
        if (this.verticalApproachArmed !== APVerticalModes.NONE &&
            (!this.verticalModes.has(this.verticalApproachArmed) || ((_g = this.verticalModes.get(this.verticalApproachArmed)) === null || _g === void 0 ? void 0 : _g.state) !== DirectorState.Armed)) {
            this.setVerticalApproachArmed(APVerticalModes.NONE);
        }
    }
    /**
     * Runs update on each of the active and armed modes.
     */
    updateModes() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (this.lateralActive !== APLateralModes.NONE && this.lateralModes.has(this.lateralActive)) {
            (_a = this.lateralModes.get(this.lateralActive)) === null || _a === void 0 ? void 0 : _a.update();
        }
        if (this.lateralArmed !== APLateralModes.NONE && this.lateralModes.has(this.lateralArmed)) {
            (_b = this.lateralModes.get(this.lateralArmed)) === null || _b === void 0 ? void 0 : _b.update();
        }
        if (this.verticalActive !== APVerticalModes.NONE && this.verticalActive !== APVerticalModes.VNAV && this.verticalModes.has(this.verticalActive)) {
            (_c = this.verticalModes.get(this.verticalActive)) === null || _c === void 0 ? void 0 : _c.update();
        }
        if (this.verticalArmed !== APVerticalModes.NONE && this.verticalArmed !== APVerticalModes.VNAV && this.verticalModes.has(this.verticalArmed)) {
            (_d = this.verticalModes.get(this.verticalArmed)) === null || _d === void 0 ? void 0 : _d.update();
        }
        if (this.verticalApproachArmed !== APVerticalModes.NONE && this.verticalModes.has(this.verticalApproachArmed)) {
            (_e = this.verticalModes.get(this.verticalApproachArmed)) === null || _e === void 0 ? void 0 : _e.update();
        }
        if (this.altCapArmed) {
            (_f = this.verticalModes.get(APVerticalModes.CAP)) === null || _f === void 0 ? void 0 : _f.update();
        }
        //while vnav and vnav director are one in the same we always want to
        //run the vnav update cycle no matter the director state
        (_g = this.verticalModes.get(APVerticalModes.VNAV)) === null || _g === void 0 ? void 0 : _g.update();
        //while lnav and lnav director are one in the same we always want to
        //run the lnav update cycle no matter the director state
        (_h = this.lateralModes.get(APLateralModes.GPSS)) === null || _h === void 0 ? void 0 : _h.update();
    }
    /**
     * Checks and sets the proper armed altitude mode.
     */
    manageAltitudeCapture() {
        var _a, _b, _c;
        let altCapType = APAltitudeModes.NONE;
        let armAltCap = false;
        switch (this.verticalActive) {
            case APVerticalModes.VS:
            case APVerticalModes.FLC:
            case APVerticalModes.PITCH:
                if (this.inClimb && this.apValues.selectedAltitude.get() > this.currentAltitude) {
                    altCapType = APAltitudeModes.ALTS;
                    armAltCap = true;
                }
                else if (!this.inClimb && this.apValues.selectedAltitude.get() < this.currentAltitude) {
                    altCapType = APAltitudeModes.ALTS;
                    armAltCap = true;
                }
                break;
            case APVerticalModes.VNAV: {
                if (!this.inClimb) {
                    altCapType = this.vnavCaptureType === VNavAltCaptureType.VNAV ? APAltitudeModes.ALTV : APAltitudeModes.ALTS;
                }
                break;
            }
            case APVerticalModes.CAP:
                altCapType = this.verticalAltitudeArmed;
                break;
        }
        if (this.verticalAltitudeArmed !== altCapType) {
            this.verticalAltitudeArmed = altCapType;
        }
        if (armAltCap && (!this.altCapArmed || ((_a = this.verticalModes.get(APVerticalModes.CAP)) === null || _a === void 0 ? void 0 : _a.state) === DirectorState.Inactive)) {
            (_b = this.verticalModes.get(APVerticalModes.CAP)) === null || _b === void 0 ? void 0 : _b.arm();
        }
        else if (!armAltCap && this.altCapArmed) {
            (_c = this.verticalModes.get(APVerticalModes.CAP)) === null || _c === void 0 ? void 0 : _c.deactivate();
            this.altCapArmed = false;
        }
    }
    /**
     * Monitors subevents and bus events.
     */
    monitorEvents() {
        this.stateManager.lateralPressed.on((sender, data) => {
            if (this.autopilotInitialized && data !== undefined) {
                this.lateralPressed(data);
            }
        });
        this.stateManager.verticalPressed.on((sender, data) => {
            if (this.autopilotInitialized && data !== undefined) {
                this.verticalPressed(data);
            }
        });
        this.stateManager.approachPressed.on((sender, data) => {
            if (this.autopilotInitialized) {
                this.approachPressed(data);
            }
        });
        this.stateManager.vnavPressed.on((sender, data) => {
            var _a, _b;
            if (this.autopilotInitialized) {
                if (data === true) {
                    (_a = this.verticalModes.get(APVerticalModes.VNAV)) === null || _a === void 0 ? void 0 : _a.arm();
                }
                else {
                    (_b = this.verticalModes.get(APVerticalModes.VNAV)) === null || _b === void 0 ? void 0 : _b.deactivate();
                }
            }
        });
        const ap = this.bus.getSubscriber();
        ap.on('alt_select').withPrecision(0).handle((alt) => {
            this.apValues.selectedAltitude.set(alt);
        });
        ap.on('heading_select').withPrecision(0).handle((hdg) => {
            this.apValues.selectedHeading.set(hdg);
        });
        ap.on('flc_hold_knots').withPrecision(0).handle((ias) => {
            this.apValues.selectedIas.set(ias);
        });
        ap.on('pitch_ref').withPrecision(1).handle((pitch) => {
            this.apValues.selectedPitch.set(pitch);
        });
        ap.on('vs_hold_fpm').withPrecision(0).handle((ias) => {
            this.apValues.selectedVerticalSpeed.set(ias);
        });
        const nav = this.bus.getSubscriber();
        nav.on('cdi_select').handle((src) => {
            this.cdiSource = src;
        });
        nav.on('glideslope').handle((gs) => {
            if (gs.source.type === NavSourceType.Nav) {
                switch (gs.source.index) {
                    case 1:
                        this.apValues.nav1HasGs.set(gs.isValid);
                        break;
                    case 2:
                        this.apValues.nav2HasGs.set(gs.isValid);
                        break;
                }
            }
        });
        const adc = this.bus.getSubscriber();
        adc.on('vs').withPrecision(0).handle((vs) => {
            this.inClimb = vs < 1 ? false : true;
        });
        adc.on('alt').withPrecision(0).handle(alt => {
            this.currentAltitude = alt;
        });
        const vnav = this.bus.getSubscriber();
        vnav.on('vnavAltCaptureType').whenChanged().handle((v) => {
            this.vnavCaptureType = v;
        });
        this.stateManager.apMasterOn.sub(() => {
            if (this.autopilotInitialized) {
                this.handleApFdStateChange();
            }
        });
        this.stateManager.fdMasterOn.sub(() => {
            if (this.autopilotInitialized) {
                this.handleApFdStateChange();
            }
        });
    }
    /**
     * Additional events to be monitored (to be overridden).
     */
    monitorAdditionalEvents() {
        //noop
    }
    /**
     * Manages the FD state and the modes when AP/FD are off.
     */
    handleApFdStateChange() {
        const ap = this.stateManager.apMasterOn.get();
        const fd = this.stateManager.fdMasterOn.get();
        if (ap && !fd) {
            SimVar.SetSimVarValue('K:TOGGLE_FLIGHT_DIRECTOR', 'number', 0);
        }
        else if (!ap && !fd) {
            this.lateralModes.forEach((mode) => {
                if (mode.state !== DirectorState.Inactive) {
                    mode.deactivate();
                }
            });
            this.verticalModes.forEach((mode) => {
                if (mode.state !== DirectorState.Inactive) {
                    mode.deactivate();
                }
            });
            this.lateralActive = APLateralModes.NONE;
            this.lateralArmed = APLateralModes.NONE;
            this.verticalActive = APVerticalModes.NONE;
            this.verticalArmed = APVerticalModes.NONE;
            this.verticalApproachArmed = APVerticalModes.NONE;
            this.verticalAltitudeArmed = APAltitudeModes.NONE;
            this.altCapArmed = false;
        }
    }
    /**
     * Sets a sim AP mode.
     * @param mode The mode to set.
     * @param enabled Whether or not the mode is enabled or disabled.
     */
    setSimAP(mode, enabled) {
        Coherent.call('apSetAutopilotMode', mode, enabled ? 1 : 0);
    }
    /**
     * Checks if the sim AP is in roll mode and sets it if not.
     */
    checkRollModeActive() {
        if (!APController.apGetAutopilotModeActive(MSFSAPStates.Bank)) {
            console.log('checkRollModeActive had to set Bank mode');
            this.setSimAP(MSFSAPStates.Bank, true);
        }
    }
    /**
     * Checks if the sim AP is in pitch mode and sets it if not.
     */
    checkPitchModeActive() {
        if (!APController.apGetAutopilotModeActive(MSFSAPStates.Pitch)) {
            console.log('checkPitchModeActive had to set Pitch mode');
            this.setSimAP(MSFSAPStates.Pitch, true);
        }
    }
}

/**
 * A G1000 NXi autopilot.
 */
class G1000Autopilot extends Autopilot {
    constructor() {
        super(...arguments);
        this.externalAutopilotInstalled = Subject.create(false);
        this.lateralArmedModeSubject = Subject.create(APLateralModes.NONE);
        this.altArmedSubject = Subject.create(false);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterUpdate() {
        if (!this.externalAutopilotInstalled.get()) {
            this.updateFma();
        }
        else {
            this.lateralArmedModeSubject.set(this.lateralArmed);
            this.altArmedSubject.set(this.altCapArmed);
        }
        //this.updateFma();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onInitialized() {
        this.monitorAdditionalEvents();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    monitorAdditionalEvents() {
        //check for KAP140 installed
        this.bus.getSubscriber().on('kap_140_installed').handle(v => {
            this.externalAutopilotInstalled.set(v);
            if (v) {
                this.config.defaultVerticalMode = APVerticalModes.VS;
                this.config.defaultLateralMode = APLateralModes.LEVEL;
                this.handleApFdStateChange();
                this.updateFma(true);
                Fms.g1000EvtPub.publishEvent('fd_not_installed', true);
            }
        });
    }
    /**
     * Publishes data for the FMA.
     * @param clear Is to clear the FMA
     */
    updateFma(clear = false) {
        const publisher = this.bus.getPublisher();
        const data = {
            verticalActive: clear ? APVerticalModes.NONE : this.verticalActive,
            verticalArmed: clear ? APVerticalModes.NONE : this.verticalArmed,
            verticalApproachArmed: clear ? APVerticalModes.NONE : this.verticalApproachArmed,
            verticalAltitudeArmed: clear ? APAltitudeModes.NONE : this.verticalAltitudeArmed,
            altitideCaptureArmed: clear ? false : this.altCapArmed,
            altitideCaptureValue: clear ? -1 : this.apValues.capturedAltitude.get(),
            lateralActive: clear ? APLateralModes.NONE : this.lateralActive,
            lateralArmed: clear ? APLateralModes.NONE : this.lateralArmed,
            lateralModeFailed: clear ? false : this.lateralModeFailed
        };
        publisher.pub('fma_modes', data, true);
    }
}

/// <reference types="msfstypes/JS/simvar" />
/**
 * A director that handles OBS Lateral Navigation.
 */
class GpsObsDirector {
    /**
     * Creates an instance of the GPS OBS Director.
     * @param bus The event bus to use with this instance.
     * @param aircraftState Is the current aircraft state.
     */
    constructor(bus, aircraftState) {
        this.bus = bus;
        this.aircraftState = aircraftState;
        this.obsSetting = 0;
        this.obsActive = false;
        this.xtk = undefined;
        this.magvar = 0;
        this.obsLeg = Subject.create(undefined);
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.currentBankRef = 0;
        this.bankServo = new LinearServo(10);
        const hEvent = bus.getSubscriber();
        hEvent.on('hEvent').handle((e) => {
            if (e === 'AS1000_PFD_CRS_INC' || e === 'AS1000_MFD_CRS_INC') {
                this.incrementObs(true);
            }
            else if (e === 'AS1000_PFD_CRS_DEC' || e === 'AS1000_MFD_CRS_DEC') {
                this.incrementObs(false);
            }
        });
        const nav = this.bus.getSubscriber();
        nav.on('gps_obs_active').whenChanged().handle((state) => {
            var _a, _b;
            this.obsActive = state;
            if (this.obsActive) {
                const dtk = (_b = (_a = this.obsLeg.get()) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.initialDtk;
                if (dtk !== undefined) {
                    this.obsSetting = dtk;
                }
                else if (this.obsSetting < 0 || this.obsSetting > 360) {
                    this.obsSetting = 0;
                }
                SimVar.SetSimVarValue('K:GPS_OBS_SET', SimVarValueType.Degree, this.obsSetting);
            }
            if (!this.obsActive) {
                this.deactivate();
            }
        });
        nav.on('gps_obs_value').whenChanged().handle((value) => {
            this.obsSetting = value;
        });
        const adc = this.bus.getSubscriber();
        adc.on('magvar').whenChanged().handle((v) => {
            this.magvar = v;
        });
        this.state = DirectorState.Inactive;
    }
    /**
     * Activates the LNAV director.
     */
    activate() {
        this.state = DirectorState.Active;
    }
    /**
     * Arms the LNAV director.
     */
    arm() {
        this.state = DirectorState.Armed;
    }
    /**
     * Deactivates the LNAV director.
     */
    deactivate() {
        if (this.onDeactivate !== undefined) {
            this.onDeactivate();
        }
        this.state = DirectorState.Inactive;
    }
    /**
     * Increments or Decrements the OBS Setting for GPS if in GPS OBS MODE.
     * @param increment is whether to increment (or decrement) the value.
     */
    incrementObs(increment) {
        if (this.obsActive) {
            if (increment) {
                SimVar.SetSimVarValue('K:GPS_OBS_INC', SimVarValueType.Number, 0);
            }
            else {
                SimVar.SetSimVarValue('K:GPS_OBS_DEC', SimVarValueType.Number, 0);
            }
        }
    }
    /**
     * Updates the lateral director.
     */
    update() {
        if (this.obsActive) {
            if (this.obsSetting >= 0 && this.obsSetting <= 360) {
                SimVar.SetSimVarValue(LNavVars.DTK, 'degrees', Math.floor(this.obsSetting));
            }
            this.getObsXtk();
            if (this.xtk !== undefined) {
                SimVar.SetSimVarValue(LNavVars.XTK, 'nautical miles', this.xtk);
            }
        }
        if (this.state === DirectorState.Active) {
            this.navigateFlightPath();
        }
    }
    /**
     * Gets the current obs xtk.
     */
    getObsXtk() {
        var _a, _b;
        const leg = this.obsLeg.get();
        if (((_a = leg === null || leg === void 0 ? void 0 : leg.calculated) === null || _a === void 0 ? void 0 : _a.endLat) !== undefined && ((_b = leg === null || leg === void 0 ? void 0 : leg.calculated) === null || _b === void 0 ? void 0 : _b.endLon) !== undefined) {
            const start = this.geoPointCache[0].set(leg.calculated.endLat, leg.calculated.endLon);
            const obsTrue = NavMath.normalizeHeading(this.obsSetting + this.magvar);
            const path = this.geoCircleCache[0].setAsGreatCircle(start, obsTrue);
            this.xtk = UnitType.GA_RADIAN.convertTo(path.distance(this.aircraftState.pos), UnitType.NMILE);
        }
        else {
            this.xtk = undefined;
        }
    }
    /**
     * Navigates the provided leg flight path.
     */
    navigateFlightPath() {
        if (this.xtk === undefined) {
            this.deactivate();
            return;
        }
        const absInterceptAngle = Math.min(Math.pow(Math.abs(this.xtk) * 20, 1.35) + (Math.abs(this.xtk) * 50), 45);
        const interceptAngle = this.xtk < 0 ? absInterceptAngle : -1 * absInterceptAngle;
        const obsTrue = NavMath.normalizeHeading(this.obsSetting + this.magvar);
        const bankAngle = this.desiredBank(NavMath.normalizeHeading(obsTrue + interceptAngle), this.xtk);
        if (this.state === DirectorState.Active) {
            this.setBank(bankAngle);
        }
    }
    /**
     * Tries to activate when armed.
     * @returns whether OBS can activate
     */
    canActivate() {
        if (this.xtk !== undefined && Math.abs(this.xtk) < 1) {
            return true;
        }
        return false;
    }
    /**
     * Gets a desired bank from a desired track.
     * @param desiredTrack The desired track.
     * @param xtk The cross track.
     * @returns The desired bank angle.
     */
    desiredBank(desiredTrack, xtk) {
        const turnDirection = NavMath.getTurnDirection(this.aircraftState.track, desiredTrack);
        const headingDiff = Math.abs(NavMath.diffAngle(this.aircraftState.track, desiredTrack));
        let baseBank = Math.min(1.25 * headingDiff, 25);
        if (baseBank <= 2.5) {
            baseBank = NavMath.clamp(xtk * 100, -2.5, 2.5);
        }
        else {
            baseBank *= (turnDirection === 'left' ? 1 : -1);
        }
        return baseBank;
    }
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    setBank(bankAngle) {
        if (isFinite(bankAngle)) {
            this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
            SimVar.SetSimVarValue('AUTOPILOT BANK HOLD REF', 'degrees', this.currentBankRef);
        }
    }
}

/// <reference types="msfstypes/JS/simvar" />
var TurnMode;
(function (TurnMode) {
    TurnMode[TurnMode["None"] = 0] = "None";
    TurnMode[TurnMode["Ingress"] = 1] = "Ingress";
    TurnMode[TurnMode["Egress"] = 2] = "Egress";
})(TurnMode || (TurnMode = {}));
/**
 * A class that handles lateral navigation.
 */
class LNavDirector {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     */
    constructor(bus, flightPlanner) {
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.previousLegIndex = 0;
        /** The current active leg index. */
        this.currentLegIndex = 0;
        /** The current flight path vector index. */
        this.currentVectorIndex = 0;
        this.dtk = 0;
        this.xtk = 0;
        this.turnMode = TurnMode.None;
        this.isSuspended = false;
        this.suspendedLegIndex = 0;
        this.missedApproachActive = false;
        this.currentBankRef = 0;
        this.arcController = new ArcTurnController();
        this.bankServo = new LinearServo(10);
        this.lnavData = {
            vectorIndex: 0,
            turnMode: TurnMode.None,
            courseToSteer: 0
        };
        this.bearingToEnd = 0;
        this.canArm = false;
        this.trackAtActivation = 0;
        this.isInterceptingFromArmedState = false;
        this.aircraftState = {
            tas: 0,
            track: 0,
            magvar: 0,
            windSpeed: 0,
            windDirection: 0,
            pos: new GeoPoint(0, 0),
            hdgTrue: 0
        };
        this.obsDirector = new GpsObsDirector(this.bus, this.aircraftState);
        this.obsDirector.onDeactivate = () => {
            this.isSuspended = false;
            SimVar.SetSimVarValue(LNavVars.DTK, 'degrees', this.dtk);
        };
        const adc = bus.getSubscriber();
        const controls = bus.getSubscriber();
        const plan = bus.getSubscriber();
        this.publisher = bus.getPublisher();
        adc.on('ambient_wind_velocity').handle(w => this.aircraftState.windSpeed = w);
        adc.on('ambient_wind_direction').handle(wd => this.aircraftState.windDirection = wd);
        adc.on('magvar').handle(m => this.aircraftState.magvar = m);
        adc.on('tas').handle(tas => this.aircraftState.tas = tas);
        adc.on('hdg_deg_true').handle(hdg => this.aircraftState.hdgTrue = hdg);
        const nav = this.bus.getSubscriber();
        nav.on('cdi_select').handle((src) => {
            if (this.state !== DirectorState.Inactive && src.type !== NavSourceType.Gps) {
                this.deactivate();
            }
        });
        controls.on('suspend').handle(() => {
            this.trySetSuspended(false);
        });
        controls.on('activate_missed_approach').handle((v) => {
            this.missedApproachActive = v;
        });
        plan.on('fplActiveLegChange').handle(e => {
            if (e.type === ActiveLegType.Lateral) {
                this.currentVectorIndex = 0;
                this.turnMode = TurnMode.Ingress;
            }
        });
        plan.on('fplIndexChanged').handle(() => {
            this.currentVectorIndex = 0;
            this.turnMode = TurnMode.Ingress;
        });
        plan.on('fplSegmentChange').handle((e) => {
            if (e.type === PlanChangeType.Removed && (!this.flightPlanner.hasActiveFlightPlan() || this.flightPlanner.getActiveFlightPlan().length < 1)) {
                this.lnavData.vectorIndex = 0;
                this.lnavData.turnMode = TurnMode.None;
                this.lnavData.state = undefined;
                this.lnavData.currentLeg = undefined;
                this.lnavData.nextLeg = undefined;
            }
        });
        const gps = bus.getSubscriber();
        gps.on('gps-position').handle(lla => {
            this.aircraftState.pos.set(lla.lat, lla.long);
        });
        gps.on('track_deg_true').handle(t => this.aircraftState.track = t);
        this.state = DirectorState.Inactive;
    }
    /**
     * Activates the LNAV director.
     */
    activate() {
        this.isInterceptingFromArmedState = true;
        this.trackAtActivation = this.aircraftState.track;
        this.state = DirectorState.Active;
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        SimVar.SetSimVarValue('AUTOPILOT NAV1 LOCK', 'Bool', true);
    }
    /**
     * Arms the LNAV director.
     */
    arm() {
        if (this.state === DirectorState.Inactive) {
            this.isInterceptingFromArmedState = false;
            if (this.canArm) {
                this.state = DirectorState.Armed;
                if (this.onArm !== undefined) {
                    this.onArm();
                }
                SimVar.SetSimVarValue('AUTOPILOT NAV1 LOCK', 'Bool', true);
            }
        }
    }
    /**
     * Deactivates the LNAV director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        if (this.obsDirector.state !== DirectorState.Inactive) {
            this.obsDirector.deactivate();
        }
        this.isInterceptingFromArmedState = false;
        SimVar.SetSimVarValue('AUTOPILOT NAV1 LOCK', 'Bool', false);
    }
    /**
     * Updates the lateral director.
     */
    update() {
        var _a, _b;
        const flightPlan = this.flightPlanner.hasActiveFlightPlan() ? this.flightPlanner.getActiveFlightPlan() : undefined;
        this.currentLegIndex = flightPlan ? flightPlan.activeLateralLeg : 0;
        if (flightPlan && this.currentLegIndex <= flightPlan.length - 1) {
            let leg = flightPlan.getLeg(this.currentLegIndex);
            let nextLeg = undefined;
            try {
                nextLeg = flightPlan.getLeg(this.currentLegIndex + 1);
            }
            catch ( /* Continue */_c) { /* Continue */ }
            this.calculateTracking(leg);
            if (this.currentLegIndex > flightPlan.length - 1) {
                return;
            }
            leg = flightPlan.getLeg(this.currentLegIndex);
            try {
                nextLeg = flightPlan.getLeg(this.currentLegIndex + 1);
            }
            catch ( /* Continue */_d) { /* Continue */ }
            const calcs = leg.calculated;
            this.calculateNextTracking(nextLeg === null || nextLeg === void 0 ? void 0 : nextLeg.calculated);
            this.lnavData.currentLeg = leg;
            this.lnavData.nextLeg = nextLeg;
            this.lnavData.vectorIndex = this.currentVectorIndex;
            this.lnavData.turnMode = this.turnMode;
            this.obsDirector.obsLeg.set(leg);
            if (this.obsDirector.obsActive) {
                this.isSuspended = true;
                this.suspendedLegIndex = this.currentLegIndex;
                if (this.state === DirectorState.Active && this.obsDirector.state !== DirectorState.Active) {
                    this.obsDirector.activate();
                    SimVar.SetSimVarValue('AUTOPILOT NAV1 LOCK', 'Bool', true);
                }
                if (this.state === DirectorState.Armed && this.obsDirector.canActivate()) {
                    this.obsDirector.activate();
                    this.state = DirectorState.Active;
                    if (this.onActivate !== undefined) {
                        this.onActivate();
                    }
                    SimVar.SetSimVarValue('AUTOPILOT NAV1 LOCK', 'Bool', true);
                }
                if (leg && ((_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.endLat) && ((_b = leg.calculated) === null || _b === void 0 ? void 0 : _b.endLon) && this.aircraftState.pos) {
                    this.bearingToEnd = MagVar.trueToMagnetic(this.aircraftState.pos.bearingTo(leg.calculated.endLat, leg.calculated.endLon), this.aircraftState.pos);
                    SimVar.SetSimVarValue(LNavVars.Bearing, 'degrees', this.bearingToEnd);
                    const distance = this.aircraftState.pos.distance(leg.calculated.endLat, leg.calculated.endLon);
                    SimVar.SetSimVarValue(LNavVars.Distance, 'meters', UnitType.GA_RADIAN.convertTo(distance, UnitType.METER));
                }
                this.obsDirector.update();
                return;
            }
            if (calcs !== undefined) {
                this.canArm = true;
            }
            else {
                this.canArm = false;
            }
            if (this.state !== DirectorState.Inactive && calcs !== undefined) {
                this.navigateFlightPath(calcs);
            }
        }
        else {
            this.canArm = false;
        }
        if (this.state === DirectorState.Armed) {
            this.tryActivate();
        }
        this.lnavData.state = this.aircraftState;
        this.publisher.pub('dataChanged', this.lnavData, false);
    }
    /**
     * Calculates the tracking information for the next leg.
     * @param calcs The leg calculations for the next leg.
     */
    calculateNextTracking(calcs) {
        var _a;
        if (calcs !== undefined) {
            const vector = calcs.flightPath[0];
            if (vector !== undefined) {
                SimVar.SetSimVarValue(LNavVars.NextDTK, 'degrees', (_a = calcs.initialDtk) !== null && _a !== void 0 ? _a : 0);
                const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
                SimVar.SetSimVarValue(LNavVars.NextXTK, 'nautical miles', UnitType.GA_RADIAN.convertTo(circle.distance(this.aircraftState.pos), UnitType.NMILE));
            }
        }
    }
    /**
     * Navigates the provided leg flight path.
     * @param calcs The legs calculations that has the provided flight path.
     */
    navigateFlightPath(calcs) {
        let absInterceptAngle;
        const naturalAbsInterceptAngle = Math.min(Math.pow(Math.abs(this.xtk) * 20, 1.35) + (Math.abs(this.xtk) * 50), 45);
        if (this.isInterceptingFromArmedState) {
            absInterceptAngle = Math.abs(NavMath.diffAngle(this.trackAtActivation, this.dtk));
            if (absInterceptAngle > naturalAbsInterceptAngle || absInterceptAngle < 5 || absInterceptAngle < Math.abs(NavMath.diffAngle(this.dtk, this.bearingToEnd))) {
                absInterceptAngle = naturalAbsInterceptAngle;
                this.isInterceptingFromArmedState = false;
            }
        }
        else {
            absInterceptAngle = naturalAbsInterceptAngle;
        }
        const interceptAngle = this.xtk < 0 ? absInterceptAngle : -1 * absInterceptAngle;
        this.lnavData.courseToSteer = NavMath.normalizeHeading(this.dtk + interceptAngle);
        let vector = calcs.flightPath[this.currentVectorIndex];
        let bankAngle = this.desiredBank(this.lnavData.courseToSteer, this.xtk);
        const isFirstVector = this.currentVectorIndex === 0;
        const isLastVector = this.currentVectorIndex === calcs.flightPath.length - 1;
        if (isFirstVector && this.turnMode === TurnMode.Ingress) {
            vector = calcs.ingressTurn;
        }
        else if (isLastVector && this.turnMode === TurnMode.Egress && !this.isSuspended) {
            vector = calcs.egressTurn;
        }
        if (vector !== undefined && !FlightPathUtils.isVectorGreatCircle(vector)) {
            bankAngle = this.adjustBankAngleForArc(vector, bankAngle);
        }
        if (this.state === DirectorState.Active) {
            this.setBank(bankAngle);
        }
    }
    /**
     * Adjusts the desired bank angle for arc vectors.
     * @param vector The arc vector to adjust for.
     * @param bankAngle The current starting input desired bank angle.
     * @returns The adjusted bank angle.
     */
    adjustBankAngleForArc(vector, bankAngle) {
        const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
        const turnDirection = FlightPathUtils.getTurnDirectionFromCircle(circle);
        const radius = UnitType.GA_RADIAN.convertTo(FlightPathUtils.getTurnRadiusFromCircle(circle), UnitType.METER);
        const relativeWindHeading = NavMath.normalizeHeading(this.aircraftState.windDirection - this.aircraftState.hdgTrue);
        const headwind = this.aircraftState.windSpeed * Math.cos(relativeWindHeading * Avionics.Utils.DEG2RAD);
        const ppos = this.aircraftState.pos;
        const distance = UnitType.GA_RADIAN.convertTo(circle.distance(ppos), UnitType.METER);
        const bankAdjustment = this.arcController.getOutput(distance);
        const turnBankAngle = NavMath.bankAngle(this.aircraftState.tas - headwind, radius) * (turnDirection === 'left' ? 1 : -1);
        const turnRadius = NavMath.turnRadius(this.aircraftState.tas - headwind, 25);
        const bankBlendFactor = Math.max(1 - (Math.abs(UnitType.NMILE.convertTo(this.xtk, UnitType.METER)) / turnRadius), 0);
        bankAngle = (bankAngle * (1 - bankBlendFactor)) + (turnBankAngle * bankBlendFactor) + bankAdjustment;
        bankAngle = Math.min(Math.max(bankAngle, -25), 25);
        return bankAngle;
    }
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    setBank(bankAngle) {
        if (isFinite(bankAngle)) {
            this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
            SimVar.SetSimVarValue('AUTOPILOT BANK HOLD REF', 'degrees', this.currentBankRef);
        }
    }
    /**
     * Gets a desired bank from a desired track.
     * @param desiredTrack The desired track.
     * @param xtk The cross track.
     * @returns The desired bank angle.
     */
    desiredBank(desiredTrack, xtk) {
        const turnDirection = NavMath.getTurnDirection(this.aircraftState.track, desiredTrack);
        const headingDiff = Math.abs(NavMath.diffAngle(this.aircraftState.track, desiredTrack));
        let baseBank = Math.min(1.25 * headingDiff, 25);
        if (baseBank <= 2.5) {
            baseBank = NavMath.clamp(xtk * 100, -2.5, 2.5);
        }
        else {
            baseBank *= (turnDirection === 'left' ? 1 : -1);
        }
        return baseBank;
    }
    /**
     * Calculates the tracking from the current leg.
     * @param leg The leg to calculate tracking from.
     */
    calculateTracking(leg) {
        var _a;
        const plan = this.flightPlanner.getActiveFlightPlan();
        let vector = (_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.flightPath[this.currentVectorIndex];
        const calcs = leg.calculated;
        //Don't really need to fly the intial leg?
        if (leg.leg.type === LegType.IF && this.currentLegIndex === 0 && plan.length > 1) {
            this.currentLegIndex++;
            plan.setLateralLeg(this.currentLegIndex);
            plan.setCalculatingLeg(this.currentLegIndex);
            return;
        }
        if (vector !== undefined && calcs !== undefined) {
            const isFirstVector = this.currentVectorIndex === 0;
            const isLastVector = this.currentVectorIndex === calcs.flightPath.length - 1;
            if (isFirstVector && this.turnMode === TurnMode.Ingress) {
                vector = calcs.ingressTurn;
            }
            else if (isLastVector && this.turnMode === TurnMode.Egress && !this.isSuspended) {
                vector = calcs.egressTurn;
            }
            if (vector.radius === 0) {
                this.advanceVector(leg);
            }
            else {
                const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
                const start = GeoPoint.sphericalToCartesian(vector.startLat, vector.startLon, this.vec3Cache[0]);
                const end = this.geoPointCache[0];
                const alongCirclePos = circle.closest(this.aircraftState.pos, this.vec3Cache[1]);
                this.xtk = UnitType.GA_RADIAN.convertTo(circle.distance(this.aircraftState.pos), UnitType.NMILE);
                this.dtk = circle.bearingAt(alongCirclePos);
                if (isLastVector && this.turnMode === TurnMode.None && calcs.egressTurn.radius > 0 && !this.isSuspended) {
                    end.set(calcs.egressTurn.startLat, calcs.egressTurn.startLon);
                }
                else {
                    end.set(vector.endLat, vector.endLon);
                }
                this.bearingToEnd = MagVar.trueToMagnetic(this.aircraftState.pos.bearingTo(end), this.aircraftState.pos);
                SimVar.SetSimVarValue(LNavVars.Bearing, 'degrees', this.bearingToEnd);
                if (FlightPathUtils.getAlongArcNormalizedDistance(circle, start, end, alongCirclePos) > 1) {
                    this.advanceVector(leg);
                }
            }
        }
        if (leg.calculated !== undefined && this.currentVectorIndex > leg.calculated.flightPath.length - 1 && plan.activeLateralLeg != plan.length - 1) {
            this.applyEndOfLegSuspends();
            if (!this.isSuspended) {
                this.currentLegIndex++;
                this.flightPlanner.getActiveFlightPlan().setLateralLeg(this.currentLegIndex);
                this.currentVectorIndex = 0;
                this.suspendedLegIndex = 0;
            }
            else {
                if (leg.leg.type === LegType.HM) {
                    this.currentVectorIndex = 0;
                }
            }
        }
        this.lnavData.courseToSteer = this.dtk;
    }
    /**
     * Applies suspends that apply at the end of a leg.
     */
    applyEndOfLegSuspends() {
        const plan = this.flightPlanner.getActiveFlightPlan();
        const leg = plan.getLeg(plan.activeLateralLeg);
        if (leg.leg.type === LegType.FM || leg.leg.type === LegType.VM) {
            this.trySetSuspended(true);
        }
        else if (plan.activeLateralLeg < plan.length - 1) {
            const nextLeg = plan.getLeg(plan.activeLateralLeg + 1);
            if (!this.missedApproachActive && (leg.leg.fixTypeFlags === FixTypeFlags.MAP || (!leg.isInMissedApproachSequence && nextLeg.isInMissedApproachSequence))) {
                this.trySetSuspended(true);
            }
        }
    }
    /**
     * Applies suspends that apply at the beginning of a leg.
     */
    applyStartOfLegSuspends() {
        const plan = this.flightPlanner.getActiveFlightPlan();
        const leg = plan.getLeg(plan.activeLateralLeg);
        if (leg.leg.type === LegType.HM || plan.activeLateralLeg === plan.length - 1) {
            this.trySetSuspended(true);
        }
    }
    /**
     * Advances the flight path vector along the flight path.
     * @param leg The definition of the leg being flown.
     */
    advanceVector(leg) {
        if (this.turnMode === TurnMode.Ingress) {
            this.turnMode = TurnMode.None;
            this.arcController.reset();
        }
        else if (this.turnMode === TurnMode.Egress) {
            this.advanceEgressToIngress();
        }
        else {
            if (this.hasEgressTurn(this.currentVectorIndex, leg)) {
                this.turnMode = TurnMode.Egress;
                this.flightPlanner.getFlightPlan(0).setCalculatingLeg(this.currentLegIndex + 1);
            }
            else {
                if (leg.calculated && this.currentVectorIndex === leg.calculated.flightPath.length - 1) {
                    this.advanceEgressToIngress();
                }
                else {
                    this.currentVectorIndex++;
                }
            }
        }
        if (leg.leg.type === LegType.HM && this.turnMode !== TurnMode.Egress) {
            if (leg.calculated && this.currentVectorIndex === leg.calculated.flightPath.length - 1) {
                this.flightPlanner.getFlightPlan(0).setCalculatingLeg(this.currentLegIndex - 1);
            }
            else {
                this.flightPlanner.getFlightPlan(0).setCalculatingLeg(this.currentLegIndex);
            }
        }
    }
    /**
     * Advances the end of a leg to the beginning of the next leg.
     */
    advanceEgressToIngress() {
        const plan = this.flightPlanner.getActiveFlightPlan();
        this.applyEndOfLegSuspends();
        if (!this.isSuspended) {
            if (this.currentLegIndex + 1 > plan.length - 1) {
                this.turnMode = TurnMode.None;
                return;
            }
            this.currentVectorIndex = 0;
            this.suspendedLegIndex = 0;
            plan.setLateralLeg(this.currentLegIndex + 1);
            plan.setCalculatingLeg(this.currentLegIndex + 1);
            const nextLeg = plan.getLeg(this.currentLegIndex + 1);
            if (this.hasIngressTurn(this.currentVectorIndex, nextLeg)) {
                this.turnMode = TurnMode.Ingress;
            }
            else {
                this.turnMode = TurnMode.None;
            }
            this.applyStartOfLegSuspends();
            this.currentLegIndex++;
        }
        else {
            const activeLeg = plan.getLeg(plan.activeLateralLeg);
            if (activeLeg.leg.type === LegType.HM) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.currentVectorIndex = activeLeg.calculated.flightPath.length - 4;
            }
        }
    }
    /**
     * Checks if a vector has an ingress turn.
     * @param vectorIndex The index of the vector.
     * @param leg The definition of the leg.
     * @returns Whether the vector has an ingress turn.
     */
    hasIngressTurn(vectorIndex, leg) {
        const calcs = leg.calculated;
        if (calcs !== undefined) {
            return vectorIndex === 0 && calcs.ingressTurn.radius !== 0;
        }
        return false;
    }
    /**
     * Checks if a vector has an egress turn.
     * @param vectorIndex The index of the vector.
     * @param leg The definition of the leg.
     * @returns Whether the vector has an egress turn.
     */
    hasEgressTurn(vectorIndex, leg) {
        const calcs = leg.calculated;
        if (calcs !== undefined && !this.isSuspended) {
            return vectorIndex === calcs.flightPath.length - 1 && calcs.egressTurn.radius !== 0;
        }
        return false;
    }
    /**
     * Sets flight plan advance in or out of SUSP.
     * @param isSuspended Whether or not advance is suspended.
     */
    trySetSuspended(isSuspended) {
        if (isSuspended && this.currentLegIndex === this.suspendedLegIndex) {
            return;
        }
        else if (isSuspended) {
            this.suspendedLegIndex = this.currentLegIndex;
        }
        if (this.isSuspended !== isSuspended) {
            this.publisher.pub('suspChanged', isSuspended, true, true);
            this.isSuspended = isSuspended;
        }
    }
    /**
     * Tries to activate when armed.
     */
    tryActivate() {
        const headingDiff = NavMath.diffAngle(this.aircraftState.track, this.dtk);
        if (Math.abs(this.xtk) < 0.6 && Math.abs(headingDiff) < 110) {
            this.activate();
        }
    }
}

/**
 * A VNAV path autopilot director.
 */
class VNavDirector {
    /**
     * Creates an instance of the VNAV director.
     * @param bus The event bus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     * @param calculator The VNAV path calculator to use with this instance.
     * @param apValues are the autopilot ap values.
     */
    constructor(bus, flightPlanner, calculator, apValues) {
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.calculator = calculator;
        this.apValues = apValues;
        this.mode = VNavMode.None;
        this._pathMode = VNavPathMode.None;
        this.state = DirectorState.Inactive;
        this.approachDetails = {
            approachLoaded: false,
            approachType: ApproachType.APPROACH_TYPE_UNKNOWN,
            approachRnavType: RnavTypeFlags.None,
            approachIsActive: false
        };
        this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.currentAltitude = 0;
        this.currentGpsAltitude = 0;
        this.preselectedAltitude = 0;
        this.currentGroundSpeed = 0;
        this.capturedAltitude = 0;
        this.isAltCaptured = false;
        this.awaitingAltCap = -1;
        this.awaitingRearm = -1;
        /** The leg distance from the current leg to the constraint leg, not including the distance from ppos to the current leg target. */
        this.constraintDistance = -1;
        this.lpvDeviation = Subject.create(0);
        this.bus.getSubscriber().on('dataChanged').handle(data => this.lnavData = data);
        this.bus.getSubscriber().on('alt_select').handle(selected => this.preselectedAltitude = selected);
        this.bus.getSubscriber().on('approach_details_set').handle(d => {
            this.approachDetails = d;
            this.apValues.approachIsActive.set(d.approachLoaded && d.approachIsActive);
        });
        this.bus.getSubscriber().on('alt').handle(alt => this.currentAltitude = alt);
        const gnss = this.bus.getSubscriber();
        gnss.on('gps-position').handle(lla => this.currentGpsAltitude = lla.alt);
        gnss.on('ground_speed').handle(gs => this.currentGroundSpeed = gs);
        this.apValues.verticalActive.sub(mode => {
            if (mode === APVerticalModes.ALT && this.awaitingAltCap !== -1) {
                this.awaitingRearm = this.awaitingAltCap;
                this.awaitingAltCap = -1;
            }
            if (this.awaitingRearm > -1 && mode !== APVerticalModes.ALT && mode !== APVerticalModes.CAP) {
                this.awaitingRearm = -1;
                this.awaitingAltCap = -1;
            }
        });
        this.apValues.lateralActive.sub(mode => {
            if (mode === APLateralModes.LOC && this.pathMode === VNavPathMode.PathArmed) {
                this.awaitingAltCap = -1;
                this.awaitingRearm = -1;
                this.deactivate();
            }
        });
        SimVar.SetSimVarValue(VNavSimVars.TODDistance, SimVarValueType.Number, Number.MAX_SAFE_INTEGER);
        SimVar.SetSimVarValue(VNavSimVars.LPVVerticalDeviation, SimVarValueType.Number, Number.MAX_SAFE_INTEGER);
        SimVar.SetSimVarValue(VNavSimVars.PathMode, SimVarValueType.Number, VNavPathMode.None);
    }
    /**
     * Setter for pathMode that also sets the simvar
     * @param mode is the VNavPathMode to set.
     */
    set pathMode(mode) {
        if (mode !== this._pathMode) {
            this._pathMode = mode;
            SimVar.SetSimVarValue(VNavSimVars.PathMode, SimVarValueType.Number, this._pathMode);
        }
        if (this._pathMode === VNavPathMode.PathArmed) {
            this.state = DirectorState.Armed;
            this.isAltCaptured = false;
            this.onArm && this.onArm();
        }
        if (this._pathMode === VNavPathMode.PathActive) {
            this.state = DirectorState.Active;
            this.onActivate && this.onActivate();
        }
    }
    /**
     * Getter for pathMode that also sets the simvar
     * @returns the current VNavPathMode.
     */
    get pathMode() {
        return this._pathMode;
    }
    /**
     * Activates the VNAV director's calculations.
     * Does NOT enable any path following.
     */
    enable() {
        this.pathMode = VNavPathMode.None;
        this.state = DirectorState.Inactive;
    }
    /**
     * Activates the director.
     * We do not use this method in vnav director.
     * @throws an error if someone calls this method.
     */
    activate() {
        throw new Error('Activate Method in VNAV Director not supported.');
    }
    /**
     * Arms the VNAV Director.
     * This is called by the Autopilot when the VNAV button is pressed to an on state.
     */
    arm() {
        this.awaitingAltCap = -1;
        this.awaitingRearm = -1;
        this.state = DirectorState.Armed;
        this.pathMode = VNavPathMode.None;
    }
    /**
     * Deactivates the VNAV director.
     * This is called by the Autopilot when the VNAV button is pressed to an off state or when GP/GS activates.
     * This is called by the VNAV Director at the end of the path or if there is an invalid path or other error.
     */
    deactivate() {
        if (this.state !== DirectorState.Inactive) {
            this.pathMode = VNavPathMode.None;
            this.state = DirectorState.Inactive;
            this.isAltCaptured = false;
            if (this.awaitingAltCap === -1 && this.awaitingRearm === -1) {
                SimVar.SetSimVarValue('L:XMLVAR_VNAVButtonValue', 'Bool', 0);
            }
        }
    }
    /**
     * Method to call when VNAV Encounters a failed state.
     */
    failed() {
        if (this.state === DirectorState.Active) {
            this.state = DirectorState.Inactive;
            if (!this.isAltCaptured) {
                this.apValues.capturedAltitude.set(this.currentAltitude);
            }
            this.onDeactivate && this.onDeactivate();
        }
        else {
            this.deactivate();
        }
    }
    /**
     * Method called to delegate altitude capture to the Alt Cap Director.
     */
    onDelegateAltCap() {
        this.onDeactivate && this.onDeactivate();
    }
    /**
     * Updates the VNAV director.
     */
    update() {
        var _a, _b, _c, _d;
        if (this.lnavData !== undefined && this.flightPlanner.hasFlightPlan(Fms.PRIMARY_PLAN_INDEX)) {
            const plan = this.flightPlanner.getFlightPlan(Fms.PRIMARY_PLAN_INDEX);
            let desiredAltFeet = Number.POSITIVE_INFINITY;
            let targetAltitudeFeet;
            let verticalDeviation = Number.MAX_SAFE_INTEGER;
            let requiredVs = 0;
            const alongLegDistance = this.getAlongLegDistance(this.lnavData);
            if (this.lnavData.nextLeg !== undefined && plan.activeLateralLeg < plan.length) {
                const todBodDetails = this.calculator.todBodDetails(plan.activeLateralLeg, alongLegDistance);
                SimVar.SetSimVarValue(VNavSimVars.TODDistance, SimVarValueType.Number, todBodDetails.distanceFromTod);
                SimVar.SetSimVarValue(VNavSimVars.TODLegIndex, SimVarValueType.Number, todBodDetails.todLegIndex);
                SimVar.SetSimVarValue(VNavSimVars.TODDistanceInLeg, SimVarValueType.Number, todBodDetails.distanceFromLegEnd);
                SimVar.SetSimVarValue(VNavSimVars.BODLegIndex, SimVarValueType.Number, todBodDetails.bodLegIndex);
                SimVar.SetSimVarValue(VNavSimVars.BODDistance, SimVarValueType.Number, todBodDetails.distanceFromBod);
                SimVar.SetSimVarValue(VNavSimVars.CurrentConstraintLegIndex, SimVarValueType.Number, todBodDetails.currentConstraintIndex);
                const nextConstraintAltitude = this.calculator.getNextConstraintAltitude(plan.activeLateralLeg);
                if (nextConstraintAltitude === undefined) {
                    this.bus.getPublisher().pub('vnavNextConstraintAltitude', -1);
                }
                else {
                    this.bus.getPublisher().pub('vnavNextConstraintAltitude', UnitType.METER.convertTo(nextConstraintAltitude, UnitType.FOOT));
                }
                const constraintAltitude = this.calculator.getCurrentConstraintAltitude(plan.activeLateralLeg);
                const simvarAltitudeSet = constraintAltitude !== undefined ? UnitType.METER.convertTo(constraintAltitude, UnitType.FOOT) : -1;
                SimVar.SetSimVarValue(VNavSimVars.CurrentConstraintAltitude, SimVarValueType.Feet, simvarAltitudeSet);
                const desiredAltitude = this.calculator.getDesiredAltitude(plan.activeLateralLeg, alongLegDistance);
                desiredAltFeet = UnitType.METER.convertTo(desiredAltitude, UnitType.FOOT);
                this.setConstraintDistance(plan, todBodDetails.currentConstraintIndex);
                if (((_b = (_a = this.lnavData.currentLeg) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTurns) && constraintAltitude !== undefined) {
                    const distance = this.constraintDistance +
                        UnitType.METER.convertTo(((_d = (_c = this.lnavData.currentLeg) === null || _c === void 0 ? void 0 : _c.calculated) === null || _d === void 0 ? void 0 : _d.distanceWithTurns) - this.getAlongLegDistance(this.lnavData), UnitType.NMILE);
                    requiredVs = this.getRequiredVs(distance, constraintAltitude);
                }
            }
            else {
                this.failed();
            }
            if (plan.length > 0) {
                const finalLeg = plan.getLeg(plan.length - 1);
                const lpvDistance = this.manageGP(finalLeg, plan, alongLegDistance);
                verticalDeviation = desiredAltFeet - this.currentAltitude;
                SimVar.SetSimVarValue(VNavSimVars.VerticalDeviation, SimVarValueType.Feet, verticalDeviation);
                const targetAltitude = this.calculator.getTargetAltitude(plan.activeLateralLeg);
                if (targetAltitude !== undefined) {
                    targetAltitudeFeet = UnitType.METER.convertTo(targetAltitude, UnitType.FOOT);
                    SimVar.SetSimVarValue(VNavSimVars.TargetAltitude, SimVarValueType.Feet, targetAltitudeFeet);
                }
                else {
                    SimVar.SetSimVarValue(VNavSimVars.TargetAltitude, SimVarValueType.Feet, -1);
                }
                if (this.apValues.verticalActive.get() === APVerticalModes.GP ||
                    (this.apValues.approachHasGP.get() && this.state === DirectorState.Inactive && plan.activeLateralLeg >= this.calculator.getFafLegIndex())) {
                    requiredVs = this.getRequiredVs(UnitType.METER.convertTo(lpvDistance, UnitType.NMILE), this.calculator.getLpvRunwayAltitude(), this.currentGpsAltitude);
                }
                SimVar.SetSimVarValue(VNavSimVars.RequiredVS, SimVarValueType.Number, requiredVs);
                if (plan.activeLateralLeg === this.awaitingRearm) {
                    this.arm();
                }
                if (this.state !== DirectorState.Inactive && this.awaitingAltCap === -1 && this.awaitingRearm === -1) {
                    this.manageAltHold(targetAltitudeFeet);
                    this.trackVerticalPath(targetAltitudeFeet, verticalDeviation, plan);
                }
                else if (plan.activeLateralLeg < plan.length) {
                    const fpa = this.calculator.getLeg(plan.activeLateralLeg).fpa;
                    SimVar.SetSimVarValue(VNavSimVars.FPA, SimVarValueType.FPM, fpa);
                }
                else {
                    SimVar.SetSimVarValue(VNavSimVars.FPA, SimVarValueType.FPM, 0);
                }
            }
            else {
                // TODO: remove this once we have a better way to get LPV state - does an LPV exist or not
                SimVar.SetSimVarValue(VNavSimVars.LPVDistance, SimVarValueType.Number, Number.MAX_SAFE_INTEGER);
                this.lpvDeviation.set(-1001);
            }
        }
        else {
            this.failed();
        }
    }
    /**
     * Tracks the vertical path.
     * @param targetAltitude The current VNAV target altitude, if any.
     * @param verticalDeviation The current vertical deviation.
     * @param plan The active flight plan.
     */
    trackVerticalPath(targetAltitude, verticalDeviation, plan) {
        if (targetAltitude === undefined) {
            targetAltitude = Number.NEGATIVE_INFINITY;
        }
        if (plan.activeLateralLeg >= plan.length) {
            this.isAltCaptured = false;
            this.failed();
            return;
        }
        const targetIsSelectedAltitude = this.preselectedAltitude > targetAltitude;
        targetAltitude = Math.max(targetAltitude, this.preselectedAltitude);
        const deviationFromTarget = targetAltitude - this.currentAltitude;
        const fpaPercentage = Math.max(verticalDeviation / -100, -1) + 1;
        const fpa = this.calculator.getLeg(plan.activeLateralLeg).fpa;
        const desiredPitch = (fpa * fpaPercentage) * -1;
        SimVar.SetSimVarValue(VNavSimVars.FPA, SimVarValueType.FPM, fpa);
        if (this.pathMode === VNavPathMode.None) {
            if (this.preselectedAltitude + 75 < this.currentAltitude) {
                this.pathMode = VNavPathMode.PathArmed;
            }
            else {
                this.deactivate();
            }
        }
        if (!this.isAltCaptured && this.pathMode === VNavPathMode.PathActive && fpa === 0) {
            this.apValues.capturedAltitude.set(100 * Math.round(targetAltitude / 100));
            this.pathMode = VNavPathMode.PathArmed;
            this.onDelegateAltCap();
            if (UnitType.METER.convertTo(this.calculator.getFafAltitude(), UnitType.FOOT) === targetAltitude) {
                this.deactivate();
            }
        }
        if (this.pathMode === VNavPathMode.PathArmed || this.pathMode == VNavPathMode.PathActive) {
            if (verticalDeviation <= 100 && verticalDeviation >= -15 && this.pathMode === VNavPathMode.PathArmed) {
                if (Math.abs(deviationFromTarget) > 75 && (!this.isAltCaptured && fpa !== 0)) {
                    SimVar.SetSimVarValue('AUTOPILOT PITCH HOLD', 'Bool', 0);
                    this.pathMode = VNavPathMode.PathActive;
                }
            }
            if (!this.isAltCaptured && Math.abs(deviationFromTarget) <= 250 && this.pathMode == VNavPathMode.PathActive) {
                this.capturedAltitude = targetAltitude;
                this.apValues.capturedAltitude.set(Math.round(this.capturedAltitude));
                this.isAltCaptured = true;
            }
            if (this.isAltCaptured && this.pathMode === VNavPathMode.PathActive) {
                const altCapDeviation = Math.abs(this.capturedAltitude - this.currentAltitude);
                const captureActivationValue = Math.tan(UnitType.DEGREE.convertTo(fpa, UnitType.RADIAN)) * UnitType.NMILE.convertTo(this.currentGroundSpeed / 360, UnitType.FOOT);
                if (altCapDeviation < Math.abs(captureActivationValue)) {
                    if (!targetIsSelectedAltitude && !this.calculator.getIsPathEnd(plan.activeLateralLeg)) {
                        this.awaitingAltCap = plan.activeLateralLeg + 1;
                    }
                    this.onDelegateAltCap();
                    return;
                }
            }
            if (this.pathMode === VNavPathMode.PathActive) {
                //We need the instant AOA here so we're avoiding the bus
                const aoa = SimVar.GetSimVarValue('INCIDENCE ALPHA', SimVarValueType.Degree);
                const maximumPitch = this.isAltCaptured ? 6 : 0;
                const targetPitch = aoa + NavMath.clamp(desiredPitch, -6, maximumPitch);
                SimVar.SetSimVarValue('AUTOPILOT PITCH HOLD REF', SimVarValueType.Degree, -targetPitch);
            }
        }
    }
    /**
     * Manages the sim ALT hold.
     * @param targetAltitude The current VNAV target altitude, if any.
     */
    manageAltHold(targetAltitude) {
        if (targetAltitude !== undefined) {
            const targetAltFeet = targetAltitude;
            if (this.preselectedAltitude >= targetAltFeet) {
                SimVar.SetSimVarValue(VNavSimVars.CaptureType, SimVarValueType.Number, VNavAltCaptureType.Selected);
            }
            else {
                SimVar.SetSimVarValue(VNavSimVars.CaptureType, SimVarValueType.Number, VNavAltCaptureType.VNAV);
            }
        }
        else {
            SimVar.SetSimVarValue(VNavSimVars.TargetAltitude, SimVarValueType.Feet, -1);
            SimVar.SetSimVarValue(VNavSimVars.CaptureType, SimVarValueType.Number, VNavAltCaptureType.None);
        }
    }
    /**
     * Gets the distance along the current leg.
     * @param lnavData The current LNAV data.
     * @returns The distance along the current leg.
     */
    getAlongLegDistance(lnavData) {
        let distance = 0;
        if (lnavData.currentLeg && lnavData.currentLeg.calculated && lnavData.state) {
            const calcs = lnavData.currentLeg.calculated;
            if (lnavData.turnMode === TurnMode.Ingress && calcs.ingressTurn.radius > 0) {
                const circle = FlightPathUtils.setGeoCircleFromVector(calcs.ingressTurn, this.geoCircleCache[0]);
                return UnitType.GA_RADIAN.convertTo(FlightPathUtils.getAlongArcSignedDistance(circle, GeoPoint.sphericalToCartesian(calcs.ingressTurn.startLat, calcs.ingressTurn.startLon, this.vec3Cache[0]), GeoPoint.sphericalToCartesian(calcs.ingressTurn.endLat, calcs.ingressTurn.endLon, this.vec3Cache[1]), circle.closest(lnavData.state.pos, this.vec3Cache[2])), UnitType.METER);
            }
            if (lnavData.currentLeg.calculated.flightPath.length < 1) {
                return 0;
            }
            for (let index = 0; index <= lnavData.vectorIndex; index++) {
                const start = this.vec3Cache[0];
                const end = this.vec3Cache[1];
                const vector = calcs.flightPath[index];
                if (index === 0 && calcs.ingressTurn.radius !== 0) {
                    distance += calcs.ingressTurn.distance;
                    GeoPoint.sphericalToCartesian(calcs.ingressTurn.endLat, calcs.ingressTurn.endLon, start);
                }
                else {
                    GeoPoint.sphericalToCartesian(vector.startLat, vector.startLon, start);
                }
                if (index === calcs.flightPath.length - 1 && calcs.egressTurn.radius !== 0) {
                    GeoPoint.sphericalToCartesian(calcs.egressTurn.startLat, calcs.egressTurn.startLon, end);
                    const turnEnd = GeoPoint.sphericalToCartesian(calcs.egressTurn.endLat, calcs.egressTurn.endLon, this.vec3Cache[2]);
                    if (lnavData.turnMode === TurnMode.Egress) {
                        const circle = FlightPathUtils.setGeoCircleFromVector(calcs.egressTurn, this.geoCircleCache[0]);
                        distance += UnitType.GA_RADIAN.convertTo(FlightPathUtils.getAlongArcSignedDistance(circle, end, turnEnd, circle.closest(lnavData.state.pos, this.vec3Cache[3])), UnitType.METER);
                    }
                }
                else {
                    GeoPoint.sphericalToCartesian(vector.endLat, vector.endLon, end);
                }
                const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
                distance += UnitType.GA_RADIAN.convertTo(FlightPathUtils.getAlongArcSignedDistance(circle, start, end, index === lnavData.vectorIndex && lnavData.turnMode !== TurnMode.Egress
                    ? circle.closest(lnavData.state.pos, this.vec3Cache[2])
                    : end), UnitType.METER);
            }
        }
        return distance;
    }
    /**
     * Manages the GP State and sets required data for GP guidance.
     * @param finalLeg The LegDefinition for the last flight plan leg.
     * @param plan The FlightPlan.
     * @param alongLegDistance The Along Leg Distance
     * @returns The LPV Distance
     */
    manageGP(finalLeg, plan, alongLegDistance) {
        var _a;
        let lpvDeviation = Number.POSITIVE_INFINITY;
        let lpvDistance = -1;
        let gpExists = false;
        let gpCalculated = false;
        if (this.approachDetails.approachLoaded && this.approachDetails.approachIsActive) {
            switch (this.approachDetails.approachType) {
                case ApproachType.APPROACH_TYPE_GPS:
                case ApproachType.APPROACH_TYPE_RNAV:
                case AdditionalApproachType.APPROACH_TYPE_VISUAL:
                    gpExists = true;
            }
        }
        if (gpExists && (finalLeg === null || finalLeg === void 0 ? void 0 : finalLeg.calculated) !== undefined && ((_a = this.lnavData) === null || _a === void 0 ? void 0 : _a.state) !== undefined) {
            lpvDistance = this.calculator.getLpvDistance(plan.activeLateralLeg, alongLegDistance, this.lnavData.state.pos);
            const desiredLPVAltitude = this.calculator.getDesiredLpvAltitude(lpvDistance);
            const desiredLPVAltitudeFeet = UnitType.METER.convertTo(desiredLPVAltitude, UnitType.FOOT);
            lpvDeviation = desiredLPVAltitudeFeet - this.currentGpsAltitude;
            this.lpvDeviation.set(lpvDeviation);
            gpCalculated = true;
        }
        else {
            this.lpvDeviation.set(-1001);
        }
        SimVar.SetSimVarValue(VNavSimVars.LPVVerticalDeviation, SimVarValueType.Feet, lpvDeviation);
        SimVar.SetSimVarValue(VNavSimVars.LPVDistance, SimVarValueType.Number, lpvDistance);
        this.apValues.approachHasGP.set(gpCalculated);
        return lpvDistance;
    }
    /**
     * Gets the current required vertical speed.
     * @param distance is the distance to the constraint.
     * @param targetAltitude is the target altitude for the constraint.
     * @param currentAltitude is the current altitude (defaults to baro alt)
     * @returns the required vs in fpm.
     */
    getRequiredVs(distance, targetAltitude, currentAltitude = this.currentAltitude) {
        if (targetAltitude > 0) {
            const deviation = currentAltitude - UnitType.METER.convertTo(targetAltitude, UnitType.FOOT);
            if (deviation > 0 && distance > 0) {
                const fpaRequired = UnitType.RADIAN.convertTo(Math.atan((deviation / UnitType.NMILE.convertTo(distance, UnitType.FOOT))), UnitType.DEGREE);
                return UnitType.NMILE.convertTo(this.currentGroundSpeed / 60, UnitType.FOOT) * Math.tan(UnitType.DEGREE.convertTo(-fpaRequired, UnitType.RADIAN));
            }
        }
        return 0;
    }
    /**
     * Sets the leg distance from the current leg to the constraint leg, not include the distance to the current active leg.
     * @param plan is the flight plan.
     * @param constraintLegIndex is the leg index of the current constraint.
     */
    setConstraintDistance(plan, constraintLegIndex) {
        if (constraintLegIndex !== undefined && constraintLegIndex > -1) {
            const currentLeg = plan.getLeg(plan.activeLateralLeg);
            const constraintLeg = plan.getLeg(constraintLegIndex);
            if (constraintLeg.calculated && currentLeg.calculated && constraintLeg.calculated.cumulativeDistanceWithTurns && currentLeg.calculated.cumulativeDistanceWithTurns) {
                const currentLegCumulativeNM = UnitType.METER.convertTo(currentLeg.calculated.cumulativeDistanceWithTurns, UnitType.NMILE);
                const bodCumulativeNM = UnitType.METER.convertTo(constraintLeg.calculated.cumulativeDistanceWithTurns, UnitType.NMILE);
                this.constraintDistance = (bodCumulativeNM - currentLegCumulativeNM);
                return;
            }
        }
        this.constraintDistance = -1;
    }
}

/**
 * Handles the calculation of the VNAV flight path.
 */
class VNavPathCalculator {
    /**
     * Creates an instance of the VNavPathCalculator.
     * @param bus The EventBus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     */
    constructor(bus, flightPlanner) {
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.flightPathAngle = 3;
        this.maxFlightPathAngle = 6;
        this.segments = [];
        this.constraints = [];
        this.destLegIndex = 0;
        this.fafLegIndex = 0;
        this.discontinuityIndex = -1;
        this.missedApproachStartIndex = -1;
        this.isSuspended = false;
        this.cursor = {
            segment: new FlightPlanSegment(-1, -1, []),
            legIndex: -1,
            legDefinition: {
                leg: FlightPlan.createLeg({}),
                isInDirectToSequence: false,
                isInMissedApproachSequence: false
            },
            index: 0
        };
        this.currentAltitude = 0;
        this.lpvFpa = 0;
        const fpl = bus.getSubscriber();
        fpl.on('fplCopied').handle(e => e.planIndex === 0 && this.onPlanChanged());
        fpl.on('fplCreated').handle(e => e.planIndex === 0 && this.onPlanChanged());
        fpl.on('fplLegChange').handle(e => e.planIndex === 0 && this.onPlanChanged());
        fpl.on('fplLoaded').handle(e => e.planIndex === 0 && this.onPlanChanged());
        fpl.on('fplSegmentChange').handle(e => e.planIndex === 0 && this.onPlanChanged());
        fpl.on('fplIndexChanged').handle(this.onPlanChanged.bind(this));
        fpl.on('fplCalculated').handle(e => e.planIndex === 0 && this.computeVnavPath());
        bus.getSubscriber().on('alt').handle(alt => this.currentAltitude = UnitType.FOOT.convertTo(alt, UnitType.METER));
        bus.getSubscriber().on('suspChanged').handle(v => this.isSuspended = v);
    }
    /**
     * Gets a VNAV leg from the plan.
     * @param index The index of the leg to get.
     * @returns The requested VNAV leg.
     * @throws Not found if the index is not valid.
     */
    getLeg(index) {
        for (let i = 0; i < this.segments.length; i++) {
            const segment = this.segments[i];
            if (index >= segment.offset && index < segment.offset + segment.legs.length) {
                return segment.legs[index - segment.offset];
            }
        }
        throw new Error(`Leg with index ${index} not found`);
    }
    /**
     * Gets a VNAV leg from the plan from a specified segment.
     * @param segmentIndex The segment index of the leg to get.
     * @param legIndex The index of the leg to get within the specified segment.
     * @returns The requested VNAV leg.
     * @throws Not found if the index is not valid.
     */
    getLegFromSegment(segmentIndex, legIndex) {
        const segment = this.segments[segmentIndex];
        const leg = segment.legs[legIndex];
        if (segment && leg) {
            return leg;
        }
        else {
            throw new Error(`Leg from segment ${segmentIndex} index ${legIndex} not found`);
        }
    }
    /**
     * Gets a VNAV leg from the plan from a specified segment.
     * @returns The vnav segments.
     * @throws Not found if the index is not valid.
     */
    getSegments() {
        return this.segments;
    }
    /**
     * Gets the VNAV desired altitude.
     * @param index The leg index to get the target for.
     * @param distanceAlongLeg The distance along the leg the aircraft is presently.
     * @returns The current VNAV desired altitude.
     */
    getDesiredAltitude(index, distanceAlongLeg) {
        const priorConstraint = this.getIsPriorConstraintPathEnd(index);
        if (priorConstraint && priorConstraint.nextVnavEligibleLegIndex && index < priorConstraint.nextVnavEligibleLegIndex) {
            return priorConstraint.altitude;
        }
        const leg = this.getLeg(index);
        return leg.altitude + this.altitudeForDistance(leg.fpa, leg.distance - distanceAlongLeg);
    }
    /**
     * Gets the current LPV distance.
     * @param index The current leg index.
     * @param distanceAlongLeg The distance along the leg the aircraft is presently.
     * @param ppos The current position from LNAV Data State
     * @returns The current LPV distance.
     */
    getLpvDistance(index, distanceAlongLeg, ppos) {
        let globalLegIndex = 0;
        let distance = 0;
        const plan = this.flightPlanner.getFlightPlan(Fms.PRIMARY_PLAN_INDEX);
        const destLeg = plan.getLeg(this.destLegIndex);
        if (index <= this.destLegIndex) {
            for (let segmentIndex = 0; segmentIndex < this.segments.length; segmentIndex++) {
                const segment = this.segments[segmentIndex];
                for (let legIndex = 0; legIndex < segment.legs.length; legIndex++) {
                    const leg = segment.legs[legIndex];
                    if (globalLegIndex <= this.destLegIndex) {
                        if (index === globalLegIndex) {
                            distance += leg.distance - distanceAlongLeg;
                        }
                        else if (globalLegIndex > index) {
                            distance += segment.legs[legIndex].distance;
                        }
                    }
                    globalLegIndex++;
                }
            }
            if (ICAO.isFacility(destLeg.leg.fixIcao)
                && ICAO.getFacilityType(destLeg.leg.fixIcao) !== FacilityType.RWY
                && plan.procedureDetails.destinationRunway !== undefined
                && destLeg.calculated && destLeg.calculated.endLat !== undefined && destLeg.calculated.endLon !== undefined) {
                const runway = plan.procedureDetails.destinationRunway;
                const runwayGeoPoint = new GeoPoint(runway.latitude, runway.longitude);
                if (index === this.destLegIndex && this.isSuspended) {
                    distance = UnitType.GA_RADIAN.convertTo(runwayGeoPoint.distance(ppos), UnitType.METER);
                }
                else {
                    distance += UnitType.GA_RADIAN.convertTo(runwayGeoPoint.distance(destLeg.calculated.endLat, destLeg.calculated.endLon), UnitType.METER);
                }
            }
        }
        return distance;
    }
    /**
     * Gets the LPV desired altitude.
     * @param distance The current LPV distance.
     * @returns The current LPV desired altitude.
     */
    getDesiredLpvAltitude(distance) {
        return this.getLpvRunwayAltitude() + this.altitudeForDistance(this.lpvFpa, distance + 100);
    }
    /**
     * Gets the LPV runway altitude.
     * @returns The LPV runway altitude.
     */
    getLpvRunwayAltitude() {
        const plan = this.flightPlanner.getFlightPlan(Fms.PRIMARY_PLAN_INDEX);
        const destLeg = plan.getLeg(this.destLegIndex);
        let destAltitude = destLeg.leg.altitude1;
        if (ICAO.isFacility(destLeg.leg.fixIcao)
            && ICAO.getFacilityType(destLeg.leg.fixIcao) !== FacilityType.RWY
            && plan.procedureDetails.destinationRunway !== undefined) {
            destAltitude = plan.procedureDetails.destinationRunway.elevation;
        }
        return destAltitude;
    }
    /**
     * Gets the VNAV target altitude for the given leg index.
     * @param index The index of the leg.
     * @returns The next VNAV target altitude, or undefined if none exists.
     */
    getTargetAltitude(index) {
        const priorConstraint = this.getIsPriorConstraintPathEnd(index);
        if (priorConstraint && priorConstraint.nextVnavEligibleLegIndex && index < priorConstraint.nextVnavEligibleLegIndex) {
            return priorConstraint.altitude;
        }
        let i = this.constraints.length - 1;
        while (i >= 0) {
            const constraint = this.constraints[i];
            if (index <= constraint.index && constraint.isTarget && !constraint.isBeyondFaf) {
                return constraint.altitude;
            }
            i--;
        }
    }
    /**
     * Gets the VNAV TOD/BOD details.
     * @param index The current leg index.
     * @param distanceAlongLeg The distance the plane is along the current leg.
     * @returns The distance the plane is from the next TOD.
     */
    todBodDetails(index, distanceAlongLeg) {
        const details = {
            todLegIndex: -1,
            bodLegIndex: -1,
            distanceFromLegEnd: 0,
            distanceFromTod: 0,
            distanceFromBod: 0,
            currentConstraintIndex: -1
        };
        let globalIndex = 0;
        const constraint = this.getConstraintFromLegIndex(index);
        details.currentConstraintIndex = constraint && constraint.index ? constraint.index : -1;
        const priorConstraint = this.getIsPriorConstraintPathEnd(index);
        if (priorConstraint !== undefined && priorConstraint.nextVnavEligibleLegIndex && priorConstraint.nextVnavEligibleLegIndex > index) {
            return details;
        }
        for (let i = 0; i < this.segments.length && details.bodLegIndex === -1; i++) {
            const segment = this.segments[i];
            for (let l = 0; l < segment.legs.length; l++) {
                const leg = segment.legs[l];
                if (globalIndex >= index) {
                    if (details.todLegIndex === -1) {
                        if (index === globalIndex) {
                            details.distanceFromTod = leg.distance - distanceAlongLeg;
                        }
                        else {
                            details.distanceFromTod += leg.distance;
                        }
                        if (leg.todDistance !== undefined && leg.altitude <= this.currentAltitude) {
                            details.todLegIndex = globalIndex;
                            details.distanceFromTod -= leg.todDistance;
                            details.distanceFromLegEnd = leg.todDistance;
                        }
                    }
                    if (leg.isBod) {
                        details.bodLegIndex = globalIndex;
                        const plan = this.flightPlanner.getFlightPlan(Fms.PRIMARY_PLAN_INDEX);
                        const currentLeg = plan.getLeg(plan.activeLateralLeg);
                        let bodDistanceInMeters = 0;
                        if (plan.activeLateralLeg === globalIndex && currentLeg.calculated) {
                            bodDistanceInMeters = currentLeg.calculated.distanceWithTurns - distanceAlongLeg;
                        }
                        else if (plan.activeLateralLeg < globalIndex) {
                            const bodLeg = plan.getLeg(globalIndex);
                            if (bodLeg.calculated && currentLeg.calculated && bodLeg.calculated.cumulativeDistanceWithTurns && currentLeg.calculated.cumulativeDistanceWithTurns) {
                                bodDistanceInMeters = (bodLeg.calculated.cumulativeDistanceWithTurns - currentLeg.calculated.cumulativeDistanceWithTurns)
                                    + (currentLeg.calculated.distanceWithTurns - distanceAlongLeg);
                            }
                        }
                        details.distanceFromBod = bodDistanceInMeters;
                        if (details.todLegIndex < index) {
                            details.distanceFromTod = 0;
                        }
                        return details;
                    }
                }
                globalIndex++;
            }
        }
        if (details.todLegIndex < index) {
            details.distanceFromTod = 0;
        }
        return details;
    }
    /**
     * Gets and returns the FAF altitude.
     * @returns the FAF constraint altitude.
     */
    getFafAltitude() {
        return this.getLeg(this.fafLegIndex).altitude;
    }
    /**
     * Gets and returns the FAF Leg Index.
     * @returns the FAF Leg Index.
     */
    getFafLegIndex() {
        return this.fafLegIndex;
    }
    /**
     * Gets and returns whether the input leg index is a path end.
     * @param legIndex is the global leg index to check.
     * @returns whether the input leg index is a path end.
     */
    getIsPathEnd(legIndex) {
        const constraintIndex = this.constraints.findIndex(c => c.index === legIndex);
        if (constraintIndex > -1 && this.constraints[constraintIndex].isPathEnd) {
            return true;
        }
        return false;
    }
    /**
     * Gets and returns the current constraint altitude.
     * @param index is the global leg index to check.
     * @returns the altitude or undefined.
     */
    getCurrentConstraintAltitude(index) {
        const priorConstraint = this.getIsPriorConstraintPathEnd(index);
        const currentConstraint = this.getConstraintFromLegIndex(index);
        if (priorConstraint && priorConstraint.nextVnavEligibleLegIndex && index < priorConstraint.nextVnavEligibleLegIndex) {
            return priorConstraint.altitude;
        }
        else {
            return currentConstraint && currentConstraint.altitude ? currentConstraint.altitude : undefined;
        }
    }
    /**
     * Gets and returns the next constraint altitude.
     * @param index is the global leg index to check.
     * @returns the altitude or undefined.
     */
    getNextConstraintAltitude(index) {
        const currentConstraint = this.getConstraintFromLegIndex(index);
        return currentConstraint && currentConstraint.altitude ? currentConstraint.altitude : undefined;
    }
    /**
     * Calculates the LPV flight path angle using the destination elevation
     * and FAF altitude restriction.
     * @param plan The plan to calculate from.
     * @param fafIndex The leg index of the FAF.
     * @param destIndex The leg index of the destination.
     */
    calcLpvFpa(plan, fafIndex, destIndex) {
        // TODO: make smarter - don't calc FPA if RNAV approach isn't loaded.
        if (plan.length < 2 || fafIndex > plan.length || destIndex > plan.length) {
            return;
        }
        const fafLeg = plan.getLeg(fafIndex);
        const destLeg = plan.getLeg(destIndex);
        let fafToDestDistance = 0;
        for (let i = fafIndex + 1; i <= destIndex; i++) {
            const leg = plan.getLeg(i);
            if (leg.calculated !== undefined) {
                fafToDestDistance += leg.calculated.distance;
            }
        }
        let destAltitude = destLeg.leg.altitude1;
        if (ICAO.isFacility(destLeg.leg.fixIcao)
            && ICAO.getFacilityType(destLeg.leg.fixIcao) !== FacilityType.RWY
            && plan.procedureDetails.destinationRunway !== undefined
            && destLeg.calculated && destLeg.calculated.endLat !== undefined && destLeg.calculated.endLon !== undefined) {
            const runway = plan.procedureDetails.destinationRunway;
            const runwayGeoPoint = new GeoPoint(runway.latitude, runway.longitude);
            destAltitude = runway.elevation;
            fafToDestDistance += UnitType.GA_RADIAN.convertTo(runwayGeoPoint.distance(destLeg.calculated.endLat, destLeg.calculated.endLon), UnitType.METER);
        }
        this.lpvFpa = this.getFpa(fafToDestDistance + 225, fafLeg.leg.altitude1 - destAltitude + 15);
    }
    /**
     * Fills the VNAV plan leg and constraint segment distances.
     */
    fillLegAndConstraintDistances() {
        this.iterateReverse(cursor => { var _a, _b; return this.segments[cursor.segment.segmentIndex].legs[cursor.legIndex].distance = (_b = (_a = cursor.legDefinition.calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTurns) !== null && _b !== void 0 ? _b : 0; });
        for (let constraintIndex = 0; constraintIndex < this.constraints.length; constraintIndex++) {
            const constraint = this.constraints[constraintIndex];
            constraint.distance = 0;
            for (let legIndex = 0; legIndex < constraint.legs.length; legIndex++) {
                constraint.distance += constraint.legs[legIndex].distance;
            }
        }
    }
    /**
     * Computes the flight path angles for each constraint segment.
     */
    computeFlightPathAngles() {
        let isCurrentlyDirect = false;
        for (let i = 0; i < this.constraints.length; i++) {
            const currentConstraint = this.constraints[i];
            const nextConstraint = this.constraints[i + 1];
            if (currentConstraint.type !== 'direct') {
                currentConstraint.fpa = this.flightPathAngle;
            }
            currentConstraint.isTarget = isCurrentlyDirect ? false : true;
            if (currentConstraint.index === this.fafLegIndex) {
                currentConstraint.isTarget = true;
            }
            if (currentConstraint.index > this.fafLegIndex) {
                currentConstraint.isBeyondFaf = true;
            }
            if (nextConstraint !== undefined && nextConstraint.type !== 'dep' && !nextConstraint.isPathEnd) {
                const directFpa = this.getFpa(currentConstraint.distance, nextConstraint.altitude - currentConstraint.altitude);
                const endAltitude = currentConstraint.altitude + this.altitudeForDistance(this.flightPathAngle, currentConstraint.distance);
                const todDistance = this.distanceForAltitude(this.flightPathAngle, nextConstraint.altitude - currentConstraint.altitude);
                currentConstraint.todDistance = todDistance;
                //If going direct is within a half a degree of the default FPA, or if we were unable to meet
                //the next constraint, go direct
                if (Math.abs(directFpa - this.flightPathAngle) <= 0.5 || endAltitude < nextConstraint.altitude) {
                    currentConstraint.fpa = directFpa;
                    isCurrentlyDirect = true;
                    currentConstraint.todDistance = currentConstraint.distance;
                }
                else if (currentConstraint.altitude === nextConstraint.altitude || currentConstraint.isBeyondFaf) {
                    currentConstraint.fpa = 0;
                    isCurrentlyDirect = false;
                }
                else {
                    isCurrentlyDirect = false;
                }
            }
            else {
                isCurrentlyDirect = false;
            }
            //If the constraint is a vertical direct, check if an FPA > 3 is required and, if so, attempt to set the max FPA
            if (currentConstraint.type === 'direct' && !nextConstraint && currentConstraint.fpa === 0) {
                const plan = this.flightPlanner.getActiveFlightPlan();
                const directTargetSegment = plan.directToData.segmentIndex;
                const directTargetLegIndex = plan.directToData.segmentLegIndex;
                let distance = 0;
                for (let l = 0; l < currentConstraint.legs.length; l++) {
                    const leg = currentConstraint.legs[l];
                    distance += leg.distance;
                    if (leg.segmentIndex === directTargetSegment && leg.legIndex === directTargetLegIndex) {
                        break;
                    }
                }
                const fpaRequired = this.getFpa(distance, 50 + this.currentAltitude - currentConstraint.altitude);
                currentConstraint.fpa = Utils.Clamp(fpaRequired, 3, this.maxFlightPathAngle);
                currentConstraint.todDistance = this.distanceForAltitude(currentConstraint.fpa, this.currentAltitude - currentConstraint.altitude);
            }
        }
    }
    /**
     * Computes the VNAV descent path.
     */
    computeVnavPath() {
        this.fillLegAndConstraintDistances();
        this.computeFlightPathAngles();
        for (let constraintIndex = 0; constraintIndex < this.constraints.length; constraintIndex++) {
            const constraint = this.constraints[constraintIndex];
            let todDistance = constraint.todDistance;
            let altitude = constraint.altitude;
            //If the next constraint altitude is going to bust our current altitude, adjust the
            //constraint segment TOD distance to match our current altitude
            const nextAlt = constraint.altitude + this.altitudeForDistance(constraint.fpa, constraint.distance);
            if (nextAlt > this.currentAltitude) {
                todDistance = this.distanceForAltitude(constraint.fpa, this.currentAltitude - altitude);
            }
            for (let legIndex = 0; legIndex < constraint.legs.length; legIndex++) {
                const leg = constraint.legs[legIndex];
                leg.fpa = constraint.index <= this.fafLegIndex ? constraint.fpa : 0;
                leg.altitude = altitude;
                altitude += this.altitudeForDistance(leg.fpa, leg.distance);
                if (legIndex === 0) {
                    leg.isAdvisory = false;
                }
                else {
                    leg.isAdvisory = true;
                }
                if (legIndex === 0 && constraint.isTarget) {
                    leg.isBod = true;
                }
                else {
                    leg.isBod = false;
                }
                if (leg.distance >= todDistance && !constraint.isBeyondFaf) {
                    leg.todDistance = todDistance;
                }
                else {
                    leg.todDistance = undefined;
                    todDistance -= leg.distance;
                }
            }
        }
        this.calcLpvFpa(this.flightPlanner.getFlightPlan(Fms.PRIMARY_PLAN_INDEX), this.fafLegIndex, this.destLegIndex);
        this.notify();
    }
    /**
     * Resets the VNAV plan segments, legs, and constraints based on the new plan.
     */
    onPlanChanged() {
        this.fafLegIndex = this.getFafIndex();
        this.constraints.length = 0;
        let currentConstraintAlt = 0;
        let forceNextConstraintAsTarget = false;
        let vnavIneligibleIndex = -1;
        let currentConstraint = this.createConstraint(0, 0, '$DEST', 'dest');
        let currentSegmentIndex = -1;
        this.segments.length = 0;
        this.discontinuityIndex = -1;
        const plan = this.flightPlanner.getFlightPlan(Fms.PRIMARY_PLAN_INDEX);
        for (const segment of plan.segments()) {
            this.segments[segment.segmentIndex] = {
                offset: segment.offset,
                legs: []
            };
        }
        this.destLegIndex = Math.max(0, plan.length - 1);
        this.missedApproachStartIndex = this.destLegIndex;
        this.destLegIndex = Math.max(0, plan.length - 1);
        this.missedApproachStartIndex = this.destLegIndex;
        this.iterateReverse(cursor => {
            var _a, _b;
            if (cursor.segment.segmentIndex !== currentSegmentIndex) {
                currentSegmentIndex = cursor.segment.segmentIndex;
            }
            if (cursor.legDefinition.leg.type === LegType.Discontinuity) {
                this.discontinuityIndex = cursor.segment.offset + cursor.legIndex;
                if (currentConstraint.altitude < this.currentAltitude) {
                    currentConstraint.type = 'direct';
                }
            }
            const leg = this.createLeg(cursor.segment.segmentIndex, cursor.legIndex, (_a = cursor.legDefinition.name) !== null && _a !== void 0 ? _a : '');
            if (cursor.segment.segmentType === FlightPlanSegmentType.Approach) {
                //Check if the leg is part of the missed approach
                if (cursor.legDefinition.isInMissedApproachSequence) {
                    this.missedApproachStartIndex = cursor.segment.offset + cursor.legIndex;
                }
                //Check if the leg is the destination leg
                if (!cursor.legDefinition.isInMissedApproachSequence && this.missedApproachStartIndex === cursor.segment.offset + cursor.legIndex + 1) {
                    this.destLegIndex = cursor.segment.offset + cursor.legIndex;
                }
            }
            //If the current leg has a valid constraint, create a new constraint segment
            if (cursor.legDefinition.leg.altDesc !== AltitudeRestrictionType.Unused && this.discontinuityIndex < 0 && !cursor.legDefinition.isInMissedApproachSequence) {
                const constraintAlt = this.getConstraintAltitude(cursor.legDefinition.leg);
                //Only create constraint segments if the previous constraint is lower or the same, in order to reject
                //climb constraints
                if (constraintAlt >= currentConstraintAlt) {
                    //If we happen to be in the destination segment (i.e. the end of the plan)
                    //set the alt to the next constraint alt so that the segment is flat
                    if (currentConstraint.type === 'dest') {
                        currentConstraint.altitude = constraintAlt;
                    }
                    const dep = cursor.segment.segmentType === FlightPlanSegmentType.Departure ? true : false;
                    currentConstraint = this.createConstraint(cursor.segment.offset + cursor.legIndex, constraintAlt, (_b = cursor.legDefinition.name) !== null && _b !== void 0 ? _b : '', (dep ? 'dep' : 'normal'));
                    if (forceNextConstraintAsTarget) {
                        currentConstraint.isTarget = true;
                        currentConstraint.isPathEnd = true;
                        currentConstraint.nextVnavEligibleLegIndex = vnavIneligibleIndex + 1;
                        forceNextConstraintAsTarget = false;
                        vnavIneligibleIndex = -1;
                    }
                    if (cursor.segment.offset + cursor.legIndex === this.fafLegIndex) {
                        currentConstraint.isTarget = true;
                        currentConstraint.isPathEnd = true;
                    }
                    this.constraints.push(currentConstraint);
                    currentConstraintAlt = constraintAlt;
                }
            }
            currentConstraint.legs.push(leg);
            this.segments[cursor.segment.segmentIndex].legs.unshift(leg);
            if (this.discontinuityIndex < 0) {
                switch (cursor.legDefinition.leg.type) {
                    case LegType.HA:
                    case LegType.HM:
                    case LegType.HF:
                    case LegType.VM:
                    case LegType.FM:
                    case LegType.PI:
                        forceNextConstraintAsTarget = true;
                        if (vnavIneligibleIndex < 0) {
                            vnavIneligibleIndex = cursor.segment.offset + cursor.legIndex;
                        }
                }
            }
        });
        this.calcLpvFpa(plan, this.fafLegIndex, this.destLegIndex);
    }
    /**
     * Gets the FAF index in the plan.
     * @returns The FAF index in the plan.
     */
    getFafIndex() {
        const plan = this.flightPlanner.getFlightPlan(Fms.PRIMARY_PLAN_INDEX);
        let fafIndex = plan.length - 2;
        this.iterateReverse(cursor => {
            if (cursor.legDefinition.leg.fixTypeFlags & FixTypeFlags.FAF) {
                fafIndex = cursor.legIndex + cursor.segment.offset;
                return;
            }
        });
        return fafIndex;
    }
    /**
     * Gets an increase in altitude for a given flight path angle and
     * lateral distance.
     * @param fpa The flight path angle to use, in degrees.
     * @param distance The lateral distance.
     * @returns The increase in altitude.
     */
    altitudeForDistance(fpa, distance) {
        return Math.tan(UnitType.DEGREE.convertTo(fpa, UnitType.RADIAN)) * distance;
    }
    /**
     * Gets a lateral distance for a given altitude increase and flight
     * path angle.
     * @param fpa The flight path angle to use, in degrees.
     * @param altitude The increase in altitude.
     * @returns The lateral distance.
     */
    distanceForAltitude(fpa, altitude) {
        return altitude / Math.tan(UnitType.DEGREE.convertTo(fpa, UnitType.RADIAN));
    }
    /**
     * Gets the flight path angle for a given distance and altitude.
     * @param distance The distance to get the angle for.
     * @param altitude The altitude to get the angle for.
     * @returns The required flight path angle, in degrees.
     */
    getFpa(distance, altitude) {
        return UnitType.RADIAN.convertTo(Math.atan(altitude / distance), UnitType.DEGREE);
    }
    /**
     * Gets the leg index for the current constraint.
     * @param index The current leg index.
     * @returns Index if the current constraint, or -1 if none is found.
     */
    getCurrentConstraintIndex(index) {
        for (let c = this.constraints.length - 1; c >= 0; c--) {
            const constraintIndex = this.constraints[c].index;
            if (constraintIndex >= index) {
                return constraintIndex;
            }
        }
        return -1;
    }
    /**
     * Gets the VNAV Constraint that contains the supplied leg index.
     * @param legIndex The flight plan leg index to find the constraint for.
     * @returns The VNAV Constraint that contains the input leg index.
     */
    getConstraintFromLegIndex(legIndex) {
        if (this.constraints.length > 0) {
            const constraintIndex = this.constraints.findIndex(c => c.index === this.getCurrentConstraintIndex(legIndex));
            return this.constraints[constraintIndex];
        }
        return undefined;
    }
    /**
     * Gets the first VNAV Constraint Altitude.
     * @returns The first VNAV constraint altitude in the plan.
     */
    getFirstDescentConstraintAltitude() {
        if (this.constraints.length > 0) {
            for (let i = this.constraints.length - 1; i >= 0; i--) {
                const constraint = this.constraints[i];
                if (constraint.type !== 'dep') {
                    return constraint.altitude;
                }
            }
        }
        return undefined;
    }
    /**
     * Checks if the prior constraint was a path end.
     * @param index The current leg index.
     * @returns Whether the prior constraint was a path end.
     */
    getIsPriorConstraintPathEnd(index) {
        for (let c = 0; c < this.constraints.length; c++) {
            if (this.constraints[c].index < index) {
                return this.constraints[c];
            }
        }
        return undefined;
    }
    /**
     * Gets the constraint for a leg altitude restriction.
     * @param leg The leg to get the constraint for.
     * @returns The altitude constraint.
     */
    getConstraintAltitude(leg) {
        switch (leg.altDesc) {
            case AltitudeRestrictionType.At:
            case AltitudeRestrictionType.AtOrAbove:
            case AltitudeRestrictionType.AtOrBelow:
                return leg.altitude1;
            case AltitudeRestrictionType.Between:
                return leg.altitude2;
        }
        return Number.POSITIVE_INFINITY;
    }
    /**
     * Iterates through the active flight plan in reverse order.
     * @param each The function to call for each flight plan leg.
     */
    iterateReverse(each) {
        const plan = this.flightPlanner.getFlightPlan(Fms.PRIMARY_PLAN_INDEX);
        let segmentIndex = plan.segmentCount - 1;
        let index = 0;
        while (segmentIndex >= 0) {
            const segment = plan.getSegment(segmentIndex);
            let legIndex = segment.legs.length - 1;
            while (legIndex >= 0) {
                this.cursor.legDefinition = segment.legs[legIndex];
                this.cursor.legIndex = legIndex;
                this.cursor.segment = segment;
                this.cursor.index = index;
                each(this.cursor);
                legIndex--;
                index++;
            }
            segmentIndex--;
        }
    }
    /**
     * Creates a new empty constraint.
     * @param index The leg index of the constraint.
     * @param altitude The altitude of the constraint.
     * @param name The name of the leg for the constraint.
     * @param type The type of constraint.
     * @returns A new empty constraint.
     */
    createConstraint(index, altitude, name, type = 'normal') {
        return {
            index,
            altitude,
            name,
            isTarget: false,
            isPathEnd: false,
            todDistance: 0,
            distance: 0,
            fpa: 0,
            legs: [],
            type,
            isBeyondFaf: false
        };
    }
    /**
     * Creates a new VNAV plan leg.
     * @param segmentIndex The segment index for the leg.
     * @param legIndex The index of the leg within the segment.
     * @param name The name of the leg.
     * @returns A new VNAV plan leg.
     */
    createLeg(segmentIndex, legIndex, name) {
        return {
            segmentIndex,
            legIndex,
            fpa: 0,
            altitude: 0,
            isUserDefined: false,
            distance: 0,
            isBod: false,
            isAdvisory: true,
            name
        };
    }
    /**
     * Sends an event on the fpl bus that the vertical plan has been updated.
     */
    notify() {
        this.bus.pub('vnavUpdated', true, false);
    }
}

/// <reference types="msfstypes/JS/simvar" />
/**
 * An altitude capture autopilot director.
 */
class APAltCapDirector {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues are the ap selected values for the autopilot.
     */
    constructor(bus, apValues) {
        this.bus = bus;
        this.apValues = apValues;
        this.groundSpeed = 0;
        this.capturedAltitude = 0;
        this.indicatedAltitude = 0;
        this.verticalSpeed = 0;
        this.initialFpa = 0;
        this.selectedAltitude = 0;
        this.state = DirectorState.Inactive;
        this.bus.getSubscriber().on('ground_speed').withPrecision(0).handle((g) => {
            this.groundSpeed = g;
        });
        const adc = this.bus.getSubscriber();
        adc.on('alt').withPrecision(0).handle((alt) => {
            this.indicatedAltitude = alt;
        });
        adc.on('vs').withPrecision(0).handle((vs) => {
            this.verticalSpeed = vs;
        });
        this.apValues.capturedAltitude.sub((cap) => {
            this.capturedAltitude = Math.round(cap);
        });
        this.apValues.selectedAltitude.sub((alt) => {
            this.selectedAltitude = alt;
        });
    }
    /**
     * Activates this director.
     */
    activate() {
        this.state = DirectorState.Active;
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        this.setCaptureFpa(this.verticalSpeed);
        SimVar.SetSimVarValue('AUTOPILOT ALTITUDE LOCK', 'Bool', true);
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
        this.state = DirectorState.Armed;
        if (this.onArm !== undefined) {
            this.onArm();
        }
    }
    /**
     * Deactivates this director.
     * @param captured is whether the altitude was captured.
     */
    deactivate(captured = false) {
        this.state = DirectorState.Inactive;
        if (!captured) {
            SimVar.SetSimVarValue('AUTOPILOT ALTITUDE LOCK', 'Bool', false);
        }
        //this.capturedAltitude = 0;
    }
    /**
     * Updates this director.
     */
    update() {
        if (this.state === DirectorState.Active) {
            this.captureAltitude(this.capturedAltitude);
        }
        if (this.state === DirectorState.Armed) {
            this.tryActivate();
        }
    }
    /**
     * Attempts to activate altitude capture.
     */
    tryActivate() {
        const deviationFromTarget = Math.abs(this.selectedAltitude - this.indicatedAltitude);
        if (deviationFromTarget <= Math.abs(this.verticalSpeed / 6)) {
            this.apValues.capturedAltitude.set(Math.round(this.selectedAltitude));
            this.activate();
        }
    }
    /**
     * Holds a captured altitude.
     * @param targetAltitude is the captured targed altitude
     */
    captureAltitude(targetAltitude) {
        const altCapDeviation = this.indicatedAltitude - targetAltitude;
        const altCapPitchPercentage = Math.min(Math.abs(altCapDeviation) / 100, 1);
        const desiredPitch = (this.initialFpa * altCapPitchPercentage);
        const aoa = SimVar.GetSimVarValue('INCIDENCE ALPHA', SimVarValueType.Degree);
        const targetPitch = aoa + MathUtils.clamp(desiredPitch, -6, 6);
        this.setPitch(targetPitch);
    }
    /**
     * Sets the initial capture FPA from the current vs value when capture is initiated.
     * @param vs target vertical speed.
     */
    setCaptureFpa(vs) {
        if (Math.abs(vs) < 400) {
            const altCapDeviation = this.indicatedAltitude - this.selectedAltitude;
            vs = altCapDeviation > 0 ? -400 : 400;
        }
        this.initialFpa = this.getFpa(UnitType.NMILE.convertTo(this.groundSpeed / 60, UnitType.FOOT), vs);
    }
    /**
     * Gets a desired fpa.
     * @param distance is the distance traveled per minute.
     * @param altitude is the vertical speed per minute.
     * @returns The desired pitch angle.
     */
    getFpa(distance, altitude) {
        return UnitType.RADIAN.convertTo(Math.atan(altitude / distance), UnitType.DEGREE);
    }
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    setPitch(targetPitch) {
        if (isFinite(targetPitch)) {
            SimVar.SetSimVarValue('AUTOPILOT PITCH HOLD REF', SimVarValueType.Degree, -targetPitch);
        }
    }
}

/// <reference types="msfstypes/JS/simvar" />
/**
 * An altitude hold autopilot director.
 */
class APAltDirector {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues are the ap selected values for the autopilot.
     */
    constructor(bus, apValues) {
        this.bus = bus;
        this.groundSpeed = 0;
        this.capturedAltitude = 0;
        this.indicatedAltitude = 0;
        this.state = DirectorState.Inactive;
        this.bus.getSubscriber().on('ground_speed').withPrecision(0).handle((g) => {
            this.groundSpeed = g;
        });
        this.bus.getSubscriber().on('alt').withPrecision(0).handle((alt) => {
            this.indicatedAltitude = alt;
        });
        apValues.capturedAltitude.sub((cap) => {
            this.capturedAltitude = Math.round(cap);
        });
    }
    /**
     * Activates this director.
     */
    activate() {
        this.state = DirectorState.Active;
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        SimVar.SetSimVarValue('AUTOPILOT ALTITUDE LOCK', 'Bool', true);
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
        this.state = DirectorState.Armed;
        if (this.onArm !== undefined) {
            this.onArm();
        }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        SimVar.SetSimVarValue('AUTOPILOT ALTITUDE LOCK', 'Bool', false);
    }
    /**
     * Updates this director.
     */
    update() {
        if (this.state === DirectorState.Active) {
            this.holdAltitude(this.capturedAltitude);
        }
        if (this.state === DirectorState.Armed) {
            this.tryActivate();
        }
    }
    /**
     * Attempts to activate altitude capture.
     */
    tryActivate() {
        const deviationFromTarget = Math.abs(this.capturedAltitude - this.indicatedAltitude);
        if (deviationFromTarget <= 20) {
            this.activate();
        }
    }
    /**
     * Holds a captured altitude.
     * @param targetAltitude is the captured targed altitude
     */
    holdAltitude(targetAltitude) {
        const deltaAlt = this.indicatedAltitude - targetAltitude;
        let setVerticalSpeed = 0;
        const correction = MathUtils.clamp(10 * Math.abs(deltaAlt), 100, 500);
        if (deltaAlt > 10) {
            setVerticalSpeed = 0 - correction;
        }
        else if (deltaAlt < -10) {
            setVerticalSpeed = correction;
        }
        this.setPitch(this.getDesiredPitch(setVerticalSpeed));
    }
    /**
     * Gets a desired pitch from the selected vs value.
     * @param vs target vertical speed.
     * @returns The desired pitch angle.
     */
    getDesiredPitch(vs) {
        //We need the instant AOA and VS here so we're avoiding the bus
        const aoa = SimVar.GetSimVarValue('INCIDENCE ALPHA', SimVarValueType.Degree);
        const desiredPitch = this.getFpa(UnitType.NMILE.convertTo(this.groundSpeed / 60, UnitType.FOOT), vs);
        return NavMath.clamp(aoa + desiredPitch, -10, 10);
    }
    /**
     * Gets a desired fpa.
     * @param distance is the distance traveled per minute.
     * @param altitude is the vertical speed per minute.
     * @returns The desired pitch angle.
     */
    getFpa(distance, altitude) {
        return UnitType.RADIAN.convertTo(Math.atan(altitude / distance), UnitType.DEGREE);
    }
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    setPitch(targetPitch) {
        if (isFinite(targetPitch)) {
            SimVar.SetSimVarValue('AUTOPILOT PITCH HOLD REF', SimVarValueType.Degree, -targetPitch);
        }
    }
}

/// <reference types="msfstypes/JS/simvar" />
/**
 * A Flight Level Change autopilot director.
 */
class APFLCDirector {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues is the AP selected values subject.
     */
    constructor(bus, apValues) {
        this.bus = bus;
        this._lastTime = 0;
        this.currentIas = 0;
        this.selectedIas = 0;
        this.selectedAltitude = 0;
        this.currentAltitude = 0;
        this.currentPitch = 0;
        this.accelerationController = new PidController(.3, 0, 0.5, 10, -10);
        this.pitchController = new PidController(1.5, 0, 0, 15, -15);
        this.state = DirectorState.Inactive;
        const adc = this.bus.getSubscriber();
        adc.on('alt').withPrecision(0).handle((alt) => {
            this.currentAltitude = alt;
        });
        adc.on('ias').withPrecision(2).handle((ias) => {
            this.currentIas = ias;
        });
        adc.on('pitch_deg').withPrecision(1).handle((pitch) => {
            this.currentPitch = -pitch;
        });
        apValues.selectedIas.sub((ias) => {
            this.selectedIas = ias;
        });
        apValues.selectedAltitude.sub((alt) => {
            this.selectedAltitude = alt;
        });
    }
    /**
     * Activates this director.
     */
    activate() {
        this.state = DirectorState.Active;
        this.initialize();
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        SimVar.SetSimVarValue('AUTOPILOT FLIGHT LEVEL CHANGE', 'Bool', true);
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
        if (this.state == DirectorState.Inactive) {
            this.activate();
        }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        SimVar.SetSimVarValue('AUTOPILOT FLIGHT LEVEL CHANGE', 'Bool', false);
    }
    /**
     * Updates this director.
     */
    update() {
        if (this.state === DirectorState.Active) {
            this.setPitch(this.getDesiredPitch());
        }
    }
    /**
     * Initializes this director on activation.
     */
    initialize() {
        this._lastTime = 0;
        this.accelerationController.reset();
        this.pitchController.reset();
    }
    /**
     * Gets a desired pitch from the selected vs value.
     * @returns The desired pitch angle.
     */
    getDesiredPitch() {
        const time = performance.now() / 1000;
        let dt = time - this._lastTime;
        if (this._lastTime === 0) {
            dt = 0;
        }
        //step 1 - we want to find the IAS error from target and set a target acceleration
        const iasError = this.currentIas - this.selectedIas;
        const targetAcceleration = this.accelerationController.getOutput(dt, -iasError);
        //step 2 - we want to find the current acceleration, feed that to the pid to manage to the target acceleration
        const acceleration = UnitType.FOOT.convertTo(SimVar.GetSimVarValue('ACCELERATION BODY Z', 'feet per second squared'), UnitType.NMILE) * 3600;
        const accelerationError = acceleration - targetAcceleration;
        const pitchCorrection = this.pitchController.getOutput(dt, accelerationError);
        const aoa = SimVar.GetSimVarValue('INCIDENCE ALPHA', SimVarValueType.Degree);
        this._lastTime = time;
        const targetPitch = isNaN(pitchCorrection) ? this.currentPitch - aoa : (this.currentPitch - aoa) + pitchCorrection;
        if (this.selectedAltitude > this.currentAltitude) {
            return MathUtils.clamp(targetPitch + aoa, aoa, 15);
        }
        else {
            return MathUtils.clamp(targetPitch + aoa, -15, aoa);
        }
    }
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    setPitch(targetPitch) {
        if (isFinite(targetPitch)) {
            SimVar.SetSimVarValue('AUTOPILOT PITCH HOLD REF', SimVarValueType.Degree, -targetPitch);
        }
    }
}

/// <reference types="msfstypes/JS/simvar" />
/**
 * A heading autopilot director.
 */
class APHdgDirector {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues The AP Values from the Autopilot.
     */
    constructor(bus, apValues) {
        this.bus = bus;
        this.currentBankRef = 0;
        this.currentHeading = 0;
        this.selectedHeading = 0;
        this.bankServo = new LinearServo(10);
        this.state = DirectorState.Inactive;
        apValues.selectedHeading.sub((h) => {
            this.selectedHeading = h;
        });
        const adc = this.bus.getSubscriber();
        adc.on('hdg_deg').withPrecision(0).handle((h) => {
            this.currentHeading = h;
        });
    }
    /**
     * Activates this director.
     */
    activate() {
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        SimVar.SetSimVarValue('AUTOPILOT HEADING LOCK', 'Bool', true);
        this.state = DirectorState.Active;
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
        if (this.state == DirectorState.Inactive) {
            this.activate();
        }
    }
    /**
     * Deactivates this director.
     */
    async deactivate() {
        await SimVar.SetSimVarValue('AUTOPILOT HEADING LOCK', 'Bool', false);
        this.state = DirectorState.Inactive;
    }
    /**
     * Updates this director.
     */
    update() {
        if (this.state === DirectorState.Active) {
            // let bankAngle = this.desiredBank(NavMath.normalizeHeading(this.dtk + interceptAngle), this.xtk);
            this.setBank(this.desiredBank(this.selectedHeading));
        }
    }
    /**
     * Gets a desired bank from a Target Selected Heading.
     * @param targetHeading The target heading.
     * @returns The desired bank angle.
     */
    desiredBank(targetHeading) {
        const turnDirection = NavMath.getTurnDirection(this.currentHeading, targetHeading);
        const headingDiff = Math.abs(NavMath.diffAngle(this.currentHeading, targetHeading));
        let baseBank = Math.min(1.25 * headingDiff, 25);
        baseBank *= (turnDirection === 'left' ? 1 : -1);
        return baseBank;
    }
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    setBank(bankAngle) {
        if (isFinite(bankAngle)) {
            this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
            SimVar.SetSimVarValue('AUTOPILOT BANK HOLD REF', 'degrees', this.currentBankRef);
        }
    }
}

/// <reference types="msfstypes/JS/simvar" />
/**
 * An autopilot pitch director.
 */
class APPitchDirector {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues are the AP Values subjects.
     */
    constructor(bus, apValues) {
        this.bus = bus;
        this.apValues = apValues;
        this.selectedPitch = 0;
        this.currentPitch = 0;
        this.state = DirectorState.Inactive;
        this.apValues.selectedPitch.sub((p) => {
            this.selectedPitch = p;
        });
        const adc = this.bus.getSubscriber();
        adc.on('pitch_deg').withPrecision(1).handle((p) => {
            this.currentPitch = p;
        });
    }
    /**
     * Activates this director.
     */
    activate() {
        this.state = DirectorState.Active;
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        this.apValues.selectedPitch.set(this.currentPitch);
        SimVar.SetSimVarValue('AUTOPILOT PITCH HOLD', 'Bool', true);
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
        if (this.state == DirectorState.Inactive) {
            this.activate();
        }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        SimVar.SetSimVarValue('AUTOPILOT PITCH HOLD', 'Bool', false);
    }
    /**
     * Updates this director.
     */
    update() {
        if (this.state === DirectorState.Active) {
            this.setPitch(this.selectedPitch);
        }
    }
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    setPitch(targetPitch) {
        if (isFinite(targetPitch)) {
            SimVar.SetSimVarValue('AUTOPILOT PITCH HOLD REF', SimVarValueType.Degree, targetPitch);
        }
    }
}

/// <reference types="msfstypes/JS/simvar" />
/**
 * An autopilot roll director.
 */
class APRollDirector {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     */
    constructor(bus) {
        this.bus = bus;
        this.currentBankRef = 0;
        this.desiredBank = 0;
        this.actualBank = 0;
        this.bankServo = new LinearServo(10);
        this.state = DirectorState.Inactive;
        const adc = this.bus.getSubscriber();
        adc.on('roll_deg').withPrecision(1).handle((roll) => {
            this.actualBank = roll;
        });
    }
    /**
     * Activates this director.
     */
    activate() {
        this.state = DirectorState.Active;
        this.desiredBank = this.actualBank;
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        SimVar.SetSimVarValue('AUTOPILOT BANK HOLD', 'Bool', true);
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
        if (this.state == DirectorState.Inactive) {
            this.activate();
        }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        this.desiredBank = 0;
        SimVar.SetSimVarValue('AUTOPILOT BANK HOLD', 'Bool', false);
    }
    /**
     * Updates this director.
     */
    update() {
        if (this.state === DirectorState.Active) {
            this.setBank(this.desiredBank);
        }
    }
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    setBank(bankAngle) {
        if (isFinite(bankAngle)) {
            this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
            SimVar.SetSimVarValue('AUTOPILOT BANK HOLD REF', 'degrees', this.currentBankRef);
        }
    }
}

/// <reference types="msfstypes/JS/simvar" />
/**
 * A vertical speed autopilot director.
 */
class APVSDirector {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues are the ap selected values for the autopilot.
     */
    constructor(bus, apValues) {
        this.bus = bus;
        this.groundSpeed = 0;
        this.selectedVS = 0;
        this.state = DirectorState.Inactive;
        this.bus.getSubscriber().on('ground_speed').withPrecision(0).handle((g) => {
            this.groundSpeed = g;
        });
        apValues.selectedVerticalSpeed.sub((vs) => {
            this.selectedVS = vs;
        });
    }
    /**
     * Activates this director.
     */
    activate() {
        this.state = DirectorState.Active;
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        Coherent.call('AP_VS_VAR_SET_ENGLISH', 1, Simplane.getVerticalSpeed());
        SimVar.SetSimVarValue('AUTOPILOT VERTICAL HOLD', 'Bool', true);
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
        if (this.state == DirectorState.Inactive) {
            this.activate();
        }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        SimVar.SetSimVarValue('AUTOPILOT VERTICAL HOLD', 'Bool', false);
    }
    /**
     * Updates this director.
     */
    update() {
        if (this.state === DirectorState.Active) {
            this.setPitch(this.getDesiredPitch());
        }
    }
    /**
     * Gets a desired pitch from the selected vs value.
     * @returns The desired pitch angle.
     */
    getDesiredPitch() {
        //We need the instant AOA and VS here so we're avoiding the bus
        const aoa = SimVar.GetSimVarValue('INCIDENCE ALPHA', SimVarValueType.Degree);
        // const vs = SimVar.GetSimVarValue('VERTICAL SPEED', SimVarValueType.FPM);
        // const currentfpa = this.getFpa(this.groundSpeed / 60, vs);
        const desiredPitch = this.getFpa(UnitType.NMILE.convertTo(this.groundSpeed / 60, UnitType.FOOT), this.selectedVS);
        return MathUtils.clamp(aoa + (isNaN(desiredPitch) ? 10 : desiredPitch), -10, 10);
    }
    /**
     * Gets a desired fpa.
     * @param distance is the distance traveled per minute.
     * @param altitude is the vertical speed per minute.
     * @returns The desired pitch angle.
     */
    getFpa(distance, altitude) {
        return UnitType.RADIAN.convertTo(Math.atan(altitude / distance), UnitType.DEGREE);
    }
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    setPitch(targetPitch) {
        if (isFinite(targetPitch)) {
            SimVar.SetSimVarValue('AUTOPILOT PITCH HOLD REF', SimVarValueType.Degree, -targetPitch);
        }
    }
}

/// <reference types="msfstypes/JS/simvar" />
/**
 * A Nav/Loc autopilot director.
 */
class APNavDirector {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues Is the apValues object.
     * @param mode is the APLateralMode for this instance of the director.
     */
    constructor(bus, apValues, mode) {
        this.bus = bus;
        this.apValues = apValues;
        this.mode = mode;
        this.bankServo = new LinearServo(10);
        this.currentBankRef = 0;
        this.currentHeading = 0;
        this.currentTrack = 0;
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.ppos = new GeoPoint(0, 0);
        this.navLocation = new GeoPoint(NaN, NaN);
        this.isApproachMode = Subject.create(false);
        this.state = DirectorState.Inactive;
        this.monitorEvents();
    }
    /**
     * Activates this director.
     */
    activate() {
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        SimVar.SetSimVarValue('AUTOPILOT NAV1 LOCK', 'Bool', true);
        this.state = DirectorState.Active;
    }
    /**
     * Arms this director.
     */
    arm() {
        if (this.state === DirectorState.Inactive && this.canArm()) {
            this.state = DirectorState.Armed;
            if (this.onArm !== undefined) {
                this.onArm();
            }
            SimVar.SetSimVarValue('AUTOPILOT NAV1 LOCK', 'Bool', true);
        }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        SimVar.SetSimVarValue('AUTOPILOT NAV1 LOCK', 'Bool', false);
    }
    /**
     * Updates this director.
     */
    update() {
        if (!this.canArm()) {
            this.deactivate();
        }
        if (this.state === DirectorState.Armed) {
            if (this.canActivate()) {
                this.activate();
            }
        }
        if (this.state === DirectorState.Active) {
            this.setBank(this.desiredBank());
        }
    }
    /**
     * Method to check whether the director can arm.
     * @returns Whether or not this director can arm.
     */
    canArm() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const typeIsCorrect = ((_a = this.navSource) === null || _a === void 0 ? void 0 : _a.type) === NavSourceType.Nav;
        const index = (_b = this.navSource) === null || _b === void 0 ? void 0 : _b.index;
        if (this.mode === APLateralModes.LOC && typeIsCorrect) {
            const indexIsCorrect = index == ((_c = this.cdi) === null || _c === void 0 ? void 0 : _c.source.index) && ((_d = this.loc) === null || _d === void 0 ? void 0 : _d.isValid) && index == ((_e = this.loc) === null || _e === void 0 ? void 0 : _e.source.index);
            if (indexIsCorrect) {
                this.isApproachMode.set(true);
                return true;
            }
        }
        if (this.mode === APLateralModes.VOR && typeIsCorrect) {
            const indexIsCorrect = index == ((_f = this.cdi) === null || _f === void 0 ? void 0 : _f.source.index) && !((_g = this.loc) === null || _g === void 0 ? void 0 : _g.isValid) && index == ((_h = this.obs) === null || _h === void 0 ? void 0 : _h.source.index);
            if (indexIsCorrect) {
                this.isApproachMode.set(false);
                return true;
            }
        }
        if (this.mode === APLateralModes.LOC && this.apValues.navToNavLocArm) {
            this.isApproachMode.set(true);
            return true;
        }
        this.isApproachMode.set(false);
        return false;
    }
    /**
     * Method to check whether the director can activate.
     * @returns Whether or not this director can activate.
     */
    canActivate() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const typeIsCorrect = ((_a = this.navSource) === null || _a === void 0 ? void 0 : _a.type) === NavSourceType.Nav;
        const index = (_b = this.navSource) === null || _b === void 0 ? void 0 : _b.index;
        const indexIsCorrect = index == ((_c = this.cdi) === null || _c === void 0 ? void 0 : _c.source.index)
            && ((((_d = this.loc) === null || _d === void 0 ? void 0 : _d.isValid) && index == ((_e = this.loc) === null || _e === void 0 ? void 0 : _e.source.index)) || (!((_f = this.loc) === null || _f === void 0 ? void 0 : _f.isValid) && index == ((_g = this.obs) === null || _g === void 0 ? void 0 : _g.source.index)));
        if (typeIsCorrect && indexIsCorrect && this.cdi !== undefined && this.cdi.deviation !== null && Math.abs(this.cdi.deviation) < 127 && (((_h = this.obs) === null || _h === void 0 ? void 0 : _h.heading) || ((_j = this.loc) === null || _j === void 0 ? void 0 : _j.course))) {
            const dtk = this.loc && this.loc.isValid && this.loc.course ? Units.Radians.toDegrees(this.loc.course) : (_k = this.obs) === null || _k === void 0 ? void 0 : _k.heading;
            if (dtk === null || dtk === undefined) {
                return false;
            }
            const headingDiff = NavMath.diffAngle(this.currentHeading, dtk);
            const isLoc = (_m = (_l = this.loc) === null || _l === void 0 ? void 0 : _l.isValid) !== null && _m !== void 0 ? _m : false;
            const sensitivity = isLoc ? 1 : .6;
            if (Math.abs(this.cdi.deviation * sensitivity) < 127 && Math.abs(headingDiff) < 110) {
                return true;
            }
        }
        return false;
    }
    /**
     * Gets a desired bank from the nav input data.
     * @returns The desired bank angle.
     */
    desiredBank() {
        var _a, _b, _c, _d;
        const isLoc = (_b = (_a = this.loc) === null || _a === void 0 ? void 0 : _a.isValid) !== null && _b !== void 0 ? _b : false;
        const hasValidDeviation = this.cdi !== undefined && this.cdi.deviation !== null && Math.abs(this.cdi.deviation) < 127;
        const hasValidObs = this.obs !== undefined && this.obs.heading !== null;
        let zoneOfConfusion = false;
        if (isLoc && !hasValidDeviation) {
            this.deactivate();
            return NaN;
        }
        if (!isLoc && (!hasValidDeviation || !hasValidObs)) {
            if (!this.checkForZoneOfConfusion()) {
                this.deactivate();
                return NaN;
            }
            else {
                zoneOfConfusion = true;
            }
        }
        if (zoneOfConfusion || (this.cdi && this.cdi.deviation !== null)) {
            const xtk = zoneOfConfusion ? 0 : (this.cdi && this.cdi.deviation !== null) ? this.getXtk(this.cdi.deviation, isLoc) : 0;
            const dtk = isLoc && ((_c = this.loc) === null || _c === void 0 ? void 0 : _c.course) !== undefined ? Units.Radians.toDegrees(this.loc.course) : (_d = this.obs) === null || _d === void 0 ? void 0 : _d.heading;
            if (dtk === null || dtk === undefined) {
                this.deactivate();
                return NaN;
            }
            const absInterceptAngle = Math.min(Math.pow(Math.abs(xtk) * 20, 1.35) + (Math.abs(xtk) * 50), isLoc ? 20 : 40);
            const interceptAngle = xtk > 0 ? absInterceptAngle : -1 * absInterceptAngle;
            const desiredTrack = NavMath.normalizeHeading(dtk + interceptAngle);
            const turnDirection = NavMath.getTurnDirection(this.currentTrack, desiredTrack);
            const headingDiff = Math.abs(NavMath.diffAngle(this.currentTrack, desiredTrack));
            let baseBank = Math.min(1.25 * headingDiff, 25);
            if (baseBank <= 2.5) {
                baseBank = NavMath.clamp(xtk * -100, -2.5, 2.5);
            }
            else {
                baseBank *= (turnDirection === 'left' ? 1 : -1);
            }
            return baseBank;
        }
        this.deactivate();
        return NaN;
    }
    /**
     * Gets a xtk value from the nav input data.
     * @param deviation is the input deviation value
     * @param isLoc is whether this is a LOC signal.
     * @returns The xtk value.
     */
    getXtk(deviation, isLoc) {
        const scale = isLoc ? 1 : 2;
        const factor = isLoc ? .35 : 1;
        return MathUtils.clamp(this.getNavDistance() * Math.sin(UnitType.DEGREE.convertTo(12, UnitType.RADIAN) * ((factor * deviation) / 127)), -scale, scale);
    }
    /**
     * Gets the lateral distance from PPOS to the nav signal.
     * @returns The distance value in nautical miles.
     */
    getNavDistance() {
        let navDistance = 5;
        if (!isNaN(this.navLocation.lat)) {
            const navPosition = this.geoPointCache[0];
            navPosition.set(this.navLocation);
            const planePosGP = this.geoPointCache[1];
            planePosGP.set(this.ppos);
            navDistance = UnitType.GA_RADIAN.convertTo(planePosGP.distance(navPosition), UnitType.NMILE);
        }
        return Math.abs(navDistance);
    }
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    setBank(bankAngle) {
        if (isFinite(bankAngle)) {
            this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
            SimVar.SetSimVarValue('AUTOPILOT BANK HOLD REF', 'degrees', this.currentBankRef);
        }
    }
    /**
     * Checks if we might be getting a wild deviation because of the zone of confusion and allows APNavDirector some time to resolve.
     * @returns Whether we might be in the zone of confusion.
     */
    checkForZoneOfConfusion() {
        if (this.getNavDistance() < 2 && this.cdi !== undefined && this.cdi.deviation !== null) {
            return true;
        }
        return false;
    }
    /**
     * Method to monitor nav events to keep track of NAV related data needed for guidance.
     */
    monitorEvents() {
        const nav = this.bus.getSubscriber();
        nav.on('cdi_deviation').handle(cdi => this.cdi = cdi);
        nav.on('obs_setting').handle(obs => this.obs = obs);
        nav.on('localizer').handle(loc => this.loc = loc);
        nav.on('cdi_select').handle((source) => {
            this.navSource = source;
            if (this.state === DirectorState.Active) {
                this.deactivate();
            }
        });
        nav.on('navLocation').handle((loc) => {
            this.navLocation.set(loc.lat, loc.long);
        });
        this.bus.getSubscriber().on('hdg_deg')
            .withPrecision(0)
            .handle((h) => {
            this.currentHeading = h;
        });
        const gnss = this.bus.getSubscriber();
        gnss.on('gps-position').atFrequency(1).handle((lla) => {
            this.ppos.set(lla.lat, lla.long);
        });
        gnss.on('track_deg_magnetic').withPrecision(0).handle((t) => {
            this.currentTrack = t;
        });
    }
}

/// <reference types="msfstypes/JS/simvar" />
/**
 * An RNAV LPV glidepath autopilot director.
 */
class APGPDirector {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues are the ap selected values for the autopilot.
     * @param vnavDirector is the vnav director (required to fly LPV approaches)
     */
    constructor(bus, apValues, vnavDirector) {
        this.bus = bus;
        this.apValues = apValues;
        this.vnavDirector = vnavDirector;
        this.lpvDeviation = 0;
        this.state = DirectorState.Inactive;
        vnavDirector.lpvDeviation.sub((dev) => {
            this.lpvDeviation = dev;
        });
        apValues.approachHasGP.sub(v => {
            if (this.state !== DirectorState.Inactive && !v) {
                this.deactivate();
            }
        });
    }
    /**
     * Activates this director.
     */
    activate() {
        this.state = DirectorState.Active;
        SimVar.SetSimVarValue(VNavSimVars.ApproachMode, SimVarValueType.Number, VNavApproachGuidanceMode.GPActive);
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        SimVar.SetSimVarValue('AUTOPILOT GLIDESLOPE ACTIVE', 'Bool', true);
        SimVar.SetSimVarValue('AUTOPILOT APPROACH ACTIVE', 'Bool', true);
        SimVar.SetSimVarValue('AUTOPILOT GLIDESLOPE ARM', 'Bool', false);
    }
    /**
     * Arms this director.
     */
    arm() {
        if (this.state === DirectorState.Inactive) {
            this.state = DirectorState.Armed;
            SimVar.SetSimVarValue(VNavSimVars.ApproachMode, SimVarValueType.Number, VNavApproachGuidanceMode.GPArmed);
            if (this.onArm !== undefined) {
                this.onArm();
            }
            SimVar.SetSimVarValue('AUTOPILOT GLIDESLOPE ARM', 'Bool', true);
            SimVar.SetSimVarValue('AUTOPILOT GLIDESLOPE ACTIVE', 'Bool', false);
            SimVar.SetSimVarValue('AUTOPILOT APPROACH ACTIVE', 'Bool', true);
        }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        SimVar.SetSimVarValue(VNavSimVars.ApproachMode, SimVarValueType.Number, VNavApproachGuidanceMode.None);
        SimVar.SetSimVarValue('AUTOPILOT GLIDESLOPE ARM', 'Bool', false);
        SimVar.SetSimVarValue('AUTOPILOT GLIDESLOPE ACTIVE', 'Bool', false);
        SimVar.SetSimVarValue('AUTOPILOT APPROACH ACTIVE', 'Bool', false);
    }
    /**
     * Updates this director.
     */
    update() {
        if (this.state === DirectorState.Armed) {
            if (this.apValues.lateralActive.get() === APLateralModes.GPSS && this.lpvDeviation <= 100 && this.lpvDeviation >= -15 && this.vnavDirector.calculator.lpvFpa !== 0) {
                this.activate();
            }
        }
        if (this.state === DirectorState.Active) {
            if (this.apValues.lateralActive.get() !== APLateralModes.GPSS) {
                this.deactivate();
            }
            this.setPitch(this.getDesiredPitch());
        }
    }
    /**
     * Gets a desired pitch from the selected vs value.
     * @returns The desired pitch angle.
     */
    getDesiredPitch() {
        const fpaPercentage = Math.max(this.lpvDeviation / -100, -1) + 1;
        const desiredPitch = (this.vnavDirector.calculator.lpvFpa * fpaPercentage) * -1;
        //We need the instant AOA here so we're avoiding the bus
        const aoa = SimVar.GetSimVarValue('INCIDENCE ALPHA', SimVarValueType.Degree);
        return aoa + MathUtils.clamp(desiredPitch, -6, 2);
    }
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    setPitch(targetPitch) {
        if (isFinite(targetPitch)) {
            SimVar.SetSimVarValue('AUTOPILOT PITCH HOLD REF', SimVarValueType.Degree, -targetPitch);
        }
    }
}

/// <reference types="msfstypes/JS/simvar" />
/**
 * A glideslope autopilot director.
 */
class APGSDirector {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues is the APValues object from the Autopilot.
     */
    constructor(bus, apValues) {
        this.bus = bus;
        this.apValues = apValues;
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.ppos = new GeoPoint(0, 0);
        this.gsLocation = new GeoPoint(NaN, NaN);
        this.state = DirectorState.Inactive;
        const nav = this.bus.getSubscriber();
        nav.on('glideslope').handle(gs => this.glideslope = gs);
        nav.on('gsLocation').handle((loc) => {
            this.gsLocation.set(loc.lat, loc.long);
        });
        const gnss = this.bus.getSubscriber();
        gnss.on('gps-position').atFrequency(1).handle((lla) => {
            this.ppos.set(lla.lat, lla.long);
        });
    }
    /**
     * Activates this director.
     */
    activate() {
        this.state = DirectorState.Active;
        SimVar.SetSimVarValue(VNavSimVars.ApproachMode, SimVarValueType.Number, VNavApproachGuidanceMode.GSActive);
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        SimVar.SetSimVarValue('AUTOPILOT GLIDESLOPE ACTIVE', 'Bool', true);
        SimVar.SetSimVarValue('AUTOPILOT APPROACH ACTIVE', 'Bool', true);
        SimVar.SetSimVarValue('AUTOPILOT GLIDESLOPE ARM', 'Bool', false);
    }
    /**
     * Arms this director.
     */
    arm() {
        if (this.canArm() && this.state === DirectorState.Inactive) {
            this.state = DirectorState.Armed;
            SimVar.SetSimVarValue(VNavSimVars.ApproachMode, SimVarValueType.Number, VNavApproachGuidanceMode.GSArmed);
            if (this.onArm !== undefined) {
                this.onArm();
            }
            SimVar.SetSimVarValue('AUTOPILOT GLIDESLOPE ARM', 'Bool', true);
            SimVar.SetSimVarValue('AUTOPILOT GLIDESLOPE ACTIVE', 'Bool', false);
            SimVar.SetSimVarValue('AUTOPILOT APPROACH ACTIVE', 'Bool', true);
        }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        SimVar.SetSimVarValue(VNavSimVars.ApproachMode, SimVarValueType.Number, VNavApproachGuidanceMode.None);
        SimVar.SetSimVarValue('AUTOPILOT GLIDESLOPE ARM', 'Bool', false);
        SimVar.SetSimVarValue('AUTOPILOT GLIDESLOPE ACTIVE', 'Bool', false);
        SimVar.SetSimVarValue('AUTOPILOT APPROACH ACTIVE', 'Bool', false);
    }
    /**
     * Updates this director.
     */
    update() {
        if (this.state === DirectorState.Armed) {
            if (this.apValues.lateralActive.get() === APLateralModes.LOC && this.glideslope !== undefined &&
                this.glideslope.isValid && this.glideslope.deviation <= 0.1 && this.glideslope.deviation >= -0.1) {
                this.activate();
            }
            if (!this.canArm()) {
                this.deactivate();
            }
        }
        if (this.state === DirectorState.Active) {
            if (this.apValues.lateralActive.get() !== APLateralModes.LOC) {
                this.deactivate();
            }
            this.trackGlideslope();
        }
    }
    /**
     * Method to check whether the director can arm.
     * @returns Whether or not this director can arm.
     */
    canArm() {
        if (this.apValues.navToNavLocArm || (this.glideslope !== undefined && this.glideslope.isValid)) {
            return true;
        }
        return false;
    }
    /**
     * Tracks the Glideslope.
     */
    trackGlideslope() {
        if (this.glideslope !== undefined && this.glideslope.isValid) {
            let gsDistance = UnitType.NMILE.convertTo(5, UnitType.METER);
            if (!isNaN(this.gsLocation.lat)) {
                const gsPosition = this.geoPointCache[0];
                gsPosition.set(this.gsLocation);
                const planePosGP = this.geoPointCache[1];
                planePosGP.set(this.ppos);
                gsDistance = UnitType.GA_RADIAN.convertTo(planePosGP.distance(gsPosition), UnitType.METER);
            }
            const gainDenominator = MathUtils.clamp((2200 - (0.4 * gsDistance)) / 3000, 0.1, 1);
            const fpaPercentage = Math.max(this.glideslope.deviation / gainDenominator, -1) + 1;
            const desiredPitch = (this.glideslope.gsAngle * fpaPercentage) * -1;
            //We need the instant AOA here so we're avoiding the bus
            const aoa = SimVar.GetSimVarValue('INCIDENCE ALPHA', SimVarValueType.Degree);
            const targetPitch = aoa + MathUtils.clamp(desiredPitch, -6, 6);
            SimVar.SetSimVarValue('AUTOPILOT PITCH HOLD REF', SimVarValueType.Degree, -targetPitch);
        }
        else {
            this.deactivate();
        }
    }
}

/**
 * A G1000 NXi nav-to-nav manager.
 */
class G1000NavToNavManager {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues are the ap state values.
     */
    constructor(bus, apValues) {
        this.bus = bus;
        this.apValues = apValues;
        this.onTransferred = () => { };
        this.currentHeading = 0;
        this.approachFrequency = undefined;
        this.nav1Frequency = 0;
        this.nav2Frequency = 0;
        this.isSourceChanging = false;
        /** Index of nav radio that has a localizer and frequency matches loaded approach. */
        this.canArmIndex = 0;
        this.approachProcedureDetails = {
            approachIndex: -1,
            approachTransitionIndex: -1
        };
        this.navToNavCompleted = false;
        /**
         * Callback to handle the nav source changed event when received.
         * @param e is the NavSourceId event
         */
        this.handleNavToNavSourceChanged = (e) => {
            if (e.type === NavSourceType.Nav && e.index === this.canArmIndex) {
                this.onTransferred();
                this.isSourceChanging = false;
                if (this.navToNavCdiConsumer !== undefined) {
                    this.navToNavCdiConsumer.off(this.handleNavToNavSourceChanged);
                    this.navToNavCdiConsumer = undefined;
                    this.navToNavCompleted = true;
                    return;
                }
            }
        };
        this.monitorEvents();
    }
    /** @inheritdoc */
    canLocArm() {
        return this.canArmIndex > 0;
    }
    /** @inheritdoc */
    canLocActivate() {
        if (this.canArmIndex < 1) {
            return false;
        }
        const cdi = this.canArmIndex === 1 ? this.nav1Cdi : this.nav2Cdi;
        const loc = this.canArmIndex === 1 ? this.nav1Localizer : this.nav2Localizer;
        if (cdi && cdi.deviation !== null && Math.abs(cdi.deviation) < 127 && (loc === null || loc === void 0 ? void 0 : loc.course)) {
            const dtk = loc && loc.isValid && loc.course ? Units.Radians.toDegrees(loc.course) : undefined;
            if (dtk === null || dtk === undefined) {
                return false;
            }
            const headingDiff = NavMath.diffAngle(this.currentHeading, dtk);
            if (cdi.deviation > 0 && cdi.deviation < 65 && headingDiff < 0 && headingDiff > -90) {
                return true;
            }
            else if (cdi.deviation < 0 && cdi.deviation > -65 && headingDiff > 0 && headingDiff < 90) {
                return true;
            }
            else if (Math.abs(cdi.deviation) < 35 && Math.abs(headingDiff) < 20) {
                return true;
            }
        }
        return false;
    }
    /**
     * Updates the canArmIndex after inputs from the event bus or changes in the approach frequency.
     */
    updateState() {
        if (this.approachFrequency !== undefined) {
            const apprFreq = Math.round(this.approachFrequency.freqMHz * 100) / 100;
            if (apprFreq > 107) {
                if (apprFreq == this.nav1Frequency && this.nav1Localizer && this.nav1Localizer.isValid) {
                    this.canArmIndex = 1;
                }
                else if (apprFreq == this.nav2Frequency && this.nav2Localizer && this.nav2Localizer.isValid) {
                    this.canArmIndex = 2;
                }
                else {
                    this.canArmIndex = 0;
                }
            }
            else {
                this.canArmIndex = 0;
            }
        }
        else {
            this.canArmIndex = 0;
        }
    }
    /**
     * Updates the nav 1 and nav 2 frequency from the bus.
     * @param radioState A radiostate event.
     */
    updateRadioState(radioState) {
        if (radioState.radioType === RadioType.Nav) {
            switch (radioState.index) {
                case 1:
                    this.nav1Frequency = Math.round(radioState.activeFrequency * 100) / 100;
                    break;
                case 2:
                    this.nav2Frequency = Math.round(radioState.activeFrequency * 100) / 100;
                    break;
            }
            this.updateState();
        }
    }
    /**
     * Tries to auto switch the source if criteria are met.
     * @param d is the lnav data from the event bus
     */
    tryAutoSwitchSource(d) {
        var _a, _b, _c, _d, _e;
        if (!this.navToNavCompleted
            && !this.isSourceChanging
            && d.state !== undefined
            && ((_b = (_a = d.currentLeg) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.endLat) !== undefined
            && ((_d = (_c = d.currentLeg) === null || _c === void 0 ? void 0 : _c.calculated) === null || _d === void 0 ? void 0 : _d.endLon) !== undefined) {
            const fafIsActive = (d.currentLeg.leg.fixTypeFlags & FixTypeFlags.FAF) !== 0;
            const fafDistance = UnitType.GA_RADIAN.convertTo(d.state.pos.distance(d.currentLeg.calculated.endLat, d.currentLeg.calculated.endLon), UnitType.NMILE);
            if (fafIsActive && fafDistance < 15 && this.canArmIndex > 0 && this.canLocActivate() && ((_e = this.activeSource) === null || _e === void 0 ? void 0 : _e.type) === NavSourceType.Gps) {
                this.changeSource();
                this.navToNavCdiConsumer = this.bus.getSubscriber().on('cdi_select');
                this.navToNavCdiConsumer.handle(this.handleNavToNavSourceChanged);
            }
        }
    }
    /**
     * Method to set the HSI/NAV Source to the Can Arm Index.
     */
    changeSource() {
        const controlPublisher = this.bus.getPublisher();
        const navSource = {
            type: NavSourceType.Nav,
            index: this.canArmIndex
        };
        this.isSourceChanging = true;
        controlPublisher.pub('cdi_src_set', navSource, true);
    }
    /**
     * Method to monitor nav events to keep track of NAV related data needed for guidance.
     */
    monitorEvents() {
        const radio = this.bus.getSubscriber();
        radio.on('setRadioState').handle((state) => {
            this.updateRadioState(state);
        });
        radio.on('setFrequency').handle((frequency) => {
            if (frequency.bank == FrequencyBank.Active && frequency.radio.radioType === RadioType.Nav) {
                switch (frequency.radio.index) {
                    case 1:
                        this.nav1Frequency = Math.round(frequency.frequency * 100) / 100;
                        break;
                    case 2:
                        this.nav2Frequency = Math.round(frequency.frequency * 100) / 100;
                }
                this.updateState();
            }
        });
        const nav = this.bus.getSubscriber();
        nav.on('nav_1_localizer').handle((loc) => {
            this.nav1Localizer = loc;
            this.updateState();
        });
        nav.on('nav_2_localizer').handle((loc) => {
            this.nav2Localizer = loc;
            this.updateState();
        });
        nav.on('nav_1_cdi').handle((cdi) => {
            this.nav1Cdi = cdi;
        });
        nav.on('nav_2_cdi').handle((cdi) => {
            this.nav2Cdi = cdi;
        });
        nav.on('cdi_select').handle((source) => this.activeSource = source);
        const adc = this.bus.getSubscriber();
        adc.on('hdg_deg').withPrecision(0).handle((h) => {
            this.currentHeading = h;
        });
        this.bus.getSubscriber().on('approach_freq_set').handle((v) => {
            this.approachFrequency = v;
            this.navToNavCompleted = false;
            this.updateState();
        });
        this.bus.getSubscriber().on('dataChanged').handle((d) => {
            this.tryAutoSwitchSource(d);
        });
        // const fpl = this.bus.getSubscriber<FlightPlannerEvents>();
        // fpl.on('fplProcDetailsChanged').handle((e: FlightPlanProcedureDetailsEvent) => {
        //   if (e.details.approachIndex !== this.approachProcedureDetails.approachIndex ||
        //     e.details.approachTransitionIndex !== this.approachProcedureDetails.approachTransitionIndex) {
        //     this.approachProcedureDetails.approachIndex = e.details.approachIndex;
        //     this.approachProcedureDetails.approachTransitionIndex = e.details.approachTransitionIndex;
        //     this.navToNavCompleted = false;
        //   }
        // });
        this.apValues.approachIsActive.sub((v) => {
            if (v) {
                this.navToNavCompleted = false;
            }
        });
    }
}

/// <reference types="msfstypes/JS/simvar" />
/**
 * An autopilot wing leveler director.
 */
class APLvlDirector {
    /**
     * Creates an instance of the wing leveler.
     * @param bus The event bus to use with this instance.
     */
    constructor(bus) {
        this.bus = bus;
        this.currentBankRef = 0;
        this.desiredBank = 0;
        this.actualBank = 0;
        this.bankServo = new LinearServo(10);
        this.state = DirectorState.Inactive;
        const adc = this.bus.getSubscriber();
        adc.on('roll_deg').withPrecision(1).handle((roll) => {
            this.actualBank = roll;
        });
    }
    /**
     * Activates this director.
     */
    activate() {
        this.state = DirectorState.Active;
        this.desiredBank = 0;
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        SimVar.SetSimVarValue('AUTOPILOT WING LEVELER', 'Bool', true);
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
        if (this.state == DirectorState.Inactive) {
            this.activate();
        }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        this.desiredBank = 0;
        SimVar.SetSimVarValue('AUTOPILOT WING LEVELER', 'Bool', false);
    }
    /**
     * Updates this director.
     */
    update() {
        if (this.state === DirectorState.Active) {
            this.setBank(this.desiredBank);
        }
    }
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    setBank(bankAngle) {
        if (isFinite(bankAngle)) {
            this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
            SimVar.SetSimVarValue('AUTOPILOT BANK HOLD REF', 'degrees', this.currentBankRef);
        }
    }
}

/**
 * A G1000 NXi autopilot configuration.
 */
class G1000APConfig {
    /**
     * Instantiates the AP Config for the Autopilot.
     * @param bus is an instance of the Event Bus.
     * @param flightPlanner is an instance of the flight planner.
     */
    constructor(bus, flightPlanner) {
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.defaultLateralMode = APLateralModes.ROLL;
        this.defaultVerticalMode = APVerticalModes.PITCH;
    }
    /** @inheritdoc */
    createHeadingDirector(apValues) {
        return new APHdgDirector(this.bus, apValues);
    }
    /** @inheritdoc */
    createRollDirector() {
        return new APRollDirector(this.bus);
    }
    /** @inheritdoc */
    createWingLevelerDirector() {
        return new APLvlDirector(this.bus);
    }
    /** @inheritdoc */
    createGpssDirector() {
        return new LNavDirector(this.bus, this.flightPlanner);
    }
    /** @inheritdoc */
    createVorDirector(apValues) {
        return new APNavDirector(this.bus, apValues, APLateralModes.VOR);
    }
    /** @inheritdoc */
    createLocDirector(apValues) {
        return new APNavDirector(this.bus, apValues, APLateralModes.LOC);
    }
    /** @inheritdoc */
    createBcDirector() {
        return undefined;
    }
    /** @inheritdoc */
    createPitchDirector(apValues) {
        return new APPitchDirector(this.bus, apValues);
    }
    /** @inheritdoc */
    createVsDirector(apValues) {
        return new APVSDirector(this.bus, apValues);
    }
    /** @inheritdoc */
    createFlcDirector(apValues) {
        return new APFLCDirector(this.bus, apValues);
    }
    /** @inheritdoc */
    createAltHoldDirector(apValues) {
        return new APAltDirector(this.bus, apValues);
    }
    /** @inheritdoc */
    createAltCapDirector(apValues) {
        return new APAltCapDirector(this.bus, apValues);
    }
    /** @inheritdoc */
    createVNavDirector(apValues) {
        var _a;
        return (_a = this.vnavDirector) !== null && _a !== void 0 ? _a : (this.vnavDirector = new VNavDirector(this.bus, this.flightPlanner, new VNavPathCalculator(this.bus, this.flightPlanner), apValues));
    }
    /** @inheritdoc */
    createGpDirector(apValues) {
        return new APGPDirector(this.bus, apValues, this.createVNavDirector(apValues));
    }
    /** @inheritdoc */
    createGsDirector(apValues) {
        return new APGSDirector(this.bus, apValues);
    }
    /** @inheritdoc */
    createNavToNavManager(apValues) {
        return new G1000NavToNavManager(this.bus, apValues);
    }
}

/**
 * A G1000 NXi autopilot state manager.
 */
class G1000APStateManager extends APStateManager {
    constructor() {
        super(...arguments);
        this.vsLastPressed = 0;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAPListenerRegistered() {
        super.onAPListenerRegistered();
        const hEvent = this.bus.getSubscriber();
        hEvent.on('hEvent').handle((e) => {
            if (e === 'AS1000_VNAV_TOGGLE') {
                this.toggleVnav();
            }
        });
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setupKeyIntercepts() {
        //alt modes
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_ALT_HOLD', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_ALT_HOLD_ON', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_ALT_HOLD_OFF', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_PANEL_ALTITUDE_HOLD', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_PANEL_ALTITUDE_ON', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_PANEL_ALTITUDE_OFF', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_PANEL_ALTITUDE_SET', 1);
        //vs modes
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_PANEL_VS_HOLD', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_PANEL_VS_ON', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_PANEL_VS_OFF', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_PANEL_VS_SET', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_VS_HOLD', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_VS_ON', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_VS_OFF', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_VS_SET', 1);
        //pitch modes
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_ATT_HOLD', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_ATT_HOLD_ON', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_ATT_HOLD_OFF', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_PITCH_LEVELER', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_PITCH_LEVELER_ON', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_PITCH_LEVELER_OFF', 1);
        //roll modes
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_BANK_HOLD', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_BANK_HOLD_ON', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_BANK_HOLD_OFF', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_WING_LEVELER', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_WING_LEVELER_ON', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_WING_LEVELER_OFF', 1);
        //flc modes
        Coherent.call('INTERCEPT_KEY_EVENT', 'FLIGHT_LEVEL_CHANGE', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'FLIGHT_LEVEL_CHANGE_ON', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'FLIGHT_LEVEL_CHANGE_OFF', 1);
        //nav modes
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_NAV1_HOLD', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_NAV1_HOLD_ON', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_NAV1_HOLD_OFF', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_NAV_SELECT_SET', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'TOGGLE_GPS_DRIVES_NAV1', 1);
        //hdg modes
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_HDG_HOLD', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_HDG_HOLD_ON', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_HDG_HOLD_OFF', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_PANEL_HEADING_HOLD', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_PANEL_HEADING_ON', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_PANEL_HEADING_OFF', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_PANEL_HEADING_SET', 1);
        //bank modes
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_BANK_HOLD', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_BANK_HOLD_ON', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_BANK_HOLD_OFF', 1);
        //appr modes
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_LOC_HOLD', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_LOC_HOLD_ON', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_LOC_HOLD_OFF', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_APR_HOLD', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_APR_HOLD_ON', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_APR_HOLD_OFF', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_BC_HOLD', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_BC_HOLD_ON', 1);
        Coherent.call('INTERCEPT_KEY_EVENT', 'AP_BC_HOLD_OFF', 1);
        //baro set intercept
        Coherent.call('INTERCEPT_KEY_EVENT', 'BAROMETRIC', 0);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    handleKeyIntercepted(key, index, value) {
        const controlEventPub = this.bus.getPublisher();
        switch (key) {
            case 'AP_NAV1_HOLD':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.NAV);
                break;
            case 'AP_NAV1_HOLD_ON':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.NAV, true);
                break;
            case 'AP_NAV1_HOLD_OFF':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.NAV, false);
                break;
            case 'AP_LOC_HOLD':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.LOC);
                break;
            case 'AP_LOC_HOLD_ON':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.LOC, true);
                break;
            case 'AP_LOC_HOLD_OFF':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.LOC, false);
                break;
            case 'AP_APR_HOLD':
                this.sendApModeEvent(APModeType.APPROACH);
                break;
            case 'AP_APR_HOLD_ON':
                this.sendApModeEvent(APModeType.APPROACH, undefined, true);
                break;
            case 'AP_APR_HOLD_OFF':
                this.sendApModeEvent(APModeType.APPROACH, undefined, false);
                break;
            case 'AP_BC_HOLD':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.BC);
                break;
            case 'AP_BC_HOLD_ON':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.BC, true);
                break;
            case 'AP_BC_HOLD_OFF':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.BC, false);
                break;
            case 'AP_HDG_HOLD':
            case 'AP_PANEL_HEADING_HOLD':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.HEADING);
                break;
            case 'AP_PANEL_HEADING_ON':
            case 'AP_HDG_HOLD_ON':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.HEADING, true);
                break;
            case 'AP_PANEL_HEADING_OFF':
            case 'AP_HDG_HOLD_OFF':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.HEADING, false);
                break;
            case 'AP_PANEL_HEADING_SET':
                if (value !== undefined) {
                    this.sendApModeEvent(APModeType.LATERAL, APLateralModes.HEADING, value === 1 ? true : false);
                }
                break;
            case 'AP_BANK_HOLD':
            case 'AP_BANK_HOLD_ON':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.ROLL, true);
                break;
            case 'AP_WING_LEVELER':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.LEVEL);
                break;
            case 'AP_WING_LEVELER_ON':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.LEVEL, true);
                break;
            case 'AP_WING_LEVELER_OFF':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.LEVEL, false);
                break;
            case 'AP_PANEL_VS_HOLD':
            case 'AP_VS_HOLD':
                this.sendApModeEvent(APModeType.VERTICAL, APVerticalModes.VS);
                break;
            case 'AP_PANEL_VS_ON':
            case 'AP_VS_ON':
                this.sendApModeEvent(APModeType.VERTICAL, APVerticalModes.VS, true);
                break;
            case 'AP_PANEL_VS_OFF':
            case 'AP_VS_OFF':
                this.sendApModeEvent(APModeType.VERTICAL, APVerticalModes.VS, false);
                break;
            case 'AP_PANEL_VS_SET':
            case 'AP_VS_SET':
                // TODO Remove this when the Bravo default mapping is fixed.
                if (value !== undefined && this.vsLastPressed < Date.now() - 100) {
                    this.sendApModeEvent(APModeType.VERTICAL, APVerticalModes.VS, value === 1 ? true : false);
                }
                this.vsLastPressed = Date.now();
                break;
            case 'AP_ALT_HOLD':
            case 'AP_PANEL_ALTITUDE_HOLD':
                this.sendApModeEvent(APModeType.VERTICAL, APVerticalModes.ALT);
                break;
            case 'AP_ALT_HOLD_ON':
            case 'AP_PANEL_ALTITUDE_ON':
                this.sendApModeEvent(APModeType.VERTICAL, APVerticalModes.ALT, true);
                break;
            case 'AP_ALT_HOLD_OFF':
            case 'AP_PANEL_ALTITUDE_OFF':
                this.sendApModeEvent(APModeType.VERTICAL, APVerticalModes.ALT, false);
                break;
            case 'AP_PANEL_ALTITUDE_SET':
                if (value !== undefined) {
                    this.sendApModeEvent(APModeType.VERTICAL, APVerticalModes.ALT, value === 1 ? true : false);
                }
                break;
            case 'FLIGHT_LEVEL_CHANGE':
                this.sendApModeEvent(APModeType.VERTICAL, APVerticalModes.FLC);
                break;
            case 'FLIGHT_LEVEL_CHANGE_ON':
                this.sendApModeEvent(APModeType.VERTICAL, APVerticalModes.FLC, true);
                break;
            case 'FLIGHT_LEVEL_CHANGE_OFF':
                this.sendApModeEvent(APModeType.VERTICAL, APVerticalModes.FLC, false);
                break;
            case 'AP_NAV_SELECT_SET':
                if (value !== undefined && value >= 1 && value <= 2) {
                    controlEventPub.pub('cdi_src_set', { type: NavSourceType.Nav, index: value }, true);
                }
                break;
            case 'TOGGLE_GPS_DRIVES_NAV1':
                controlEventPub.pub('cdi_src_gps_toggle', true, true);
                break;
            case 'BAROMETRIC':
                controlEventPub.pub('baro_set', true, true);
                break;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onBeforeInitialize() {
        SimVar.SetSimVarValue('L:WT1000_AP_G1000_INSTALLED', SimVarValueType.Bool, true);
    }
}

/**
 * The image cache specific to this instrument.
 * @class GImageCache
 * @augments {ImageCache}
 */
class WaypointIconImageCache extends ImageCache {
    /**
     * Initializes the icons used in this instrument.
     * @static
     */
    static init() {
        WaypointIconImageCache.addToCache('AIRPORT_PRIVATE', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/airport_r.png');
        WaypointIconImageCache.addToCache('AIRPORT_UNKNOWN', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/airport_q.png');
        WaypointIconImageCache.addToCache('AIRPORT_NONTOWERED_SERVICED', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/airport_large_magenta.png');
        WaypointIconImageCache.addToCache('AIRPORT_TOWERED_NONSERVICED', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/airport_med_blue.png');
        WaypointIconImageCache.addToCache('AIRPORT_TOWERED_SERVICED', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/airport_large_blue.png');
        WaypointIconImageCache.addToCache('AIRPORT_NONTOWERED_NON_SERVICED', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/airport_med_magenta.png');
        WaypointIconImageCache.addToCache('AIRPORT_SMALL_NONSERVICED', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/airport_small_a.png');
        WaypointIconImageCache.addToCache('AIRPORT_SMALL_SERVICED', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/airport_small_b.png');
        WaypointIconImageCache.addToCache('INTERSECTION_CYAN', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/intersection_cyan.png');
        WaypointIconImageCache.addToCache('VOR', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/vor.png');
        WaypointIconImageCache.addToCache('VORDME', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/vor_dme.png');
        WaypointIconImageCache.addToCache('DME', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/dme.png');
        WaypointIconImageCache.addToCache('VORVORTAC', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/vor_vortac.png');
        // TODO TACAN icon
        WaypointIconImageCache.addToCache('NDB', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/ndb.png');
        WaypointIconImageCache.addToCache('USER', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/user.png');
        WaypointIconImageCache.addToCache('FPLN_WAYPOINT', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/map_icon_flight_path_waypoint.png');
        WaypointIconImageCache.addToCache('VNAV', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/vnav.png');
    }
    /**
     * Maps the airport type to the right icon.
     * @param fac The airport facility to get the icon for.
     * @returns The image element used for this type of airport.
     */
    static getAirportIcon(fac) {
        // HINT class 1 airports are always assumed serviced
        const serviced = (fac.fuel1 !== '' || fac.fuel2 !== '') || fac.airportClass === 1;
        if (fac.airportPrivateType !== AirportPrivateType.Public) {
            return WaypointIconImageCache.get('AIRPORT_PRIVATE');
        }
        else if (serviced && fac.towered) {
            return WaypointIconImageCache.get('AIRPORT_TOWERED_SERVICED');
        }
        else if (serviced && !fac.towered) {
            if (fac.airportClass === 1) {
                return WaypointIconImageCache.get('AIRPORT_NONTOWERED_SERVICED');
            }
            else {
                return WaypointIconImageCache.get('AIRPORT_SMALL_SERVICED');
            }
        }
        else if (!serviced && fac.towered) {
            return WaypointIconImageCache.get('AIRPORT_TOWERED_NONSERVICED');
        }
        else if (!serviced && !fac.towered) {
            if (fac.airportClass === 1) {
                return WaypointIconImageCache.get('AIRPORT_NONTOWERED_NONSERVICED');
            }
            else {
                return WaypointIconImageCache.get('AIRPORT_SMALL_NONSERVICED');
            }
        }
        else {
            return WaypointIconImageCache.get('AIRPORT_UNKNOWN');
        }
    }
    /**
     * Maps the vor type to the right icon.
     * @param type The vor type enum to get the icon for.
     * @returns The image elements used for this  type of vor.
     */
    static getVorIcon(type) {
        switch (type) {
            case VorType.DME:
                return WaypointIconImageCache.get('DME');
            case VorType.ILS:
            case VorType.VORDME:
                return WaypointIconImageCache.get('VORDME');
            case VorType.VORTAC:
            case VorType.TACAN:
                return WaypointIconImageCache.get('VORVORTAC');
            default:
                return WaypointIconImageCache.get('VOR');
        }
    }
}

/**
 * A class that calculates displayed lateral nav data information from
 * supplied lnav values.
 */
class NavdataComputer {
    /**
     * Creates a new instance of the NavdataComputer.
     * @param bus The event bus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     * @param facilityLoader The facility loader to use with this instance.
     */
    constructor(bus, flightPlanner, facilityLoader) {
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.facilityLoader = facilityLoader;
        this.vec3Cache = [new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.obsAvailable = false;
        this.approachDetails = {
            approachLoaded: false,
            approachType: ApproachType.APPROACH_TYPE_UNKNOWN,
            approachRnavType: RnavTypeFlags.None,
            approachIsActive: false
        };
        this.bus.getSubscriber()
            .on('dataChanged')
            .handle(this.onDataChange.bind(this));
        this.bus.getSubscriber()
            .on('fplOriginDestChanged')
            .handle(this.flightPlanOriginDestChanged.bind(this));
        this.bus.getSubscriber()
            .on('approach_details_set')
            .handle(d => this.approachDetails = d);
    }
    /**
     * A callback fired when the LNAV data changes.
     * @param data The new LNAV data.
     */
    onDataChange(data) {
        if (data.state !== undefined) {
            const magVar = MagVar.get(data.state.pos);
            this.computeTrackingVars(data, magVar);
            this.computeCDIScaling(data);
            SimVar.SetSimVarValue(LNavVars.CurrentVector, 'number', data.vectorIndex);
            if (data.currentLeg) {
                this.setObsAvailable(data.currentLeg.leg.type);
            }
        }
    }
    /**
     * A callback fired when the origin or destination changes in the flight plan.
     * @param e The event that was captured.
     */
    flightPlanOriginDestChanged(e) {
        if (e.airport !== undefined) {
            this.facilityLoader.getFacility(FacilityType.Airport, e.airport).then(fac => {
                switch (e.type) {
                    case OriginDestChangeType.OriginAdded:
                        this.originFacility = fac;
                        break;
                    case OriginDestChangeType.DestinationAdded:
                        this.destinationFacility = fac;
                        break;
                }
            });
        }
        if (e.type === OriginDestChangeType.OriginRemoved) {
            this.originFacility = undefined;
        }
        if (e.type === OriginDestChangeType.DestinationRemoved) {
            this.destinationFacility = undefined;
        }
    }
    /**
     * Computes the nav tracking data, such as XTK, DTK, and distance to turn.
     * @param data The LNAV data to compute with.
     * @param magVar The computed current location magvar.
     */
    computeTrackingVars(data, magVar) {
        var _a;
        if (data.state !== undefined) {
            let xtk = 0;
            let dtk = 0;
            let distance = 0;
            let distanceToTurn = 0;
            let totalDistance = 0;
            if (data.turnMode === TurnMode.Egress && data.nextLeg !== undefined && data.nextLeg.calculated !== undefined) {
                const circle = FlightPathUtils.setGeoCircleFromVector(data.nextLeg.calculated.flightPath[0], this.geoCircleCache[0]);
                xtk = UnitType.GA_RADIAN.convertTo(circle.distance(data.state.pos), UnitType.NMILE);
                dtk = (_a = data.nextLeg.calculated.initialDtk) !== null && _a !== void 0 ? _a : 0;
                distance = this.getActiveDistance(data.nextLeg, data.state.pos);
                distanceToTurn = this.getDistanceToTurn(data.nextLeg, data.state.pos);
                SimVar.SetSimVarValue(LNavVars.DTK, 'degrees', dtk);
            }
            else if (data.currentLeg !== undefined && data.currentLeg.calculated !== undefined) {
                let vector = data.currentLeg.calculated.flightPath[data.vectorIndex];
                switch (data.currentLeg.leg.type) {
                    case LegType.DF:
                        vector = data.currentLeg.calculated.flightPath[data.currentLeg.calculated.flightPath.length - 1];
                        break;
                    case LegType.HM: {
                        const holdStartIndex = data.currentLeg.calculated.flightPath.length - 4;
                        if (data.vectorIndex < holdStartIndex + 2) {
                            vector = data.currentLeg.calculated.flightPath[holdStartIndex + 1];
                        }
                        else {
                            vector = data.currentLeg.calculated.flightPath[holdStartIndex + 3];
                        }
                    }
                }
                if (vector !== undefined) {
                    const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
                    const alongTrackPos = circle.closest(data.state.pos, this.vec3Cache[0]);
                    xtk = UnitType.GA_RADIAN.convertTo(circle.distance(data.state.pos), UnitType.NMILE);
                    dtk = circle.bearingAt(alongTrackPos);
                    distance = this.getActiveDistance(data.currentLeg, data.state.pos);
                    distanceToTurn = this.getDistanceToTurn(data.currentLeg, data.state.pos);
                    totalDistance = this.getTotalDistance(distance);
                    SimVar.SetSimVarValue(LNavVars.DTK, 'degrees', NavMath.normalizeHeading(dtk - magVar));
                }
            }
            SimVar.SetSimVarValue(LNavVars.XTK, SimVarValueType.NM, xtk);
            SimVar.SetSimVarValue(LNavVars.Distance, SimVarValueType.Meters, distance);
            SimVar.SetSimVarValue(LNavVars.DistanceToTurn, SimVarValueType.Meters, distanceToTurn);
            SimVar.SetSimVarValue(LNavVars.DistanceToDestination, SimVarValueType.Meters, totalDistance);
        }
    }
    /**
     * Computes the CDI scaling for the given LNAV data.
     * @param data The LNAV data to compute with.
     */
    computeCDIScaling(data) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        let scaling = 2.0;
        let scalingLabel = CDIScaleLabel.Enroute;
        const flightPlan = this.flightPlanner.hasActiveFlightPlan() ? this.flightPlanner.getActiveFlightPlan() : undefined;
        if (data.state !== undefined && flightPlan && flightPlan.length > 0 && flightPlan.activeLateralLeg < flightPlan.length) {
            const activeSegment = flightPlan.getSegment(flightPlan.getSegmentIndex(flightPlan.activeLateralLeg));
            let previousLeg;
            try {
                previousLeg = flightPlan.getLeg(flightPlan.activeLateralLeg - 1);
            }
            catch ( /*Do nothing*/_j) { /*Do nothing*/ }
            //We are currently in the departure segment
            if (activeSegment.segmentType === FlightPlanSegmentType.Departure) {
                scaling = 0.3;
                scalingLabel = CDIScaleLabel.Departure;
                const prevLegType = previousLeg === null || previousLeg === void 0 ? void 0 : previousLeg.leg.type;
                if (prevLegType && prevLegType !== LegType.IF && prevLegType !== LegType.CA && prevLegType !== LegType.FA) {
                    scaling = 1.0;
                    scalingLabel = CDIScaleLabel.Terminal;
                }
            }
            //We are not in the departure segment any longer
            if (this.originFacility !== undefined && activeSegment.segmentType !== FlightPlanSegmentType.Departure) {
                const distance = UnitType.GA_RADIAN.convertTo(data.state.pos.distance(this.originFacility), UnitType.NMILE);
                scaling = 2.0 - NavMath.clamp(31 - distance, 0, 1);
                if (distance <= 30) {
                    scalingLabel = CDIScaleLabel.Terminal;
                }
            }
            //Check for distance to destination
            if (this.destinationFacility !== undefined && activeSegment.segmentType !== FlightPlanSegmentType.Departure) {
                const distance = UnitType.GA_RADIAN.convertTo(data.state.pos.distance(this.destinationFacility), UnitType.NMILE);
                scaling = 2.0 - NavMath.clamp(31 - distance, 0, 1);
                if (distance <= 30) {
                    scalingLabel = CDIScaleLabel.Terminal;
                }
            }
            //Check for distance from arrival start
            if (activeSegment.segmentType === FlightPlanSegmentType.Arrival && activeSegment.legs.length > 1) {
                const firstArrivalLeg = activeSegment.legs[1];
                //If we're going from the start of the arrival (i.e. the second leg)
                if (flightPlan.activeLateralLeg === activeSegment.offset + 1
                    && ((_a = firstArrivalLeg.calculated) === null || _a === void 0 ? void 0 : _a.startLat) !== undefined
                    && ((_b = firstArrivalLeg.calculated) === null || _b === void 0 ? void 0 : _b.startLon) !== undefined
                    && ((_c = firstArrivalLeg.calculated) === null || _c === void 0 ? void 0 : _c.endLat) !== undefined
                    && ((_d = firstArrivalLeg.calculated) === null || _d === void 0 ? void 0 : _d.endLon) !== undefined) {
                    const start = this.geoPointCache[0].set(firstArrivalLeg.calculated.startLat, firstArrivalLeg.calculated.startLon);
                    const end = this.geoPointCache[1].set(firstArrivalLeg.calculated.endLat, firstArrivalLeg.calculated.endLon);
                    const distance = NavMath.alongTrack(start, end, data.state.pos);
                    scaling = 2.0 - NavMath.clamp(distance, 0, 1);
                    if (distance >= 1) {
                        scalingLabel = CDIScaleLabel.Terminal;
                    }
                }
                else if (flightPlan.activeLateralLeg > activeSegment.offset + 1) {
                    scaling = 1.0;
                    scalingLabel = CDIScaleLabel.Terminal;
                }
            }
            //We are in the approach
            if (activeSegment.segmentType === FlightPlanSegmentType.Approach) {
                scaling = 1.0;
                scalingLabel = CDIScaleLabel.Terminal;
                const fafIndex = this.getFafIndex(activeSegment);
                if (fafIndex !== undefined && flightPlan.activeLateralLeg === fafIndex) {
                    const fafCalc = flightPlan.getLeg(fafIndex).calculated;
                    if ((fafCalc === null || fafCalc === void 0 ? void 0 : fafCalc.endLat) !== undefined && (fafCalc === null || fafCalc === void 0 ? void 0 : fafCalc.endLon) !== undefined) {
                        const distance = UnitType.GA_RADIAN.convertTo(data.state.pos.distance(fafCalc.endLat, fafCalc.endLon), UnitType.NMILE);
                        scaling = 1.0 - (0.7 * (NavMath.clamp(2 - distance, 0, 2) / 2));
                        if (distance <= 2) {
                            scalingLabel = this.getApproachCdiScale();
                        }
                    }
                }
                else if (((_f = (_e = data.currentLeg) === null || _e === void 0 ? void 0 : _e.calculated) === null || _f === void 0 ? void 0 : _f.endLat) && ((_h = (_g = data.currentLeg) === null || _g === void 0 ? void 0 : _g.calculated) === null || _h === void 0 ? void 0 : _h.endLon) && fafIndex !== undefined && flightPlan.activeLateralLeg > fafIndex) {
                    if (data.currentLeg && data.currentLeg.isInMissedApproachSequence) {
                        scaling = 1.0;
                        scalingLabel = CDIScaleLabel.MissedApproach;
                    }
                    else {
                        const legLength = data.currentLeg.calculated.distance;
                        const distance = UnitType.GA_RADIAN.convertTo(data.state.pos.distance(data.currentLeg.calculated.endLat, data.currentLeg.calculated.endLon), UnitType.NMILE);
                        scaling = 0.3 - (0.112 * (NavMath.clamp(legLength - distance, 0, legLength) / legLength));
                        scalingLabel = this.getApproachCdiScale();
                    }
                }
            }
        }
        SimVar.SetSimVarValue(LNavVars.CDIScale, SimVarValueType.NM, scaling);
        SimVar.SetSimVarValue(LNavVars.CDIScaleLabel, SimVarValueType.Number, scalingLabel);
    }
    /**
     * Gets the index of the FAF in a segment.
     * @param segment The segment to search.
     * @returns The index of the FAF if found.
     */
    getFafIndex(segment) {
        let fafLeg = segment.legs[segment.legs.length - 2];
        let fafIndex = segment.legs.length - 2;
        for (let i = 0; i < segment.legs.length; i++) {
            const leg = segment.legs[i];
            if (leg.leg.fixTypeFlags & FixTypeFlags.FAF) {
                fafLeg = leg;
                fafIndex = i;
                break;
            }
        }
        if (fafLeg !== undefined) {
            return segment.offset + fafIndex;
        }
    }
    /**
     * Gets the active distance from the plane position to the leg end.
     * @param leg The leg to get the distance for.
     * @param pos The current plane position.
     * @returns The distance, in meters.
     */
    getActiveDistance(leg, pos) {
        var _a;
        const finalVector = (_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.flightPath[leg.calculated.flightPath.length - 1];
        if (finalVector !== undefined) {
            return UnitType.GA_RADIAN.convertTo(pos.distance(finalVector.endLat, finalVector.endLon), UnitType.METER);
        }
        return 0;
    }
    /**
     * Gets the total distance from the plane position to the destination leg.
     * @param activeDistance The distance from the present position to the current leg end.
     * @returns The distance, in meters.
     */
    getTotalDistance(activeDistance) {
        var _a, _b;
        const plan = this.flightPlanner.getActiveFlightPlan();
        const activeLegCumulativeDistance = plan.activeLateralLeg < plan.length
            ? (_a = plan.getLeg(plan.activeLateralLeg).calculated) === null || _a === void 0 ? void 0 : _a.cumulativeDistanceWithTurns
            : undefined;
        let lastLegIndex = Math.max(0, plan.length - 1);
        if (plan.length > 1) {
            const finalSegment = plan.getSegment(plan.getSegmentIndex(plan.length - 1));
            for (let i = finalSegment.legs.length - 1; i >= 0; i--) {
                const leg = finalSegment.legs[i];
                if (!leg.isInMissedApproachSequence) {
                    lastLegIndex = i + finalSegment.offset;
                    break;
                }
            }
        }
        const destinationLegCumulativeDistance = (_b = plan.getLeg(lastLegIndex).calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistanceWithTurns;
        if (destinationLegCumulativeDistance !== undefined && activeLegCumulativeDistance !== undefined && activeDistance >= 0) {
            return destinationLegCumulativeDistance - activeLegCumulativeDistance + activeDistance;
        }
        return 0;
    }
    /**
     * Gets the active distance from the plane position to the next leg turn.
     * @param leg The leg to get the distance for.
     * @param pos The current plane position.
     * @returns The distance, in meters.
     */
    getDistanceToTurn(leg, pos) {
        if (leg.calculated !== undefined) {
            if (leg.calculated.egressTurn.radius !== 0) {
                return UnitType.GA_RADIAN.convertTo(pos.distance(leg.calculated.egressTurn.startLat, leg.calculated.egressTurn.startLon), UnitType.METER);
            }
            else {
                return this.getActiveDistance(leg, pos);
            }
        }
        return 0;
    }
    /**
     * Checks and sets whether obs is available on the current leg and sends an event over the bus to update the softkeymenu.
     * @param currentLegType The current leg type.
     */
    setObsAvailable(currentLegType) {
        let newObsAvailable = false;
        switch (currentLegType) {
            case LegType.AF:
            case LegType.CD:
            case LegType.CF:
            case LegType.CR:
            case LegType.DF:
            case LegType.IF:
            case LegType.RF:
            case LegType.TF:
                newObsAvailable = true;
                break;
        }
        if (newObsAvailable !== this.obsAvailable) {
            this.obsAvailable = newObsAvailable;
            this.bus.getPublisher().pub('obs_available', this.obsAvailable, true, true);
        }
    }
    /**
     * Checks and returns the CDI Scale when in an approach.
     * @returns The CDIScaleLabel appropriate for the approach.
     */
    getApproachCdiScale() {
        switch (this.approachDetails.approachType) {
            case ApproachType.APPROACH_TYPE_GPS:
            case ApproachType.APPROACH_TYPE_RNAV:
                switch (this.approachDetails.approachRnavType) {
                    case RnavTypeFlags.LPV:
                        return CDIScaleLabel.LPV;
                    case RnavTypeFlags.LP:
                        return CDIScaleLabel.LPPlusV;
                    case RnavTypeFlags.LNAVVNAV:
                        return CDIScaleLabel.LNavVNav;
                }
                return CDIScaleLabel.LNavPlusV;
            case AdditionalApproachType.APPROACH_TYPE_VISUAL:
                return CDIScaleLabel.Visual;
            default:
                return CDIScaleLabel.Terminal;
        }
    }
}

var FmsHEvent;
(function (FmsHEvent) {
    FmsHEvent[FmsHEvent["UPPER_INC"] = 0] = "UPPER_INC";
    FmsHEvent[FmsHEvent["UPPER_DEC"] = 1] = "UPPER_DEC";
    FmsHEvent[FmsHEvent["LOWER_INC"] = 2] = "LOWER_INC";
    FmsHEvent[FmsHEvent["LOWER_DEC"] = 3] = "LOWER_DEC";
    FmsHEvent[FmsHEvent["PUSH"] = 4] = "PUSH";
    FmsHEvent[FmsHEvent["MENU"] = 5] = "MENU";
    FmsHEvent[FmsHEvent["ENT"] = 6] = "ENT";
    FmsHEvent[FmsHEvent["CLR"] = 7] = "CLR";
    FmsHEvent[FmsHEvent["DIRECTTO"] = 8] = "DIRECTTO";
    FmsHEvent[FmsHEvent["UPPER_PUSH"] = 9] = "UPPER_PUSH";
    FmsHEvent[FmsHEvent["FPL"] = 10] = "FPL";
    FmsHEvent[FmsHEvent["PROC"] = 11] = "PROC";
    FmsHEvent[FmsHEvent["RANGE_INC"] = 12] = "RANGE_INC";
    FmsHEvent[FmsHEvent["RANGE_DEC"] = 13] = "RANGE_DEC";
    FmsHEvent[FmsHEvent["JOYSTICK_PUSH"] = 14] = "JOYSTICK_PUSH";
    FmsHEvent[FmsHEvent["JOYSTICK_LEFT"] = 15] = "JOYSTICK_LEFT";
    FmsHEvent[FmsHEvent["JOYSTICK_UP"] = 16] = "JOYSTICK_UP";
    FmsHEvent[FmsHEvent["JOYSTICK_RIGHT"] = 17] = "JOYSTICK_RIGHT";
    FmsHEvent[FmsHEvent["JOYSTICK_DOWN"] = 18] = "JOYSTICK_DOWN";
})(FmsHEvent || (FmsHEvent = {}));

/** Scroll utils */
class ScrollUtils {
    /**
     * Scrolls the container to make sure an element is in view.
     * @param el The element to scroll into view in the container.
     * @param container The container to scroll.
     */
    static ensureInView(el, container) {
        const cHeight = container.offsetHeight;
        const eHeight = el.offsetHeight;
        if (eHeight > cHeight) {
            return;
        }
        const cTop = container.scrollTop;
        const cBottom = cTop + cHeight;
        try {
            const eTop = ScrollUtils.findOffsetTopRelativeToAncestor(el, container);
            const eBottom = eTop + eHeight;
            if (!this.isElementInViewport(cTop, cBottom, eTop, eBottom)) {
                if (eTop < cTop) {
                    container.scrollTop -= (cTop - eTop);
                }
                else if (eBottom > cBottom) {
                    container.scrollTop += (eBottom - cBottom);
                }
            }
        }
        catch (e) {
            console.log(e);
        }
    }
    /**
     * Finds the offsetTop of an element relative to one of its ancestors.
     * @param element An element.
     * @param ancestor An ancestor of `element`.
     * @returns the offsetTop of the element relative to the ancestor.
     * @throws Error if the offsetTop could not be calculated.
     */
    static findOffsetTopRelativeToAncestor(element, ancestor) {
        const ancestorParent = ancestor.offsetParent;
        let top = element.offsetTop;
        while (element.offsetParent !== ancestorParent) {
            if (!(element.offsetParent instanceof HTMLElement)) {
                throw new Error('Element\'s offset ancestry does not directly lead to the specified ancestor');
            }
            element = element.offsetParent;
            top += element.offsetTop;
        }
        return top - ancestor.offsetTop;
    }
    /**
     * Checks if an element is visible.
     * @param cTop The top coordinate of the scroll container.
     * @param cBottom The bottom coordinate of the scroll container.
     * @param eTop The top coordinate of the element.
     * @param eBottom The bottom coordinate of the element.
     * @returns A boolean.
     */
    static isElementInViewport(cTop, cBottom, eTop, eBottom) {
        return eTop >= cTop && eBottom <= cBottom;
    }
}

/**
 * The UiControl component.
 */
class UiControl extends DisplayComponent {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.focusSubject = ComputedSubject.create(false, (v) => {
            return v ? UiControl.FOCUS_CLASS : '';
        });
        this.isEnabledSubject = Subject.create(true);
        this.isVisibleSubject = Subject.create(true);
        this.isActivated = false;
        this.registerSelf = true;
        this.containerRef = FSComponent.createRef();
        this.focusSubject.sub(isFocused => {
            if (isFocused) {
                this.onFocused();
                this.props.onFocused && this.props.onFocused(this);
            }
            else {
                this.onBlurred();
                this.props.onBlurred && this.props.onBlurred(this);
            }
        });
    }
    /** Method to focus this control */
    focus() {
        this.focusSubject.set(true);
    }
    /** Method to unfocus this control */
    blur() {
        this.focusSubject.set(false);
        this.isActivated = false;
    }
    /** Activates the control. Usually after being focused and some action happens. */
    activate() {
        this.isActivated = true;
        this.onActivated();
        if (this.props.onActivated) {
            this.props.onActivated(this);
        }
    }
    /** Deactivate the control. */
    deactivate() {
        this.isActivated = false;
        this.onDeactivated();
        if (this.props.onDeactivated) {
            this.props.onDeactivated(this);
        }
    }
    /** Method to check if this UiControl is in focus
     * @returns a boolean whether this is in focus
     */
    getIsFocused() {
        return this.focusSubject.getRaw();
    }
    /**
     * Gets a boolean indicating if this control is enabled.
     * @returns A boolean.
     */
    getIsEnabled() {
        return this.isEnabledSubject.get();
    }
    /**
     * Sets the enabled state of this control.
     * @param enable A {boolean} indicating if this control should be enabled.
     */
    setIsEnabled(enable) {
        if (!enable && this.getIsFocused()) {
            this.blur();
        }
        this.isEnabledSubject.set(enable);
    }
    /**
     * Sets the visibility of this control.
     * @param visible A {boolean} indicating if this control should be visible.
     */
    setIsVisible(visible) {
        this.isVisibleSubject.set(visible);
    }
    /**
     * Gets a boolean indicating if this control is visible.
     * @returns A boolean.
     */
    getIsVisible() {
        return this.isVisibleSubject.get();
    }
    /**
     * Gets a boolean indicating if this control is able to be focused.
     * @returns A boolean.
     */
    getIsFocusable() {
        return this.getIsEnabled() && this.getIsVisible();
    }
    /**
     * Gets a boolean indicating if this control is currently activated.
     * @returns A boolean.
     */
    getIsActivated() {
        return this.isActivated;
    }
    /** @inheritdoc */
    onBeforeRender() {
        this.onRegister();
    }
    /** @inheritdoc */
    onAfterRender() {
        var _a;
        this.focusSubject.sub((v, rv) => {
            var _a, _b;
            if (rv) {
                (_a = this.getHighlightElement()) === null || _a === void 0 ? void 0 : _a.classList.add(UiControl.FOCUS_CLASS);
            }
            else {
                (_b = this.getHighlightElement()) === null || _b === void 0 ? void 0 : _b.classList.remove(UiControl.FOCUS_CLASS);
            }
        }, true);
        this.isVisibleSubject.sub((v) => {
            if (v) {
                this.containerRef.instance.classList.remove(UiControl.HIDE_CLASS);
            }
            else {
                this.containerRef.instance.classList.add(UiControl.HIDE_CLASS);
            }
        }, true);
        (_a = this.props.isVisible) === null || _a === void 0 ? void 0 : _a.sub((v) => {
            this.setIsVisible(v);
        }, true);
    }
    /**
     * Gets the element to highlight on focus.
     * Should be overriden by inheriting controls when the highlight is not the topmost container.
     * @protected
     * @returns The {Element} to highlight.
     */
    getHighlightElement() {
        return this.containerRef.instance.firstElementChild;
    }
    /** Method to register this Ui Control */
    onRegister() {
        if (this.props.onRegister) {
            if (this.registerSelf) {
                this.props.onRegister(this);
            }
        }
        else {
            console.warn('No register method found for UiControl');
        }
    }
    /**
     * A callback which is called when this control group is focused.
     */
    onFocused() {
        // noop
    }
    /**
     * A callback which is called when this control group is blurred.
     */
    onBlurred() {
        // noop
    }
    /** Method to override what to do when control is activated */
    onActivated() {
        var _a, _b;
        (_a = this.getHighlightElement()) === null || _a === void 0 ? void 0 : _a.classList.remove(UiControl.FOCUS_CLASS);
        (_b = this.getHighlightElement()) === null || _b === void 0 ? void 0 : _b.classList.add(UiControl.ACTIVE_CLASS);
    }
    /** Method to override what to do when control is deactivated */
    onDeactivated() {
        var _a, _b;
        (_a = this.getHighlightElement()) === null || _a === void 0 ? void 0 : _a.classList.remove(UiControl.ACTIVE_CLASS);
        if (this.getIsFocused()) {
            (_b = this.getHighlightElement()) === null || _b === void 0 ? void 0 : _b.classList.add(UiControl.FOCUS_CLASS);
        }
    }
    /**
     * A method which is called when this control receives an interaction event.
     * @param evt The event.
     * @returns Whether the event was handled.
     */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.UPPER_INC:
                this.onUpperKnobInc();
                return true;
            case FmsHEvent.UPPER_DEC:
                this.onUpperKnobDec();
                return true;
            case FmsHEvent.LOWER_DEC:
                this.onLowerKnobDec();
                return true;
            case FmsHEvent.LOWER_INC:
                this.onLowerKnobInc();
                return true;
            case FmsHEvent.ENT:
                return this.onEnter();
            case FmsHEvent.CLR:
                return this.onClr();
            case FmsHEvent.DIRECTTO:
                return this.onDirectTo();
        }
        return false;
    }
    /** Method to override that specifies what to do on Enter
     * @returns A boolean indicating if the control handled the event.
     */
    onEnter() {
        if (this.props.onEnter) {
            return this.props.onEnter(this);
        }
        return false;
    }
    /** Method to override that specifies what to do on Clr
     * @returns A boolean indicating if the control handled the event.
     */
    onClr() {
        if (this.props.onClr) {
            return this.props.onClr(this);
        }
        return false;
    }
    /**
     * Method to overwirte that specifies what to do on a direct to.
     * @returns A boolean indicating if the control handleded the event.
     */
    onDirectTo() {
        if (this.props.onDirectTo) {
            return this.props.onDirectTo(this);
        }
        return false;
    }
    /** Method to override that specifies what to do on upper knob */
    onUpperKnob() {
        if (this.props.onUpperKnob) {
            this.props.onUpperKnob(this);
        }
    }
    /** Method to override that specifies what to do on upper knob inc */
    onUpperKnobInc() {
        if (this.props.onUpperKnobInc) {
            this.props.onUpperKnobInc(this);
        }
        else {
            this.onUpperKnob();
        }
    }
    /** Method to override that specifies what to do on upper knob dec */
    onUpperKnobDec() {
        if (this.props.onUpperKnobDec) {
            this.props.onUpperKnobDec(this);
        }
        else {
            this.onUpperKnob();
        }
    }
    /** Method to override that specifies what to do on lower knob */
    onLowerKnob() {
        if (this.props.onLowerKnob) {
            this.props.onLowerKnob(this);
        }
    }
    /** Method to override that specifies what to do on lower knob inc */
    onLowerKnobInc() {
        if (this.props.onLowerKnobInc) {
            this.props.onLowerKnobInc(this);
        }
        else {
            this.onLowerKnob();
        }
    }
    /** Method to override that specifies what to do on lower knob dec */
    onLowerKnobDec() {
        if (this.props.onLowerKnobDec) {
            this.props.onLowerKnobDec(this);
        }
        else {
            this.onLowerKnob();
        }
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        var _a;
        const content = (this.props.children && this.props.children.length > 0) ? this.props.children : this.renderControl();
        const hideClass = this.getIsVisible() ? '' : UiControl.HIDE_CLASS;
        return (
        // TODO: would like to have this more layout neutral
        FSComponent.buildComponent("div", { ref: this.containerRef, class: `${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''} ${hideClass}` }, content));
    }
}
UiControl.FOCUS_CLASS = 'highlight-select';
UiControl.ACTIVE_CLASS = 'highlight-active';
UiControl.HIDE_CLASS = 'hide-element';

/** The ScrollController for UI Elements. */
class ScrollController {
    constructor() {
        this.controls = [];
        this.isEnabled = true;
        this.lastFocusedIndex = 0;
        /**
         * Scroll forward.
         * @returns true if it was able to scroll into the given direction.
         */
        this.gotoNext = () => {
            return this.scrollTo('next');
        };
        /**
         * Scroll backwards.
         * @returns true if it was able to scroll into the given direction.
         */
        this.gotoPrev = () => {
            return this.scrollTo('prev');
        };
        /**
         * Callback to override when a scroll event happens.
         * @param ctrl The control now in focus.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.onScroll = (ctrl) => {
            const el = ctrl.getHighlightElement();
            if (el !== null && this.scrollContainer) {
                ScrollUtils.ensureInView(el, this.scrollContainer);
            }
        };
    }
    /**
     * Method to register a control.
     * @param ctrl The control to register.
     */
    registerCtrl(ctrl) {
        this.controls.push(ctrl);
    }
    /**
     * Registers a scroll container with this controller.
     * @param scrollContainer The html block element to assign.
     */
    registerScrollContainer(scrollContainer) {
        this.scrollContainer = scrollContainer;
    }
    // TODO how to handle DOM modifications (add/remove)
    // this solution is not ideal. in theory we need to observe DOM changes and react accordingly
    // but a uicontrol must not be a DOM element directly, its just a component at first. so it all becomes a bit messy. ideas?
    /**
     * Method to unregister a control.
     * @param ctrl The control to unregister.
     */
    unregisterCtrl(ctrl) {
        this.controls.splice(this.controls.indexOf(ctrl), 1);
    }
    /** Method to reset this control. */
    resetCtrls() {
        this.controls.length = 0;
    }
    /**
     * Toggles the scroll enabled state.
     */
    toggleScrollEnabled() {
        this.isEnabled = !this.isEnabled;
        if (this.isEnabled) {
            if (this.lastFocusedIndex > -1) {
                this.gotoIndex(this.lastFocusedIndex);
            }
        }
        for (let i = 0; i < this.controls.length; i++) {
            const ctrl = this.controls[i];
            if (ctrl.setScrollEnabled) {
                ctrl.setScrollEnabled(this.isEnabled);
            }
        }
        if (!this.isEnabled) {
            const focusCtrl = this.getFocusedUiControl();
            this.lastFocusedIndex = focusCtrl ? this.getFocusedUiControlIndex() : -1;
            focusCtrl === null || focusCtrl === void 0 ? void 0 : focusCtrl.blur();
        }
    }
    /**
     * Gets a value indicating if scrolling is enabled
     * @returns true if is scroll enabled
     */
    getIsScrollEnabled() {
        return this.isEnabled;
    }
    /**
     * Method to get the UiControl highlighted by the control.
     * @returns the selected UiControl or undefine
     */
    getFocusedUiControl() {
        return this.controls.find((v) => { return v.getIsFocused(); });
    }
    /**
     * Method to get the UiControl highlighted by the control.
     * @returns the selected UiControl or undefine
     */
    getActivatedUiControl() {
        return this.controls.find((v) => { return (v instanceof UiControl) && v.getIsActivated(); });
    }
    /**
     * Scrolls to the first suitable control.
     * @returns Whether the operation was successful.
     */
    gotoFirst() {
        return this.scrollTo('next', -1);
    }
    /**
     * Highlight the last suitable control.
     * @returns Whether the operation was successful.
     */
    gotoLast() {
        return this.scrollTo('prev', this.controls.length);
    }
    /**
     * Highlight the selected control on the page.
     * @param index is the index to highlight.
     * @returns Whether the operation was successful.
     */
    gotoIndex(index) {
        if (index < 0) {
            return this.scrollTo('next', -1);
        }
        else if (index < this.controls.length) {
            return this.scrollTo('next', index - 1);
        }
        else {
            return this.scrollTo('prev', this.controls.length);
        }
    }
    /**
     * Gets controls count
     * @returns controls count
     */
    getControlsCount() {
        return this.controls.length;
    }
    /** Unfocus the focused control. */
    blur() {
        for (let i = 0; i < this.controls.length; i++) {
            this.controls[i].blur();
        }
    }
    /**
     * Highlights the next focusable control in the direction.
     * @param direction The direction to scroll to.
     * @param activeIdx The index to start the scroll from.
     * @returns true if it was able to scroll into the given direction.
     */
    scrollTo(direction, activeIdx = this.getFocusedUiControlIndex()) {
        var _a;
        if (!this.isEnabled) {
            return false;
        }
        if (this.controls.length > 0) {
            const isAtBounds = ((activeIdx === 0 && direction === 'prev')
                || (activeIdx === this.controls.length - 1 && direction === 'next'));
            const nextCtrl = this.findControlToFocus(activeIdx, direction);
            if (nextCtrl !== undefined) {
                (_a = this.getFocusedUiControl()) === null || _a === void 0 ? void 0 : _a.blur();
                // typecheck for UiControlGroup to avoid circular dependency
                if (nextCtrl.processHEvent) {
                    nextCtrl.focus((direction === 'next') ? 'top' : 'bottom');
                }
                else {
                    nextCtrl.focus();
                }
                this.onScroll(nextCtrl);
                return !isAtBounds;
            }
            else {
                const focusedCtrl = this.getFocusedUiControl();
                if (focusedCtrl !== undefined) {
                    this.onScroll(focusedCtrl);
                }
                return false;
            }
        }
        return false;
    }
    /**
     * Founds the next/prev control that is able to be focused.
     * Returns undefined when no suitable control is found.
     * @private
     * @param activeIdx The index to start the search from.
     * @param direction The direction to look into.
     * @returns A focusable UiControl or undefined.
     */
    findControlToFocus(activeIdx, direction) {
        const nextIdx = (direction === 'next') ? activeIdx + 1 : activeIdx - 1;
        // const ctrl = this.controls[MathUtils.clamp(nextIdx, 0, this.controls.length - 1)];
        const ctrl = this.controls[nextIdx];
        if (ctrl === undefined || ctrl.getIsFocusable()) {
            return ctrl;
        }
        else {
            return this.findControlToFocus(nextIdx, direction);
        }
    }
    /**
     * Gets the index of the focused control.
     * @private
     * @returns The index.
     */
    getFocusedUiControlIndex() {
        return this.controls.findIndex((v) => { return v.getIsFocused(); });
    }
}

/** Ui control group */
class UiControlGroup extends DisplayComponent {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.scrollController = new ScrollController();
        this.focusSubject = Subject.create(false);
        /** Register/Unregisters a UiControl with the scroll controller.
         * @param ctrl The UiControl to register.
         * @param unregister Indicates if the UiControl should be unregistered.
         */
        this.register = (ctrl, unregister = false) => {
            if (unregister) {
                this.scrollController.unregisterCtrl(ctrl);
            }
            else {
                this.scrollController.registerCtrl(ctrl);
            }
        };
        this.focusSubject.sub(isFocused => {
            if (isFocused) {
                this.onFocused();
                this.props.onFocused && this.props.onFocused(this);
            }
            else {
                this.onBlurred();
                this.props.onBlurred && this.props.onBlurred(this);
            }
        });
    }
    /** @inheritdoc */
    onBeforeRender() {
        if (this.props.onRegister) {
            this.props.onRegister(this);
        }
    }
    /**
     * Method to focus this control group
     * @param dir The direction of entry.
     */
    focus(dir = 'top') {
        this.focusSubject.set(true);
        if (dir === 'top') {
            this.scrollController.gotoFirst();
        }
        else {
            this.scrollController.gotoLast();
        }
    }
    /** Method to unfocus this control group */
    blur() {
        this.focusSubject.set(false);
        // TODO: maybe we need to bubble down the blur...
        this.scrollController.blur();
    }
    /** Method to check if this UiControlGroup is in focus
     * @returns true if the control group is in focus, false otherwise
     */
    getIsFocused() {
        return this.focusSubject.get();
    }
    /**
     * Gets a boolean indicating if this control is able to be focused.
     * @returns true
     */
    getIsFocusable() {
        return this.scrollController.getControlsCount() > 0;
    }
    /**
     * A method called when the control group scroll is toggled.
     * @param enabled if the scroll is enabled.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onScrollToggled(enabled) {
        // noop, override it if needed
    }
    /**
     * Toggles the scroll highlighting
     */
    toggleScroll() {
        this.scrollController.toggleScrollEnabled();
        this.onScrollToggled(this.scrollController.getIsScrollEnabled());
    }
    /**
     * Sets the scroll enabled state
     * @param enabled indicating if scrolling should be enabled
     */
    setScrollEnabled(enabled) {
        if (this.scrollController.getIsScrollEnabled() !== enabled) {
            this.toggleScroll();
        }
    }
    /**
     * This is just a dummy that exists here to be compatible
     * with the union type of ScrollableControl
     * @returns null
     */
    getHighlightElement() {
        return null;
    }
    /**
     * Handles HEvents and routes them to the subdialog when existant.
     * @param evt The received event.
     * @returns true if the event was handled in this control group, false otherwise.
     */
    processHEvent(evt) {
        const focusCtrl = this.scrollController.getFocusedUiControl();
        if (focusCtrl instanceof UiControlGroup && focusCtrl.processHEvent(evt)) {
            return true;
        }
        const activeCtrl = this.scrollController.getActivatedUiControl();
        if (activeCtrl instanceof UiControl && this.routeEventToControl(evt, activeCtrl)) {
            return true;
        }
        if (focusCtrl instanceof UiControl
            && evt !== FmsHEvent.LOWER_DEC
            && evt !== FmsHEvent.LOWER_INC
            && this.routeEventToControl(evt, focusCtrl)) {
            return true;
        }
        switch (evt) {
            case FmsHEvent.UPPER_DEC:
            case FmsHEvent.UPPER_INC:
                if (!this.props.upperKnobCanScroll) {
                    break;
                }
            // eslint-disable-next-line no-fallthrough
            case FmsHEvent.LOWER_DEC:
            case FmsHEvent.LOWER_INC:
                if (this.processScrollEvent(evt)) {
                    return true;
                }
        }
        return this.onInteractionEvent(evt);
    }
    /**
     * Routes an interaction event to a UiControl.
     * @param evt An interaction event.
     * @param control The UiControl to which to route the event.
     * @returns Whether the event was handled by the UiControl.
     */
    routeEventToControl(evt, control) {
        switch (evt) {
            case FmsHEvent.UPPER_DEC:
            case FmsHEvent.UPPER_INC:
                if (this.props.upperKnobCanScroll) {
                    break;
                }
            // eslint-disable-next-line no-fallthrough
            default:
                return control.onInteractionEvent(evt);
        }
        return false;
    }
    /**
     * Attempts to handle scroll events.
     * @param evt The received event.
     * @returns whether the event was handled.
     */
    processScrollEvent(evt) {
        if (this.scrollController.getIsScrollEnabled()) {
            switch (evt) {
                case FmsHEvent.LOWER_DEC:
                case FmsHEvent.UPPER_DEC:
                    return this.scrollController.gotoPrev();
                case FmsHEvent.LOWER_INC:
                case FmsHEvent.UPPER_INC:
                    return this.scrollController.gotoNext();
            }
        }
        return false;
    }
    /**
     * Handler for interaction events to be handled by the view.
     * @param evt The HEvenet.
     * @returns true if the event was handled in this group
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onInteractionEvent(evt) {
        // noop, override it if needed
        return false;
    }
    /**
     * A callback which is called when this control group is focused.
     */
    onFocused() {
        // noop
    }
    /**
     * A callback which is called when this control group is blurred.
     */
    onBlurred() {
        // noop
    }
}

/** A UiView component. */
class UiView extends UiControlGroup {
    constructor() {
        super(...arguments);
        this.viewContainerRef = FSComponent.createRef();
        this.inputData = Subject.create(undefined);
        this.onOpen = new SubEvent();
        this.onClose = new SubEvent();
        this.onAccept = new SubEvent();
    }
    /**
     * Shows the view.
     * @param isSubView Whether the view is being displayed as a subview.
     * @param zIndex The z-index to assign on the view container.
     */
    open(isSubView, zIndex) {
        if (this.viewContainerRef.instance !== null) {
            if (zIndex) {
                this.viewContainerRef.instance.style.zIndex = `${zIndex}`;
            }
            this.viewContainerRef.instance.classList.remove('quickclosed');
            this.viewContainerRef.instance.classList.remove('closed');
            this.viewContainerRef.instance.classList.add('open');
            isSubView && this.viewContainerRef.instance.classList.add('subview');
            this.notifyViewOpened();
            this.notifyViewResumed();
        }
    }
    /**
     * Closes the view.
     * @param quickclose bool stating whether to quickclose the child.
     */
    close(quickclose = false) {
        if (this.viewContainerRef.instance !== null) {
            this.notifyViewPaused();
            this.viewContainerRef.instance.classList.remove('open');
            if (quickclose === true) {
                this.viewContainerRef.instance.classList.add('quickclosed');
            }
            else {
                this.viewContainerRef.instance.classList.add('closed');
            }
            this.notifyViewClosed();
            this.setInput(undefined);
            this.viewResult = undefined;
            this.onAccept.clear();
        }
    }
    /**
     * Sets this view's z-index.
     * @param zIndex The new z-indez. If not defined, the view's z-index will be reset.
     */
    setZIndex(zIndex) {
        this.viewContainerRef.instance.style.zIndex = `${zIndex !== null && zIndex !== void 0 ? zIndex : ''}`;
    }
    /**
     * Set data on this view.
     * @param input The input data.
     * @returns This view instance for chain commands.
     */
    setInput(input) {
        this.inputData.set(input);
        this.onInputDataSet(input);
        return this;
    }
    /**
     * Confirms the view result and closes the view.
     * @param [result] Provide the view result if not already set.
     * @param closeView Indicates if the view should be closed after confirming the result.
     */
    accept(result, closeView = true) {
        if (result !== undefined) {
            this.viewResult = result;
        }
        this.notifyViewAccept();
        if (closeView) {
            this.close();
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    processScrollEvent(evt) {
        if (this.scrollController.getIsScrollEnabled()) {
            // Do not let scroll events fall through if scrolling is enabled.
            super.processScrollEvent(evt);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Notifies subscribers that the view has been opened.
     * @protected
     */
    notifyViewOpened() {
        this.focus();
        this.onViewOpened();
        this.onOpen.notify(this);
    }
    /**
     * Notifies subscribers that the view has been resumed.
     */
    notifyViewResumed() {
        this.onViewResumed();
    }
    /**
     * Notifies subscribers that the view has been paused.
     */
    notifyViewPaused() {
        this.onViewPaused();
    }
    /**
     * Notifies subscribers that the view has been closed including the view result.
     */
    notifyViewClosed() {
        this.onViewClosed();
        this.onClose.notify(this);
        this.blur();
    }
    /**
     * Notifies subscribers that the view the user confirmed the view and a result should be available.
     */
    notifyViewAccept() {
        this.onAccept.notify(this, this.viewResult);
    }
    /** Method to be overridden by view inheriting UiView to do something when the view opens. */
    onViewOpened() {
        //noop
    }
    /** Method to be overridden by view inheriting UiView to do something when the dialog opens. */
    onViewResumed() {
        // noope
    }
    /** Method to be overridden by view inheriting UiView to do something when the dialog opens. */
    onViewPaused() {
        //noop
    }
    /** Method to be overridden by view inheriting UiView to do something when the dialog opens. */
    onViewClosed() {
        //noop
    }
    /**
     * Method to be overridden by view inheriting UiView to do something when the input data is set.
     * @protected
     * @param input The data that was set.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onInputDataSet(input) {
        //noop
    }
    /**
     * Pauses the view (usually only called by ViewService).
     */
    pause() {
        this.notifyViewPaused();
    }
    /**
     * Resumes the view (usually only called by ViewService).
     */
    resume() {
        this.notifyViewResumed();
    }
}

/** A UiPage component. */
class UiPage extends UiView {
    /** @inheritdoc */
    constructor(props) {
        props.title = '';
        props.showTitle = false;
        super(props);
        this._title = Subject.create('');
        this.isPaused = false;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The title of this page. */
    get title() {
        return this._title;
    }
    /**
     * Opens the page.
     */
    open() {
        super.open(false);
    }
    /**
     * This method has no effect.
     */
    setZIndex() {
        // noop
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    processScrollEvent(evt) {
        // Do not handle scroll inputs while paused.
        if (this.isPaused) {
            return false;
        }
        return super.processScrollEvent(evt);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewResumed() {
        this.isPaused = false;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewPaused() {
        this.isPaused = true;
        // commenting this out for now because it seems to break some stuff with components expecting lists to keep track
        // of selections even when the list is not in the active view.
        //this.blur();
    }
}

/**
 * A service to manage views.
 */
class ViewService {
    /**
     * Constructs the view service.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.registeredViews = new Map();
        this.refsMap = new Map();
        this.openViews = [];
        this.openPageKeySub = Subject.create('');
        this.openPageSub = this.openPageKeySub.map(key => { var _a, _b; return (_b = (_a = this.refsMap.get(key)) === null || _a === void 0 ? void 0 : _a.instance) !== null && _b !== void 0 ? _b : null; });
        /** override in child class */
        this.fmsEventMap = new Map([]);
        const hEvtPub = this.bus.getSubscriber();
        hEvtPub.on('hEvent').handle(hEvent => {
            this.onInteractionEvent(hEvent);
        });
        this.viewClosedHandler = this.handleViewClosed.bind(this);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The key of the currently open page. */
    get openPageKey() {
        return this.openPageKeySub;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The currently open page. */
    get openPage() {
        return this.openPageSub;
    }
    /**
     * Routes the HEvents to the views.
     * @param hEvent The event identifier.
     */
    onInteractionEvent(hEvent) {
        console.log(hEvent);
        const evt = this.fmsEventMap.get(hEvent);
        if (evt !== undefined) {
            this.routeInteractionEventToViews(evt);
        }
    }
    /**
     * Routes an interaction to the active view, and if it is not handled, re-routes the interaction to the currently
     * open page if it exists and is not the active view.
     * @param evt An interaction event.
     * @returns Whether the event was handled.
     */
    routeInteractionEventToViews(evt) {
        const activeView = this.getActiveView();
        if (activeView) {
            let handled = activeView.processHEvent(evt);
            if (!handled) {
                // If the event was not handled, then give the open page (if any) a chance to handle the event.
                const page = this.openPage.get();
                if (page && page !== activeView) {
                    handled = page.processHEvent(evt);
                }
            }
            if (handled) {
                return true;
            }
        }
        return false;
    }
    /**
     * Gets the active view.
     * @returns The topmost view that is considered active.
     */
    getActiveView() {
        return this.openViews[this.openViews.length - 1];
    }
    /**
     * Gets an array of all currently open views.
     * @returns an array of all currently open views.
     */
    getOpenViews() {
        return this.openViews;
    }
    /**
     * Registers a view with the service.
     * @param [type] The type of the view.
     * @param vnodeFn A function creating the VNode.
     */
    registerView(type, vnodeFn) {
        console.log('registering ' + type);
        this.registeredViews.set(type, vnodeFn);
    }
    /**
     * Opens a view. The opened view can be a page, regular view, or subview. Opening a page will close all other views,
     * including the currently open page. Opening a regular view will close all other views except the currently open
     * page. Opening a subview does not close any other views. The opened view will immediately become the active view,
     * and the previously active view (if one exists) will be paused.
     * @param type The type of the view to open.
     * @param isSubView A boolean indicating if the view to be opened is a subview.
     * @returns The view that was opened.
     * @throws Error if the view type is not registered with this service.
     */
    open(type, isSubView = false) {
        var _a;
        let viewRef = this.refsMap.get(type);
        if (viewRef === undefined) {
            // when we hve no ref, create the view
            viewRef = this.createView(type);
            this.refsMap.set(type, viewRef);
        }
        const view = viewRef.instance;
        const isPage = view instanceof UiPage;
        if (isPage) {
            this.clearStack(true);
        }
        else if (!isSubView) {
            this.clearStack(false);
        }
        (_a = this.getActiveView()) === null || _a === void 0 ? void 0 : _a.pause();
        view.open(isSubView, 900 + this.openViews.length);
        view.onClose.clear();
        view.onClose.on(this.viewClosedHandler);
        const index = this.openViews.indexOf(view);
        if (index >= 0) {
            this.openViews.splice(index, 1);
        }
        this.openViews.push(view);
        if (isPage) {
            this.openPageKeySub.set(type);
        }
        return view;
    }
    /**
     * Creates a view.
     * @param type The type string of the view to create.
     * @returns A NodeReference to the created view.
     * @throws When type of view is not registered.
     */
    createView(type) {
        const vnodeFn = this.registeredViews.get(type);
        if (vnodeFn === undefined) {
            console.error(`Could not find a registered view of type ${type.toString()}!`);
            throw new Error(`Could not find a registered view of type ${type.toString()}!`);
        }
        const node = vnodeFn();
        FSComponent.render(node, document.getElementById('InstrumentsContainer'));
        const viewRef = FSComponent.createRef();
        viewRef.instance = node.instance;
        return viewRef;
    }
    /**
     * Handles views that got closed, removing them from the stack.
     * @param closedView The view that was closed.
     */
    handleViewClosed(closedView) {
        var _a;
        const viewIndex = this.openViews.findIndex((v) => {
            return v === closedView;
        });
        closedView.onClose.off(this.viewClosedHandler);
        if (viewIndex > -1) {
            this.openViews.splice(viewIndex, 1);
            // need to reset z-indices.
            const len = this.openViews.length;
            for (let i = viewIndex; i < len; i++) {
                this.openViews[i].setZIndex(900 + i);
            }
            (_a = this.getActiveView()) === null || _a === void 0 ? void 0 : _a.resume();
        }
        if (closedView === this.openPageSub.get()) {
            this.openPageKeySub.set('');
        }
    }
    /**
     * Closes the currently active view.
     */
    closeActiveView() {
        this.getActiveView().close();
    }
    /**
     * Closes all open views except for the currently open page, if one exists.
     */
    closeAllViews() {
        this.clearStack(false);
    }
    /**
     * Closes all open views and clears the stack.
     * @param closePage Whether to close the currently open page, if one exists.
     */
    clearStack(closePage) {
        if (this.openViews.length === 0) {
            return;
        }
        const views = [...this.openViews];
        const len = views.length;
        for (let i = len - 1; i > 0; i--) {
            views[i].close(true);
        }
        this.openViews.length = 1;
        if (closePage || !(views[0] instanceof UiPage)) {
            views[0].close(true);
            this.openViews.length = 0;
        }
    }
}

/**
 * A service to manage views.
 */
class MFDViewService extends ViewService {
    constructor() {
        super(...arguments);
        this.fmsEventMap = new Map([
            ['AS1000_MFD_FMS_Upper_INC', FmsHEvent.UPPER_INC],
            ['AS1000_MFD_FMS_Upper_DEC', FmsHEvent.UPPER_DEC],
            ['AS1000_MFD_FMS_Lower_INC', FmsHEvent.LOWER_INC],
            ['AS1000_MFD_FMS_Lower_DEC', FmsHEvent.LOWER_DEC],
            ['AS1000_MFD_MENU_Push', FmsHEvent.MENU],
            ['AS1000_MFD_CLR', FmsHEvent.CLR],
            ['AS1000_MFD_ENT_Push', FmsHEvent.ENT],
            ['AS1000_MFD_FMS_Upper_PUSH', FmsHEvent.UPPER_PUSH],
            ['AS1000_MFD_DIRECTTO', FmsHEvent.DIRECTTO],
            ['AS1000_MFD_FPL_Push', FmsHEvent.FPL],
            ['AS1000_MFD_PROC_Push', FmsHEvent.PROC],
            ['AS1000_MFD_RANGE_INC', FmsHEvent.RANGE_INC],
            ['AS1000_MFD_RANGE_DEC', FmsHEvent.RANGE_DEC],
            ['AS1000_MFD_JOYSTICK_PUSH', FmsHEvent.JOYSTICK_PUSH],
            ['AS1000_MFD_JOYSTICK_LEFT', FmsHEvent.JOYSTICK_LEFT],
            ['AS1000_MFD_JOYSTICK_UP', FmsHEvent.JOYSTICK_UP],
            ['AS1000_MFD_JOYSTICK_RIGHT', FmsHEvent.JOYSTICK_RIGHT],
            ['AS1000_MFD_JOYSTICK_DOWN', FmsHEvent.JOYSTICK_DOWN]
        ]);
    }
    /**
     * Routes the HEvents to the views.
     * @param hEvent The event identifier.
     */
    onInteractionEvent(hEvent) {
        console.log(hEvent);
        const evt = this.fmsEventMap.get(hEvent);
        if (evt !== undefined) {
            if (this.routeInteractionEventToViews(evt)) {
                return;
            }
        }
        switch (evt) {
            case FmsHEvent.UPPER_INC:
            case FmsHEvent.UPPER_DEC:
            case FmsHEvent.LOWER_INC:
            case FmsHEvent.LOWER_DEC:
                this.open('PageSelect', true);
                break;
        }
    }
}

/**
 * Utility class for retrieving map range setting managers.
 */
class MapRangeSettings {
    /**
     * Retrieves a manager for map range setting.
     * @param bus The event bus.
     * @returns a manager for map range setting.
     */
    static getManager(bus) {
        var _a;
        return (_a = MapRangeSettings.INSTANCE) !== null && _a !== void 0 ? _a : (MapRangeSettings.INSTANCE = new DefaultUserSettingManager(bus, [
            {
                name: 'pfdMapRangeIndex',
                defaultValue: 11
            },
            {
                name: 'mfdMapRangeIndex',
                defaultValue: 11
            },
        ]));
    }
}
MapRangeSettings.DEFAULT_RANGES = [
    ...[
        250,
        400,
        500,
        750,
        1000,
        1500,
        2500
    ].map(value => UnitType.FOOT.createNumber(value)),
    ...[
        0.5,
        0.75,
        1,
        1.5,
        2.5,
        4,
        5,
        7.5,
        10,
        15,
        25,
        40,
        50,
        75,
        100,
        150,
        250,
        400,
        500,
        750,
        1000
    ].map(value => UnitType.NMILE.createNumber(value))
];

/**
 * The different types of map projection changes.
 */
var MapProjectionChangeType;
(function (MapProjectionChangeType) {
    MapProjectionChangeType[MapProjectionChangeType["Target"] = 1] = "Target";
    MapProjectionChangeType[MapProjectionChangeType["Center"] = 2] = "Center";
    MapProjectionChangeType[MapProjectionChangeType["TargetProjected"] = 4] = "TargetProjected";
    MapProjectionChangeType[MapProjectionChangeType["Range"] = 8] = "Range";
    MapProjectionChangeType[MapProjectionChangeType["Rotation"] = 16] = "Rotation";
    MapProjectionChangeType[MapProjectionChangeType["ProjectedSize"] = 32] = "ProjectedSize";
    MapProjectionChangeType[MapProjectionChangeType["ProjectedResolution"] = 64] = "ProjectedResolution";
})(MapProjectionChangeType || (MapProjectionChangeType = {}));
/**
 * A geographic projection model for a map. MapProjection uses a mercator projection.
 */
class MapProjection {
    /**
     * Creates a new map projection.
     * @param projectedWidth The initial width of the projection window, in pixels.
     * @param projectedHeight The initial height of the projection window, in pixels.
     */
    constructor(projectedWidth, projectedHeight) {
        // settable parameters
        this.target = new GeoPoint(0, 0);
        this.targetProjectedOffset = new Float64Array(2);
        this.targetProjected = new Float64Array(2);
        this.range = 1;
        this.projectedSize = new Float64Array(2);
        // computed parameters
        this.center = new GeoPoint(0, 0);
        this.centerProjected = new Float64Array(2);
        this.oldParameters = {
            target: new GeoPoint(0, 0),
            center: new GeoPoint(0, 0),
            targetProjected: new Float64Array(2),
            range: 1,
            rotation: 0,
            projectedSize: new Float64Array(2),
            projectedResolution: 0
        };
        this.changeListeners = [];
        Vec2Math.set(projectedWidth, projectedHeight, this.projectedSize);
        this.geoProjection = new MercatorProjection();
        Vec2Math.set(projectedWidth / 2, projectedHeight / 2, this.centerProjected);
        this.targetProjected.set(this.centerProjected);
        this.geoProjection.setReflectY(true).setTranslation(this.centerProjected);
        this.recompute();
    }
    /**
     * Gets this map projection's GeoProjection instance.
     * @returns this map projection's GeoProjection instance.
     */
    getGeoProjection() {
        return this.geoProjection;
    }
    /**
     * Gets the target geographic point of this projection. The target is guaranteed to be projected to a specific
     * point in the projected window defined by the center of the window plus the target projected offset.
     * @returns the target geographic point of this projection.
     */
    getTarget() {
        return this.target.readonly;
    }
    /**
     * Gets the projected offset from the center of the projected window of the target of this projection.
     * @returns the projected offset from the center of the projected window of the target of this projection.
     */
    getTargetProjectedOffset() {
        return this.targetProjectedOffset;
    }
    /**
     * Gets the projected location of the target of this projection.
     * @returns the projected location of the target of this projection.
     */
    getTargetProjected() {
        return this.targetProjected;
    }
    /**
     * Gets the range of this projection in great arc radians. The range is measured from the center of the top edge of
     * the projection to the center of the bottom edge.
     * @returns the range of this projection.
     */
    getRange() {
        return this.range;
    }
    /**
     * Gets the post-projected (planar) rotation angle of this projection in radians.
     * @returns the post-projected rotation angle of this projection.
     */
    getRotation() {
        return this.geoProjection.getPostRotation();
    }
    /**
     * Gets the size of the projected window, in pixels.
     * @returns the size of the projected window.
     */
    getProjectedSize() {
        return this.projectedSize;
    }
    /**
     * Gets the geographic point located at the center of this projection's projected window.
     * @returns the geographic point located at the center of this projection's projected window.
     */
    getCenter() {
        return this.center.readonly;
    }
    /**
     * Gets the center of this projection's projected window.
     * @returns the center of this projection's projected window.
     */
    getCenterProjected() {
        return this.centerProjected;
    }
    /**
     * Gets the resolution of the projected map, in great-arc radians per pixel.
     * @returns the resolution fo the projected map.
     */
    getProjectedResolution() {
        return this.range / this.projectedSize[1];
    }
    /**
     * Calculates the true range of this projection, in great-arc radians, given a hypothetical projected center point.
     * @param centerProjected - the projected location of the hypothetical center point to use for the calculation.
     * @returns the true range of this projection given the hypothetical projected center point.
     */
    calculateRangeAtCenter(centerProjected) {
        const projectedHeight = this.projectedSize[1];
        const topProjected = MapProjection.tempVec2_3;
        topProjected[0] = centerProjected[0];
        topProjected[1] = centerProjected[1] - projectedHeight / 2;
        const bottomProjected = MapProjection.tempVec2_4;
        bottomProjected[0] = centerProjected[0];
        bottomProjected[1] = centerProjected[1] + projectedHeight / 2;
        const top = this.geoProjection.invert(topProjected, MapProjection.tempGeoPoint_1);
        const bottom = this.geoProjection.invert(bottomProjected, MapProjection.tempGeoPoint_2);
        return top.distance(bottom);
    }
    /**
     * Recomputes this projection's computed parameters.
     */
    recompute() {
        const currentTargetProjected = this.geoProjection.project(this.target, MapProjection.tempVec2_1);
        if (isNaN(currentTargetProjected[0] + currentTargetProjected[1])) {
            return;
        }
        const currentCenterProjected = MapProjection.tempVec2_2;
        currentCenterProjected.set(currentTargetProjected);
        currentCenterProjected[0] -= this.targetProjectedOffset[0];
        currentCenterProjected[1] -= this.targetProjectedOffset[1];
        let currentRange = this.calculateRangeAtCenter(currentCenterProjected);
        let ratio = currentRange / this.range;
        if (isNaN(ratio) || ratio === 0) {
            return;
        }
        // iteratively find the appropriate scale factor (empiric testing shows this typically takes less than 4 iterations
        // to converge)
        let iterCount = 0;
        let ratioError = Math.abs(ratio - 1);
        let deltaRatioError = MapProjection.SCALE_FACTOR_TOLERANCE + 1;
        while (iterCount++ < MapProjection.SCALE_FACTOR_MAX_ITER
            && ratioError > MapProjection.SCALE_FACTOR_TOLERANCE
            && deltaRatioError > MapProjection.SCALE_FACTOR_TOLERANCE) {
            this.geoProjection.setScaleFactor(ratio * this.geoProjection.getScaleFactor());
            this.geoProjection.project(this.target, currentTargetProjected);
            currentCenterProjected.set(currentTargetProjected);
            currentCenterProjected[0] -= this.targetProjectedOffset[0];
            currentCenterProjected[1] -= this.targetProjectedOffset[1];
            currentRange = this.calculateRangeAtCenter(currentCenterProjected);
            ratio = currentRange / this.range;
            const newRatioError = Math.abs(ratio - 1);
            deltaRatioError = Math.abs(newRatioError - ratioError);
            ratioError = newRatioError;
        }
        // calculate the center point of the projection
        this.invert(currentCenterProjected, this.center);
        this.geoProjection.setCenter(this.center);
        // set the projection's pre-rotation to avoid anti-meridian wrapping issues
        const preRotation = Vec2Math.set(-this.center.lon * Avionics.Utils.DEG2RAD, 0, MapProjection.tempVec2_1);
        this.geoProjection.setPreRotation(preRotation);
    }
    /**
     * Sets this projection's parameters. Parameters not explicitly defined in the parameters argument will be left
     * unchanged.
     * @param parameters The new parameters.
     */
    set(parameters) {
        // save old values
        this.storeParameters(this.oldParameters);
        parameters.projectedSize && this.setProjectedSize(parameters.projectedSize);
        parameters.target && this.target.set(parameters.target);
        parameters.targetProjectedOffset && this.setTargetProjectedOffset(parameters.targetProjectedOffset);
        parameters.range !== undefined && (this.range = parameters.range);
        parameters.rotation !== undefined && this.geoProjection.setPostRotation(parameters.rotation);
        this.recompute();
        const changeFlags = this.computeChangeFlags(this.oldParameters);
        this.notifyChangeListeners(changeFlags);
    }
    /**
     * Sets the size of the projected window.
     * @param size The new size, in pixels.
     */
    setProjectedSize(size) {
        this.projectedSize.set(size);
        Vec2Math.set(size[0] / 2, size[1] / 2, this.centerProjected);
        this.geoProjection.setTranslation(this.centerProjected);
        Vec2Math.add(this.centerProjected, this.targetProjectedOffset, this.targetProjected);
    }
    /**
     * Sets the projected offset from the center of the projected window of the target of this projection.
     * @param offset The new offset, in pixels.
     */
    setTargetProjectedOffset(offset) {
        this.targetProjectedOffset.set(offset);
        Vec2Math.add(this.centerProjected, this.targetProjectedOffset, this.targetProjected);
    }
    /**
     * Stores this projection's current parameters into a record.
     * @param record The record in which to store the parameters.
     */
    storeParameters(record) {
        record.target.set(this.target);
        record.center.set(this.center);
        record.targetProjected.set(this.targetProjected);
        record.range = this.range;
        record.rotation = this.getRotation();
        record.projectedSize.set(this.projectedSize);
        record.projectedResolution = this.getProjectedResolution();
    }
    /**
     * Computes change flags given a set of old parameters.
     * @param oldParameters The old parameters.
     * @returns change flags based on the specified old parameters.
     */
    computeChangeFlags(oldParameters) {
        return BitFlags.union(oldParameters.target.equals(this.target) ? 0 : MapProjectionChangeType.Target, oldParameters.center.equals(this.center) ? 0 : MapProjectionChangeType.Center, Vec2Math.equals(oldParameters.targetProjected, this.targetProjected) ? 0 : MapProjectionChangeType.TargetProjected, oldParameters.range === this.range ? 0 : MapProjectionChangeType.Range, oldParameters.rotation === this.getRotation() ? 0 : MapProjectionChangeType.Rotation, Vec2Math.equals(oldParameters.projectedSize, this.projectedSize) ? 0 : MapProjectionChangeType.ProjectedSize, oldParameters.projectedResolution === this.getProjectedResolution() ? 0 : MapProjectionChangeType.ProjectedResolution);
    }
    /**
     * Projects a set of lat/lon coordinates.
     * @param point - the point to project.
     * @param out - the vector to which to write the result.
     * @returns the projected point, as a vector.
     */
    project(point, out) {
        return this.geoProjection.project(point, out);
    }
    /**
     * Inverts a set of projected coordinates. This method will determine the geographic point whose projected location
     * is the equal to that described by a 2D position vector.
     * @param vec - the 2D position vector describing the location of the projected coordinates.
     * @param out - the point to which to write the result.
     * @returns the inverted point.
     */
    invert(vec, out) {
        return this.geoProjection.invert(vec, out);
    }
    /**
     * Checks whether a point falls within certain projected bounds. The point can be specified as either a GeoPoint
     * object or a 2D vector. If a GeoPoint object is supplied, it will be projected before the bounds check takes
     * place.
     * @param point - the point to check.
     * @param bounds - the bounds to check against, expressed as a vector ([left, top, right, bottom]). Defaults to the
     * bounds of the projected window.
     * @returns whether the point falls within the projected bounds.
     */
    isInProjectedBounds(point, bounds) {
        let left;
        let top;
        let right;
        let bottom;
        if (bounds) {
            left = bounds[0];
            top = bounds[1];
            right = bounds[2];
            bottom = bounds[3];
        }
        else {
            left = 0;
            top = 0;
            right = this.projectedSize[0];
            bottom = this.projectedSize[1];
        }
        if (!(point instanceof Float64Array)) {
            point = this.project(point, MapProjection.tempVec2_2);
        }
        const x = point[0];
        const y = point[1];
        return x >= left && x <= right && y >= top && y <= bottom;
    }
    /**
     * Gets the geographic great-circle distance between two points in great-arc radians. The points can be specified as
     * either GeoPoint objects or 2D vectors. If 2D vectors are supplied, they are interpreted as projected points and
     * inverse projection will be used to convert them to geographic points.
     * @param point1 - the first point.
     * @param point2 - the second point.
     * @returns the geographic great-circle distance between the points.
     */
    geoDistance(point1, point2) {
        if (point1 instanceof Float64Array) {
            point1 = this.invert(point1, MapProjection.tempGeoPoint_1);
        }
        if (point2 instanceof Float64Array) {
            point2 = this.invert(point2, MapProjection.tempGeoPoint_2);
        }
        return point1.distance(point2);
    }
    /**
     * Gets the projected Euclidean distance between two points in pixels. The points can be specified as either GeoPoint
     * objects or 2D vectors. If GeoPoint objects are supplied, they will be projected to convert them to projected
     * points.
     * @param point1 - the first point.
     * @param point2 - the second point.
     * @returns the projected Euclidean distance between two points.
     */
    projectedDistance(point1, point2) {
        if (!(point1 instanceof Float64Array)) {
            point1 = this.project(point1, MapProjection.tempVec2_1);
        }
        if (!(point2 instanceof Float64Array)) {
            point2 = this.project(point2, MapProjection.tempVec2_2);
        }
        return Vec2Math.distance(point1, point2);
    }
    /**
     * Notifies all registered change listeners that this projection has been changed.
     * @param changeFlags The types of changes that were made.
     */
    notifyChangeListeners(changeFlags) {
        this.changeListeners.forEach(listener => listener(this, changeFlags));
    }
    /**
     * Registers a change listener with this projection. The listener will be called every time this projection changes.
     * A listener can be registered multiple times; it will be called once for every time it is registered.
     * @param listener - the change listener to register.
     */
    addChangeListener(listener) {
        this.changeListeners.push(listener);
    }
    /**
     * Removes a change listener from this projection. If the specified listener was registered multiple times, this
     * method will only remove one instance of the listener.
     * @param listener - the listener to remove.
     * @returns whether the listener was successfully removed.
     */
    removeChangeListener(listener) {
        const index = this.changeListeners.lastIndexOf(listener);
        if (index >= 0) {
            this.changeListeners.splice(index, 1);
            return true;
        }
        else {
            return false;
        }
    }
}
MapProjection.SCALE_FACTOR_MAX_ITER = 20;
MapProjection.SCALE_FACTOR_TOLERANCE = 1e-6;
MapProjection.tempVec2_1 = new Float64Array(2);
MapProjection.tempVec2_2 = new Float64Array(2);
MapProjection.tempVec2_3 = new Float64Array(2);
MapProjection.tempVec2_4 = new Float64Array(2);
MapProjection.tempGeoPoint_1 = new GeoPoint(0, 0);
MapProjection.tempGeoPoint_2 = new GeoPoint(0, 0);

/**
 * A component which displays a map. A map projects geographic coordinates onto a planar pixel grid. Each map component
 * maintains a MapProjection instance which handles the details of the projection. MapLayer objects added to the map
 * as children determine what is drawn on the map.
 */
class MapComponent extends DisplayComponent {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.layers = [];
        this.lastUpdateTime = 0;
        this._isAwake = true;
        this.mapProjection = new MapProjection(this.props.projectedWidth, this.props.projectedHeight);
    }
    /**
     * Gets the size of this map's projected window, in pixels.
     * @returns the size of this map's projected window.
     */
    getProjectedSize() {
        return this.mapProjection.getProjectedSize();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setProjectedSize(arg1, arg2) {
        const size = arg1 instanceof Float64Array ? arg1 : Vec2Math.set(arg1, arg2, new Float64Array(2));
        this.mapProjection.set({ projectedSize: size });
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * Whether this map is awake.
     */
    get isAwake() {
        return this._isAwake;
    }
    /**
     * Puts this map to sleep. While asleep, this map will not be updated.
     */
    sleep() {
        this.setAwakeState(false);
    }
    /**
     * Wakes this map, allowing it to be updated.
     */
    wake() {
        this.setAwakeState(true);
    }
    /**
     * Sets this map's awake state. If the new awake state is the same as the current state, nothing will happen.
     * Otherwise, this map's layers will be notified that the map has either been woken or put to sleep.
     * @param isAwake The new awake state.
     */
    setAwakeState(isAwake) {
        if (this._isAwake === isAwake) {
            return;
        }
        this._isAwake = isAwake;
        this._isAwake ? this.onWake() : this.onSleep();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.mapProjection.addChangeListener(this.onMapProjectionChanged.bind(this));
        this.props.bus.getSubscriber().on('realTime')
            .whenChanged().atFrequency(this.props.updateFreq).handle(this.updateCycleCallback.bind(this));
    }
    /**
     * This method is called when the map is awakened.
     */
    onWake() {
        this.wakeLayers();
    }
    /**
     * Calls the onWake() method of this map's layers.
     */
    wakeLayers() {
        const len = this.layers.length;
        for (let i = 0; i < len; i++) {
            this.layers[i].onWake();
        }
    }
    /**
     * This method is called when the map is put to sleep.
     */
    onSleep() {
        this.sleepLayers();
    }
    /**
     * Calls the onSleep() method of this map's layers.
     */
    sleepLayers() {
        const len = this.layers.length;
        for (let i = 0; i < len; i++) {
            this.layers[i].onSleep();
        }
    }
    /**
     * This method is called when the map projection changes.
     * @param mapProjection This layer's map projection.
     * @param changeFlags The types of changes made to the projection.
     */
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.onProjectedSizeChanged();
        }
        const len = this.layers.length;
        for (let i = 0; i < len; i++) {
            this.layers[i].onMapProjectionChanged(mapProjection, changeFlags);
        }
    }
    /**
     * Attaches a layer to this map component. If the layer is already attached, then this method has no effect.
     * @param layer The layer to attach.
     */
    attachLayer(layer) {
        if (this.layers.indexOf(layer) >= 0) {
            return;
        }
        this.layers.push(layer);
        layer.onAttached();
    }
    /**
     * Detaches a layer from this map component.
     * @param layer The layer to detach.
     * @returns whether the layer was succesfully detached.
     */
    detachLayer(layer) {
        const index = this.layers.indexOf(layer);
        if (index >= 0) {
            layer.onDetached();
            this.layers.splice(index, 1);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * A callback which is called once every update cycle.
     * @param time The current time as a UNIX timestamp.
     */
    updateCycleCallback(time) {
        if (!this._isAwake) {
            return;
        }
        this.onUpdated(time, time - this.lastUpdateTime);
        this.lastUpdateTime = time;
    }
    /**
     * This method is called once every update cycle.
     * @param time The current time as a UNIX timestamp.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    onUpdated(time, elapsed) {
        this.updateLayers(time, elapsed);
    }
    /**
     * Updates this map's attached layers.
     * @param time The current time as a UNIX timestamp.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    updateLayers(time, elapsed) {
        const len = this.layers.length;
        for (let i = 0; i < len; i++) {
            this.layers[i].onUpdated(time, elapsed);
        }
    }
}

/**
 * A base component for map layers.
 */
class MapLayer extends DisplayComponent {
    constructor() {
        super(...arguments);
        this._isVisible = true;
    }
    /**
     * Checks whether this layer is visible.
     * @returns whether this layer is visible.
     */
    isVisible() {
        return this._isVisible;
    }
    /**
     * Sets this layer's visibility.
     * @param val Whether this layer should be visible.
     */
    setVisible(val) {
        if (this._isVisible === val) {
            return;
        }
        this._isVisible = val;
        this.onVisibilityChanged(val);
    }
    /**
     * This method is called when this layer's visibility changes.
     * @param isVisible Whether the layer is now visible.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        // noop
    }
    /**
     * This method is called when this layer is attached to its parent map component.
     */
    onAttached() {
        // noop
    }
    /**
     * This method is called when this layer's parent map is woken.
     */
    onWake() {
        // noop
    }
    /**
     * This method is called when this layer's parent map is put to sleep.
     */
    onSleep() {
        // noop
    }
    /**
     * This method is called when the map projection changes.
     * @param mapProjection - this layer's map projection.
     * @param changeFlags The types of changes made to the projection.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onMapProjectionChanged(mapProjection, changeFlags) {
        // noop
    }
    /**
     * This method is called once every map update cycle.
     * @param time The current time as a UNIX timestamp.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        // noop
    }
    /**
     * This method is called when this layer is detached from its parent map component.
     */
    onDetached() {
        // noop
    }
}

/**
 * A model for maps. Specific functionality is added by adding one or more modules to the model. Each module added to
 * the model is assigned a name which is used to retrieve it from the model.
 */
class MapModel {
    constructor() {
        this.modules = new Map();
    }
    /**
     * Gets a module from this model.
     * @param name The name of the module.
     * @returns A module.
     */
    getModule(name) {
        return this.modules.get(name);
    }
    /**
     * Adds a module to this model.
     * @param name The name of the module to add.
     * @param module The module to add.
     */
    addModule(name, module) {
        if (this.modules.has(name)) {
            return;
        }
        this.modules.set(name, module);
    }
}

/**
 * An abstract implementation of a map text label.
 */
class AbstractMapTextLabel {
    /**
     * Constructor.
     * @param text The text of this label.
     * @param priority The render priority of this label.
     * @param options Options with which to initialize this label.
     */
    constructor(text, priority, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        this.text = text;
        this.priority = priority;
        /**
         * The anchor point of this label, expressed relative to this label's width/height. [0, 0] is the top-left corner,
         * and [1, 1] is the bottom-right corner.
         */
        this.anchor = new Float64Array(2);
        /** The padding of this label's background, in pixels. Expressed as [left, top, right, bottom]. */
        this.bgPadding = new Float64Array(4);
        (options === null || options === void 0 ? void 0 : options.anchor) && this.anchor.set(options.anchor);
        this.font = (_a = options === null || options === void 0 ? void 0 : options.font) !== null && _a !== void 0 ? _a : 'Roboto';
        this.fontSize = (_b = options === null || options === void 0 ? void 0 : options.fontSize) !== null && _b !== void 0 ? _b : 10;
        this.fontColor = (_c = options === null || options === void 0 ? void 0 : options.fontColor) !== null && _c !== void 0 ? _c : 'white';
        this.fontOutlineWidth = (_d = options === null || options === void 0 ? void 0 : options.fontOutlineWidth) !== null && _d !== void 0 ? _d : 0;
        this.fontOutlineColor = (_e = options === null || options === void 0 ? void 0 : options.fontOutlineColor) !== null && _e !== void 0 ? _e : 'black';
        this.showBg = (_f = options === null || options === void 0 ? void 0 : options.showBg) !== null && _f !== void 0 ? _f : false;
        this.bgColor = (_g = options === null || options === void 0 ? void 0 : options.bgColor) !== null && _g !== void 0 ? _g : 'black';
        (options === null || options === void 0 ? void 0 : options.bgPadding) && this.bgPadding.set(options.bgPadding);
        this.bgBorderRadius = (_h = options === null || options === void 0 ? void 0 : options.bgBorderRadius) !== null && _h !== void 0 ? _h : 0;
        this.bgOutlineWidth = (_j = options === null || options === void 0 ? void 0 : options.bgOutlineWidth) !== null && _j !== void 0 ? _j : 0;
        this.bgOutlineColor = (_k = options === null || options === void 0 ? void 0 : options.bgOutlineColor) !== null && _k !== void 0 ? _k : 'white';
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    draw(context, mapProjection) {
        this.setTextStyle(context);
        const width = context.measureText(this.text).width;
        const height = this.fontSize;
        const pos = this.getPosition(mapProjection, AbstractMapTextLabel.tempVec2);
        const centerX = pos[0] - (this.anchor[0] - 0.5) * width;
        const centerY = pos[1] - (this.anchor[1] - 0.5) * height;
        if (this.showBg) {
            this.drawBackground(context, centerX, centerY, width, height);
        }
        this.drawText(context, centerX, centerY);
    }
    /**
     * Loads this label's text style to a canvas rendering context.
     * @param context The canvas rendering context to use.
     */
    setTextStyle(context) {
        context.font = `${this.fontSize}px ${this.font}`;
        context.textBaseline = 'middle';
        context.textAlign = 'center';
    }
    /**
     * Draws this label's text to a canvas.
     * @param context The canvas rendering context.
     * @param centerX The x-coordinate of the center of the label, in pixels.
     * @param centerY the y-coordinate of the center of the label, in pixels.
     */
    drawText(context, centerX, centerY) {
        if (this.fontOutlineWidth > 0) {
            context.lineWidth = this.fontOutlineWidth * 2;
            context.strokeStyle = this.fontOutlineColor;
            context.strokeText(this.text, centerX, centerY);
        }
        context.fillStyle = this.fontColor;
        context.fillText(this.text, centerX, centerY);
    }
    /**
     * Draws this label's background to a canvas.
     * @param context The canvas rendering context.
     * @param centerX The x-coordinate of the center of the label, in pixels.
     * @param centerY the y-coordinate of the center of the label, in pixels.
     * @param width The width of the background, in pixels.
     * @param height The height of the background, in pixels.
     */
    drawBackground(context, centerX, centerY, width, height) {
        const backgroundLeft = centerX - width / 2 - (this.bgPadding[3] + this.bgOutlineWidth);
        const backgroundTop = centerY - height / 2 - (this.bgPadding[0] + this.bgOutlineWidth);
        const backgroundWidth = width + (this.bgPadding[1] + this.bgPadding[3] + 2 * this.bgOutlineWidth);
        const backgroundHeight = height + (this.bgPadding[0] + this.bgPadding[2] + 2 * this.bgOutlineWidth);
        let isRounded = false;
        if (this.bgBorderRadius > 0) {
            isRounded = true;
            this.loadBackgroundPath(context, backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight, this.bgBorderRadius);
        }
        if (this.bgOutlineWidth > 0) {
            context.lineWidth = this.bgOutlineWidth * 2;
            context.strokeStyle = this.bgOutlineColor;
            if (isRounded) {
                context.stroke();
            }
            else {
                context.strokeRect(backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight);
            }
        }
        context.fillStyle = this.bgColor;
        if (isRounded) {
            context.fill();
        }
        else {
            context.fillRect(backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight);
        }
    }
    /**
     * Loads the path of this label's background to a canvas rendering context.
     * @param context The canvas rendering context to use.
     * @param left The x-coordinate of the left edge of the background, in pixels.
     * @param top The y-coordinate of the top edge of the background, in pixels.
     * @param width The width of the background, in pixels.
     * @param height The height of the background, in pixels.
     * @param radius The border radius of the background, in pixels.
     */
    loadBackgroundPath(context, left, top, width, height, radius) {
        const right = left + width;
        const bottom = top + height;
        context.beginPath();
        context.moveTo(left + radius, top);
        context.lineTo(right - radius, top);
        context.arcTo(right, top, right, top + radius, radius);
        context.lineTo(right, bottom - radius);
        context.arcTo(right, bottom, right - radius, bottom, radius);
        context.lineTo(left + radius, bottom);
        context.arcTo(left, bottom, left, bottom - radius, radius);
        context.lineTo(left, top + radius);
        context.arcTo(left, top, left + radius, top, radius);
    }
}
AbstractMapTextLabel.tempVec2 = new Float64Array(2);
/**
 * A text label associated with a specific geographic location.
 */
class MapLocationTextLabel extends AbstractMapTextLabel {
    /**
     * Constructor.
     * @param text The text of this label.
     * @param priority The render priority of this label.
     * @param location The geographic location of this label.
     * @param options Options with which to initialize this label.
     */
    constructor(text, priority, location, options) {
        super(text, priority, options);
        this.offset = new Float64Array(2);
        this._location = location.copy();
        this.location = this._location.readonly;
        (options === null || options === void 0 ? void 0 : options.offset) && this.offset.set(options.offset);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getPosition(mapProjection, out) {
        mapProjection.project(this._location, out);
        Vec2Math.add(out, this.offset, out);
        return out;
    }
}

/**
 * A cullable text label associated with a specific geographic location.
 */
class MapCullableLocationTextLabel extends MapLocationTextLabel {
    /**
     * Constructor.
     * @param text The text of this label.
     * @param priority The priority of this label.
     * @param location The geographic location of this label.
     * @param alwaysShow Whether this label is immune to culling.
     * @param options Options with which to initialize this label.
     */
    constructor(text, priority, location, alwaysShow, options) {
        super(text, priority, location, options);
        this.alwaysShow = alwaysShow;
        this.bounds = new Float64Array(4);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    updateBounds(mapProjection) {
        const width = 0.6 * this.fontSize * this.text.length;
        const height = this.fontSize;
        const pos = this.getPosition(mapProjection, MapCullableLocationTextLabel.tempVec2);
        let left = pos[0] - this.anchor[0] * width;
        let right = left + width;
        let top = pos[1] - this.anchor[1] * height;
        let bottom = top + height;
        if (this.showBg) {
            left -= (this.bgPadding[3] + this.bgOutlineWidth);
            right += (this.bgPadding[1] + this.bgOutlineWidth);
            top -= (this.bgPadding[0] + this.bgOutlineWidth);
            bottom += (this.bgPadding[2] + this.bgOutlineWidth);
        }
        this.bounds[0] = left;
        this.bounds[1] = top;
        this.bounds[2] = right;
        this.bounds[3] = bottom;
    }
}
/**
 * Manages a set of MapCullableTextLabels. Colliding labels will be culled based on their render priority. Labels with
 * lower priorities will be culled before labels with higher priorities.
 */
class MapCullableTextLabelManager {
    constructor() {
        this.registered = new Set();
        this._visibleLabels = [];
        this.needUpdate = false;
        this.lastRange = 0;
        this.lastRotation = 0;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** An array of labels registered with this manager that are visible. */
    get visibleLabels() {
        return this._visibleLabels;
    }
    /**
     * Registers a label with this manager. Newly registered labels will be processed with the next manager update.
     * @param label The label to register.
     */
    register(label) {
        if (this.registered.has(label)) {
            return;
        }
        this.registered.add(label);
        this.needUpdate = true;
    }
    /**
     * Deregisters a label with this manager. Newly deregistered labels will be processed with the next manager update.
     * @param label The label to deregister.
     */
    deregister(label) {
        this.needUpdate = this.registered.delete(label) || this.needUpdate;
    }
    /**
     * Updates this manager.
     * @param mapProjection The projection of the map to which this manager's labels are to be drawn.
     */
    update(mapProjection) {
        if (!this.needUpdate) {
            if (mapProjection.getRange() === this.lastRange) {
                const rotationDelta = Math.abs(mapProjection.getRotation() - this.lastRotation);
                if (Math.min(rotationDelta, 2 * Math.PI - rotationDelta) < MapCullableTextLabelManager.ROTATION_UPDATE_THRESHOLD) {
                    return;
                }
            }
        }
        this._visibleLabels = [];
        const labelArray = Array.from(this.registered.values());
        const len = labelArray.length;
        for (let i = 0; i < len; i++) {
            labelArray[i].updateBounds(mapProjection);
        }
        labelArray.sort((a, b) => {
            if (a.alwaysShow && !b.alwaysShow) {
                return -1;
            }
            else if (b.alwaysShow && !a.alwaysShow) {
                return 1;
            }
            else {
                return b.priority - a.priority;
            }
        });
        const collisionArray = [];
        for (let i = 0; i < len; i++) {
            const label = labelArray[i];
            let show = true;
            if (!label.alwaysShow) {
                const len2 = collisionArray.length;
                for (let j = 0; j < len2; j++) {
                    const other = collisionArray[j];
                    if (MapCullableTextLabelManager.doesCollide(label.bounds, other)) {
                        show = false;
                        break;
                    }
                }
            }
            if (show) {
                collisionArray.push(label.bounds);
                this._visibleLabels.push(label);
            }
        }
        this.lastRange = mapProjection.getRange();
        this.lastRotation = mapProjection.getRotation();
        this.needUpdate = false;
    }
    /**
     * Checks if two bounding boxes collide.
     * @param a The first bounding box, as a 4-tuple [left, top, right, bottom].
     * @param b The second bounding box, as a 4-tuple [left, top, right, bottom].
     * @returns whether the bounding boxes collide.
     */
    static doesCollide(a, b) {
        return a[0] < b[2]
            && a[2] > b[0]
            && a[1] < b[3]
            && a[3] > b[1];
    }
}
MapCullableTextLabelManager.ROTATION_UPDATE_THRESHOLD = Math.PI / 6;

/**
 * An airspace renderer which does not draw any graphics.
 */
class NullAirspaceRenderer {
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    render(airspace, projection, context) {
        // noop
    }
}
/**
 * An airspace renderer which renders airspace borders as a single line.
 */
class SingleLineAirspaceRenderer {
    /**
     * Constructor.
     * @param lineWidth The stroke width of the rendered airspace line.
     * @param strokeStyle The stroke style of the rendered airspace line.
     * @param dash The dash of the rendered airspace line.
     */
    constructor(lineWidth, strokeStyle, dash) {
        this.lineWidth = lineWidth;
        this.strokeStyle = strokeStyle;
        this.dash = dash;
    }
    /** @inheritdoc */
    render(airspace, projection, context) {
        const segments = airspace.segments;
        if (segments.length < 2) {
            return;
        }
        context.beginPath();
        const firstProjected = projection.project(segments[0], SingleLineAirspaceRenderer.tempVec2_1);
        context.moveTo(firstProjected[0], firstProjected[1]);
        const max = segments.length - 1;
        for (let i = 1; i < max; i++) {
            const projected = projection.project(segments[i], SingleLineAirspaceRenderer.tempVec2_1);
            context.lineTo(projected[0], projected[1]);
        }
        if (segments[0].equals(segments[segments.length - 1])) {
            context.closePath();
        }
        else {
            const projected = projection.project(segments[segments.length - 1], SingleLineAirspaceRenderer.tempVec2_1);
            context.lineTo(projected[0], projected[1]);
        }
        context.lineWidth = this.lineWidth;
        context.strokeStyle = this.strokeStyle;
        context.setLineDash(this.dash);
        context.stroke();
    }
}
SingleLineAirspaceRenderer.tempVec2_1 = new Float64Array(2);
/**
 * An airspace renderer which supports rendering airspace borders as multiple, optionally offset lines.
 */
class MultiLineAirspaceRenderer {
    /** @inheritdoc */
    render(airspace, projection, context) {
        var _a;
        const segments = airspace.segments;
        if (segments.length < 2) {
            return;
        }
        // project all points and calculate winding order
        let signedArea = 0;
        const projectedArray = MultiLineAirspaceRenderer.tempProjectedArray;
        const len = segments.length;
        for (let i = 0; i < len; i++) {
            const projected = (_a = projectedArray[i]) !== null && _a !== void 0 ? _a : (projectedArray[i] = new Float64Array(2));
            projection.project(segments[i], projected);
            if (i > 0) {
                const prev = projectedArray[i - 1];
                signedArea += prev[0] * projected[1] - projected[0] * prev[1];
            }
        }
        const isClosed = segments[0].equals(segments[len - 1]);
        // if the path is not closed, we need to close the path to calculate a pseudo-winding order
        if (!isClosed) {
            const projected = projectedArray[0];
            const prev = projectedArray[len - 1];
            signedArea += prev[0] * projected[1] - projected[0] * prev[1];
        }
        const windingOrder = signedArea >= 0 ? 1 : -1;
        const vertexNormals = this.calculateVertexNormals(projectedArray, len, isClosed, windingOrder);
        this.renderLines(context, projectedArray, vertexNormals, len, isClosed);
    }
    /**
     * Calculates all vertex normals for the projected airspace polygon. Returns the results as an array with indexes
     * that match the indexes of the supplied vertex array.
     * @param vertexArray The vertices of the projected polygon.
     * @param length The number of the vertices in the projected polygon.
     * @param isClosed Whether the polygon is closed.
     * @param windingOrder the winding order of the polygon.
     * @returns an array of vertex normals.
     */
    calculateVertexNormals(vertexArray, length, isClosed, windingOrder) {
        var _a;
        const array = MultiLineAirspaceRenderer.tempVertexNormalArray;
        const max = isClosed ? length - 1 : length;
        for (let i = 0; i < max; i++) {
            const normal = (_a = array[i]) !== null && _a !== void 0 ? _a : (array[i] = new Float64Array(2));
            const prev = vertexArray[(i + max - 1) % max];
            const curr = vertexArray[i];
            const next = vertexArray[(i + 1) % max];
            this.calculateVertexNormal(windingOrder, prev, curr, next, normal);
        }
        return array;
    }
    /**
     * Calculates a vertex normal. For any given vertex v(i), its vertex normal is defined as the displacement vector d
     * from v(i) such that lines drawn from v(i-1) to v(i) and from v(i) to v(i+1) which are offset by +1 pixel from the
     * reference polygon would terminate at v(i) + d.
     * @param windingOrder The winding order of the polygon to which the vertex belongs.
     * @param prev The position vector of the previous vertex in the polygon.
     * @param curr The position vector of the vertex.
     * @param next The position vector of the next vertex in the polygon.
     * @param out The vector to which to write the result.
     * @returns the vertex normal.
     */
    calculateVertexNormal(windingOrder, prev, curr, next, out) {
        const prevDelta = prev
            ? Vec2Math.sub(Vec2Math.set(curr[0], curr[1], MultiLineAirspaceRenderer.tempVec2_1), prev, MultiLineAirspaceRenderer.tempVec2_1)
            : undefined;
        const nextDelta = next
            ? Vec2Math.sub(Vec2Math.set(next[0], next[1], MultiLineAirspaceRenderer.tempVec2_2), curr, MultiLineAirspaceRenderer.tempVec2_2)
            : undefined;
        if (prevDelta && nextDelta) {
            const segmentWindingOrder = this.getTriangleWindingOrder(prevDelta, nextDelta);
            if (segmentWindingOrder === 0) {
                // prevDelta and nextDelta are parallel
                return Vec2Math.normalize(Vec2Math.normal(prevDelta, out, windingOrder === -1), out);
            }
            else {
                // the normal will be in the direction of the bisecting vector
                // (inverted if the segment winding order is different from the polygon winding order)
                const prevDeltaUnit = Vec2Math.normalize(prevDelta, prevDelta);
                const nextDeltaUnit = Vec2Math.normalize(nextDelta, nextDelta);
                const norm = Vec2Math.multScalar(Vec2Math.normalize(Vec2Math.sub(nextDeltaUnit, prevDeltaUnit, out), out), windingOrder * segmentWindingOrder, out);
                // scale the vertex normal unit vector to adjust for angle between prevDelta and nextDelta
                // (the closer the angle to 0, the farther the point of intersection of offset lines from prev and next lie
                // to the vertex)
                const scaleFactor = Math.abs(1 / (norm[0] * nextDeltaUnit[1] - norm[1] * nextDeltaUnit[0]));
                return Vec2Math.multScalar(norm, scaleFactor, out);
            }
        }
        else if (prevDelta) {
            return Vec2Math.normalize(Vec2Math.normal(prevDelta, out, windingOrder === -1), out);
        }
        else {
            return Vec2Math.normalize(Vec2Math.normal(nextDelta, out, windingOrder === -1), out);
        }
    }
    /**
     * Gets the winding order of a triangle whose sides are described by two displacement vectors (the third side is
     * implied).
     * @param v1 The displacement vector describing the first side of the triangle.
     * @param v2 The displacement vector describing the second side of the triangle.
     * @returns the winding order of the triangle.
     */
    getTriangleWindingOrder(v1, v2) {
        const signedArea = v1[0] * (v2[1] + v1[1]) - (v2[0] + v1[0]) * v1[1];
        return Math.sign(signedArea);
    }
    /**
     * Renders a polygon with a line.
     * @param context The canvas rendering context to which to render.
     * @param vertexArray The vertices of the polygon.
     * @param vertexNormalArray The vertex normals of the polygon.
     * @param length The number of vertices in the polygon.
     * @param isClosed Whether the polygon is closed.
     * @param offset The offset, in pixels, of the rendered line with respect to the polygon. Positive offsets shift the
     * line toward the inside of the polygon.
     * @param lineWidth The stroke width of the line to render.
     * @param strokeStyle The stroke style of the line to render.
     * @param dash The dash of the line to render.
     */
    renderLine(context, vertexArray, vertexNormalArray, length, isClosed, offset, lineWidth, strokeStyle, dash) {
        context.beginPath();
        const max = isClosed ? length - 1 : length;
        for (let i = 0; i < max; i++) {
            const vertex = vertexArray[i];
            const vertexNormal = vertexNormalArray[i];
            const offsetVec = MultiLineAirspaceRenderer.tempVec2_1;
            Vec2Math.multScalar(Vec2Math.set(vertexNormal[0], vertexNormal[1], offsetVec), offset, offsetVec);
            const offsetVertex = Vec2Math.add(vertex, offsetVec, offsetVec);
            i === 0 ? context.moveTo(offsetVertex[0], offsetVertex[1]) : context.lineTo(offsetVertex[0], offsetVertex[1]);
        }
        if (isClosed) {
            context.closePath();
        }
        context.lineWidth = lineWidth;
        context.strokeStyle = strokeStyle;
        context.setLineDash(dash);
        context.stroke();
    }
}
MultiLineAirspaceRenderer.tempProjectedArray = [];
MultiLineAirspaceRenderer.tempVertexNormalArray = [];
MultiLineAirspaceRenderer.tempVec2_1 = new Float64Array(2);
MultiLineAirspaceRenderer.tempVec2_2 = new Float64Array(2);
MultiLineAirspaceRenderer.tempVec2_3 = new Float64Array(2);

/**
 * An abstract implementation of AirspaceRenderManager.
 */
class AbstractAirspaceRenderManager {
    constructor() {
        this.airspaces = [];
        this.taskQueueProcess = null;
    }
    /**
     * Gets all airspaces registered to this render manager.
     * @returns all airspaces registered to this render manager.
     */
    getRegisteredAirspaces() {
        return this.airspaces;
    }
    /**
     * Registers an airspace with this render manager. An airspace may only be registered once.
     * @param airspace The airspace to register.
     * @returns whether the airspace was successfully registered.
     */
    registerAirspace(airspace) {
        if (this.airspaces.findIndex(registered => registered.equals(airspace)) >= 0) {
            return false;
        }
        // Since it's unlikely the manager will be handling more than a few dozen airspaces at any given time, we won't
        // bother with binary search.
        const len = this.airspaces.length;
        let insertionIndex = 0;
        while (insertionIndex < len && this.getRenderOrder(airspace, this.airspaces[insertionIndex]) >= 0) {
            ++insertionIndex;
        }
        // to avoid creating a new array with splice(), we will shift manually.
        for (let i = len - 1; i >= insertionIndex; i--) {
            this.airspaces[i + 1] = this.airspaces[i];
        }
        this.airspaces[insertionIndex] = airspace;
        return true;
    }
    /**
     * Deregisters an airspace with this render manager.
     * @param airspace The airspace to deregister.
     * @returns whether the airspace was successfully deregistered.
     */
    deregisterAirspace(airspace) {
        const index = this.airspaces.findIndex(registered => registered.equals(airspace));
        if (index >= 0) {
            this.airspaces.splice(index, 1);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Replace all airspaces currently registered with this render manager with a new list of airspaces.
     * @param airspaces The new list of airspaces.
     * @returns whether the replace operation changed the set of registered airspaces.
     */
    replaceRegisteredAirspaces(airspaces) {
        const oldAirspaces = this.airspaces;
        this.airspaces = [];
        const len = airspaces.length;
        for (let i = 0; i < len; i++) {
            this.registerAirspace(airspaces[i]);
        }
        return this.airspaces.length !== oldAirspaces.length
            || this.airspaces.some(registered => oldAirspaces.findIndex(airspace => !airspace.equals(registered)) >= 0);
    }
    /**
     * Deregisters all airspaces currently registered with this render manager.
     * @returns whether any airspaces were deregistered.
     */
    clearRegisteredAirspaces() {
        if (this.airspaces.length === 0) {
            return false;
        }
        this.airspaces = [];
        return true;
    }
    /**
     * Generates a throttled task queue process, which when started will render all the airspaces registered with this
     * manager.
     * @param projection The projection to use when rendering.
     * @param context The canvas rendering context to which to render.
     * @param taskQueueHandler The handler to assign to the task queue process.
     * @returns a throttled task queue process.
     */
    prepareRenderProcess(projection, context, taskQueueHandler) {
        const tasks = this.airspaces.map(airspace => {
            const renderer = this.getAirspaceRenderer(airspace);
            return renderer.render.bind(renderer, airspace, projection, context);
        });
        return new ThrottledTaskQueueProcess(new ArrayTaskQueue(tasks), taskQueueHandler);
    }
}

/**
 * A module describing properties of the own airplane icon.
 */
class MapOwnAirplaneIconModule {
    constructor() {
        /** Whether to show the airplane icon. */
        this.show = Subject.create(true);
    }
}

/**
 * A module describing properties of the own airplane icon.
 */
class MapOwnAirplanePropsModule {
    constructor() {
        /** The airplane's position. */
        this.position = GeoPointSubject.createFromGeoPoint(new GeoPoint(0, 0));
        /** The airplane's true heading, in degrees. */
        this.hdgTrue = Subject.create(0);
        /** The airplane's true ground track, in degrees. */
        this.trackTrue = Subject.create(0);
        /** Whether the airplane is on the ground. */
        this.isOnGround = Subject.create(true);
        this.positionHandler = (pos) => {
            this.position.set(pos.lat, pos.long);
        };
        this.headingHandler = (heading) => {
            this.hdgTrue.set(heading);
        };
        this.trackHandler = (track) => {
            this.trackTrue.set(track);
        };
        this.onGroundHandler = (isOnGround) => {
            this.isOnGround.set(isOnGround);
        };
        this.isSyncing = false;
        this.positionConsumer = null;
        this.headingConsumer = null;
        this.trackConsumer = null;
        this.onGroundConsumer = null;
    }
    /**
     * Begins syncing this module with the event bus. While syncing is active, this module's properties will be
     * automatically updated with the latest information provided by the event bus.
     * @param bus The event bus.
     * @param updateFreq The frequencing at which to sync with the event bus.
     */
    beginSync(bus, updateFreq) {
        this.stopSync();
        const gnssSubscriber = bus.getSubscriber();
        this.positionConsumer = gnssSubscriber
            .on('gps-position')
            .atFrequency(updateFreq);
        this.positionConsumer.handle(this.positionHandler);
        this.trackConsumer = gnssSubscriber
            .on('track_deg_true')
            .atFrequency(updateFreq);
        this.trackConsumer.handle(this.trackHandler);
        const adcSubscriber = bus.getSubscriber();
        this.headingConsumer = adcSubscriber
            .on('hdg_deg_true')
            .atFrequency(updateFreq);
        this.headingConsumer.handle(this.headingHandler);
        this.onGroundConsumer = adcSubscriber
            .on('on_ground')
            .atFrequency(updateFreq);
        this.onGroundConsumer.handle(this.onGroundHandler);
        this.isSyncing = true;
    }
    /**
     * Stops syncing this module with the event bus.
     */
    stopSync() {
        var _a, _b, _c, _d;
        if (!this.isSyncing) {
            return;
        }
        (_a = this.positionConsumer) === null || _a === void 0 ? void 0 : _a.off(this.positionHandler);
        (_b = this.headingConsumer) === null || _b === void 0 ? void 0 : _b.off(this.headingHandler);
        (_c = this.trackConsumer) === null || _c === void 0 ? void 0 : _c.off(this.trackHandler);
        (_d = this.onGroundConsumer) === null || _d === void 0 ? void 0 : _d.off(this.onGroundHandler);
        this.isSyncing = false;
    }
}

/**
 * A module describing the nominal range of a map.
 */
class MapRangeModule {
    constructor() {
        this.nominalRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(1));
    }
}

/**
 * A module describing the nominal range of a map.
 */
class MapIndexedRangeModule extends MapRangeModule {
    /** @inheritdoc */
    constructor() {
        super();
        /** The index of the map nominal range. */
        this.nominalRangeIndex = Subject.create(0);
        /** The array of possible map nominal ranges. */
        this.nominalRanges = Subject.create([UnitType.NMILE.createNumber(1)]);
        this.nominalRanges.sub(this.onNominalRangesChanged.bind(this));
    }
    /**
     * A callback which is called when the nominal range array changes.
     * @param array The new array.
     */
    onNominalRangesChanged(array) {
        const currentIndex = this.nominalRangeIndex.get();
        this.setNominalRangeIndex(Utils.Clamp(currentIndex, 0, array.length - 1));
    }
    /**
     * Sets the nominal range by index.
     * @param index The index of the new nominal range.
     * @returns The value of the new nominal range.
     * @throws Error if index of out of bounds.
     */
    setNominalRangeIndex(index) {
        const rangeArray = this.nominalRanges.get();
        if (index < 0 || index >= rangeArray.length) {
            throw new Error('Index out of bounds.');
        }
        const range = rangeArray[index];
        this.nominalRangeIndex.set(index);
        this.nominalRange.set(range);
        return range;
    }
}

/// <reference types="msfstypes/JS/common" />
/**
 * A FSComponent that displays the MSFS Bing Map, weather radar, and 3D terrain.
 */
class BingComponent extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.modeFlags = this.props.mode === EBingMode.HORIZON ? 4 : 0;
        this.isListenerRegistered = false;
        this.imgRef = FSComponent.createRef();
        this.uid = 0;
        this._isBound = false;
        this._isAwake = true;
        this.pos = null;
        this.radius = 0;
        this.resolutionSub = Vec2Subject.createFromVector(new Float64Array([BingComponent.DEFAULT_RESOLUTION, BingComponent.DEFAULT_RESOLUTION]));
        this.resolutionPropHandler = (resolution) => {
            this.resolutionSub.set(resolution);
        };
        this.resolutionHandler = (resolution) => {
            Coherent.call('SET_MAP_RESOLUTION', this.uid, resolution[0], resolution[1]);
        };
        this.earthColorsSub = ArraySubject.create(BingComponent.createEarthColorsArray('#000000', [{ elev: 0, color: '#000000' }, { elev: 60000, color: '#000000' }]));
        this.skyColorSub = Subject.create(BingComponent.hexaToRGBColor('#000000'));
        this.referenceSub = Subject.create(EBingReference.SEA);
        this.wxrModeSub = Subject.create({ mode: EWeatherRadar.OFF, arcRadians: 0.5 }, (cur, prev) => cur.mode === prev.mode && cur.arcRadians === prev.arcRadians, (ref, val) => Object.assign(ref, val));
        this.earthColorsPropHandler = (index, type, item, array) => {
            if (array.length !== 61) {
                return;
            }
            this.earthColorsSub.set(array);
        };
        this.skyColorPropHandler = (color) => {
            this.skyColorSub.set(color);
        };
        this.referencePropHandler = (reference) => {
            this.referenceSub.set(reference);
        };
        this.wxrModePropHandler = (wxrMode) => {
            this.wxrModeSub.set(wxrMode);
        };
        this.earthColorsHandler = (index, type, item, array) => {
            if (type !== SubscribableArrayEventType.Cleared) {
                if (array.length !== 61) {
                    throw new Error(`Incorrect number of colors provided: was ${array.length} but should be 61`);
                }
                Coherent.call('SET_MAP_HEIGHT_COLORS', this.uid, array);
            }
        };
        this.skyColorHandler = (color) => {
            Coherent.call('SET_MAP_CLEAR_COLOR', this.uid, color);
        };
        this.referenceHandler = (reference) => {
            const flags = this.modeFlags | (reference === EBingReference.PLANE ? 1 : 0);
            this.mapListener.trigger('JS_BIND_BINGMAP', this.props.id, flags);
        };
        this.wxrModeHandler = (wxrMode) => {
            Coherent.call('SHOW_MAP_WEATHER', this.uid, wxrMode.mode, wxrMode.arcRadians);
        };
        /**
         * A callback called when the listener is registered.
         */
        this.onListenerRegistered = () => {
            if (this.isListenerRegistered) {
                return;
            }
            this.mapListener.on('MapBinded', this.onListenerBound);
            this.mapListener.on('MapUpdated', this.onMapUpdate);
            this.isListenerRegistered = true;
            this.mapListener.trigger('JS_BIND_BINGMAP', this.props.id, this.modeFlags);
        };
        /**
         * A callback called when the listener is fully bound.
         * @param binder The binder from the listener.
         * @param uid The unique ID of the bound map.
         */
        this.onListenerBound = (binder, uid) => {
            if (binder.friendlyName === this.props.id) {
                console.log('Bing map listener bound.');
                this.binder = binder;
                this.uid = uid;
                if (this._isBound) {
                    return;
                }
                this._isBound = true;
                Coherent.call('SHOW_MAP', uid, true);
                if (this._isAwake) {
                    Coherent.call('SET_MAP_RESOLUTION', uid, BingComponent.DEFAULT_RESOLUTION, BingComponent.DEFAULT_RESOLUTION);
                    this.earthColorsSub.sub(this.earthColorsHandler, true);
                    this.skyColorSub.sub(this.skyColorHandler, true);
                    this.referenceSub.sub(this.referenceHandler, true);
                    this.wxrModeSub.sub(this.wxrModeHandler, true);
                    this.resolutionSub.sub(this.resolutionHandler, true);
                }
                this.props.onBoundCallback(this);
            }
        };
        /**
         * A callback called when the map image is updated.
         * @param uid The unique ID of the bound map.
         * @param imgSrc The img tag src attribute to assign to the bing map image.
         */
        this.onMapUpdate = (uid, imgSrc) => {
            if (this.binder !== undefined && this.uid === uid && this.imgRef.instance !== null) {
                if (this.imgRef.instance.src !== imgSrc) {
                    this.imgRef.instance.src = imgSrc;
                }
            }
        };
        /**
         * A callback called when the instrument is destroyed.
         */
        this.onDestroy = () => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            this._isBound = false;
            (_a = this.props.earthColors) === null || _a === void 0 ? void 0 : _a.unsub(this.earthColorsPropHandler);
            (_b = this.props.skyColor) === null || _b === void 0 ? void 0 : _b.unsub(this.skyColorPropHandler);
            (_c = this.props.reference) === null || _c === void 0 ? void 0 : _c.unsub(this.referencePropHandler);
            (_d = this.props.wxrMode) === null || _d === void 0 ? void 0 : _d.unsub(this.wxrModePropHandler);
            (_e = this.props.resolution) === null || _e === void 0 ? void 0 : _e.unsub(this.resolutionPropHandler);
            (_f = this.mapListener) === null || _f === void 0 ? void 0 : _f.off('MapBinded', this.onListenerBound);
            (_g = this.mapListener) === null || _g === void 0 ? void 0 : _g.off('MapUpdated', this.onMapUpdate);
            (_h = this.mapListener) === null || _h === void 0 ? void 0 : _h.trigger('JS_UNBIND_BINGMAP', this.props.id);
            this.isListenerRegistered = false;
            if (this.imgRef.instance !== null) {
                this.imgRef.instance.src = '';
                (_j = this.imgRef.instance.parentNode) === null || _j === void 0 ? void 0 : _j.removeChild(this.imgRef.instance);
            }
        };
    }
    /**
     * Checks whether this Bing component has been bound.
     * @returns whether this Bing component has been bound.
     */
    isBound() {
        return this._isBound;
    }
    /**
     * Checks whether this Bing component is awake.
     * @returns whether this Bing component is awake.
     */
    isAwake() {
        return this._isAwake;
    }
    /** @inheritdoc */
    onAfterRender() {
        var _a, _b, _c, _d, _e;
        (_a = this.props.resolution) === null || _a === void 0 ? void 0 : _a.sub(this.resolutionPropHandler, true);
        (_b = this.props.earthColors) === null || _b === void 0 ? void 0 : _b.sub(this.earthColorsPropHandler, true);
        (_c = this.props.skyColor) === null || _c === void 0 ? void 0 : _c.sub(this.skyColorPropHandler, true);
        (_d = this.props.reference) === null || _d === void 0 ? void 0 : _d.sub(this.referencePropHandler, true);
        (_e = this.props.wxrMode) === null || _e === void 0 ? void 0 : _e.sub(this.wxrModePropHandler, true);
        setTimeout(() => {
            this.mapListener = RegisterViewListener('JS_LISTENER_MAPS', this.onListenerRegistered);
        }, 3000);
        window.addEventListener('OnDestroy', this.onDestroy);
    }
    /**
     * Wakes this Bing component. Upon awakening, this component will synchronize its state from when it was put to sleep
     * to the Bing instance to which it is bound.
     */
    wake() {
        this._isAwake = true;
        if (!this._isBound) {
            return;
        }
        Coherent.call('SET_MAP_PARAMS', this.uid, this.pos, this.radius, 1);
        this.earthColorsSub.sub(this.earthColorsHandler, true);
        this.skyColorSub.sub(this.skyColorHandler, true);
        this.referenceSub.sub(this.referenceHandler, true);
        this.wxrModeSub.sub(this.wxrModeHandler, true);
        this.resolutionSub.sub(this.resolutionHandler, true);
    }
    /**
     * Puts this Bing component to sleep. While asleep, this component cannot make changes to the Bing instance to which
     * it is bound.
     */
    sleep() {
        var _a;
        this._isAwake = false;
        if (!this._isBound) {
            return;
        }
        this.earthColorsSub.unsub(this.earthColorsHandler);
        this.skyColorSub.unsub(this.skyColorHandler);
        this.referenceSub.unsub(this.referenceHandler);
        this.wxrModeSub.unsub(this.wxrModeHandler);
        this.resolutionSub.unsub(this.resolutionHandler);
        (_a = this.mapListener) === null || _a === void 0 ? void 0 : _a.off('MapUpdated', this.onMapUpdate);
    }
    /**
     * Sets the center position and radius.
     * @param pos The center position.
     * @param radius The radius, in meters.
     */
    setPositionRadius(pos, radius) {
        if (this._isBound && this._isAwake) {
            Coherent.call('SET_MAP_PARAMS', this.uid, pos, radius, 1);
            this.pos = pos;
            this.radius = radius;
        }
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("img", { ref: this.imgRef, src: '', style: 'position: absolute; left: 0; top: 0; width: 100%; height: 100%;', class: `${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}` }));
    }
    /**
     * Converts an HTML hex color string to a numerical map RGB value.
     * @param hexColor The hex color string to convert.
     * @returns A numerical map RGB value.
     */
    static hexaToRGBColor(hexColor) {
        const hexStringColor = hexColor;
        let offset = 0;
        if (hexStringColor[0] === '#') {
            offset = 1;
        }
        const r = parseInt(hexStringColor.substr(0 + offset, 2), 16);
        const g = parseInt(hexStringColor.substr(2 + offset, 2), 16);
        const b = parseInt(hexStringColor.substr(4 + offset, 2), 16);
        const rgb = 256 * 256 * b + 256 * g + r;
        return rgb;
    }
    /**
     * Converts RGB color components to a numerical map RGB value.
     * @param r The red component, from 0 to 255.
     * @param g The green component, from 0 to 255.
     * @param b The blue component, from 0 to 255.
     * @returns A numerical map RGB value.
     */
    static rgbColor(r, g, b) {
        const rgb = 256 * 256 * b + 256 * g + r;
        return rgb;
    }
    /**
     * Creates a full Bing component earth colors array. The earth colors array will contain the specified water color
     * and terrain colors (including interpolated values between the explicitly defined ones, as necessary).
     * @param waterColor The desired water color, as a hex string with the format `#hhhhhh`.
     * @param terrainColors An array of desired terrain colors at specific elevations. Elevations should be specified in
     * feet and colors as hex strings with the format `#hhhhhh`.
     * @returns a full Bing component earth colors array.
     */
    // eslint-disable-next-line jsdoc/require-jsdoc
    static createEarthColorsArray(waterColor, terrainColors) {
        const earthColors = [BingComponent.hexaToRGBColor(waterColor)];
        const curve = new Avionics.Curve();
        curve.interpolationFunction = Avionics.CurveTool.StringColorRGBInterpolation;
        for (let i = 0; i < terrainColors.length; i++) {
            curve.add(terrainColors[i].elev, terrainColors[i].color);
        }
        for (let i = 0; i < 60; i++) {
            const color = curve.evaluate(i * 30000 / 60);
            earthColors[i + 1] = BingComponent.hexaToRGBColor(color);
        }
        return earthColors;
    }
}
BingComponent.DEFAULT_RESOLUTION = 1024;

/// <reference types="msfstypes/JS/common" />
/**
 * A FSComponent that display the MSFS Bing Map, weather radar, and 3D terrain.
 */
class MapBingLayer$1 extends MapLayer {
    constructor() {
        super(...arguments);
        this.wrapperRef = FSComponent.createRef();
        this.bingRef = FSComponent.createRef();
        this.size = 0;
        this.needUpdate = false;
        /**
         * A callback which is called when the Bing component is bound.
         * @param component The bound Bing component.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.onBingBound = (component) => {
            this.needUpdate = true;
        };
    }
    /** @inheritdoc */
    onAfterRender() {
        this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onWake() {
        this.bingRef.instance.wake();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onSleep() {
        this.bingRef.instance.sleep();
    }
    /**
     * Updates this layer according to the current size of the projected map window.
     * @param projectedSize The size of the projected map window.
     */
    updateFromProjectedSize(projectedSize) {
        this.size = this.getSize(projectedSize);
        const offsetX = (projectedSize[0] - this.size) / 2;
        const offsetY = (projectedSize[1] - this.size) / 2;
        this.wrapperRef.instance.style.left = `${offsetX}px`;
        this.wrapperRef.instance.style.top = `${offsetY}px`;
        this.wrapperRef.instance.style.width = `${this.size}px`;
        this.wrapperRef.instance.style.height = `${this.size}px`;
    }
    /**
     * Gets an appropriate size, in pixels, for this Bing layer given specific map projection window dimensions.
     * @param projectedSize - the size of the projected map window.
     * @returns an appropriate size for this Bing layer.
     */
    getSize(projectedSize) {
        return Vec2Math.abs(projectedSize);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.updateFromProjectedSize(mapProjection.getProjectedSize());
        }
        if (this.bingRef.instance.isBound()) {
            this.needUpdate = true;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        if (!this.needUpdate) {
            return;
        }
        this.updatePositionRadius();
        this.needUpdate = false;
    }
    /**
     * Updates the Bing map center position and radius.
     */
    updatePositionRadius() {
        const center = this.props.mapProjection.getCenter();
        const radius = this.calculateDesiredRadius(this.props.mapProjection);
        this.bingRef.instance.setPositionRadius(new LatLong(center.lat, center.lon), radius);
        this.wrapperRef.instance.style.transform = `rotate(${this.props.mapProjection.getRotation() * Avionics.Utils.RAD2DEG}deg)`;
    }
    /**
     * Gets the desired Bing map radius in meters given a map projection model.
     * @param mapProjection - a map projection model.
     * @returns the desired Bing map radius.
     */
    calculateDesiredRadius(mapProjection) {
        const scaleFactor = mapProjection.getGeoProjection().getScaleFactor();
        const pointScaleFactor = 1 / Math.cos(mapProjection.getCenter().lat * Avionics.Utils.DEG2RAD);
        const radiusGARad = this.size / (2 * scaleFactor * pointScaleFactor);
        return UnitType.GA_RADIAN.convertTo(radiusGARad, UnitType.METER);
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { ref: this.wrapperRef, style: 'position: absolute;', class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' },
            FSComponent.buildComponent(BingComponent, { ref: this.bingRef, id: this.props.bingId, mode: EBingMode.PLANE, onBoundCallback: this.onBingBound, earthColors: this.props.earthColors, reference: this.props.reference, wxrMode: this.props.wxrMode })));
    }
}
MapBingLayer$1.OVERDRAW_FACTOR = Math.SQRT2;
MapBingLayer$1.tempVec2_1 = new Float64Array(2);
MapBingLayer$1.tempVec2_2 = new Float64Array(2);
MapBingLayer$1.tempVec2_3 = new Float64Array(2);

/**
 * An implementation of MapCanvasLayerCanvasInstance.
 */
class MapCanvasLayerCanvasInstanceClass {
    /**
     * Creates a new canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     */
    constructor(canvas, context, isDisplayed) {
        this.canvas = canvas;
        this.context = context;
        this.isDisplayed = isDisplayed;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    clear() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    reset() {
        const width = this.canvas.width;
        this.canvas.width = 0;
        this.canvas.width = width;
    }
}
/**
 * A layer which uses a canvas to draw graphics.
 */
class MapCanvasLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.displayCanvasRef = FSComponent.createRef();
        this.width = 0;
        this.height = 0;
        this.displayCanvasContext = null;
        this.isInit = false;
        this.needUpdateCanvasVisibility = false;
    }
    /**
     * Gets this layer's display canvas instance.
     * @returns this layer's display canvas instance.
     */
    get display() {
        return this._display;
    }
    /**
     * Gets this layer's buffer canvas instance.
     * @returns this layer's buffer canvas instance.
     */
    get buffer() {
        return this._buffer;
    }
    /**
     * Gets the width of the canvas element, in pixels.
     * @returns the width of the canvas element.
     */
    getWidth() {
        return this.width;
    }
    /**
     * Gets the height of the canvas element, in pixels.
     * @returns the height of the canvas element.
     */
    getHeight() {
        return this.height;
    }
    /**
     * Sets the width of the canvas element, in pixels.
     * @param width The new width.
     */
    setWidth(width) {
        if (width === this.width) {
            return;
        }
        this.width = width;
        if (this.isInit) {
            this.updateCanvasSize();
        }
    }
    /**
     * Sets the height of the canvas element, in pixels.
     * @param height The new height.
     */
    setHeight(height) {
        if (height === this.height) {
            return;
        }
        this.height = height;
        if (this.isInit) {
            this.updateCanvasSize();
        }
    }
    /**
     * Copies the contents of the buffer to the display. Has no effect if this layer does not have a buffer.
     */
    copyBufferToDisplay() {
        if (!this.isInit || !this.props.useBuffer) {
            return;
        }
        this.display.context.drawImage(this.buffer.canvas, 0, 0, this.width, this.height);
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        this.displayCanvasContext = this.displayCanvasRef.instance.getContext('2d');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        this.needUpdateCanvasVisibility = true;
    }
    /**
     * Updates this layer according to its current visibility.
     */
    updateFromVisibility() {
        this.display.canvas.style.display = this.isVisible() ? 'block' : 'none';
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAttached() {
        this.initCanvasInstances();
        this.isInit = true;
        this.needUpdateCanvasVisibility = true;
        this.updateCanvasSize();
    }
    /**
     * Initializes this layer's canvas instances.
     */
    initCanvasInstances() {
        this._display = this.createCanvasInstance(this.displayCanvasRef.instance, this.displayCanvasContext, true);
        if (this.props.useBuffer) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            this._buffer = this.createCanvasInstance(canvas, context, false);
        }
    }
    /**
     * Creates a canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     * @returns a canvas instance.
     */
    createCanvasInstance(canvas, context, isDisplayed) {
        return new MapCanvasLayerCanvasInstanceClass(canvas, context, isDisplayed);
    }
    /**
     * Updates the canvas element's size.
     */
    updateCanvasSize() {
        const displayCanvas = this._display.canvas;
        displayCanvas.width = this.width;
        displayCanvas.height = this.height;
        displayCanvas.style.width = `${this.width}px`;
        displayCanvas.style.height = `${this.height}px`;
        if (this._buffer) {
            const bufferCanvas = this._buffer.canvas;
            bufferCanvas.width = this.width;
            bufferCanvas.height = this.height;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        if (this.needUpdateCanvasVisibility) {
            this.updateCanvasVisibility();
            this.needUpdateCanvasVisibility = false;
        }
    }
    /**
     * Updates the visibility of the display canvas.
     */
    updateCanvasVisibility() {
        this.display.canvas.style.display = this.isVisible() ? 'block' : 'none';
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("canvas", { ref: this.displayCanvasRef, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', width: '0', height: '0', style: 'position: absolute;' }));
    }
}

/**
 * A canvas map layer whose size and position is synced with the map projection window.
 */
class MapSyncedCanvasLayer extends MapCanvasLayer {
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAttached() {
        super.onAttached();
        this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
    }
    /**
     * Updates this layer according to the current size of the projected map window.
     * @param projectedSize The size of the projected map window.
     */
    updateFromProjectedSize(projectedSize) {
        this.setWidth(projectedSize[0]);
        this.setHeight(projectedSize[1]);
        const displayCanvas = this.display.canvas;
        displayCanvas.style.left = '0px';
        displayCanvas.style.top = '0px';
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.updateFromProjectedSize(mapProjection.getProjectedSize());
        }
    }
}

/**
 * Implementation of MapCachedCanvasLayerReference.
 */
class MapCachedCanvasLayerReferenceClass {
    constructor() {
        this._center = new GeoPoint(0, 0);
        this._range = UnitType.NMILE.createNumber(1);
        this._scaleFactor = 1;
        this._rotation = 0;
    }
    /** @inheritdoc */
    get center() {
        return this._center.readonly;
    }
    /** @inheritdoc */
    get range() {
        return this._range.readonly;
    }
    /** @inheritdoc */
    get scaleFactor() {
        return this._scaleFactor;
    }
    /** @inheritdoc */
    get rotation() {
        return this._rotation;
    }
    /**
     * Syncs this reference with the current state of a map projection.
     * @param mapProjection The map projection with which to sync.
     */
    syncWithMapProjection(mapProjection) {
        this._range.set(mapProjection.getRange(), UnitType.GA_RADIAN);
        this._center.set(mapProjection.getCenter());
        this._scaleFactor = mapProjection.getGeoProjection().getScaleFactor();
        this._rotation = mapProjection.getRotation();
    }
    /**
     * Syncs this reference with another reference.
     * @param reference - the reference with which to sync.
     */
    syncWithReference(reference) {
        this._range.set(reference.range);
        this._center.set(reference.center);
        this._scaleFactor = reference.scaleFactor;
        this._rotation = reference.rotation;
    }
}
/**
 * Implementation of MapCachedCanvasLayerTransform.
 */
class MapCachedCanvasLayerTransformClass {
    constructor() {
        this._scale = 0;
        this._rotation = 0;
        this._translation = new Float64Array(2);
        this._margin = 0;
    }
    /** @inheritdoc */
    get scale() {
        return this._scale;
    }
    /** @inheritdoc */
    get rotation() {
        return this._rotation;
    }
    /** @inheritdoc */
    get translation() {
        return this._translation;
    }
    /** @inheritdoc */
    get margin() {
        return this._margin;
    }
    /**
     * Updates this transform given the current map projection and a reference.
     * @param mapProjection The current map projection.
     * @param reference The reference to use.
     * @param referenceMargin The reference margin, in pixels.
     */
    update(mapProjection, reference, referenceMargin) {
        this._scale = mapProjection.getGeoProjection().getScaleFactor() / reference.scaleFactor;
        this._rotation = mapProjection.getRotation() - reference.rotation;
        mapProjection.project(reference.center, this._translation);
        Vec2Math.sub(this._translation, mapProjection.getCenterProjected(), this._translation);
        this._margin = referenceMargin * this._scale;
    }
    /**
     * Copies another transform's parameters to this one.
     * @param other The other transform.
     */
    copyFrom(other) {
        this._scale = other.scale;
        this._rotation = other.rotation;
        this._translation.set(other.translation);
        this._margin = other.margin;
    }
}
/**
 * An implementation of MapCachedCanvasLayerCanvasInstance.
 */
class MapCachedCanvasLayerCanvasInstanceClass extends MapCanvasLayerCanvasInstanceClass {
    constructor() {
        super(...arguments);
        this._reference = new MapCachedCanvasLayerReferenceClass();
        this._transform = new MapCachedCanvasLayerTransformClass();
        this._isInvalid = false;
        this._geoProjection = new MercatorProjection();
    }
    /** @inheritdoc */
    get reference() {
        return this._reference;
    }
    /** @inheritdoc */
    get transform() {
        return this._transform;
    }
    /** @inheritdoc */
    get isInvalid() {
        return this._isInvalid;
    }
    /** @inheritdoc */
    get geoProjection() {
        return this._geoProjection;
    }
    /** @inheritdoc */
    syncWithMapProjection(mapProjection, referenceMargin) {
        const projectedCenter = Vec2Math.set(this.canvas.width / 2, this.canvas.height / 2, MapCachedCanvasLayerCanvasInstanceClass.tempVec2_1);
        this._reference.syncWithMapProjection(mapProjection);
        this._geoProjection.copyParametersFrom(mapProjection.getGeoProjection()).setTranslation(projectedCenter);
        this._transform.update(mapProjection, this.reference, referenceMargin);
        this._isInvalid = false;
        if (this.isDisplayed) {
            this.transformCanvasElement();
        }
    }
    /** @inheritdoc */
    syncWithCanvasInstance(other) {
        this._reference.syncWithReference(other.reference);
        this._geoProjection.copyParametersFrom(other.geoProjection);
        this._transform.copyFrom(other.transform);
        this._isInvalid = other.isInvalid;
        if (this.isDisplayed && !this._isInvalid) {
            this.transformCanvasElement();
        }
    }
    /**
     * Updates this canvas instance's transform given the current map projection.
     * @param mapProjection The current map projection.
     * @param referenceMargin The reference margin, in pixels.
     */
    updateTransform(mapProjection, referenceMargin) {
        this._transform.update(mapProjection, this.reference, referenceMargin);
        const translationXAbs = Math.abs(this._transform.translation[0]);
        const translationYAbs = Math.abs(this._transform.translation[1]);
        this._isInvalid = this._isInvalid
            || !this._reference.range.equals(mapProjection.getRange(), UnitType.GA_RADIAN)
            || (translationXAbs > this._transform.margin || translationYAbs > this._transform.margin);
        if (this.isDisplayed && !this._isInvalid) {
            this.transformCanvasElement();
        }
    }
    /**
     * Transforms this instance's canvas element.
     */
    transformCanvasElement() {
        const transform = this.transform;
        const offsetX = transform.translation[0] / transform.scale;
        const offsetY = transform.translation[1] / transform.scale;
        this.canvas.style.transform = `scale(${transform.scale.toFixed(3)}) translate(${offsetX.toFixed(1)}px, ${offsetY.toFixed(1)}px) rotate(${(transform.rotation * Avionics.Utils.RAD2DEG).toFixed(2)}deg)`;
    }
    /** @inheritdoc */
    invalidate() {
        this._isInvalid = true;
        this.clear();
    }
}
MapCachedCanvasLayerCanvasInstanceClass.tempVec2_1 = new Float64Array(2);
/**
 * A canvas map layer whose image can be cached and transformed as the map projection changes.
 */
class MapCachedCanvasLayer extends MapCanvasLayer {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.size = 0;
        this.referenceMargin = 0;
        this.needUpdateTransforms = false;
        this.props.overdrawFactor = Math.max(1, this.props.overdrawFactor);
    }
    /** @inheritdoc */
    get display() {
        return super.display;
    }
    /** @inheritdoc */
    get buffer() {
        return super.buffer;
    }
    /**
     * Gets the size, in pixels, of this layer's canvas.
     * @returns the size of this layer's canvas.
     */
    getSize() {
        return this.size;
    }
    /**
     * Gets the reference translation margin, in pixels, of this layer's display canvas. This value is the maximum amount
     * the display canvas can be translated in the x or y direction at a scale of 1 without invalidation.
     * @returns the reference translation margin of this layer's display canvas.
     */
    getReferenceMargin() {
        return this.referenceMargin;
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
        this.needUpdateTransforms = true;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    createCanvasInstance(canvas, context, isDisplayed) {
        return new MapCachedCanvasLayerCanvasInstanceClass(canvas, context, isDisplayed);
    }
    /**
     * Updates this layer according to the current size of the projected map window.
     * @param projectedSize The size of the projected map window.
     */
    updateFromProjectedSize(projectedSize) {
        const projectedWidth = projectedSize[0];
        const projectedHeight = projectedSize[1];
        const diag = Math.hypot(projectedWidth, projectedHeight);
        this.size = diag * this.props.overdrawFactor;
        this.referenceMargin = (this.size - diag) / 2;
        this.setWidth(this.size);
        this.setHeight(this.size);
        const posX = (projectedWidth - this.size) / 2;
        const posY = (projectedHeight - this.size) / 2;
        const displayCanvas = this.display.canvas;
        displayCanvas.style.left = `${posX}px`;
        displayCanvas.style.top = `${posY}px`;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.updateFromProjectedSize(mapProjection.getProjectedSize());
            this.display.invalidate();
            this.buffer.invalidate();
        }
        this.needUpdateTransforms = true;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        super.onUpdated(time, elapsed);
        if (!this.needUpdateTransforms) {
            return;
        }
        this.updateTransforms();
    }
    /**
     * Updates this layer's canvas instances' transforms.
     */
    updateTransforms() {
        const mapProjection = this.props.mapProjection;
        const display = this.display;
        const buffer = this.buffer;
        display.updateTransform(mapProjection, this.referenceMargin);
        buffer.updateTransform(mapProjection, this.referenceMargin);
        this.needUpdateTransforms = false;
    }
}

/**
 * A map layer which displays a ring (circle) with one or more labels.
 */
class MapLabeledRingLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.labelContainerRef = FSComponent.createRef();
        this.canvasLayerRef = FSComponent.createRef();
        this.center = new Float64Array(2);
        this.radius = 0;
        this.strokeWidth = 0;
        this.strokeStyle = '';
        this.strokeDash = [];
        this.outlineWidth = 0;
        this.outlineStyle = '';
        this.outlineDash = [];
        this.needUpdateVisibility = false;
        this.needUpdateRingPosition = false;
        this.isInit = false;
        this.labels = [];
    }
    /**
     * Gets the center position of this layer's ring, in pixels.
     * @returns the center position of this layer's ring.
     */
    getRingCenter() {
        return this.center;
    }
    /**
     * Gets the radius of this layer's ring, in pixels.
     * @returns the radius of this layer's ring.
     */
    getRingRadius() {
        return this.radius;
    }
    /**
     * Sets the center and radius of this layer's ring.
     * @param center The new center, in pixels.
     * @param radius The new radius, in pixels.
     */
    setRingPosition(center, radius) {
        if (Vec2Math.equals(this.center, center) && radius === this.radius) {
            return;
        }
        this.center.set(center);
        this.radius = radius;
        this.needUpdateRingPosition = true;
    }
    /**
     * Sets the styling for this layer's ring stroke. Any style that is not explicitly defined will be left unchanged.
     * @param width The new stroke width.
     * @param style The new stroke style.
     * @param dash The new stroke dash.
     */
    setRingStrokeStyles(width, style, dash) {
        this.strokeWidth = width !== null && width !== void 0 ? width : this.strokeWidth;
        this.strokeStyle = style !== null && style !== void 0 ? style : this.strokeStyle;
        this.strokeDash = dash !== null && dash !== void 0 ? dash : this.strokeDash;
        this.needUpdateRingPosition = true;
    }
    /**
     * Sets the styling for this layer's ring outline. Any style that is not explicitly defined will be left unchanged.
     * @param width The new outline width.
     * @param style The new outline style.
     * @param dash The new outline dash.
     */
    setRingOutlineStyles(width, style, dash) {
        this.outlineWidth = width !== null && width !== void 0 ? width : this.outlineWidth;
        this.outlineStyle = style !== null && style !== void 0 ? style : this.outlineStyle;
        this.outlineDash = dash !== null && dash !== void 0 ? dash : this.outlineDash;
        this.needUpdateRingPosition = true;
    }
    /**
     * Creates a ring label. Labels can only be created after this layer has been rendered.
     * @param content The content of the new label.
     * @returns the newly created ring label, or null if a label could not be created.
     */
    createLabel(content) {
        if (!this.labelContainerRef.instance) {
            return null;
        }
        const wrapperRef = FSComponent.createRef();
        FSComponent.render(FSComponent.buildComponent("div", { ref: wrapperRef, style: 'position: absolute;' }, content), this.labelContainerRef.instance);
        const label = new MapLabeledRingLabelClass(content.instance, wrapperRef.instance);
        label.setRingPosition(this.center, this.radius);
        this.labels.push(label);
        return label;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        this.needUpdateVisibility = true;
    }
    /** @inheritdoc */
    onAttached() {
        this.canvasLayerRef.instance.onAttached();
        this.isInit = true;
        this.needUpdateVisibility = true;
        this.needUpdateRingPosition = true;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            // resizing the map will cause the canvas layer to clear itself, so we need to force a redraw.
            this.needUpdateRingPosition = true;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        if (this.needUpdateVisibility) {
            this.updateFromVisibility();
            this.needUpdateVisibility = false;
        }
        if (this.needUpdateRingPosition) {
            this.updateRingPosition();
            this.needUpdateRingPosition = false;
        }
        this.canvasLayerRef.instance.onUpdated(time, elapsed);
    }
    /**
     * Updates this layer according to its current visibility.
     */
    updateFromVisibility() {
        const isVisible = this.isVisible();
        this.canvasLayerRef.instance.setVisible(isVisible);
        this.labelContainerRef.instance.style.display = isVisible ? 'block' : 'none';
    }
    /**
     * Updates the position of this layer's ring.
     */
    updateRingPosition() {
        this.drawRing();
        this.updateLabelPositions();
    }
    /**
     * Draws this layer's ring to canvas.
     */
    drawRing() {
        const canvasDisplay = this.canvasLayerRef.instance.display;
        canvasDisplay.clear();
        if (!this.isRingInView()) {
            return;
        }
        canvasDisplay.context.beginPath();
        canvasDisplay.context.arc(this.center[0], this.center[1], this.radius, 0, Math.PI * 2);
        if (this.outlineWidth > 0) {
            this.applyStrokeToContext(canvasDisplay.context, this.strokeWidth + this.outlineWidth * 2, this.outlineStyle, this.outlineDash);
        }
        this.applyStrokeToContext(canvasDisplay.context, this.strokeWidth, this.strokeStyle, this.strokeDash);
    }
    /**
     * Checks whether this layer's ring is in view.
     * @returns whether this layer's ring is in view.
     */
    isRingInView() {
        const centerX = this.center[0];
        const centerY = this.center[1];
        const innerHalfLength = this.radius / Math.SQRT2;
        const innerLeft = centerX - innerHalfLength;
        const innerRight = centerX + innerHalfLength;
        const innerTop = centerY - innerHalfLength;
        const innerBottom = centerY + innerHalfLength;
        const outerLeft = centerX - this.radius;
        const outerRight = centerX + this.radius;
        const outerTop = centerY - this.radius;
        const outerBottom = centerY + this.radius;
        const width = this.props.mapProjection.getProjectedSize()[0];
        const height = this.props.mapProjection.getProjectedSize()[1];
        if (innerLeft < 0 && innerRight > width && innerTop < 0 && innerBottom > height) {
            return false;
        }
        if (outerLeft > width || outerRight < 0 || outerTop > height || outerBottom < 0) {
            return false;
        }
        return true;
    }
    /**
     * Applies a stroke to a canvas rendering context.
     * @param context The canvas to which to apply a stroke.
     * @param lineWidth The stroke width.
     * @param strokeStyle The stroke style.
     * @param dash The stroke dash.
     */
    applyStrokeToContext(context, lineWidth, strokeStyle, dash) {
        context.lineWidth = lineWidth;
        context.strokeStyle = strokeStyle;
        context.setLineDash(dash);
        context.stroke();
    }
    /**
     * Updates the position of this layer's labels based on the position of the ring.
     */
    updateLabelPositions() {
        const len = this.labels.length;
        for (let i = 0; i < len; i++) {
            this.labels[i].setRingPosition(this.center, this.radius);
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { style: 'position: absolute; left: 0; top: 0; width: 100%; height: 100%;' },
            FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection }),
            FSComponent.buildComponent("div", { ref: this.labelContainerRef, style: 'position: absolute; left: 0; top: 0; width: 100%; height: 100%;' })));
    }
}
/**
 *
 */
class MapLabeledRingLabelClass {
    /**
     * Constructor.
     * @param content The content of this label.
     * @param wrapper The wrapper for this label.
     */
    constructor(content, wrapper) {
        this.content = content;
        this.wrapper = wrapper;
        this.center = new Float64Array(2);
        this.radius = 0;
        this.anchor = new Float64Array(2);
        this.radialAngle = 0;
        this.radialOffset = 0;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getAnchor() {
        return this.anchor;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getRadialAngle() {
        return this.radialAngle;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getRadialOffset() {
        return this.radialOffset;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setAnchor(anchor) {
        this.anchor.set(anchor);
        this.wrapper.style.transform = `translate(${-anchor[0] * 100}%, ${-anchor[1] * 100}%)`;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setRadialAngle(angle) {
        if (this.radialAngle === angle) {
            return;
        }
        this.radialAngle = angle;
        this.updatePosition();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setRadialOffset(offset) {
        if (this.radialOffset === offset) {
            return;
        }
        this.radialOffset = offset;
        this.updatePosition();
    }
    /**
     * Sets the center and radius of this label's parent ring.
     * @param center The center of the ring, in pixels.
     * @param radius The radius of the ring, in pixels.
     */
    setRingPosition(center, radius) {
        if (Vec2Math.equals(this.center, center) && radius === this.radius) {
            return;
        }
        this.center.set(center);
        this.radius = radius;
        this.updatePosition();
    }
    /**
     * Updates this label's position.
     */
    updatePosition() {
        const pos = MapLabeledRingLabelClass.tempVec2_1;
        Vec2Math.setFromPolar(this.radius + this.radialOffset, this.radialAngle, pos);
        Vec2Math.add(this.center, pos, pos);
        this.wrapper.style.left = `${pos[0]}px`;
        this.wrapper.style.top = `${pos[1]}px`;
    }
}
MapLabeledRingLabelClass.tempVec2_1 = new Float64Array(2);

/**
 * A layer which draws an own airplane icon.
 */
class MapOwnAirplaneLayer extends MapLayer {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.iconImgRef = FSComponent.createRef();
        this.iconOffset = new Float64Array(2);
        this.updateFlags = 0;
        this.iconOffset.set(this.props.iconAnchor);
        Vec2Math.multScalar(this.iconOffset, -this.props.iconSize, this.iconOffset);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        this.scheduleUpdate(MapOwnAirplaneLayer.UPDATE_VISIBILITY);
    }
    /** @inheritdoc */
    onAttached() {
        const ownAirplaneIconModule = this.props.model.getModule('ownAirplaneIcon');
        ownAirplaneIconModule.show.sub(this.onIconShowChanged.bind(this));
        const ownAirplanePropsModule = this.props.model.getModule('ownAirplaneProps');
        ownAirplanePropsModule.position.sub(this.onAirplanePositionChanged.bind(this));
        ownAirplanePropsModule.hdgTrue.sub(this.onAirplaneHeadingChanged.bind(this));
        const img = this.iconImgRef.instance;
        img.style.left = `${this.iconOffset[0]}px`;
        img.style.top = `${this.iconOffset[1]}px`;
        img.style.transformOrigin = `${this.props.iconAnchor[0] * 100}% ${this.props.iconAnchor[1] * 100}%`;
        this.scheduleUpdate(MapOwnAirplaneLayer.UPDATE_VISIBILITY | MapOwnAirplaneLayer.UPDATE_TRANSFORM);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.scheduleUpdate(MapOwnAirplaneLayer.UPDATE_TRANSFORM);
    }
    /**
     * Schedules an update.
     * @param updateFlags The types of updates to schedule.
     */
    scheduleUpdate(updateFlags) {
        this.updateFlags = BitFlags.union(this.updateFlags, updateFlags);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        if (this.updateFlags === 0) {
            return;
        }
        if (BitFlags.isAll(this.updateFlags, MapOwnAirplaneLayer.UPDATE_VISIBILITY)) {
            this.updateIconVisibility();
        }
        if (BitFlags.isAll(this.updateFlags, MapOwnAirplaneLayer.UPDATE_TRANSFORM)) {
            this.updateIconTransform();
        }
        this.updateFlags = BitFlags.not(this.updateFlags, MapOwnAirplaneLayer.UPDATE_VISIBILITY | MapOwnAirplaneLayer.UPDATE_TRANSFORM);
    }
    /**
     * Updates the airplane icon's visibility.
     */
    updateIconVisibility() {
        const show = this.isVisible() && this.props.model.getModule('ownAirplaneIcon').show.get();
        this.iconImgRef.instance.style.display = show ? 'block' : 'none';
    }
    /**
     * Updates the airplane icon's display transformation.
     */
    updateIconTransform() {
        const ownAirplanePropsModule = this.props.model.getModule('ownAirplaneProps');
        const projected = this.props.mapProjection.project(ownAirplanePropsModule.position.get(), MapOwnAirplaneLayer.tempVec2_1);
        const rotation = ownAirplanePropsModule.hdgTrue.get() + this.props.mapProjection.getRotation() * Avionics.Utils.RAD2DEG;
        this.iconImgRef.instance.style.transform = `translate(${projected[0].toFixed(1)}px, ${projected[1].toFixed(1)}px) rotate(${rotation.toFixed(1)}deg) rotateX(0deg)`;
    }
    /**
     * A callback which is called when the show airplane icon property changes.
     * @param show The new value of the show airplane icon property.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onIconShowChanged(show) {
        this.scheduleUpdate(MapOwnAirplaneLayer.UPDATE_VISIBILITY);
    }
    /**
     * A callback which is called when the airplane's position changes.
     * @param pos The new position of the airplane.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onAirplanePositionChanged(pos) {
        this.scheduleUpdate(MapOwnAirplaneLayer.UPDATE_TRANSFORM);
    }
    /**
     * A callback which is called when the airplane's true heading changes.
     * @param hdgTrue - the new true heading of the airplane.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onAirplaneHeadingChanged(hdgTrue) {
        this.scheduleUpdate(MapOwnAirplaneLayer.UPDATE_TRANSFORM);
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("img", { ref: this.iconImgRef, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', src: this.props.imageFilePath, style: `position: absolute; width: ${this.props.iconSize}px; height: ${this.props.iconSize}px; transform: rotateX(0deg);` }));
    }
}
MapOwnAirplaneLayer.UPDATE_VISIBILITY = 1;
MapOwnAirplaneLayer.UPDATE_TRANSFORM = 1 << 1;
MapOwnAirplaneLayer.tempVec2_1 = new Float64Array(2);

/**
 * A layer which displays text which can be culled to avoid overlap.
 */
class MapCullableTextLayer extends MapSyncedCanvasLayer {
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        super.onUpdated(time, elapsed);
        this.props.manager.update(this.props.mapProjection);
        this.redrawLabels();
    }
    /**
     * Clears this layer's canvas and redraws the currently visible labels registered to this layer's text manager.
     */
    redrawLabels() {
        const labels = this.props.manager.visibleLabels;
        const display = this.display;
        display.clear();
        for (let i = labels.length - 1; i >= 0; i--) {
            labels[i].draw(display.context, this.props.mapProjection);
        }
    }
}

var AirspaceRangeType;
(function (AirspaceRangeType) {
    AirspaceRangeType["ClassB"] = "ClassB";
    AirspaceRangeType["ClassC"] = "ClassC";
    AirspaceRangeType["ClassD"] = "ClassD";
    AirspaceRangeType["Restricted"] = "Restricted";
    AirspaceRangeType["MOA"] = "MOA";
    AirspaceRangeType["Other"] = "Other";
})(AirspaceRangeType || (AirspaceRangeType = {}));
/**
 * A module describing the display of airspaces.
 */
class MapAirspaceModule {
    constructor() {
        /** Whether to show airspaces. */
        this.show = Subject.create(true);
        // TODO: Defaults are hard-coded here for now, but eventually will want to move default definitions outside of this
        // class (probably to initialization code of specific MapModels).
        /** The index of the maximum nominal map range at which to show airspaces of a specific type. */
        this.maxRangeIndex = {
            [AirspaceRangeType.ClassB]: Subject.create(19),
            [AirspaceRangeType.ClassC]: Subject.create(21),
            [AirspaceRangeType.ClassD]: Subject.create(20),
            [AirspaceRangeType.Restricted]: Subject.create(19),
            [AirspaceRangeType.MOA]: Subject.create(19),
            [AirspaceRangeType.Other]: Subject.create(19),
        };
    }
}

/**
 * Orientation types for a map.
 */
var MapOrientation;
(function (MapOrientation) {
    MapOrientation[MapOrientation["NorthUp"] = 0] = "NorthUp";
    MapOrientation[MapOrientation["TrackUp"] = 1] = "TrackUp";
    MapOrientation[MapOrientation["HeadingUp"] = 2] = "HeadingUp";
})(MapOrientation || (MapOrientation = {}));
/**
 * A module describing the map orientation.
 */
class MapOrientationModule {
    constructor() {
        /** The orientation of the map. */
        this.orientation = Subject.create(MapOrientation.HeadingUp);
        /** Whether auto-north-up is active. */
        this.autoNorthUpActive = Subject.create(true);
    }
}

/**
 * A module describing the map range compass.
 */
class MapRangeCompassModule {
    constructor() {
        /** Whether to show the range compass. */
        this.show = Subject.create(true);
    }
}

/**
 * A module describing the map range ring.
 */
class MapRangeRingModule {
    constructor() {
        /** Whether to show the range ring. */
        this.show = Subject.create(true);
    }
}

/**
 * Map terrain display mode.
 */
var MapTerrainMode;
(function (MapTerrainMode) {
    MapTerrainMode[MapTerrainMode["None"] = 0] = "None";
    MapTerrainMode[MapTerrainMode["Absolute"] = 1] = "Absolute";
    MapTerrainMode[MapTerrainMode["Relative"] = 2] = "Relative";
    MapTerrainMode[MapTerrainMode["Ground"] = 3] = "Ground";
})(MapTerrainMode || (MapTerrainMode = {}));
/**
 * A module describing the display of terrain.
 */
class MapTerrainModule {
    constructor() {
        /** The terrain display mode. */
        this.terrainMode = Subject.create(MapTerrainMode.Absolute);
        /** Whether to show the terrain scale. */
        this.showScale = Subject.create(false);
    }
}

/**
 * An abstract implementation of Waypoint.
 */
class AbstractWaypoint {
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(other) {
        return this.uid === other.uid;
    }
}
/**
 * A waypoint with custom defined lat/lon coordinates.
 */
class CustomWaypoint extends AbstractWaypoint {
    /**
     * Constructor.
     * @param lat The latitude of this waypoint.
     * @param lon The longitude of this waypoint.
     * @param uidPrefix The prefix of this waypoint's UID.
     */
    constructor(lat, lon, uidPrefix) {
        super();
        this._location = new GeoPoint(lat, lon);
        this._uid = `${uidPrefix}[${this.location.lat},${this.location.lon}]`;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get location() {
        return this._location.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get uid() {
        return this._uid;
    }
}
/**
 * A waypoint associated with a facility.
 */
class FacilityWaypoint extends AbstractWaypoint {
    /**
     * Constructor.
     * @param facility The facility associated with this waypoint.
     */
    constructor(facility) {
        super();
        this.facility = facility;
        this._location = new GeoPoint(facility.lat, facility.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get location() {
        return this._location.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get uid() {
        return this.facility.icao;
    }
}
/**
 * Airport size.
 */
var AirportSize;
(function (AirportSize) {
    AirportSize["Large"] = "Large";
    AirportSize["Medium"] = "Medium";
    AirportSize["Small"] = "Small";
})(AirportSize || (AirportSize = {}));
/**
 * A waypoint associated with an airport.
 */
class AirportWaypoint extends FacilityWaypoint {
    /**
     * Constructor.
     * @param airport The airport associated with this waypoint.
     */
    constructor(airport) {
        super(airport);
        this.longestRunway = AirportWaypoint.getLongestRunway(airport);
        this.size = AirportWaypoint.getAirportSize(airport, this.longestRunway);
    }
    /**
     * Gets the longest runway at an airport.
     * @param airport An airport.
     * @returns the longest runway at an airport, or null if the airport has no runways.
     */
    static getLongestRunway(airport) {
        if (airport.runways.length === 0) {
            return null;
        }
        return airport.runways.reduce((a, b) => a.length > b.length ? a : b);
    }
    /**
     * Gets the size of an airport.
     * @param airport An airport.
     * @param longestRunway The longest runway at the airport.
     * @returns the size of the airport.
     */
    static getAirportSize(airport, longestRunway) {
        if (!longestRunway) {
            return AirportSize.Small;
        }
        const longestRwyLengthFeet = UnitType.METER.convertTo(longestRunway.length, UnitType.FOOT);
        return longestRwyLengthFeet >= 8100 ? AirportSize.Large
            : (longestRwyLengthFeet >= 5000 || airport.towered) ? AirportSize.Medium
                : AirportSize.Small;
    }
}
/**
 * A flight path waypoint.
 */
class FlightPathWaypoint extends CustomWaypoint {
    /**
     * Constructor.
     * @param lat The latitude of this waypoint.
     * @param lon The longitude of this waypoint.
     * @param ident The ident string of this waypoint.
     */
    constructor(lat, lon, ident) {
        super(lat, lon, `${FlightPathWaypoint.UID_PREFIX}_${ident}`);
        this.ident = ident;
    }
}
FlightPathWaypoint.UID_PREFIX = 'FLPTH';
/**
 * A VNAV TOD/BOD waypoint.
 */
class VNavWaypoint extends AbstractWaypoint {
    /**
     * Constructor.
     * @param leg The leg that the VNAV waypoint is contained in.
     * @param distanceFromEnd The distance along the flight path from the end of the leg to the location of the waypoint,
     * in meters.
     * @param type The type of VNAV leg.
     */
    constructor(leg, distanceFromEnd, type) {
        super();
        this._uid = VNavWaypoint.uidMap[type];
        this._location = this.getWaypointLocation(leg, distanceFromEnd);
    }
    /**
     * Gets the waypoint's location in space.
     * @param leg The leg that the waypoint resides in.
     * @param distanceFromEnd The distance along the flight path from the end of the leg to the location of the waypoint,
     * in meters.
     * @returns The waypoint's location.
     */
    getWaypointLocation(leg, distanceFromEnd) {
        const out = new GeoPoint(0, 0);
        if (leg.calculated !== undefined) {
            let vectorIndex = leg.calculated.flightPath.length - 1;
            const ingressTurn = leg.calculated.ingressTurn;
            const egressTurn = leg.calculated.egressTurn;
            while (vectorIndex >= 0) {
                const vector = leg.calculated.flightPath[vectorIndex];
                const start = VNavWaypoint.vec3Cache[0];
                const end = VNavWaypoint.vec3Cache[1];
                if (vectorIndex === leg.calculated.flightPath.length - 1 && egressTurn.radius !== 0) {
                    if (egressTurn.distance >= distanceFromEnd) {
                        const egressCircle = FlightPathUtils.setGeoCircleFromVector(egressTurn, VNavWaypoint.geoCircleCache[0]);
                        const turnEnd = VNavWaypoint.geoPointCache[0].set(egressTurn.endLat, egressTurn.endLon);
                        return egressCircle.offsetDistanceAlong(turnEnd, UnitType.METER.convertTo(-distanceFromEnd, UnitType.GA_RADIAN), out);
                    }
                    else {
                        distanceFromEnd -= egressTurn.distance;
                        GeoPoint.sphericalToCartesian(egressTurn.startLat, egressTurn.startLon, end);
                    }
                }
                else {
                    GeoPoint.sphericalToCartesian(vector.endLat, vector.endLon, end);
                }
                if (vectorIndex === 0 && ingressTurn.radius !== 0) {
                    GeoPoint.sphericalToCartesian(ingressTurn.endLat, ingressTurn.endLon, start);
                }
                else {
                    GeoPoint.sphericalToCartesian(vector.startLat, vector.startLon, start);
                }
                const circle = FlightPathUtils.setGeoCircleFromVector(vector, VNavWaypoint.geoCircleCache[0]);
                const vectorDistance = UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end), UnitType.METER);
                if (vectorDistance >= distanceFromEnd) {
                    return circle.offsetDistanceAlong(end, UnitType.METER.convertTo(-distanceFromEnd, UnitType.GA_RADIAN), out);
                }
                else {
                    distanceFromEnd -= vectorDistance;
                }
                if (vectorIndex === 0) {
                    if (ingressTurn.radius !== 0) {
                        if (ingressTurn.distance >= distanceFromEnd) {
                            const ingressCircle = FlightPathUtils.setGeoCircleFromVector(ingressTurn, VNavWaypoint.geoCircleCache[0]);
                            const turnEnd = VNavWaypoint.geoPointCache[0].set(ingressTurn.endLat, ingressTurn.endLon);
                            return ingressCircle.offsetDistanceAlong(turnEnd, UnitType.METER.convertTo(-distanceFromEnd, UnitType.GA_RADIAN), new GeoPoint(0, 0));
                        }
                        else {
                            return out.set(ingressTurn.startLat, ingressTurn.startLon);
                        }
                    }
                    else {
                        return out.set(vector.startLat, vector.startLon);
                    }
                }
                vectorIndex--;
            }
        }
        return out;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get location() {
        return this._location.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get uid() {
        return this._uid;
    }
}
VNavWaypoint.uidMap = { 'tod': 'vnav-tod', 'bod': 'vnav-bod' };
VNavWaypoint.vec3Cache = [new Float64Array(3), new Float64Array(3)];
VNavWaypoint.geoPointCache = [new GeoPoint(0, 0)];
VNavWaypoint.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/**
 * A module describing the display of waypoints.
 */
class MapWaypointsModule {
    constructor() {
        /** Whether to show airports. */
        this.airportShow = {
            [AirportSize.Large]: Subject.create(true),
            [AirportSize.Medium]: Subject.create(true),
            [AirportSize.Small]: Subject.create(true)
        };
        /** Whether to show VORs. */
        this.vorShow = Subject.create(true);
        /** Whether to show NDBs. */
        this.ndbShow = Subject.create(true);
        /** Whether to show intersections. */
        this.intShow = Subject.create(true);
    }
}

/**
 * A module for map weather radar mode data.
 */
class MapNexradModule {
    constructor() {
        this.showNexrad = Subject.create(false);
    }
}

var MapDeclutterMode;
(function (MapDeclutterMode) {
    MapDeclutterMode[MapDeclutterMode["All"] = 0] = "All";
    MapDeclutterMode[MapDeclutterMode["Level3"] = 1] = "Level3";
    MapDeclutterMode[MapDeclutterMode["Level2"] = 2] = "Level2";
    MapDeclutterMode[MapDeclutterMode["Level1"] = 3] = "Level1";
})(MapDeclutterMode || (MapDeclutterMode = {}));
/**
 * A module describing the declutter mode.
 */
class MapDeclutterModule {
    constructor() {
        this.mode = Subject.create(MapDeclutterMode.All);
    }
}

/**
 * A module describing the map pointer.
 */
class MapPointerModule {
    constructor() {
        /** Whether the pointer is active. */
        this.isActive = Subject.create(false);
        /** The position of the pointer on the projected map, in pixel coordinates. */
        this.position = Vec2Subject.createFromVector(new Float64Array(2));
        /** The desired map target. */
        this.target = GeoPointSubject.createFromGeoPoint(new GeoPoint(0, 0));
    }
}

/**
 * A module for the map crosshair.
 */
class MapCrosshairModule {
    constructor() {
        this.show = Subject.create(false);
    }
}

/**
 * Class for creating navmap models.
 */
class NavMapModel {
    /**
     * Creates an instance of a navmap model.
     * @param tcas A TCAS to use to get traffic avoidance information.
     * @param options Initialization options for the new model.
     * @returns a navmap model instance.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static createModel(tcas, options) {
        const model = new MapModel();
        model.addModule('range', new MapIndexedRangeModule());
        model.addModule('orientation', new MapOrientationModule());
        model.addModule('declutter', new MapDeclutterModule());
        model.addModule('terrain', new MapTerrainModule());
        model.addModule('ownAirplaneProps', new MapOwnAirplanePropsModule());
        model.addModule('ownAirplaneIcon', new MapOwnAirplaneIconModule());
        model.addModule('rangeRing', new MapRangeRingModule());
        model.addModule('rangeCompass', new MapRangeCompassModule());
        model.addModule('waypoints', new MapWaypointsModule());
        model.addModule('airspace', new MapAirspaceModule());
        model.addModule('traffic', new MapTrafficModule(tcas));
        model.addModule('nexrad', new MapNexradModule());
        model.addModule('pointer', new MapPointerModule());
        model.addModule('crosshair', new MapCrosshairModule());
        return model;
    }
}

/**
 *
 */
class MFDUiPage extends UiPage {
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        this.scrollController.gotoFirst();
        this.setScrollEnabled(false);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onInteractionEvent(evt) {
        // TODO: Move the close operations out of here into their respective views.
        switch (evt) {
            case FmsHEvent.FPL:
                return this.onFPLPressed();
            case FmsHEvent.PROC:
                return this.onPROCPressed();
            case FmsHEvent.DIRECTTO:
                return this.onDirectToPressed();
            case FmsHEvent.MENU:
                return this.onMenuPressed();
        }
        return false;
    }
    /**
     * This method is called when a MENU button event occurs.
     * @returns whether the event was handled.
     */
    onMenuPressed() {
        return false;
    }
    /**
     * This method is called when a PROC button event occurs.
     * @returns whether the event was handled.
     */
    onDirectToPressed() {
        this.props.viewService.open('DirectTo');
        return true;
    }
    /**
     * This method is called when a FPL button event occurs.
     * @returns whether the event was handled.
     */
    onFPLPressed() {
        this.props.viewService.open('FPLPage');
        return true;
    }
    /**
     * This method is called when a PROC button event occurs.
     * @returns whether the event was handled.
     */
    onPROCPressed() {
        this.props.viewService.open('PROC');
        return true;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewClosed() {
        this.setScrollEnabled(false);
    }
}

/**
 * The map layer showing a rotating compass arrow pointing to true north.
 */
class MapMiniCompassLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.imgRef = FSComponent.createRef();
        this.needUpdate = false;
    }
    /** @inheritdoc */
    onAttached() {
        this.needUpdate = true;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.needUpdate = BitFlags.isAll(changeFlags, MapProjectionChangeType.Rotation);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        if (!this.needUpdate) {
            return;
        }
        this.updateRotation();
        this.needUpdate = false;
    }
    /**
     * Updates the rotation of the arrow.
     */
    updateRotation() {
        const rotation = this.props.mapProjection.getRotation();
        this.imgRef.instance.style.transform = `rotate(${rotation}rad)`;
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', style: 'position: relative; width: var(--minicompass-size, 4em); height: var(--minicompass-size, 4em);' },
            FSComponent.buildComponent("img", { ref: this.imgRef, src: this.props.imgSrc, style: 'width: 100%; height: 100%;' }),
            FSComponent.buildComponent("div", { style: 'position: absolute; top: 50%; width: 100%; transform: translateY(-50%); text-align: center; color: black;' }, "N")));
    }
}

/**
 * A component which displays a number with units.
 */
class AbstractNumberUnitDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.valueChangedHandler = this.onValueChanged.bind(this);
        this.displayUnitChangedHandler = this.onDisplayUnitChanged.bind(this);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.value.sub(this.valueChangedHandler, true);
        this.props.displayUnit.sub(this.displayUnitChangedHandler, true);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    destroy() {
        this.props.value.unsub(this.valueChangedHandler);
        this.props.displayUnit.unsub(this.displayUnitChangedHandler);
    }
}

/**
 * A component which displays lat/lon coordinates.
 */
class LatLonDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.locationChangedHandler = this.onLocationChanged.bind(this);
        this.latPrefixSub = Subject.create('');
        this.latNumSub = Subject.create('');
        this.lonPrefixSub = Subject.create('');
        this.lonNumSub = Subject.create('');
        this.formatter = new DmsFormatter();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        this.props.location.sub(this.locationChangedHandler, true);
    }
    /**
     * A callback which is called when this component's bound location changes.
     * @param location The new location.
     */
    onLocationChanged(location) {
        if (isNaN(location.lat) || isNaN(location.lon)) {
            this.clearDisplay();
        }
        else {
            this.setDisplay(location);
        }
    }
    /**
     * Displays the formatted lat/lon coordinates of a location.
     * @param location A location.
     */
    setDisplay(location) {
        this.setCoordSub(this.latPrefixSub, this.latNumSub, this.formatter.parseLat(location.lat), 2);
        this.setCoordSub(this.lonPrefixSub, this.lonNumSub, this.formatter.parseLon(location.lon), 3);
    }
    /**
     * Sets coordinate subjects for a given set of coordinate values.
     * @param prefixSub The coordinate prefix subject.
     * @param numSub The coordinate number subject.
     * @param coordValues The DMS values of the coordinate.
     * @param padDeg The number of digits to which to pad the degrees value.
     */
    setCoordSub(prefixSub, numSub, coordValues, padDeg) {
        const prefix = coordValues.direction;
        let deg = coordValues.degrees;
        let minutes = Math.round((coordValues.minutes + coordValues.seconds / 60) * 100) / 100;
        if (minutes === 60) {
            // need to increment up degrees if minutes was rounded up to 60 from 59.xx.
            deg++;
            minutes = 0;
        }
        prefixSub.set(prefix);
        numSub.set(`${deg.toString().padStart(padDeg, '0')}°${minutes.toFixed(2)}'`);
    }
    /**
     * Displays the blank default value.
     */
    clearDisplay() {
        this.latPrefixSub.set('_');
        this.latNumSub.set('__°__.__\'');
        this.lonPrefixSub.set('_');
        this.lonNumSub.set('___°__.__\'');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' },
            FSComponent.buildComponent("div", { class: 'latlon-coord latlon-lat' },
                FSComponent.buildComponent("div", { class: 'latlon-prefix' }, this.latPrefixSub),
                FSComponent.buildComponent("div", { class: 'latlon-num', style: 'white-space: nowrap;' }, this.latNumSub)),
            FSComponent.buildComponent("div", { class: 'latlon-coord latlon-lon' },
                FSComponent.buildComponent("div", { class: 'latlon-prefix' }, this.lonPrefixSub),
                FSComponent.buildComponent("div", { class: 'latlon-num', style: 'white-space: nowrap;' }, this.lonNumSub))));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    destroy() {
        this.props.location.unsub(this.locationChangedHandler);
    }
}

var DurationDisplayFormat;
(function (DurationDisplayFormat) {
    /** hh:mm:ss. */
    DurationDisplayFormat[DurationDisplayFormat["hh_mm_ss"] = 0] = "hh_mm_ss";
    /** hh:mm. */
    DurationDisplayFormat[DurationDisplayFormat["hh_mm"] = 1] = "hh_mm";
    /** mm:ss. */
    DurationDisplayFormat[DurationDisplayFormat["mm_ss"] = 2] = "mm_ss";
    /** hh:mm if value is greater or equal to 1 hour, otherwise mm:ss. */
    DurationDisplayFormat[DurationDisplayFormat["hh_mm_or_mm_ss"] = 3] = "hh_mm_or_mm_ss";
})(DurationDisplayFormat || (DurationDisplayFormat = {}));
var DurationDisplayDelim;
(function (DurationDisplayDelim) {
    /** Colon (`:`). */
    DurationDisplayDelim[DurationDisplayDelim["Colon"] = 0] = "Colon";
    /** `:` if hh:mm:ss or mm:ss, `+` if hh:mm. */
    DurationDisplayDelim[DurationDisplayDelim["ColonOrCross"] = 1] = "ColonOrCross";
    /** Space (` `). */
    DurationDisplayDelim[DurationDisplayDelim["Space"] = 2] = "Space";
})(DurationDisplayDelim || (DurationDisplayDelim = {}));
/**
 * A component which displays duration values.
 */
class DurationDisplay extends DisplayComponent {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.valueChangedHandler = this.onValueChanged.bind(this);
        this.options = Object.assign({}, DurationDisplay.DEFAULT_OPTIONS, this.props.options);
        this.textSub = Subject.create('');
        switch (this.options.delim) {
            case DurationDisplayDelim.Colon:
                this.delim = ':';
                break;
            case DurationDisplayDelim.Space:
                this.delim = ' ';
                break;
            default:
                this.delim = '';
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        this.props.value.sub(this.valueChangedHandler);
    }
    /**
     * A callback which is called when this component's bound value changes.
     * @param value The new value.
     */
    onValueChanged(value) {
        this.setDisplay(value);
    }
    /**
     * Displays this component's current value.
     * @param value The current value.
     */
    setDisplay(value) {
        let text;
        if (value.isNaN()) {
            text = this.options.nanString;
        }
        else {
            let hrText = '';
            let minText = '';
            let secText = '';
            let hrUnitText = '';
            let minUnitText = '';
            let secUnitText = '';
            let hrDelim = '';
            let minDelim = '';
            const hours = Math.floor(value.asUnit(UnitType.HOUR));
            if (this.options.format != DurationDisplayFormat.mm_ss && !(this.options.format === DurationDisplayFormat.hh_mm_or_mm_ss && hours == 0)) {
                hrText = hours.toFixed(0);
                if (this.options.delim === DurationDisplayDelim.ColonOrCross) {
                    if (this.options.format === DurationDisplayFormat.hh_mm_or_mm_ss || this.options.format === DurationDisplayFormat.hh_mm) {
                        hrDelim = '+';
                    }
                    else {
                        hrDelim = ':';
                    }
                }
                else {
                    hrDelim = this.delim;
                }
            }
            let minutes;
            let seconds;
            if (this.options.format === DurationDisplayFormat.hh_mm || (this.options.format === DurationDisplayFormat.hh_mm_or_mm_ss && hours !== 0)) {
                minutes = value.asUnit(UnitType.MINUTE) % 60;
                minText = this.options.numberFormatter(minutes);
            }
            else {
                minutes = Math.floor(value.asUnit(UnitType.MINUTE) - hours * 60);
                minText = minutes.toFixed(0);
                minDelim = this.options.delim === DurationDisplayDelim.ColonOrCross ? ':' : this.delim;
                seconds = value.asUnit(UnitType.SECOND) % 60;
                secText = this.options.numberFormatter(seconds);
            }
            if (secText && secText.replace(/\b0+/, '').substring(0, 2) === '60') {
                secText = this.options.numberFormatter(parseFloat(secText) - 60);
                minText = `${minutes + 1}`;
            }
            if (minText && minText.replace(/\b0+/, '').substring(0, 2) === '60' && hrText) {
                if (secText) {
                    minText = '00';
                }
                else {
                    minText = this.options.numberFormatter(parseFloat(minText) - 60);
                }
                hrText = `${(hours + 1)}`;
            }
            // pad parts with leading zeroes
            if (hrText) {
                hrText = hrText.padStart(this.options.pad, '0');
                if (secText) {
                    minText = minText.padStart(2, '0');
                    secText = DurationDisplay.padIntegerPart(secText.replace(/^0+/, ''), 2, '0');
                }
                else {
                    minText = DurationDisplay.padIntegerPart(minText.replace(/^0+/, ''), 2, '0');
                }
            }
            else {
                minText = minText.padStart(this.options.pad, '0');
                secText = DurationDisplay.padIntegerPart(secText.replace(/^0+/, ''), 2, '0');
            }
            // format units
            if (this.options.showUnits) {
                hrText && (hrUnitText = this.options.unitFormatter(parseFloat(hrText), UnitType.HOUR));
                minUnitText = this.options.unitFormatter(parseFloat(minText), UnitType.MINUTE);
                secText && (secUnitText = this.options.unitFormatter(parseFloat(secText), UnitType.SECOND));
            }
            text = `${hrText}${hrUnitText}${hrDelim}${minText}${minUnitText}${minDelim}${secText}${secUnitText}`;
        }
        this.textSub.set(text);
    }
    /**
     * Pads the integer part of a string which represents a number.
     * @param str A string which represents a number.
     * @param maxLength The length to which the integer part of the string will be padded.
     * @param fillString The string with which to pad the original string.
     * @returns a new string which is the result of padding the original string.
     */
    static padIntegerPart(str, maxLength, fillString) {
        const decimalIndex = str.indexOf('.');
        return str.padStart(decimalIndex < 0 ? maxLength : str.length - decimalIndex + maxLength, fillString);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', style: 'white-space: nowrap;' }, this.textSub));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    destroy() {
        this.props.value.unsub(this.valueChangedHandler);
    }
}
/** Default formatting options. */
DurationDisplay.DEFAULT_OPTIONS = {
    pad: 0,
    format: DurationDisplayFormat.hh_mm_ss,
    delim: DurationDisplayDelim.Colon,
    showUnits: false,
    numberFormatter: (value) => value.toFixed(0),
    unitFormatter: (value, unit) => unit.name[0],
    nanString: ''
};

/**
 * A component which displays a number with units.
 */
class NumberUnitDisplay extends AbstractNumberUnitDisplay {
    constructor() {
        super(...arguments);
        this.unitTextBigRef = FSComponent.createRef();
        this.numberTextSub = Subject.create('');
        this.unitTextBigSub = Subject.create('');
        this.unitTextSmallSub = Subject.create('');
    }
    /** @inheritdoc */
    onAfterRender() {
        super.onAfterRender();
        // We have to hide the "big" unit text when empty because an empty string will get rendered as a space.
        this.unitTextBigSub.sub((text) => { this.unitTextBigRef.instance.style.display = text === '' ? 'none' : ''; }, true);
    }
    /** @inheritdoc */
    onValueChanged(value) {
        this.setDisplay(value, this.props.displayUnit.get());
    }
    /** @inheritdoc */
    onDisplayUnitChanged(displayUnit) {
        this.setDisplay(this.props.value.get(), displayUnit);
    }
    /**
     * Displays this component's current value.
     * @param value The current value.
     * @param displayUnit The current display unit.
     */
    setDisplay(value, displayUnit) {
        var _a;
        if (!displayUnit || !value.unit.canConvert(displayUnit)) {
            displayUnit = value.unit;
        }
        const numberText = this.props.formatter(value.asUnit(displayUnit));
        this.numberTextSub.set(numberText);
        const unitText = (_a = (NumberUnitDisplay.UNIT_TEXT[displayUnit.family] ? NumberUnitDisplay.UNIT_TEXT[displayUnit.family][displayUnit.name] : undefined)) !== null && _a !== void 0 ? _a : '';
        if (unitText[0] === '°') {
            this.unitTextBigSub.set('°');
            this.unitTextSmallSub.set(unitText.substring(1));
        }
        else {
            this.unitTextBigSub.set('');
            this.unitTextSmallSub.set(unitText);
        }
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', style: 'white-space: nowrap;' },
            FSComponent.buildComponent("span", { class: 'numberunit-num' }, this.numberTextSub),
            FSComponent.buildComponent("span", { ref: this.unitTextBigRef, class: 'numberunit-unit-big' }, this.unitTextBigSub),
            FSComponent.buildComponent("span", { class: 'numberunit-unit-small' }, this.unitTextSmallSub)));
    }
}
NumberUnitDisplay.UNIT_TEXT = {
    [UnitFamily.DISTANCE]: {
        [UnitType.METER.name]: 'M',
        [UnitType.FOOT.name]: 'FT',
        [UnitType.KILOMETER.name]: 'KM',
        [UnitType.NMILE.name]: 'NM'
    },
    [UnitFamily.ANGLE]: {
        [UnitType.DEGREE.name]: '°',
        [UnitType.RADIAN.name]: 'rad'
    },
    [UnitFamily.DURATION]: {
        [UnitType.SECOND.name]: 'S',
        [UnitType.MINUTE.name]: 'M',
        [UnitType.HOUR.name]: 'H'
    },
    [UnitFamily.WEIGHT]: {
        [UnitType.KILOGRAM.name]: 'KG',
        [UnitType.POUND.name]: 'LB',
        [UnitType.LITER_FUEL.name]: 'L',
        [UnitType.GALLON_FUEL.name]: 'GAL'
    },
    [UnitFamily.VOLUME]: {
        [UnitType.LITER.name]: 'L',
        [UnitType.GALLON.name]: 'GAL'
    },
    [UnitFamily.PRESSURE]: {
        [UnitType.HPA.name]: 'HPA',
        [UnitType.IN_HG.name]: 'INHG'
    },
    [UnitFamily.TEMP]: {
        [UnitType.CELSIUS.name]: '°C',
        [UnitType.FAHRENHEIT.name]: '°F'
    },
    [UnitType.KNOT.family]: {
        [UnitType.KNOT.name]: 'KT',
        [UnitType.KPH.name]: 'KH',
        [UnitType.MPM.name]: 'MPM',
        [UnitType.FPM.name]: 'FPM'
    },
    [UnitType.LPH_FUEL.family]: {
        [UnitType.KGH.name]: 'KGH',
        [UnitType.PPH.name]: 'PPH',
        [UnitType.LPH_FUEL.name]: 'LPH',
        [UnitType.GPH_FUEL.name]: 'GPH'
    }
};

/**
 * The map layer showing the range display.
 */
class MapRangeDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.displayUnitSub = Subject.create(null);
        this.autoSubject = Subject.create('false');
        this.autoOverrideSubject = Subject.create('false');
        this.displayUnitHandler = this.updateDisplayUnit.bind(this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        this.props.range.sub(this.displayUnitHandler);
        this.props.displayUnit.sub(this.displayUnitHandler, true);
    }
    /**
     * Updates this component's display unit.
     */
    updateDisplayUnit() {
        const nominalDisplayUnit = this.props.displayUnit.get();
        const range = this.props.range.get();
        let displayUnit;
        if (nominalDisplayUnit && nominalDisplayUnit.equals(UnitType.NMILE)) {
            if (range.asUnit(UnitType.FOOT) <= 2501) {
                displayUnit = UnitType.FOOT;
            }
            else {
                displayUnit = UnitType.NMILE;
            }
        }
        else if (nominalDisplayUnit && nominalDisplayUnit.equals(UnitType.KILOMETER)) {
            if (range.asUnit(UnitType.METER) < 999) {
                displayUnit = UnitType.METER;
            }
            else {
                displayUnit = UnitType.KILOMETER;
            }
        }
        else {
            displayUnit = nominalDisplayUnit;
        }
        this.displayUnitSub.set(displayUnit);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent("div", { class: `map-range-display${this.props.class ? ` ${this.props.class}` : ''}`, auto: this.autoSubject, "auto-override": this.autoOverrideSubject, style: 'display: flex; flex-flow: column nowrap; align-items: center;' },
            FSComponent.buildComponent("div", { class: 'map-range-display-auto', style: 'display: none;' }, "AUTO"),
            FSComponent.buildComponent(NumberUnitDisplay, { value: this.props.range, displayUnit: this.displayUnitSub, formatter: NumberFormatter.create({ precision: 0.01, forceDecimalZeroes: false, maxDigits: 3 }) })));
    }
}

/**
 * A map layer which draws a range compass in front of the map target.
 */
class MapRangeCompassLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.rootRef = FSComponent.createRef();
        this.arcLayerRef = FSComponent.createRef();
        this.roseLayerContainerRef = FSComponent.createRef();
        this.roseLayerRef = FSComponent.createRef();
        this.referenceMarkerContainerRef = FSComponent.createRef();
        this.roseLabelsLayerRef = FSComponent.createRef();
        this.headingIndicatorRef = FSComponent.createRef();
        this.rangeDisplayContainerRef = FSComponent.createRef();
        this.centerSubject = Vec2Subject.createFromVector(new Float64Array(2));
        this.radiusSubject = Subject.create(0);
        this.rotationSubject = Subject.create(0);
        this.isMagneticSubject = Subject.create(true);
        this.referenceMarkerTypeSub = Subject.create(MapRangeCompassReferenceMarkerType.TICK);
        this.needUpdateRootVisibility = false;
        this.needRedrawArc = true;
        this.needRedrawBearings = true;
        this.needRotateBearingTicks = true;
        this.needRechooseReferenceMarker = true;
        this.needRepositionReferenceMarker = true;
        this.needReclipTicks = true;
        this.needUpdateHeadingIndicatorVisibility = true;
        this.needRepositionLabel = true;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onVisibilityChanged(isVisible) {
        this.needUpdateRootVisibility = true;
        if (isVisible) {
            this.needRechooseReferenceMarker = true;
            this.updateParameters();
        }
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.arcLayerRef.instance.onAttached();
        this.roseLayerRef.instance.onAttached();
        this.roseLabelsLayerRef.instance.onAttached();
        this.referenceMarkerContainerRef.instance.onAttached();
        this.headingIndicatorRef.instance.onAttached();
        this.initStyles();
        this.initListeners();
        this.updateVisibility();
        this.updateParameters();
    }
    /**
     * Initializes ring styles.
     */
    initStyles() {
        const bearingLabelLayerDisplay = this.roseLabelsLayerRef.instance.display;
        bearingLabelLayerDisplay.context.lineWidth = this.props.bearingLabelOutlineWidth * 2;
        bearingLabelLayerDisplay.context.strokeStyle = 'black';
        bearingLabelLayerDisplay.context.font = `${this.props.bearingLabelFontSize}px ${this.props.bearingLabelFont}`;
        bearingLabelLayerDisplay.context.fillStyle = 'white';
    }
    /**
     * Initializes listeners.
     */
    initListeners() {
        this.initParameterListeners();
        this.initModuleListeners();
        this.props.showHeadingBug.sub(() => {
            this.needRechooseReferenceMarker = true;
            this.needUpdateHeadingIndicatorVisibility = true;
        });
    }
    /**
     * Initializes parameter listeners.
     */
    initParameterListeners() {
        this.centerSubject.sub(this.onCenterChanged.bind(this));
        this.radiusSubject.sub(this.onRadiusChanged.bind(this));
        this.rotationSubject.sub(this.onRotationChanged.bind(this));
        this.isMagneticSubject.sub(this.onIsMagneticChanged.bind(this));
    }
    /**
     * Initializes modules listeners.
     */
    initModuleListeners() {
        const rangeModule = this.props.model.getModule('range');
        rangeModule.nominalRange.sub(this.onRangeChanged.bind(this));
        const orientationModule = this.props.model.getModule('orientation');
        orientationModule.orientation.sub(this.onOrientationChanged.bind(this));
        const rangeRingModule = this.props.model.getModule('rangeCompass');
        rangeRingModule.show.sub(this.onRangeCompassShowChanged.bind(this));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.arcLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        this.roseLabelsLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        if (this.props.showHeadingBug) {
            this.headingIndicatorRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        }
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            // resizing the map will cause synced canvas layers to clear themselves, so we need to force a redraw on these
            // layers.
            this.needRedrawArc = true;
            this.needRedrawBearings = true;
            // we also need to re-initialize the styles on these canvases since these are also cleared.
            this.initStyles();
        }
        if (!this.isVisible()) {
            return;
        }
        this.updateParameters();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        if (this.needUpdateRootVisibility) {
            this.updateRootVisibility();
            this.needUpdateRootVisibility = false;
        }
        this.redraw();
        this.updateSubLayers(time, elapsed);
    }
    /**
     * Updates the visibility of this layer's root.
     */
    updateRootVisibility() {
        this.rootRef.instance.style.display = this.isVisible() ? 'block' : 'none';
    }
    /**
     * Redraws the compass.
     */
    redraw() {
        this.redrawArc();
        this.redrawBearings();
        this.updateReferenceMarker();
        this.updateHeadingIndicator();
        if (this.props.showLabel) {
            this.updateLabel();
        }
    }
    /**
     * Redraws the arc of the compass.
     */
    redrawArc() {
        if (!this.needRedrawArc) {
            return;
        }
        const arcLayerDisplay = this.arcLayerRef.instance.display;
        arcLayerDisplay.clear();
        const center = this.centerSubject.get();
        const radius = this.radiusSubject.get();
        const angularWidthRad = MapRangeCompassLayer.ARC_ANGULAR_WIDTH * Avionics.Utils.DEG2RAD;
        const startAngle = -Math.PI / 2 - angularWidthRad / 2;
        const endAngle = -Math.PI / 2 + angularWidthRad / 2;
        const leftTickStart = Vec2Math.add(Vec2Math.setFromPolar(radius + this.props.arcEndTickLength, startAngle, MapRangeCompassLayer.vec2Cache[0]), center, MapRangeCompassLayer.vec2Cache[0]);
        const leftTickEnd = Vec2Math.add(Vec2Math.setFromPolar(radius, startAngle, MapRangeCompassLayer.vec2Cache[1]), center, MapRangeCompassLayer.vec2Cache[1]);
        const rightTickStart = Vec2Math.add(Vec2Math.setFromPolar(radius, endAngle, MapRangeCompassLayer.vec2Cache[2]), center, MapRangeCompassLayer.vec2Cache[2]);
        const rightTickEnd = Vec2Math.add(Vec2Math.setFromPolar(radius + this.props.arcEndTickLength, endAngle, MapRangeCompassLayer.vec2Cache[3]), center, MapRangeCompassLayer.vec2Cache[3]);
        this.composeArcPath(center, radius, angularWidthRad, leftTickStart, leftTickEnd, rightTickStart, rightTickEnd);
        arcLayerDisplay.context.lineWidth = this.props.arcStrokeWidth;
        arcLayerDisplay.context.strokeStyle = 'white';
        arcLayerDisplay.context.stroke();
        this.needRedrawArc = false;
    }
    /**
     * Composes the path of the compass arc.
     * @param center The center of the compass, in pixels.
     * @param radius The radius of the compass, in pixels.
     * @param angularWidth The angular width of the arc, in radians.
     * @param leftTickStart The position of the start of the left end tick, in pixels.
     * @param leftTickEnd The position of the end of the left end tick, in pixels.
     * @param rightTickStart The position of the start of the right end tick, in pixels.
     * @param rightTickEnd The position of the end of the right end tick, in pixels.
     */
    composeArcPath(center, radius, angularWidth, leftTickStart, leftTickEnd, rightTickStart, rightTickEnd) {
        const arcLayerDisplay = this.arcLayerRef.instance.display;
        arcLayerDisplay.context.beginPath();
        arcLayerDisplay.context.moveTo(leftTickStart[0], leftTickStart[1]);
        arcLayerDisplay.context.lineTo(leftTickEnd[0], leftTickEnd[1]);
        arcLayerDisplay.context.arc(center[0], center[1], radius, (-angularWidth - Math.PI) / 2, (angularWidth - Math.PI) / 2);
        arcLayerDisplay.context.lineTo(rightTickEnd[0], rightTickEnd[1]);
    }
    /**
     * Redraws the bearing tick and labels.
     */
    redrawBearings() {
        if (!this.needRedrawBearings && !this.needRotateBearingTicks) {
            return;
        }
        this.roseLabelsLayerRef.instance.redraw();
        this.roseLayerRef.instance.updateRotation();
        this.needRotateBearingTicks = false;
        if (!this.needRedrawBearings && !this.needReclipTicks) {
            return;
        }
        if (this.needReclipTicks) {
            this.updateBearingTickClip();
        }
        this.roseLayerRef.instance.redraw();
        this.needRedrawBearings = false;
    }
    /**
     * Updates the bearing tick clip mask.
     */
    updateBearingTickClip() {
        const center = this.centerSubject.get();
        const radius = this.radiusSubject.get();
        const thick = this.props.arcStrokeWidth / 2;
        const innerToOuterLength = this.props.arcEndTickLength + thick + 5;
        const totalRadius = radius + this.props.arcEndTickLength + thick / 2 + 5;
        const leftAngle = -MapRangeCompassLayer.ARC_ANGULAR_WIDTH / 2 * Avionics.Utils.DEG2RAD - Math.PI / 2;
        const leftInner1 = Vec2Math.setFromPolar(radius - thick / 2, leftAngle, MapRangeCompassLayer.vec2Cache[0]);
        const leftInner2 = Vec2Math.setFromPolar(thick / 2, leftAngle - Math.PI / 2, MapRangeCompassLayer.vec2Cache[1]);
        const leftOuter = Vec2Math.setFromPolar(innerToOuterLength, leftAngle, MapRangeCompassLayer.vec2Cache[2]);
        const outerWidth = Math.abs(leftInner1[0] + leftInner2[0] + leftOuter[0]) * 2;
        this.roseLayerContainerRef.instance.style.webkitClipPath // the cast is to avoid typescript complaining webkitCliPath doesn't exist
            = `path('M${center[0]},${center[1]} l${leftInner1[0]},${leftInner1[1]} l${leftInner2[0]},${leftInner2[1]} l${leftOuter[0]},${leftOuter[1]} a${totalRadius},${totalRadius},0,0,1,${outerWidth},0 l${leftInner2[0]},${-leftInner2[1]} l${leftInner1[0]},${-leftInner1[1]} Z')`;
        this.needReclipTicks = false;
    }
    /**
     * Redraws the reference marker.
     */
    updateReferenceMarker() {
        if (!this.needRechooseReferenceMarker && !this.needRepositionReferenceMarker) {
            return;
        }
        if (this.needRechooseReferenceMarker) {
            const orientation = this.props.model.getModule('orientation').orientation.get();
            const type = (this.props.showHeadingBug.get() && orientation === MapOrientation.HeadingUp)
                ? MapRangeCompassReferenceMarkerType.ARROW
                : MapRangeCompassReferenceMarkerType.TICK;
            this.referenceMarkerTypeSub.set(type);
            this.needRechooseReferenceMarker = false;
        }
        if (!this.needRepositionReferenceMarker) {
            return;
        }
        this.referenceMarkerContainerRef.instance.reposition();
        this.needRepositionReferenceMarker = false;
    }
    /**
     * Updates the selected heading indicator.
     */
    updateHeadingIndicator() {
        if (!this.needUpdateHeadingIndicatorVisibility) {
            return;
        }
        const orientation = this.props.model.getModule('orientation').orientation.get();
        this.headingIndicatorRef.instance.setVisible(this.props.showHeadingBug.get() && orientation === MapOrientation.HeadingUp);
        this.needUpdateHeadingIndicatorVisibility = false;
    }
    /**
     * Updates the range display label.
     */
    updateLabel() {
        if (!this.needRepositionLabel) {
            return;
        }
        const center = this.centerSubject.get();
        const radius = this.radiusSubject.get();
        const pos = Vec2Math.add(Vec2Math.setFromPolar(radius, MapRangeCompassLayer.RANGE_LABEL_RADIAL_ANGLE * Avionics.Utils.DEG2RAD, MapRangeCompassLayer.vec2Cache[0]), center, MapRangeCompassLayer.vec2Cache[0]);
        this.rangeDisplayContainerRef.instance.style.left = `${pos[0]}px`;
        this.rangeDisplayContainerRef.instance.style.top = `${pos[1]}px`;
        this.needRepositionLabel = false;
    }
    /**
     * Updates this layer's sublayers.
     * @param time The current time as a UNIX timestamp.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    updateSubLayers(time, elapsed) {
        this.arcLayerRef.instance.onUpdated(time, elapsed);
        this.roseLayerRef.instance.onUpdated(time, elapsed);
        this.roseLabelsLayerRef.instance.onUpdated(time, elapsed);
        this.referenceMarkerContainerRef.instance.onUpdated(time, elapsed);
        if (this.props.showHeadingBug) {
            this.headingIndicatorRef.instance.onUpdated(time, elapsed);
        }
    }
    /**
     * Updates this layer's visibility.
     */
    updateVisibility() {
        this.setVisible(this.props.model.getModule('rangeCompass').show.get());
    }
    /**
     * Updates the ring.
     */
    updateParameters() {
        const center = this.props.mapProjection.getTargetProjected();
        const radius = this.props.model.getModule('range').nominalRange.get().asUnit(UnitType.GA_RADIAN) / this.props.mapProjection.getProjectedResolution();
        // TODO: Find a better way to get magvar.
        const rotation = Math.round((this.props.mapProjection.getRotation() + (this.isMagneticSubject.get() ? SimVar.GetSimVarValue('GPS MAGVAR', 'radians') : 0)) * 1e4) / 1e4;
        this.centerSubject.set(center);
        this.radiusSubject.set(radius);
        this.rotationSubject.set(rotation);
    }
    /**
     * A callback which is called when the center of the compass changes.
     * @param center The new center of the compass, in pixels.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onCenterChanged(center) {
        this.needRedrawArc = true;
        this.needRedrawBearings = true;
        this.needRepositionReferenceMarker = true;
        this.needReclipTicks = true;
        this.needRepositionLabel = true;
    }
    /**
     * A callback which is called when the center of the compass changes.
     * @param radius The new radius of the compass, in pixels.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onRadiusChanged(radius) {
        this.needRedrawArc = true;
        this.needRedrawBearings = true;
        this.needRepositionReferenceMarker = true;
        this.needReclipTicks = true;
        this.needRepositionLabel = true;
    }
    /**
     * A callback which is called when the rotation of the compass changes.
     * @param angle The new rotation angle of the compass, in radians.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onRotationChanged(angle) {
        this.needRotateBearingTicks = true;
    }
    /**
     * A callback which is called when whether the compass should display magnetic bearings changes.
     * @param isMagnetic Whether the compass should display magnetic bearings.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onIsMagneticChanged(isMagnetic) {
        this.updateParameters();
    }
    /**
     * A callback which is called when the nominal map range changes.
     * @param range The new nominal map range.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onRangeChanged(range) {
        if (!this.isVisible()) {
            return;
        }
        this.updateParameters();
    }
    /**
     * A callback which is called when the map orientation changes.
     * @param orientation The new map orientation.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onOrientationChanged(orientation) {
        if (!this.isVisible()) {
            return;
        }
        this.needRechooseReferenceMarker = true;
        this.needUpdateHeadingIndicatorVisibility = true;
    }
    /**
     * A callback which is called when the show range ring property changes.
     * @param show The new value of the show range ring property.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onRangeCompassShowChanged(show) {
        this.updateVisibility();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { ref: this.rootRef, style: 'position: absolute; left: 0; top: 0; width: 100%; height: 100%;' },
            FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.arcLayerRef, model: this.props.model, mapProjection: this.props.mapProjection }),
            FSComponent.buildComponent("div", { ref: this.roseLayerContainerRef, style: 'position: absolute; width: 100%; height: 100%;' },
                FSComponent.buildComponent(MapRangeCompassRose, { ref: this.roseLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, compassCenterSubject: this.centerSubject, compassRadiusSubject: this.radiusSubject, compassRotationSubject: this.rotationSubject, tickMajorInterval: MapRangeCompassLayer.BEARING_TICK_MAJOR_INTERVAL, tickMinorMultiplier: MapRangeCompassLayer.BEARING_TICK_MINOR_FACTOR, tickMajorLength: this.props.bearingTickMajorLength, tickMinorLength: this.props.bearingTickMinorLength, tickStrokeWidth: this.props.arcStrokeWidth })),
            FSComponent.buildComponent(MapRangeCompassReferenceMarkerContainer, { ref: this.referenceMarkerContainerRef, model: this.props.model, mapProjection: this.props.mapProjection, compassCenterSubject: this.centerSubject, compassRadiusSubject: this.radiusSubject, compassRotationSubject: this.rotationSubject, activeType: this.referenceMarkerTypeSub, tickWidth: this.props.referenceTickWidth, tickHeight: this.props.referenceTickHeight, arrowWidth: this.props.referenceArrowWidth, arrowHeight: this.props.referenceArrowHeight }),
            this.renderSelectedHeadingIndicator(),
            FSComponent.buildComponent(MapRangeCompassRoseLabels, { ref: this.roseLabelsLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, compassCenterSubject: this.centerSubject, compassRadiusSubject: this.radiusSubject, compassRotationSubject: this.rotationSubject, angularWidth: MapRangeCompassLayer.ARC_ANGULAR_WIDTH, interval: MapRangeCompassLayer.BEARING_TICK_MAJOR_INTERVAL, font: this.props.bearingLabelFont, fontSize: this.props.bearingLabelFontSize, outlineWidth: this.props.bearingLabelOutlineWidth, radialOffset: this.props.bearingTickMajorLength + this.props.bearingLabelRadialOffset }),
            this.renderRangeDisplay()));
    }
    /**
     * Renders the selected heading indicator.
     * @returns a VNode representing the range display label.
     */
    renderSelectedHeadingIndicator() {
        return this.props.showHeadingBug
            ? (FSComponent.buildComponent(MapRangeCompassSelectedHeading, { ref: this.headingIndicatorRef, model: this.props.model, mapProjection: this.props.mapProjection, bus: this.props.bus, compassCenterSubject: this.centerSubject, compassRadiusSubject: this.radiusSubject, compassRotationSubject: this.rotationSubject, bugWidth: this.props.headingBugWidth, bugHeight: this.props.headingBugHeight, bugNotchHeight: this.props.referenceArrowHeight / 3, bugNotchWidth: this.props.referenceArrowWidth / 3, outlineWidth: 1, lineWidth: this.props.arcStrokeWidth, lineDash: [this.props.arcStrokeWidth * 3, this.props.arcStrokeWidth * 3] }))
            : (FSComponent.buildComponent("div", { style: 'display: none;' }));
    }
    /**
     * Renders the range display label.
     * @returns a VNode representing the range display label.
     */
    renderRangeDisplay() {
        // TODO: Add customizable display unit support.
        const rangeModule = this.props.model.getModule('range');
        return this.props.showLabel
            ? (FSComponent.buildComponent("div", { ref: this.rangeDisplayContainerRef, style: 'position: absolute; transform: translate(-50%, -50%);' },
                FSComponent.buildComponent(MapRangeDisplay, { range: rangeModule.nominalRange, displayUnit: Subject.create(UnitType.NMILE) })))
            : null;
    }
}
/** The angular width of the compass arc, in degrees. */
MapRangeCompassLayer.ARC_ANGULAR_WIDTH = 120;
/** The angular interval, in degrees, between major bearing ticks. */
MapRangeCompassLayer.BEARING_TICK_MAJOR_INTERVAL = 30;
/** The number of minor bearing ticks per major bearing tick. */
MapRangeCompassLayer.BEARING_TICK_MINOR_FACTOR = 3;
/** The radial on which the range label is positioned, in degrees. */
MapRangeCompassLayer.RANGE_LABEL_RADIAL_ANGLE = -135;
MapRangeCompassLayer.vec2Cache = Array.from({ length: 4 }, () => new Float64Array(2));
/**
 * A rotating compass rose with unlabeled graduated bearing ticks.
 */
class MapRangeCompassRose extends MapCanvasLayer {
    constructor() {
        super(...arguments);
        this.bearingStep = this.props.tickMajorInterval / this.props.tickMinorMultiplier * Avionics.Utils.DEG2RAD;
        this.numMinorBearingTicks = Math.floor(2 * Math.PI / this.bearingStep);
    }
    /**
     * Redraws the canvas.
     */
    redraw() {
        const display = this.display;
        const center = this.props.compassCenterSubject.get();
        const radius = this.props.compassRadiusSubject.get();
        const canvasSize = Math.ceil(radius) * 2;
        this.setWidth(canvasSize);
        this.setHeight(canvasSize);
        display.canvas.style.left = `${center[0] - canvasSize / 2}px`;
        display.canvas.style.top = `${center[1] - canvasSize / 2}px`;
        display.clear();
        this.composeBearingTicksPath(radius);
        display.context.lineWidth = this.props.tickStrokeWidth;
        display.context.strokeStyle = 'white';
        display.context.stroke();
    }
    /**
     * Composes the path of the bearing ticks.
     * @param radius The radius of the compass, in pixels.
     */
    composeBearingTicksPath(radius) {
        const canvasSize = this.getWidth();
        const center = Vec2Math.set(canvasSize / 2, canvasSize / 2, MapRangeCompassRose.vec2Cache[0]);
        const display = this.display;
        display.context.beginPath();
        for (let i = 0; i < this.numMinorBearingTicks; i++) {
            const bearing = i * this.bearingStep;
            const angle = bearing - Math.PI / 2;
            let start;
            if (i % MapRangeCompassLayer.BEARING_TICK_MINOR_FACTOR === 0) {
                // major tick
                start = Vec2Math.add(Vec2Math.setFromPolar(radius - this.props.tickMajorLength, angle, MapRangeCompassRose.vec2Cache[1]), center, MapRangeCompassRose.vec2Cache[1]);
            }
            else {
                // minor tick
                start = Vec2Math.add(Vec2Math.setFromPolar(radius - this.props.tickMinorLength, angle, MapRangeCompassRose.vec2Cache[1]), center, MapRangeCompassRose.vec2Cache[1]);
            }
            const end = Vec2Math.add(Vec2Math.setFromPolar(radius, angle, MapRangeCompassRose.vec2Cache[2]), center, MapRangeCompassRose.vec2Cache[2]);
            display.context.moveTo(start[0], start[1]);
            display.context.lineTo(end[0], end[1]);
        }
    }
    /**
     * Updates the rotation of this rose.
     */
    updateRotation() {
        const display = this.display;
        display.canvas.style.transform = `rotate(${this.props.compassRotationSubject.get()}rad)`;
    }
}
MapRangeCompassRose.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2)];
/**
 * Bearing labels for a rotating range compass rose.
 */
class MapRangeCompassRoseLabels extends MapSyncedCanvasLayer {
    /**
     * Redraws the bearing labels.
     */
    redraw() {
        const display = this.display;
        display.clear();
        const PI2 = Math.PI * 2;
        const center = this.props.compassCenterSubject.get();
        const radius = this.props.compassRadiusSubject.get();
        const rotation = this.props.compassRotationSubject.get();
        const halfAngularWidth = this.props.angularWidth / 2 * Avionics.Utils.DEG2RAD;
        const centerBearing = (-rotation + PI2) % PI2;
        const intervalRad = this.props.interval * Avionics.Utils.DEG2RAD;
        for (let bearing = 0; bearing < PI2; bearing += intervalRad) {
            if (Math.min(Math.abs(bearing - centerBearing), PI2 - Math.abs(bearing - centerBearing)) > halfAngularWidth) {
                continue;
            }
            this.drawBearingLabel(center, radius, rotation, bearing);
        }
    }
    /**
     * Draws a bearing label.
     * @param center The center of the compass, in pixels.
     * @param radius The radius of the compass, in pixels.
     * @param rotation The rotation of the compass, in radians.
     * @param bearing The label's bearing, in radians.
     */
    drawBearingLabel(center, radius, rotation, bearing) {
        const display = this.display;
        // TODO: support the T superscript for true bearings.
        const text = (360 - (360 - (bearing * Avionics.Utils.RAD2DEG)) % 360).toFixed(0).padStart(3, '0');
        const angle = bearing - Math.PI / 2 + rotation;
        const textWidth = display.context.measureText(text).width;
        const textHeight = this.props.fontSize;
        const textOffset = Math.hypot(textWidth, textHeight) / 2 + this.props.radialOffset;
        const textRadius = radius - textOffset;
        const labelPos = Vec2Math.add(Vec2Math.setFromPolar(textRadius, angle, MapRangeCompassRoseLabels.vec2Cache[0]), Vec2Math.set(center[0] - textWidth / 2, center[1] + textHeight / 2, MapRangeCompassRoseLabels.vec2Cache[1]), MapRangeCompassRoseLabels.vec2Cache[0]);
        if (this.props.outlineWidth > 0) {
            display.context.strokeText(text, labelPos[0], labelPos[1]);
        }
        display.context.fillText(text, labelPos[0], labelPos[1]);
    }
}
MapRangeCompassRoseLabels.vec2Cache = [new Float64Array(2), new Float64Array(2)];
/**
 * A reference arrow for MapRangeCompassLayer.
 */
class MapRangeCompassReferenceArrow extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
    }
    /**
     * Sets whether this marker should be visible. This method has no effect if this marker has not been rendered.
     * @param val Whether this marker should be visible.
     */
    setVisible(val) {
        if (!this.svgRef.instance) {
            return;
        }
        this.svgRef.instance.style.display = val ? 'block' : 'none';
    }
    /**
     * Sets this marker's position. The provided position should be the position of the middle of the range compass arc.
     * This method has no effect if this marker has not been rendered.
     * @param pos The new position, in pixels.
     */
    setPosition(pos) {
        if (!this.svgRef.instance) {
            return;
        }
        const svg = this.svgRef.instance;
        svg.style.left = `${pos[0]}px`;
        svg.style.top = `${pos[1]}px`;
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("svg", { ref: this.svgRef, viewBox: '0 0 100 100', preserveAspectRatio: 'none', style: `display: none; position: absolute; width: ${this.props.width}px; height: ${this.props.height}px; transform: translate(-50%, -66.7%);` },
            FSComponent.buildComponent("path", { d: 'M 0 0 L 100 0 L 50 100 Z', fill: 'white' })));
    }
}
/**
 * A reference tick for MapRangeCompassLayer.
 */
class MapRangeCompassReferenceTick extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
    }
    /**
     * Sets whether this marker should be visible. This method has no effect if this marker has not been rendered.
     * @param val Whether this marker should be visible.
     */
    setVisible(val) {
        if (!this.svgRef.instance) {
            return;
        }
        this.svgRef.instance.style.display = val ? 'block' : 'none';
    }
    /**
     * Sets this marker's position. The provided position should be the position of the middle of the range compass arc.
     * This method has no effect if this marker has not been rendered.
     * @param pos The new position, in pixels.
     */
    setPosition(pos) {
        if (!this.svgRef.instance) {
            return;
        }
        const svg = this.svgRef.instance;
        svg.style.left = `${pos[0]}px`;
        svg.style.top = `${pos[1]}px`;
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("svg", { ref: this.svgRef, viewBox: '0 0 100 100', preserveAspectRatio: 'none', style: `display: none; position: absolute; width: ${this.props.width}px; height: ${this.props.height}px; transform: translate(-50%, -100%);` },
            FSComponent.buildComponent("rect", { x: '0', y: '0', width: '100', height: '100', fill: 'white' })));
    }
}
/**
 *
 */
var MapRangeCompassReferenceMarkerType;
(function (MapRangeCompassReferenceMarkerType) {
    MapRangeCompassReferenceMarkerType[MapRangeCompassReferenceMarkerType["TICK"] = 0] = "TICK";
    MapRangeCompassReferenceMarkerType[MapRangeCompassReferenceMarkerType["ARROW"] = 1] = "ARROW";
})(MapRangeCompassReferenceMarkerType || (MapRangeCompassReferenceMarkerType = {}));
/**
 * A container for range compass reference markers.
 */
class MapRangeCompassReferenceMarkerContainer extends MapLayer {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.referenceTickRef = FSComponent.createRef();
        this.referenceArrowRef = FSComponent.createRef();
        this.activeReferenceMarker = null;
    }
    /** @inheritdoc */
    onAttached() {
        this.props.activeType.sub(this.onActiveTypeChanged.bind(this), true);
    }
    /**
     * Responds to active marker type changes.
     * @param type The active marker type.
     */
    onActiveTypeChanged(type) {
        const selectedReferenceMarker = type === MapRangeCompassReferenceMarkerType.TICK
            ? this.referenceTickRef.instance
            : this.referenceArrowRef.instance;
        const oldActiveMarker = this.activeReferenceMarker;
        if (oldActiveMarker !== selectedReferenceMarker) {
            this.activeReferenceMarker = selectedReferenceMarker;
            oldActiveMarker === null || oldActiveMarker === void 0 ? void 0 : oldActiveMarker.setVisible(false);
            this.activeReferenceMarker.setVisible(true);
            this.reposition();
        }
    }
    /**
     * Repositions the reference marker.
     */
    reposition() {
        var _a;
        const center = this.props.compassCenterSubject.get();
        const radius = this.props.compassRadiusSubject.get();
        const pos = Vec2Math.add(Vec2Math.setFromPolar(radius, -Math.PI / 2, MapRangeCompassReferenceMarkerContainer.tempVec2), center, MapRangeCompassReferenceMarkerContainer.tempVec2);
        (_a = this.activeReferenceMarker) === null || _a === void 0 ? void 0 : _a.setPosition(pos);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { ref: this.containerRef, style: 'position: absolute; width: 100%; height: 100%;' },
            FSComponent.buildComponent(MapRangeCompassReferenceTick, { ref: this.referenceTickRef, width: this.props.tickWidth, height: this.props.tickHeight }),
            FSComponent.buildComponent(MapRangeCompassReferenceArrow, { ref: this.referenceArrowRef, width: this.props.arrowWidth, height: this.props.arrowHeight })));
    }
}
MapRangeCompassReferenceMarkerContainer.tempVec2 = new Float64Array(2);
/**
 * The selected heading bug and heading line for the map range compass layer.
 */
class MapRangeCompassSelectedHeading extends MapLayer {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.canvasLayerRef = FSComponent.createRef();
        this.selectedHeading = 0;
        this.isInit = false;
        this.isSuppressedSubject = Subject.create(true);
        this.suppressTimer = null;
        this.centerSubject = Vec2Subject.createFromVector(new Float64Array(2));
        this.radiusSubject = Subject.create(0);
        this.rotationSubject = Subject.create(0);
        this.isOOBSubject = Subject.create(true);
        this.needRedraw = true;
        this.needReposition = true;
        this.needRotate = true;
        /**
         * A callback which is called when the suppress timer fires.
         */
        this.suppressCallback = () => {
            this.suppressTimer = null;
            this.isSuppressedSubject.set(true);
        };
        /**
         * A callback which is called when the selected heading changes.
         * @param heading The new selected heading, in degrees.
         */
        this.onSelectedHeadingChanged = (heading) => {
            this.selectedHeading = heading;
            this.unsuppress(MapRangeCompassSelectedHeading.UNSUPPRESS_DURATION);
            this.updateParameters();
        };
        this.selectedHeadingConsumer = this.props.bus.getSubscriber().on('heading_select').whenChanged();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        if (this.isInit) {
            this.updateFromVisibility();
        }
    }
    /**
     * Updates this layer according to its current visibility.
     */
    updateFromVisibility() {
        const isVisible = this.isVisible();
        if (isVisible) {
            this.selectedHeadingConsumer.handle(this.onSelectedHeadingChanged);
        }
        else {
            this.selectedHeadingConsumer.off(this.onSelectedHeadingChanged);
            this.suppress();
        }
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.canvasLayerRef.instance.onAttached();
        this.initCanvas();
        this.isInit = true;
        this.initSubjectListeners();
        this.updateFromVisibility();
    }
    /**
     * Initializes canvas width.
     */
    initCanvas() {
        const width = Math.max(this.props.lineWidth, this.props.bugWidth + this.props.outlineWidth * 2);
        this.canvasLayerRef.instance.setWidth(width);
        const canvasLayerDisplay = this.canvasLayerRef.instance.display;
        canvasLayerDisplay.canvas.style.width = `${width}px`;
        canvasLayerDisplay.canvas.style.transformOrigin = '50% 100%';
    }
    /**
     * Initializes subject listeners.
     */
    initSubjectListeners() {
        this.props.compassCenterSubject.sub(this.updateParameters.bind(this));
        this.props.compassRadiusSubject.sub(this.updateParameters.bind(this));
        this.props.compassRotationSubject.sub(this.updateParameters.bind(this));
        this.centerSubject.sub(this.onCenterChanged.bind(this));
        this.radiusSubject.sub(this.onRadiusChanged.bind(this));
        this.rotationSubject.sub(this.onRotationChanged.bind(this));
        this.isSuppressedSubject.sub(this.onIsSuppressedChanged.bind(this));
        this.isOOBSubject.sub(this.onIsOOBChanged.bind(this));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.needReposition = true;
            this.needRedraw = true;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        this.canvasLayerRef.instance.onUpdated(time, elapsed);
        if (this.needReposition) {
            this.reposition();
        }
        else if (this.needRedraw) {
            this.redraw();
        }
        if (this.needRotate) {
            this.rotate();
        }
    }
    /**
     * Repositions the canvas.
     */
    reposition() {
        const center = this.props.compassCenterSubject.get();
        const projectedWidth = this.props.mapProjection.getProjectedSize()[0];
        const projectedHeight = this.props.mapProjection.getProjectedSize()[1];
        // find the distance to the farthest corner.
        const isLeft = center[0] > projectedWidth / 2;
        const isTop = center[1] > projectedHeight / 2;
        const height = Math.hypot(center[0] - (isLeft ? 0 : projectedWidth), center[1] - (isTop ? 0 : projectedHeight));
        this.canvasLayerRef.instance.setHeight(height);
        const canvasLayerDisplay = this.canvasLayerRef.instance.display;
        canvasLayerDisplay.canvas.style.height = `${height}px`;
        canvasLayerDisplay.canvas.style.left = `${center[0] - this.canvasLayerRef.instance.getWidth() / 2}px`;
        canvasLayerDisplay.canvas.style.bottom = `${projectedHeight - center[1]}px`;
        this.needReposition = false;
        this.redraw();
    }
    /**
     * Redraws the canvas.
     */
    redraw() {
        const canvasWidth = this.canvasLayerRef.instance.getWidth();
        const canvasHeight = this.canvasLayerRef.instance.getHeight();
        const radius = this.props.compassRadiusSubject.get();
        const canvasLayerDisplay = this.canvasLayerRef.instance.display;
        canvasLayerDisplay.clear();
        this.redrawLine(canvasWidth, canvasHeight);
        this.redrawBug(canvasWidth, canvasHeight, radius);
        this.needRedraw = false;
    }
    /**
     * Redraws the heading line.
     * @param canvasWidth The width of the canvas, in pixels.
     * @param canvasHeight The height of the canvas, in pixels.
     */
    redrawLine(canvasWidth, canvasHeight) {
        const canvasLayerDisplay = this.canvasLayerRef.instance.display;
        canvasLayerDisplay.context.beginPath();
        canvasLayerDisplay.context.moveTo(canvasWidth / 2, canvasHeight);
        canvasLayerDisplay.context.lineTo(canvasWidth / 2, 0);
        canvasLayerDisplay.context.lineWidth = this.props.lineWidth;
        canvasLayerDisplay.context.strokeStyle = MapRangeCompassSelectedHeading.COLOR;
        canvasLayerDisplay.context.setLineDash(this.props.lineDash);
        canvasLayerDisplay.context.stroke();
    }
    /**
     * Redraws the heading bug.
     * @param canvasWidth The width of the canvas, in pixels.
     * @param canvasHeight The height of the canvas, in pixels.
     * @param radius The radius of the compass, in pixels.
     */
    redrawBug(canvasWidth, canvasHeight, radius) {
        const canvasLayerDisplay = this.canvasLayerRef.instance.display;
        const left = (canvasWidth - this.props.bugWidth) / 2;
        const top = canvasHeight - radius;
        const middle = canvasWidth / 2;
        const right = left + this.props.bugWidth;
        const bottom = top + this.props.bugHeight;
        canvasLayerDisplay.context.beginPath();
        canvasLayerDisplay.context.moveTo(left, top);
        canvasLayerDisplay.context.lineTo(middle - this.props.bugNotchWidth / 2, top);
        canvasLayerDisplay.context.lineTo(middle, top + this.props.bugNotchHeight);
        canvasLayerDisplay.context.lineTo(middle + this.props.bugNotchWidth / 2, top);
        canvasLayerDisplay.context.lineTo(right, top);
        canvasLayerDisplay.context.lineTo(right, bottom);
        canvasLayerDisplay.context.lineTo(left, bottom);
        canvasLayerDisplay.context.closePath();
        canvasLayerDisplay.context.fillStyle = MapRangeCompassSelectedHeading.COLOR;
        canvasLayerDisplay.context.lineWidth = this.props.outlineWidth * 2;
        canvasLayerDisplay.context.strokeStyle = MapRangeCompassSelectedHeading.OUTLINE_COLOR;
        canvasLayerDisplay.context.setLineDash(MapRangeCompassSelectedHeading.NO_LINE_DASH);
        canvasLayerDisplay.context.stroke();
        canvasLayerDisplay.context.fill();
    }
    /**
     * Rotates the canvas.
     */
    rotate() {
        const compassRotation = this.props.compassRotationSubject.get();
        const rotation = this.selectedHeading * Avionics.Utils.DEG2RAD + compassRotation;
        const canvasLayerDisplay = this.canvasLayerRef.instance.display;
        canvasLayerDisplay.canvas.style.transform = `rotate(${rotation}rad)`;
        this.needRotate = false;
    }
    /**
     * Suppresses this indicator, making it invisible. Also kills the suppress timer if it is running.
     */
    suppress() {
        this.killSuppressTimer();
        this.isSuppressedSubject.set(true);
    }
    /**
     * Unsuppresses this indicator, making it visible, for a certain duration. If the suppress timer is currently
     * running, it is killed and replaced with a new one which will fire after the specified duration.
     * @param duration The duration for which to unsuppress, in milliseconds.
     */
    unsuppress(duration) {
        this.killSuppressTimer();
        this.isSuppressedSubject.set(false);
        this.suppressTimer = setTimeout(this.suppressCallback, duration);
    }
    /**
     * Kills the timer to suppress this indicator, if one is currently running.
     */
    killSuppressTimer() {
        if (this.suppressTimer !== null) {
            clearTimeout(this.suppressTimer);
        }
    }
    /**
     * Updates this indicator based on whether it should be suppressed.
     * @param isSuppressed Whether this indicator should be suppressed.
     */
    updateFromIsSuppressed(isSuppressed) {
        this.updateCanvasVisibility(isSuppressed, this.isOOBSubject.get());
    }
    /**
     * Updates this indicator based on whether it is out of the current compass bounds.
     * @param isOOB Whether this indicator is out of the current compass bounds.
     */
    updateFromIsOOB(isOOB) {
        this.updateCanvasVisibility(this.isSuppressedSubject.get(), isOOB);
    }
    /**
     * Updates the visibility of the canvas.
     * @param isSuppressed Whether this indicator is suppressed.
     * @param isOOB Whether this indicator is out of the current compass bounds.
     */
    updateCanvasVisibility(isSuppressed, isOOB) {
        this.canvasLayerRef.instance.setVisible(!isOOB && !isSuppressed);
    }
    /**
     * Updates this indicator's center, radius, and rotation.
     */
    updateParameters() {
        const compassRotation = this.props.compassRotationSubject.get();
        const compassCenter = -compassRotation * Avionics.Utils.RAD2DEG;
        const isOOB = Math.abs(NavMath.diffAngle(this.selectedHeading, compassCenter)) > MapRangeCompassLayer.ARC_ANGULAR_WIDTH / 2;
        this.isOOBSubject.set(isOOB);
        if (!this.canvasLayerRef.instance.isVisible()) {
            return;
        }
        const center = this.props.compassCenterSubject.get();
        const radius = this.props.compassRadiusSubject.get();
        const rotation = compassRotation + this.selectedHeading * Avionics.Utils.DEG2RAD;
        this.centerSubject.set(center);
        this.radiusSubject.set(radius);
        this.rotationSubject.set(rotation);
    }
    /**
     * A callback which is called when the center of the compass changes.
     * @param center The new center of the compass, in pixels.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onCenterChanged(center) {
        this.needReposition = true;
    }
    /**
     * A callback which is called when the center of the compass changes.
     * @param radius The new radius of the compass, in pixels.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onRadiusChanged(radius) {
        this.needRedraw = true;
    }
    /**
     * A callback which is called when the rotation of the compass changes.
     * @param angle The new rotation angle of the compass, in radians.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onRotationChanged(angle) {
        this.needRotate = true;
    }
    /**
     * A callback which is called when whether this indicator is suppressed has changed.
     * @param isSuppressed Whether this indicator is suppressed.
     */
    onIsSuppressedChanged(isSuppressed) {
        this.updateFromIsSuppressed(isSuppressed);
    }
    /**
     * A callback which is called when whether this indicator is out of the current compass bounds has changed.
     * @param isOOB Whether this indicator is out of the current compass bounds.
     */
    onIsOOBChanged(isOOB) {
        this.updateFromIsOOB(isOOB);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(MapCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection }));
    }
}
/** The amount of time, in milliseconds, the indicator is unsuppressed when the selected heading is changed. */
MapRangeCompassSelectedHeading.UNSUPPRESS_DURATION = 3000;
/** The color of the bug and line. */
MapRangeCompassSelectedHeading.COLOR = 'cyan';
/** The outline color of the bug. */
MapRangeCompassSelectedHeading.OUTLINE_COLOR = 'black';
MapRangeCompassSelectedHeading.NO_LINE_DASH = [];

/**
 * A map layer which draws a range ring around the map target.
 */
class MapRangeRingLayer extends MapLabeledRingLayer {
    constructor() {
        super(...arguments);
        this.label = null;
        this.needUpdateRing = false;
    }
    /**
     * Updates this layer according to its current visibility.
     */
    updateFromVisibility() {
        super.updateFromVisibility();
        const isVisible = this.isVisible();
        if (isVisible) {
            this.needUpdateRing = true;
        }
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.initLabel();
        this.initStyles();
        this.initModuleListeners();
        this.updateVisibility();
        this.needUpdateRing = true;
    }
    /**
     * Initializes the range display label.
     */
    initLabel() {
        if (!this.props.showLabel) {
            return;
        }
        // TODO: Add customizable display unit support.
        const rangeModule = this.props.model.getModule('range');
        this.label = this.createLabel(FSComponent.buildComponent(MapRangeDisplay, { range: rangeModule.nominalRange, displayUnit: Subject.create(UnitType.NMILE) }));
        this.label.setAnchor(new Float64Array([0.5, 0.5]));
        this.label.setRadialAngle(225 * Avionics.Utils.DEG2RAD);
    }
    /**
     * Initializes ring styles.
     */
    initStyles() {
        this.setRingStrokeStyles(this.props.strokeWidth, this.props.strokeStyle, this.props.strokeDash);
        this.setRingOutlineStyles(this.props.outlineWidth, this.props.outlineStyle, this.props.outlineDash);
    }
    /**
     * Initializes modules listeners.
     */
    initModuleListeners() {
        const rangeModule = this.props.model.getModule('range');
        rangeModule.nominalRange.sub(this.onRangeChanged.bind(this));
        const rangeRingModule = this.props.model.getModule('rangeRing');
        rangeRingModule.show.sub(this.onRangeRingShowChanged.bind(this));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        super.onMapProjectionChanged(mapProjection, changeFlags);
        if (!this.isVisible()) {
            return;
        }
        this.needUpdateRing = true;
    }
    /**
     * Updates this layer's visibility.
     */
    updateVisibility() {
        this.setVisible(this.props.model.getModule('rangeRing').show.get());
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        if (this.needUpdateRing) {
            this.updateRing();
            this.needUpdateRing = false;
        }
        super.onUpdated(time, elapsed);
    }
    /**
     * Updates the ring.
     */
    updateRing() {
        const center = this.props.mapProjection.getTargetProjected();
        const radius = this.props.model.getModule('range').nominalRange.get().asUnit(UnitType.GA_RADIAN) / this.props.mapProjection.getProjectedResolution();
        this.setRingPosition(center, radius);
    }
    /**
     * A callback which is called when the nominal map range changes.
     * @param range The new nominal map range.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onRangeChanged(range) {
        if (!this.isVisible()) {
            return;
        }
        this.needUpdateRing = true;
    }
    /**
     * A callback which is called when the show range ring property changes.
     * @param show The new value of the show range ring property.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onRangeRingShowChanged(show) {
        this.updateVisibility();
    }
}

/**
 * Displays a terrain color scale.
 */
class MapTerrainScaleIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.rootRef = FSComponent.createRef();
        this.absLabelTextSubs = [
            Subject.create('27000'),
            Subject.create('10000'),
            Subject.create('8000'),
            Subject.create('6000'),
            Subject.create('3000'),
            Subject.create('2000'),
            Subject.create('500'),
            Subject.create('0')
        ];
        this.relLabelTextSubs = [
            Subject.create('−500'),
            Subject.create('−1000'),
            Subject.create('−2000')
        ];
        this.unitTextSub = Subject.create('');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        this.props.show.sub(this.updateDisplay.bind(this));
        this.props.terrainMode.sub(this.updateDisplay.bind(this), true);
    }
    /**
     * Updates the display of this indicator.
     */
    updateDisplay() {
        if (this.props.show.get()) {
            switch (this.props.terrainMode.get()) {
                case MapTerrainMode.None:
                    this.rootRef.instance.style.display = 'none';
                    this.rootRef.instance.classList.remove('terrain-abs', 'terrain-rel');
                    this.unitTextSub.set('');
                    break;
                case MapTerrainMode.Absolute:
                    this.rootRef.instance.style.display = '';
                    this.rootRef.instance.classList.remove('terrain-rel');
                    this.rootRef.instance.classList.add('terrain-abs');
                    this.unitTextSub.set('');
                    break;
                case MapTerrainMode.Relative:
                    this.rootRef.instance.style.display = '';
                    this.rootRef.instance.classList.remove('terrain-abs');
                    this.rootRef.instance.classList.add('terrain-rel');
                    this.unitTextSub.set('FT');
                    break;
            }
        }
        else {
            this.rootRef.instance.style.display = 'none';
            this.rootRef.instance.classList.remove('terrain-abs', 'terrain-rel');
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { ref: this.rootRef, class: 'map-terrainscale' },
            FSComponent.buildComponent("div", { class: 'map-terrainscale-scale terrainscale-abs' },
                FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #c8c8c8;' }),
                FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #939393;' },
                    FSComponent.buildComponent("div", { class: 'map-terrainscale-label' }, this.absLabelTextSubs[0])),
                FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #904522;' },
                    FSComponent.buildComponent("div", { class: 'map-terrainscale-label' }, this.absLabelTextSubs[1])),
                FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #904f25;' },
                    FSComponent.buildComponent("div", { class: 'map-terrainscale-label' }, this.absLabelTextSubs[2])),
                FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #9d6434;' },
                    FSComponent.buildComponent("div", { class: 'map-terrainscale-label' }, this.absLabelTextSubs[3])),
                FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #c58f45;' },
                    FSComponent.buildComponent("div", { class: 'map-terrainscale-label' }, this.absLabelTextSubs[4])),
                FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #d0aa43;' },
                    FSComponent.buildComponent("div", { class: 'map-terrainscale-label' }, this.absLabelTextSubs[5])),
                FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #456821;' },
                    FSComponent.buildComponent("div", { class: 'map-terrainscale-label' }, this.absLabelTextSubs[6])),
                FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #427238;' },
                    FSComponent.buildComponent("div", { class: 'map-terrainscale-label' }, this.absLabelTextSubs[7]))),
            FSComponent.buildComponent("div", { class: 'map-terrainscale-scale terrainscale-rel' },
                FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #ff0000' }),
                FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #ffff00;' },
                    FSComponent.buildComponent("div", { class: 'map-terrainscale-label' }, this.relLabelTextSubs[0])),
                FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #00ff00;' },
                    FSComponent.buildComponent("div", { class: 'map-terrainscale-label' }, this.relLabelTextSubs[1])),
                FSComponent.buildComponent("div", { class: 'map-terrainscale-color', style: 'background: #000000;' },
                    FSComponent.buildComponent("div", { class: 'map-terrainscale-label' }, this.relLabelTextSubs[2]))),
            FSComponent.buildComponent("div", { class: 'map-terrainscale-unit' }, this.unitTextSub)));
    }
}

var AirspaceRenderType;
(function (AirspaceRenderType) {
    AirspaceRenderType[AirspaceRenderType["ClassB"] = 0] = "ClassB";
    AirspaceRenderType[AirspaceRenderType["ClassC"] = 1] = "ClassC";
    AirspaceRenderType[AirspaceRenderType["ClassD"] = 2] = "ClassD";
    AirspaceRenderType[AirspaceRenderType["Restricted"] = 3] = "Restricted";
    AirspaceRenderType[AirspaceRenderType["MOA"] = 4] = "MOA";
    AirspaceRenderType[AirspaceRenderType["Other"] = 5] = "Other";
    AirspaceRenderType[AirspaceRenderType["Null"] = 6] = "Null";
})(AirspaceRenderType || (AirspaceRenderType = {}));
/**
 * An airspace render manager which renders Garmin-style airspaces.
 */
class AirspaceRenderManager extends AbstractAirspaceRenderManager {
    /**
     * Constructor.
     */
    constructor() {
        super();
        this.renderers = [];
        this.initRenderers();
    }
    /**
     * Initializes this manager's airspace renderers.
     */
    initRenderers() {
        this.renderers[AirspaceRenderType.ClassB] = new SingleLineAirspaceRenderer(1.5, '#3080ff', []);
        this.renderers[AirspaceRenderType.ClassC] = new SingleLineAirspaceRenderer(1.5, '#4a0045', []);
        this.renderers[AirspaceRenderType.ClassD] = new SingleLineAirspaceRenderer(1.5, '#3080ff', [5, 5]);
        this.renderers[AirspaceRenderType.Restricted] = new CombedAirspaceRenderer('#3080ff', 1.5, false, 6, [1.5, 2.5]);
        this.renderers[AirspaceRenderType.MOA] = new CombedAirspaceRenderer('#4a0045', 1.5, false, 6, [1.5, 2.5]);
        this.renderers[AirspaceRenderType.Null] = new NullAirspaceRenderer();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    getRenderOrder(a, b) {
        return 0;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getAirspaceRenderer(airspace) {
        switch (airspace.type) {
            case AirspaceType.ClassB:
                return this.renderers[AirspaceRenderType.ClassB];
            case AirspaceType.ClassC:
                return this.renderers[AirspaceRenderType.ClassC];
            case AirspaceType.ClassD:
                return this.renderers[AirspaceRenderType.ClassD];
            case AirspaceType.Restricted:
                return this.renderers[AirspaceRenderType.Restricted];
            case AirspaceType.MOA:
                return this.renderers[AirspaceRenderType.MOA];
            default:
                return this.renderers[AirspaceRenderType.Null];
        }
    }
}
/**
 * Renders airspace boundaries with a comb-like pattern.
 */
class CombedAirspaceRenderer extends MultiLineAirspaceRenderer {
    /**
     * Constructor.
     * @param color The color of the rendered airspace.
     * @param baseLineWidth The stroke width of the base line that is drawn on the airspace boundary.
     * @param teethOutside Whether the teeth should appear on the outside of the boundary.
     * @param teethWidth The width of the teeth.
     * @param teethDash The dash of the teeth.
     */
    constructor(color, baseLineWidth, teethOutside, teethWidth, teethDash) {
        super();
        this.color = color;
        this.baseLineWidth = baseLineWidth;
        this.teethOutside = teethOutside;
        this.teethWidth = teethWidth;
        this.teethDash = teethDash;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    renderLines(context, vertexArray, vertexNormals, length, isClosed) {
        // render base line
        this.renderLine(context, vertexArray, vertexNormals, length, isClosed, 0, this.baseLineWidth, this.color, CombedAirspaceRenderer.emptyDash);
        // render teeth
        this.renderLine(context, vertexArray, vertexNormals, length, isClosed, this.teethWidth / 2 * (this.teethOutside ? -1 : 1), this.teethWidth, this.color, this.teethDash);
    }
}
CombedAirspaceRenderer.emptyDash = [];

/**
 * Render roles for MapWaypointRenderer.
 */
var MapWaypointRenderRole;
(function (MapWaypointRenderRole) {
    /** A highlighted waypoint. */
    MapWaypointRenderRole[MapWaypointRenderRole["Highlight"] = 1] = "Highlight";
    /** A waypoint which is the active waypoint in a flight plan. */
    MapWaypointRenderRole[MapWaypointRenderRole["FlightPlanActive"] = 2] = "FlightPlanActive";
    /** A waypoint in a flight plan which is not the active waypoint. */
    MapWaypointRenderRole[MapWaypointRenderRole["FlightPlanInactive"] = 4] = "FlightPlanInactive";
    /** A normally displayed waypoint. */
    MapWaypointRenderRole[MapWaypointRenderRole["Normal"] = 8] = "Normal";
    /** A waypoint in an airway. */
    MapWaypointRenderRole[MapWaypointRenderRole["Airway"] = 16] = "Airway";
    /** A VNAV waypoint. */
    MapWaypointRenderRole[MapWaypointRenderRole["VNav"] = 32] = "VNav";
})(MapWaypointRenderRole || (MapWaypointRenderRole = {}));
/**
 * A renderer that draws waypoints. Waypoints can be rendered in one of multiple roles: normal, as part of an airway,
 * as part of a flight plan, as the active waypoint in a flight plan, and as a highlighted waypoint. For the renderer
 * to draw a waypoint, the waypoint must first be registered with the renderer. Waypoints may be registered under
 * multiple render roles. However, a waypoint will only be rendered in one role at any point in time, chosen based on
 * the following order of precedence: highlighted > active flight plan > flight plan > normal > airway.
 */
class MapWaypointRenderer {
    /**
     * Constructor.
     * @param textManager The text manager to use for waypoint labels.
     */
    constructor(textManager) {
        this.textManager = textManager;
        this.registered = new Map();
        this.toCleanUp = new Set();
        this.roleInfos = {
            [MapWaypointRenderRole.Highlight]: Object.assign({}, MapWaypointRenderer.DEFAULT_ROLE_INFO),
            [MapWaypointRenderRole.FlightPlanActive]: Object.assign({}, MapWaypointRenderer.DEFAULT_ROLE_INFO),
            [MapWaypointRenderRole.FlightPlanInactive]: Object.assign({}, MapWaypointRenderer.DEFAULT_ROLE_INFO),
            [MapWaypointRenderRole.Normal]: Object.assign({}, MapWaypointRenderer.DEFAULT_ROLE_INFO),
            [MapWaypointRenderRole.Airway]: Object.assign({}, MapWaypointRenderer.DEFAULT_ROLE_INFO),
            [MapWaypointRenderRole.VNav]: Object.assign({}, MapWaypointRenderer.DEFAULT_ROLE_INFO)
        };
        this.allRoles = Object.keys(this.roleInfos);
    }
    /**
     * Sets the factory to use to create waypoint icons for a render role.
     * @param role A render role.
     * @param factory A waypoint icon factory.
     */
    setIconFactory(role, factory) {
        this.roleInfos[role].iconFactory = factory;
    }
    /**
     * Sets the factory to use to create waypoint labels for a render role.
     * @param role A render role.
     * @param factory A waypoint label factory.
     */
    setLabelFactory(role, factory) {
        this.roleInfos[role].labelFactory = factory;
    }
    /**
     * Sets the canvas rendering context for a render role.
     * @param role A render role.
     * @param context - a canvas 2D rendering context.
     */
    setCanvasContext(role, context) {
        this.roleInfos[role].canvasContext = context;
    }
    /**
     * Sets the handler that determines if a waypoint should visible for a render role.
     * @param role A render role.
     * @param handler A function that determines if a waypoint should be visible.
     */
    setVisibilityHandler(role, handler) {
        this.roleInfos[role].visibilityHandler = handler;
    }
    /**
     * Checks if a waypoint is registered with this renderer. A role or roles can be optionally specified such that the
     * method will only return true if the waypoint is registered under those specific roles.
     * @param waypoint A waypoint.
     * @param role The specific role(s) to check.
     * @returns whether the waypoint is registered with this renderer.
     */
    isRegistered(waypoint, role) {
        if (!waypoint) {
            return false;
        }
        const entry = this.registered.get(waypoint.uid);
        if (!entry) {
            return false;
        }
        if (role === undefined) {
            return true;
        }
        return entry.isAllRoles(role);
    }
    /**
     * Registers a waypoint with this renderer under a specific role or roles. Registered waypoints will be drawn as
     * appropriate the next time this renderer's update() method is called. Registering a waypoint under a role under
     * which it is already registered has no effect unless the source of the registration is different.
     * @param waypoint The waypoint to register.
     * @param role The role(s) under which the waypoint should be registered.
     * @param sourceId A unique string ID for the source of the registration.
     */
    register(waypoint, role, sourceId) {
        if (role === 0 || sourceId === '') {
            return;
        }
        let entry = this.registered.get(waypoint.uid);
        if (!entry) {
            entry = new MapWaypointRenderer.MapWaypointRendererEntry(this, waypoint);
            this.registered.set(waypoint.uid, entry);
        }
        entry.addRole(role, sourceId);
    }
    /**
     * Removes a registration for a waypoint for a specific role or roles. Once all of a waypoint's registrations for a
     * role are removed, it will no longer be rendered in that role the next this renderer's update() method is called.
     * @param waypoint The waypoint to deregister.
     * @param role The role(s) from which the waypoint should be deregistered.
     * @param sourceId The unique string ID for the source of the registration to remove.
     */
    deregister(waypoint, role, sourceId) {
        if (role === 0 || sourceId === '') {
            return;
        }
        const entry = this.registered.get(waypoint.uid);
        if (!entry) {
            return;
        }
        entry.removeRole(role, sourceId);
        if (entry.roles === 0) {
            this.deleteEntry(entry);
        }
    }
    /**
     * Deletes and cleans up a registered waypoint entry.
     * @param entry The entry to delete.
     */
    deleteEntry(entry) {
        this.registered.delete(entry.waypoint.uid);
        this.toCleanUp.add(entry);
    }
    /**
     * Redraws waypoints registered with this renderer.
     * @param mapProjection The map projection to use.
     */
    update(mapProjection) {
        this.toCleanUp.forEach(entry => {
            entry.destroy();
        });
        this.toCleanUp.clear();
        const entriesToDrawIcon = [];
        this.registered.forEach(entry => {
            entry.update(mapProjection);
            if (entry.icon) {
                entriesToDrawIcon.push(entry);
            }
        });
        const projectedSize = mapProjection.getProjectedSize();
        const len = this.allRoles.length;
        for (let i = 0; i < len; i++) {
            const context = this.roleInfos[this.allRoles[i]].canvasContext;
            if (context) {
                context.clearRect(0, 0, projectedSize[0], projectedSize[1]);
            }
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        entriesToDrawIcon.sort((a, b) => a.icon.priority - b.icon.priority);
        const len2 = entriesToDrawIcon.length;
        for (let i = 0; i < len2; i++) {
            const entry = entriesToDrawIcon[i];
            const icon = entry.icon;
            const context = this.roleInfos[entry.lastShownRole].canvasContext;
            if (context) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                icon.draw(context, mapProjection);
            }
        }
    }
}
MapWaypointRenderer.DEFAULT_ROLE_INFO = {
    iconFactory: null,
    labelFactory: null,
    canvasContext: null,
    visibilityHandler: () => true
};
/**
 * An entry for a waypoint registered with MapWaypointRenderer.
 */
MapWaypointRenderer.MapWaypointRendererEntry = class {
    /**
     * Constructor.
     * @param renderer The renderer to which this entry belongs.
     * @param waypoint The waypoint associated with this entry.
     */
    constructor(renderer, waypoint) {
        this.renderer = renderer;
        this.waypoint = waypoint;
        this.registrations = {
            [MapWaypointRenderRole.Highlight]: new Set(),
            [MapWaypointRenderRole.FlightPlanActive]: new Set(),
            [MapWaypointRenderRole.FlightPlanInactive]: new Set(),
            [MapWaypointRenderRole.Normal]: new Set(),
            [MapWaypointRenderRole.Airway]: new Set(),
            [MapWaypointRenderRole.VNav]: new Set(),
        };
        this._roles = 0;
        this._icon = null;
        this._label = null;
        this._lastShownRole = 0;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The render role(s) assigned to this entry. */
    get roles() {
        return this._roles;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The role under which this entry was last rendered, or 0 if this entry has not yet been rendered. */
    get lastShownRole() {
        return this._lastShownRole;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This entry's waypoint icon. */
    get icon() {
        return this._icon;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This entry's waypoint label. */
    get label() {
        return this._label;
    }
    /**
     * Checks whether this entry is assigned any of the specified render roles. Optionally, this method can also check
     * if this entry was last rendered in any of the specified roles instead.
     * @param roles The render roles against which to check.
     * @param useLastShown Whether to check the role in which this entry was last rendered instead of the current roles
     * assigned to this entry. False by default.
     * @returns whether the check passed.
     */
    isAnyRole(roles, useLastShown = false) {
        let toCompare;
        if (useLastShown) {
            toCompare = this.lastShownRole;
        }
        else {
            toCompare = this.roles;
        }
        return BitFlags.isAny(toCompare, roles);
    }
    /**
     * Checks whether this entry is assigned only the specified render role(s). Optionally, this method can also check
     * if this entry was last rendered in only the specified role(s) instead.
     * @param roles The render roles against which to check.
     * @param lastShown Whether to check the role in which this entry was last rendered instead of the current roles
     * assigned to this entry. False by default.
     * @returns whether the check passed.
     */
    isOnlyRole(roles, lastShown = false) {
        let toCompare;
        if (lastShown) {
            toCompare = this.lastShownRole;
        }
        else {
            toCompare = this.roles;
        }
        return toCompare === roles;
    }
    /**
     * Checks whether this entry is assigned all the specified render role(s). Optionally, this method can also check
     * if this entry was last rendered in all the specified role(s) instead.
     * @param roles - the render role(s) against which to check.
     * @param lastShown Whether to check the role in which this entry was last rendered instead of the current roles
     * assigned to this entry. False by default.
     * @returns whether the check passed.
     */
    isAllRoles(roles, lastShown = false) {
        let toCompare;
        if (lastShown) {
            toCompare = this.lastShownRole;
        }
        else {
            toCompare = this.roles;
        }
        return BitFlags.isAll(toCompare, roles);
    }
    /**
     * Assigns one or more render roles to this entry.
     * @param roles The render role(s) to assign.
     * @param sourceId The unique string ID of the source of the assignment.
     */
    addRole(roles, sourceId) {
        BitFlags.forEach(roles, (value, index) => { this.registrations[1 << index].add(sourceId); }, true, 0, 6);
        this._roles = this._roles | roles;
    }
    /**
     * Removes one or more render roles from this entry.
     * @param roles The render role(s) to remove.
     * @param sourceId The unique string ID of the soruce of the de-assignment.
     */
    removeRole(roles, sourceId) {
        BitFlags.forEach(roles, (value, index) => {
            const role = 1 << index;
            const registrations = this.registrations[role];
            registrations.delete(sourceId);
            if (registrations.size === 0) {
                this._roles = this._roles & ~role;
            }
        }, true, 0, 6);
    }
    /**
     * Prepares this entry for rendering.
     * @param showRole The role in which this entry should be rendered.
     * @param iconFactory The factory to use to get a waypoint icon.
     * @param labelFactory The factory to use to get a waypoint label.
     */
    prepareRender(showRole, iconFactory, labelFactory) {
        var _a, _b;
        if (showRole === this._lastShownRole) {
            return;
        }
        this._icon = (_a = iconFactory === null || iconFactory === void 0 ? void 0 : iconFactory.getIcon(this.waypoint)) !== null && _a !== void 0 ? _a : null;
        const label = (_b = labelFactory === null || labelFactory === void 0 ? void 0 : labelFactory.getLabel(this.waypoint)) !== null && _b !== void 0 ? _b : null;
        if (this._label && this._label !== label) {
            this.renderer.textManager.deregister(this._label);
        }
        if (label && label !== this._label) {
            this.renderer.textManager.register(label);
        }
        this._label = label;
        this._lastShownRole = showRole;
    }
    /**
     * Updates this entry. An appropriate render role is selected, then the icon and label are updated as appropriate
     * for the chosen role. If the waypoint's label should be visible, it is added to the appropriate text manager.
     * Of note, this method will not draw the waypoint icon to a canvas element; it will simply ensure the .showIcon
     * property contains the correct value depending on whether the icon should be visible.
     * @param mapProjection The map projection to use.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    update(mapProjection) {
        var _a, _b, _c, _d;
        let showRole = 0;
        if (this.isAnyRole(MapWaypointRenderRole.Highlight)
            && this.renderer.roleInfos[MapWaypointRenderRole.Highlight].visibilityHandler(this.waypoint)) {
            showRole = MapWaypointRenderRole.Highlight;
        }
        else if (this.isAnyRole(MapWaypointRenderRole.FlightPlanActive)
            && this.renderer.roleInfos[MapWaypointRenderRole.FlightPlanActive].visibilityHandler(this.waypoint)) {
            showRole = MapWaypointRenderRole.FlightPlanActive;
        }
        else if (this.isAnyRole(MapWaypointRenderRole.FlightPlanInactive)
            && this.renderer.roleInfos[MapWaypointRenderRole.FlightPlanInactive].visibilityHandler(this.waypoint)) {
            showRole = MapWaypointRenderRole.FlightPlanInactive;
        }
        else if (this.isAnyRole(MapWaypointRenderRole.Normal)
            && this.renderer.roleInfos[MapWaypointRenderRole.Normal].visibilityHandler(this.waypoint)) {
            showRole = MapWaypointRenderRole.Normal;
        }
        else if (this.isAnyRole(MapWaypointRenderRole.Airway)
            && this.renderer.roleInfos[MapWaypointRenderRole.Airway].visibilityHandler(this.waypoint)) {
            showRole = MapWaypointRenderRole.Airway;
        }
        else if (this.isAnyRole(MapWaypointRenderRole.VNav)
            && this.renderer.roleInfos[MapWaypointRenderRole.VNav].visibilityHandler(this.waypoint)) {
            showRole = MapWaypointRenderRole.VNav;
        }
        const iconFactory = (_b = (_a = this.renderer.roleInfos[showRole]) === null || _a === void 0 ? void 0 : _a.iconFactory) !== null && _b !== void 0 ? _b : null;
        const labelFactory = (_d = (_c = this.renderer.roleInfos[showRole]) === null || _c === void 0 ? void 0 : _c.labelFactory) !== null && _d !== void 0 ? _d : null;
        this.prepareRender(showRole, iconFactory, labelFactory);
    }
    /**
     * Destroys this entry. Any label from this entry currently registered with the text manager will be deregistered.
     */
    destroy() {
        if (this._label) {
            this.renderer.textManager.deregister(this._label);
        }
    }
};

/**
 * Provides utility functions for working with Garmin maps.
 */
class MapUtils {
    /**
     * Creates a full Bing component earth color array for no terrain colors.
     * @returns a full Bing component earth color array for no terrain colors.
     */
    static createNoTerrainEarthColors() {
        return BingComponent.createEarthColorsArray('#000049', [
            {
                elev: 0,
                color: '#000000'
            },
            {
                elev: 60000,
                color: '#000000'
            }
        ]);
    }
    /**
     * Creates a full Bing component earth color array for absolute terrain colors.
     * @returns a full Bing component earth color array for absolute terrain colors.
     */
    static createAbsoluteTerrainEarthColors() {
        return BingComponent.createEarthColorsArray('#000049', [
            {
                elev: 0,
                color: '#427238'
            },
            {
                elev: 500,
                color: '#456821'
            },
            {
                elev: 2000,
                color: '#d0aa43'
            },
            {
                elev: 3000,
                color: '#c58f45'
            },
            {
                elev: 6000,
                color: '#9d6434'
            },
            {
                elev: 8000,
                color: '#904f25'
            },
            {
                elev: 10500,
                color: '#904522'
            },
            {
                elev: 27000,
                color: '#939393'
            },
            {
                elev: 29000,
                color: '#c8c8c8'
            }
        ]);
    }
    /**
     * Creates a full Bing component earth color array for relative terrain colors.
     * @returns a full Bing component earth color array for relative terrain colors.
     */
    static createRelativeTerrainEarthColors() {
        return BingComponent.createEarthColorsArray('#000049', [
            {
                elev: 0,
                color: '#ff0000'
            },
            {
                elev: 99,
                color: '#ff0000'
            },
            {
                elev: 100,
                color: '#ffff00'
            },
            {
                elev: 999,
                color: '#ffff00'
            },
            {
                elev: 1000,
                color: '#00ff00'
            },
            {
                elev: 1999,
                color: '#00ff00'
            },
            {
                elev: 2000,
                color: '#000000'
            }
        ]);
    }
}

/**
 * A map layer which displays the Bing map.
 */
class MapBingLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.bingLayerRef = FSComponent.createRef();
        this.earthColorsSub = ArraySubject.create(MapBingLayer.ABSOLUTE_TERRAIN_COLORS.slice());
        this.referenceSub = Subject.create(EBingReference.SEA);
        this.wxrModeSub = Subject.create({ mode: EWeatherRadar.OFF, arcRadians: 2 });
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAttached() {
        var _a;
        this.props.model.getModule('terrain').terrainMode.sub(this.onTerrainModeChanged.bind(this), true);
        (_a = this.props.model.getModule('nexrad')) === null || _a === void 0 ? void 0 : _a.showNexrad.sub(on => this.wxrModeSub.set({ mode: on ? EWeatherRadar.TOPVIEW : EWeatherRadar.OFF, arcRadians: 2 }), true);
        this.bingLayerRef.instance.onAttached();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onWake() {
        this.bingLayerRef.instance.onWake();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onSleep() {
        this.bingLayerRef.instance.onSleep();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.bingLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        this.bingLayerRef.instance.onUpdated(time, elapsed);
    }
    /**
     * A callback which is called when the terrain mode changes.
     * @param mode The new terrain mode.
     */
    onTerrainModeChanged(mode) {
        let colors = MapBingLayer.NO_TERRAIN_COLORS;
        let reference = EBingReference.SEA;
        switch (mode) {
            case MapTerrainMode.Absolute:
                colors = MapBingLayer.ABSOLUTE_TERRAIN_COLORS;
                break;
            case MapTerrainMode.Relative:
                colors = MapBingLayer.RELATIVE_TERRAIN_COLORS;
                reference = EBingReference.PLANE;
                break;
        }
        this.earthColorsSub.set(colors);
        this.referenceSub.set(reference);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent(MapBingLayer$1, { ref: this.bingLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, bingId: this.props.bingId, earthColors: this.earthColorsSub, reference: this.referenceSub, class: this.props.class, wxrMode: this.wxrModeSub }));
    }
}
MapBingLayer.NO_TERRAIN_COLORS = MapUtils.createNoTerrainEarthColors();
MapBingLayer.ABSOLUTE_TERRAIN_COLORS = MapUtils.createAbsoluteTerrainEarthColors();
MapBingLayer.RELATIVE_TERRAIN_COLORS = MapUtils.createRelativeTerrainEarthColors();

/**
 * A cache of facility waypoints.
 */
class FacilityWaypointCache {
    /**
     * Constructor.
     * @param size The maximum size of this cache.
     */
    constructor(size) {
        this.size = size;
        this.cache = new Map();
    }
    /**
     * Gets a waypoint from the cache for a specific facility. If one does not exist, a new waypoint will be created.
     * @param facility The facility for which to get a waypoint.
     * @returns A waypoint.
     */
    get(facility) {
        let existing = this.cache.get(facility);
        if (!existing) {
            if (ICAO.getFacilityType(facility.icao) === FacilityType.Airport) {
                existing = new AirportWaypoint(facility);
            }
            else {
                existing = new FacilityWaypoint(facility);
            }
            this.addToCache(facility, existing);
        }
        return existing;
    }
    /**
     * Adds a waypoint to this cache. If the size of the cache is greater than the maximum after the new waypoint is
     * added, a waypoint will be removed from the cache in FIFO order.
     * @param facility The facility associated with the waypoint to add.
     * @param waypoint The waypoint to add.
     */
    addToCache(facility, waypoint) {
        this.cache.set(facility, waypoint);
        if (this.cache.size > this.size) {
            this.cache.delete(this.cache.keys().next().value);
        }
    }
    /**
     * Gets a FacilityWaypointCache instance.
     * @returns A FacilityWaypointCache instance.
     */
    static getCache() {
        var _a;
        return (_a = FacilityWaypointCache.INSTANCE) !== null && _a !== void 0 ? _a : (FacilityWaypointCache.INSTANCE = new FacilityWaypointCache(1000));
    }
}

/**
 * A blank waypoint icon.
 */
class MapBlankWaypointIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     */
    constructor(waypoint, priority) {
        this.waypoint = waypoint;
        this.priority = priority;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    draw(context, mapProjection) {
        // noop
    }
}
/**
 * An abstract implementation of MapWaypointIcon which supports an arbitrary anchor point and offset.
 */
class AbstractMapWaypointIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param width The width at which this icon should be rendered, in pixels.
     * @param height The height at which this icon should be rendered, in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, width, height, options) {
        this.waypoint = waypoint;
        this.priority = priority;
        this.width = width;
        this.height = height;
        /**
         * The anchor point of this icon, expressed relative to its width and height. [0, 0] is the top-left corner, and
         * [1, 1] is the bottom-right corner.
         */
        this.anchor = new Float64Array([0.5, 0.5]);
        /** The offset of this icon from the projected position of its associated waypoint, in pixels. */
        this.offset = new Float64Array(2);
        (options === null || options === void 0 ? void 0 : options.anchor) && this.anchor.set(options.anchor);
        (options === null || options === void 0 ? void 0 : options.offset) && this.offset.set(options.offset);
        this.totalOffsetX = this.offset[0] - this.anchor[0] * this.width;
        this.totalOffsetY = this.offset[1] - this.anchor[1] * this.height;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    draw(context, mapProjection) {
        const projected = mapProjection.project(this.waypoint.location, MapWaypointImageIcon.tempVec2);
        const left = projected[0] + this.totalOffsetX;
        const top = projected[1] + this.totalOffsetY;
        this.drawIconAt(context, mapProjection, left, top);
    }
}
AbstractMapWaypointIcon.tempVec2 = new Float64Array(2);
/**
 * A waypoint icon with an image as the icon's graphic source.
 */
class MapWaypointImageIcon extends AbstractMapWaypointIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param img This icon's image.
     * @param width The width at which this icon should be rendered, in pixels.
     * @param height The height at which this icon should be rendered, in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, img, width, height, options) {
        super(waypoint, priority, width, height, options);
        this.img = img;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    drawIconAt(context, mapProjection, left, top) {
        context.drawImage(this.img, left, top, this.width, this.height);
    }
}
/**
 * A waypoint icon with a sprite as the icon's graphic source.
 */
class MapWaypointSpriteIcon extends AbstractMapWaypointIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param img This icon's sprite's image source.
     * @param frameWidth The frame width of the sprite, in pixels.
     * @param frameHeight The frame height of the sprite, in pixels.
     * @param width The width at which this icon should be rendered, in pixels.
     * @param height The height at which this icon should be rendered, in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, img, frameWidth, frameHeight, width, height, options) {
        super(waypoint, priority, width, height, options);
        this.img = img;
        this.frameWidth = frameWidth;
        this.frameHeight = frameHeight;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    drawIconAt(context, mapProjection, left, top) {
        const spriteIndex = this.getSpriteFrame(mapProjection);
        const rowCount = Math.floor(this.img.naturalHeight / this.frameHeight);
        const colCount = Math.floor(this.img.naturalWidth / this.frameWidth);
        const row = Math.min(rowCount - 1, Math.floor(spriteIndex / colCount));
        const col = Math.min(colCount - 1, spriteIndex % colCount);
        const spriteLeft = col * this.frameWidth;
        const spriteTop = row * this.frameHeight;
        context.drawImage(this.img, spriteLeft, spriteTop, this.frameWidth, this.frameHeight, left, top, this.width, this.height);
    }
}
/**
 * An airport icon.
 */
class MapAirportIcon extends MapWaypointSpriteIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param width The width at which this icon should be rendered, in pixels.
     * @param height The height at which this icon should be rendered, in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, width, height, options) {
        super(waypoint, priority, WaypointIconImageCache.getAirportIcon(waypoint.facility), 32, 32, width, height, options);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getSpriteFrame(mapProjection) {
        if (!this.waypoint.longestRunway) {
            return 0;
        }
        const mapRotationDeg = mapProjection.getRotation() * Avionics.Utils.RAD2DEG;
        return Math.round(NavMath.normalizeHeading((this.waypoint.longestRunway.direction + mapRotationDeg)) / 22.5) % 8;
    }
}
/**
 * A VOR icon.
 */
class MapVorIcon extends MapWaypointImageIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param width The width at which this icon should be rendered, in pixels.
     * @param height The height at which this icon should be rendered, in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, width, height, options) {
        super(waypoint, priority, WaypointIconImageCache.getVorIcon(waypoint.facility.type), width, height, options);
    }
}
/**
 * An intersection icon.
 */
class MapNdbIcon extends MapWaypointImageIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param width The width at which this icon should be rendered, in pixels.
     * @param height The height at which this icon should be rendered, in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, width, height, options) {
        super(waypoint, priority, WaypointIconImageCache.get('NDB'), width, height, options);
    }
}
/**
 * An intersection icon.
 */
class MapIntersectionIcon extends MapWaypointImageIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param width The width at which this icon should be rendered, in pixels.
     * @param height The height at which this icon should be rendered, in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, width, height, options) {
        super(waypoint, priority, WaypointIconImageCache.get('INTERSECTION_CYAN'), width, height, options);
    }
}
/**
 * A runway waypoint icon.
 */
class MapRunwayWaypointIcon extends MapWaypointImageIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param width The width at which this icon should be rendered, in pixels.
     * @param height The height at which this icon should be rendered, in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, width, height, options) {
        super(waypoint, priority, WaypointIconImageCache.get('INTERSECTION_CYAN'), width, height, options);
    }
}
/**
 * A user waypoint icon.
 */
class MapUserWaypointIcon extends MapWaypointImageIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param width The width at which this icon should be rendered, in pixels.
     * @param height The height at which this icon should be rendered, in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, width, height, options) {
        super(waypoint, priority, WaypointIconImageCache.get('USER'), width, height, options);
    }
}
/**
 * A flight path waypoint icon.
 */
class MapFlightPathWaypointIcon extends MapWaypointImageIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param width The width at which this icon should be rendered, in pixels.
     * @param height The height at which this icon should be rendered, in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, width, height, options) {
        super(waypoint, priority, WaypointIconImageCache.get('FPLN_WAYPOINT'), width, height, options);
    }
}
/**
 * A VNAV waypoint icon.
 */
class MapVNavWaypointIcon extends MapWaypointImageIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param width The width at which this icon should be rendered, in pixels.
     * @param height The height at which this icon should be rendered, in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, width, height, options) {
        super(waypoint, priority, WaypointIconImageCache.get('VNAV'), width, height, options);
    }
}
/**
 * An icon for a highlighted waypoint. This icon embellishes a pre-existing ("base") icon with a surrounding ring and
 * background.
 */
class MapWaypointHighlightIcon extends AbstractMapWaypointIcon {
    /**
     * Constructor.
     * @param baseIcon This icon's base waypoint icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param options Options with which to initialize this icon.
     */
    constructor(baseIcon, priority, options) {
        var _a, _b, _c, _d, _e, _f;
        super(baseIcon.waypoint, priority, baseIcon.width, baseIcon.height, { offset: baseIcon.offset, anchor: baseIcon.anchor });
        this.baseIcon = baseIcon;
        this.ringRadiusBuffer = (_a = options === null || options === void 0 ? void 0 : options.ringRadiusBuffer) !== null && _a !== void 0 ? _a : 0;
        this.strokeWidth = (_b = options === null || options === void 0 ? void 0 : options.strokeWidth) !== null && _b !== void 0 ? _b : 2;
        this.strokeColor = (_c = options === null || options === void 0 ? void 0 : options.strokeColor) !== null && _c !== void 0 ? _c : 'white';
        this.outlineWidth = (_d = options === null || options === void 0 ? void 0 : options.outlineWidth) !== null && _d !== void 0 ? _d : 0;
        this.outlineColor = (_e = options === null || options === void 0 ? void 0 : options.outlineColor) !== null && _e !== void 0 ? _e : 'black';
        this.bgColor = (_f = options === null || options === void 0 ? void 0 : options.bgColor) !== null && _f !== void 0 ? _f : '#3c3c3c';
        this.radius = Math.hypot(baseIcon.width, baseIcon.height) / 2 + this.ringRadiusBuffer;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    drawIconAt(context, mapProjection, left, top) {
        const x = left + this.baseIcon.width / 2;
        const y = top + this.baseIcon.height / 2;
        context.beginPath();
        context.arc(x, y, this.radius, 0, 2 * Math.PI);
        this.drawRingBackground(context);
        this.baseIcon.draw(context, mapProjection);
        this.drawRing(context);
    }
    /**
     * Draws the ring background for this icon.
     * @param context  A canvas rendering context.
     */
    drawRingBackground(context) {
        context.fillStyle = this.bgColor;
        context.fill();
    }
    /**
     * Draws the ring for this icon.
     * @param context  A canvas rendering context.
     */
    drawRing(context) {
        if (this.outlineWidth > 0) {
            this.applyStroke(context, (this.strokeWidth + 2 * this.outlineWidth), this.outlineColor);
        }
        this.applyStroke(context, this.strokeWidth, this.strokeColor);
    }
    /**
     * Applies a stroke to a canvas rendering context.
     * @param context A canvas rendering context.
     * @param lineWidth The width of the stroke.
     * @param strokeStyle The style of the stroke.
     */
    applyStroke(context, lineWidth, strokeStyle) {
        context.lineWidth = lineWidth;
        context.strokeStyle = strokeStyle;
        context.stroke();
    }
}

// TODO: This entire layer (and how the map renders waypoints) will need to be refactored eventually.
/**
 * The map layer showing waypoints.
 */
class MapWaypointsLayer extends MapSyncedCanvasLayer {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.facLoader = new FacilityLoader(FacilityRespository.getRepository(this.props.bus), this.onFacilityLoaderInitialized.bind(this));
        this.facWaypointCache = FacilityWaypointCache.getCache();
        this.searchRadius = 0;
        this.searchMargin = 0;
        this.icaosToShow = new Set();
        this.isAirportVisible = {
            [AirportSize.Large]: false,
            [AirportSize.Medium]: false,
            [AirportSize.Small]: false
        };
        this.isVorVisible = false;
        this.isNdbVisible = false;
        this.isIntersectionVisible = false;
        this.iconFactory = new WaypointIconFactory$2({
            airportIconPriority: Object.assign({}, this.props.styles.airportIconPriority),
            vorIconPriority: this.props.styles.vorIconPriority,
            ndbIconPriority: this.props.styles.ndbIconPriority,
            intIconPriority: this.props.styles.intIconPriority,
            airportIconSize: Object.assign({}, this.props.styles.airportIconSize),
            vorIconSize: this.props.styles.vorIconSize,
            ndbIconSize: this.props.styles.ndbIconSize,
            intIconSize: this.props.styles.intIconSize,
        });
        this.labelFactory = new WaypointLabelFactory$2({
            airportLabelPriority: Object.assign({}, this.props.styles.airportLabelPriority),
            vorLabelPriority: this.props.styles.vorLabelPriority,
            ndbLabelPriority: this.props.styles.ndbLabelPriority,
            intLabelPriority: this.props.styles.intLabelPriority,
            airportLabelOptions: {
                [AirportSize.Large]: Object.assign({}, this.props.styles.airportLabelOptions[AirportSize.Large]),
                [AirportSize.Medium]: Object.assign({}, this.props.styles.airportLabelOptions[AirportSize.Medium]),
                [AirportSize.Small]: Object.assign({}, this.props.styles.airportLabelOptions[AirportSize.Small])
            },
            vorLabelOptions: Object.assign({}, this.props.styles.vorLabelOptions),
            ndbLabelOptions: Object.assign({}, this.props.styles.ndbLabelOptions),
            intLabelOptions: Object.assign({}, this.props.styles.intLabelOptions)
        });
    }
    /**
     * A callback called when the facility loaded finishes initialization.
     */
    onFacilityLoaderInitialized() {
        Promise.all([
            this.facLoader.startNearestSearchSession(FacilitySearchType.Airport),
            this.facLoader.startNearestSearchSession(FacilitySearchType.Vor),
            this.facLoader.startNearestSearchSession(FacilitySearchType.Ndb),
            this.facLoader.startNearestSearchSession(FacilitySearchType.Intersection)
        ]).then((value) => {
            const [airportSession, vorSession, ndbSession, intSession] = value;
            const callback = this.processSearchResults.bind(this);
            this.facilitySearches = {
                airport: new MapWaypointsLayer.NearestSearch(airportSession, MapWaypointsLayer.SEARCH_AIRPORT_LIMIT, callback),
                vor: new MapWaypointsLayer.NearestSearch(vorSession, MapWaypointsLayer.SEARCH_VOR_LIMIT, callback),
                ndb: new MapWaypointsLayer.NearestSearch(ndbSession, MapWaypointsLayer.SEARCH_NDB_LIMIT, callback),
                intersection: new MapWaypointsLayer.NearestSearch(intSession, MapWaypointsLayer.SEARCH_INTERSECTION_LIMIT, callback)
            };
            if (this.isInit) {
                this.tryRefreshAllSearches(this.props.mapProjection.getCenter(), this.searchRadius);
            }
        });
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAttached() {
        super.onAttached();
        this.isInit = false;
        this.initVisibilityFlags();
        this.initWaypointRenderer();
        this.updateSearchRadius();
        this.isInit = true;
        this.tryRefreshAllSearches(this.props.mapProjection.getCenter(), this.searchRadius);
    }
    /**
     * Initializes waypoint visibility flags and listeners.
     */
    initVisibilityFlags() {
        const waypointsModule = this.props.model.getModule('waypoints');
        waypointsModule.airportShow[AirportSize.Large].sub(this.updateAirportVisibility.bind(this, AirportSize.Large), true);
        waypointsModule.airportShow[AirportSize.Medium].sub(this.updateAirportVisibility.bind(this, AirportSize.Medium), true);
        waypointsModule.airportShow[AirportSize.Small].sub(this.updateAirportVisibility.bind(this, AirportSize.Small), true);
        waypointsModule.vorShow.sub(this.updateVorVisibility.bind(this), true);
        waypointsModule.ndbShow.sub(this.updateNdbVisibility.bind(this), true);
        waypointsModule.intShow.sub(this.updateIntersectionVisibility.bind(this), true);
    }
    /**
     * Updates airport waypoint visibility.
     * @param size The airport size class to update.
     */
    updateAirportVisibility(size) {
        const waypointsModule = this.props.model.getModule('waypoints');
        const wasAnyAirportVisible = this.isAirportVisible[AirportSize.Large]
            || this.isAirportVisible[AirportSize.Medium]
            || this.isAirportVisible[AirportSize.Small];
        this.isAirportVisible[size] = waypointsModule.airportShow[size].get();
        if (!wasAnyAirportVisible && this.isAirportVisible[size]) {
            this.tryRefreshIntersectionSearch(this.props.mapProjection.getCenter(), this.searchRadius);
        }
    }
    /**
     * Updates VOR waypoint visibility.
     */
    updateVorVisibility() {
        const waypointsModule = this.props.model.getModule('waypoints');
        this.isVorVisible = waypointsModule.vorShow.get();
        if (this.isVorVisible) {
            this.tryRefreshVorSearch(this.props.mapProjection.getCenter(), this.searchRadius);
        }
    }
    /**
     * Updates NDB waypoint visibility.
     */
    updateNdbVisibility() {
        const waypointsModule = this.props.model.getModule('waypoints');
        this.isNdbVisible = waypointsModule.ndbShow.get();
        if (this.isNdbVisible) {
            this.tryRefreshNdbSearch(this.props.mapProjection.getCenter(), this.searchRadius);
        }
    }
    /**
     * Updates intersection waypoint visibility.
     */
    updateIntersectionVisibility() {
        const waypointsModule = this.props.model.getModule('waypoints');
        this.isIntersectionVisible = waypointsModule.intShow.get();
        if (this.isIntersectionVisible) {
            this.tryRefreshIntersectionSearch(this.props.mapProjection.getCenter(), this.searchRadius);
        }
    }
    /**
     * Initializes the waypoint renderer.
     */
    initWaypointRenderer() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.props.waypointRenderer.setCanvasContext(MapWaypointRenderRole.Normal, this.display.context);
        this.props.waypointRenderer.setIconFactory(MapWaypointRenderRole.Normal, this.iconFactory);
        this.props.waypointRenderer.setLabelFactory(MapWaypointRenderRole.Normal, this.labelFactory);
        this.props.waypointRenderer.setVisibilityHandler(MapWaypointRenderRole.Normal, this.isWaypointVisible.bind(this));
    }
    /**
     * Checks whether a waypoint is visible.
     * @param waypoint A waypoint.
     * @returns whether the waypoint is visible.
     */
    isWaypointVisible(waypoint) {
        if (waypoint instanceof FacilityWaypoint) {
            switch (ICAO.getFacilityType(waypoint.facility.icao)) {
                case FacilityType.Airport:
                    return this.isAirportVisible[waypoint.size];
                case FacilityType.VOR:
                    return this.isVorVisible;
                case FacilityType.NDB:
                    return this.isNdbVisible;
                case FacilityType.Intersection:
                    return this.isIntersectionVisible;
            }
        }
        return false;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        super.onMapProjectionChanged(mapProjection, changeFlags);
        if (BitFlags.isAny(changeFlags, MapProjectionChangeType.Range | MapProjectionChangeType.ProjectedSize)) {
            this.updateSearchRadius();
            this.tryRefreshAllSearches(mapProjection.getCenter(), this.searchRadius);
        }
        else if (BitFlags.isAll(changeFlags, MapProjectionChangeType.Center)) {
            this.tryRefreshAllSearches(mapProjection.getCenter(), this.searchRadius);
        }
    }
    /**
     * Updates the desired nearest facility search radius based on the current map projection.
     */
    updateSearchRadius() {
        const mapHalfDiagRange = Vec2Math.abs(this.props.mapProjection.getProjectedSize()) * this.props.mapProjection.getProjectedResolution() / 2;
        this.searchRadius = mapHalfDiagRange * MapWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR;
        this.searchMargin = mapHalfDiagRange * (MapWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR - 1);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        this.updateSearches(elapsed);
    }
    /**
     * Updates this layer's facility searches.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    updateSearches(elapsed) {
        if (!this.facilitySearches) {
            return;
        }
        this.facilitySearches.airport.update(elapsed);
        this.facilitySearches.vor.update(elapsed);
        this.facilitySearches.ndb.update(elapsed);
        this.facilitySearches.intersection.update(elapsed);
    }
    /**
     * Attempts to refresh all of the nearest facility searches.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     */
    tryRefreshAllSearches(center, radius) {
        this.tryRefreshAirportSearch(center, radius);
        this.tryRefreshVorSearch(center, radius);
        this.tryRefreshNdbSearch(center, radius);
        this.tryRefreshIntersectionSearch(center, radius);
    }
    /**
     * Attempts to refresh the nearest airport search. The search will only be refreshed if at least one size class of
     * airport is currently visible and the desired search radius is different from the last refreshed search radius or
     * the desired search center is outside of the margin of the last refreshed search center.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     */
    tryRefreshAirportSearch(center, radius) {
        if (!this.facilitySearches
            || !(this.isAirportVisible[AirportSize.Large] || this.isAirportVisible[AirportSize.Medium] || this.isAirportVisible[AirportSize.Small])) {
            return;
        }
        const search = this.facilitySearches.airport;
        if (search.lastRadius !== radius || search.lastCenter.distance(center) >= this.searchMargin) {
            search.scheduleRefresh(center, radius, MapWaypointsLayer.SEARCH_DEBOUNCE_DELAY);
        }
    }
    /**
     * Attempts to refresh the nearest VOR search. The search will only be refreshed if VORs are currently visible and
     * the desired search radius is different from the last refreshed search radius or the desired search center is
     * outside of the margin of the last refreshed search center.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     */
    tryRefreshVorSearch(center, radius) {
        if (!this.facilitySearches || !this.isVorVisible) {
            return;
        }
        const search = this.facilitySearches.vor;
        if (search.lastRadius !== radius || search.lastCenter.distance(center) >= this.searchMargin) {
            search.scheduleRefresh(center, radius, MapWaypointsLayer.SEARCH_DEBOUNCE_DELAY);
        }
    }
    /**
     * Attempts to refresh the nearest NDB search. The search will only be refreshed if NDB are currently visible and
     * the desired search radius is different from the last refreshed search radius or the desired search center is
     * outside of the margin of the last refreshed search center.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     */
    tryRefreshNdbSearch(center, radius) {
        if (!this.facilitySearches || !this.isNdbVisible) {
            return;
        }
        const search = this.facilitySearches.ndb;
        if (search.lastRadius !== radius || search.lastCenter.distance(center) >= this.searchMargin) {
            search.scheduleRefresh(center, radius, MapWaypointsLayer.SEARCH_DEBOUNCE_DELAY);
        }
    }
    /**
     * Attempts to refresh the nearest intersection search. The search will only be refreshed if intersections are
     * currently visible and the desired search radius is different from the last refreshed search radius or the desired
     * search center is outside of the margin of the last refreshed search center.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     */
    tryRefreshIntersectionSearch(center, radius) {
        if (!this.facilitySearches || !this.isIntersectionVisible) {
            return;
        }
        const search = this.facilitySearches.intersection;
        if (search.lastRadius !== radius || search.lastCenter.distance(center) >= this.searchMargin) {
            search.scheduleRefresh(center, radius, MapWaypointsLayer.SEARCH_DEBOUNCE_DELAY);
        }
    }
    /**
     * Processes nearest facility search results. New facilities are registered, while removed facilities are deregistered.
     * @param results Nearest facility search results.
     */
    processSearchResults(results) {
        if (!results) {
            return;
        }
        const numAdded = results.added.length;
        for (let i = 0; i < numAdded; i++) {
            const icao = results.added[i];
            if (icao === undefined || icao === ICAO.emptyIcao) {
                continue;
            }
            this.registerFacility(icao);
        }
        const numRemoved = results.removed.length;
        for (let i = 0; i < numRemoved; i++) {
            const icao = results.removed[i];
            if (icao === undefined || icao === ICAO.emptyIcao) {
                continue;
            }
            this.deregisterFacility(icao);
        }
    }
    /**
     * Registers a facility with this layer. Registered facilities are drawn to this layer using a waypoint renderer.
     * @param icao The ICAO string of the facility to register.
     */
    registerFacility(icao) {
        this.icaosToShow.add(icao);
        this.facLoader.getFacility(ICAO.getFacilityType(icao), icao).then(facility => {
            if (!this.icaosToShow.has(icao)) {
                return;
            }
            const waypoint = this.facWaypointCache.get(facility);
            this.props.waypointRenderer.register(waypoint, MapWaypointRenderRole.Normal, 'waypoints-layer');
        });
    }
    /**
     * Deregisters a facility from this layer.
     * @param icao The ICAO string of the facility to deregister.
     */
    deregisterFacility(icao) {
        this.icaosToShow.delete(icao);
        this.facLoader.getFacility(ICAO.getFacilityType(icao), icao).then(facility => {
            if (this.icaosToShow.has(icao)) {
                return;
            }
            const waypoint = this.facWaypointCache.get(facility);
            this.props.waypointRenderer.deregister(waypoint, MapWaypointRenderRole.Normal, 'waypoints-layer');
        });
    }
}
MapWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR = Math.SQRT2;
MapWaypointsLayer.SEARCH_AIRPORT_LIMIT = 500;
MapWaypointsLayer.SEARCH_VOR_LIMIT = 250;
MapWaypointsLayer.SEARCH_NDB_LIMIT = 250;
MapWaypointsLayer.SEARCH_INTERSECTION_LIMIT = 500;
MapWaypointsLayer.SEARCH_DEBOUNCE_DELAY = 500; // milliseconds
/**
 * A nearest facility search for MapWaypointLayer.
 */
MapWaypointsLayer.NearestSearch = class {
    /**
     * Constructor.
     * @param session The session used by this search.
     * @param maxSearchItems The maximum number of items this search returns.
     * @param refreshCallback A callback which is called every time the search refreshes.
     */
    constructor(session, maxSearchItems, refreshCallback) {
        this.session = session;
        this.maxSearchItems = maxSearchItems;
        this.refreshCallback = refreshCallback;
        this._lastCenter = new GeoPoint(0, 0);
        this._lastRadius = 0;
        this.refreshDebounceTimer = 0;
        this.isRefreshScheduled = false;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The center of this search's last refresh.
     */
    get lastCenter() {
        return this._lastCenter.readonly;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The radius of this search's last refresh, in great-arc radians.
     */
    get lastRadius() {
        return this._lastRadius;
    }
    /**
     * Schedules a refresh of this search.  If a refresh was previously scheduled but not yet executed, this new
     * scheduled refresh will replace the old one.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     * @param delay The delay, in milliseconds, before the refresh is executed.
     */
    scheduleRefresh(center, radius, delay) {
        this._lastCenter.set(center);
        this._lastRadius = radius;
        this.refreshDebounceTimer = delay;
        this.isRefreshScheduled = true;
    }
    /**
     * Updates this search. Executes any pending refreshes if their delay timers have expired.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    update(elapsed) {
        if (!this.isRefreshScheduled) {
            return;
        }
        this.refreshDebounceTimer = Math.max(0, this.refreshDebounceTimer - elapsed);
        if (this.refreshDebounceTimer === 0) {
            this.refresh();
            this.isRefreshScheduled = false;
        }
    }
    /**
     * Refreshes this search.
     * @returns a Promise which is fulfilled with the search results when the refresh completes.
     */
    async refresh() {
        const results = await this.session.searchNearest(this._lastCenter.lat, this._lastCenter.lon, UnitType.GA_RADIAN.convertTo(this._lastRadius, UnitType.METER), this.maxSearchItems);
        this.refreshCallback(results);
    }
};
/**
 * A waypoint icon factory.
 */
class WaypointIconFactory$2 {
    /**
     * Constructor.
     * @param styles Icon styling options used by this factory.
     */
    constructor(styles) {
        this.styles = styles;
        this.cache = new Map();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getIcon(waypoint) {
        let existing = this.cache.get(waypoint.uid);
        if (!existing) {
            existing = this.createIcon(waypoint);
            this.cache.set(waypoint.uid, existing);
        }
        return existing;
    }
    /**
     * Creates a new icon for a waypoint.
     * @param waypoint The waypoint for which to create an icon.
     * @returns a waypoint icon.
     */
    createIcon(waypoint) {
        if (waypoint instanceof AirportWaypoint) {
            return new MapAirportIcon(waypoint, this.styles.airportIconPriority[waypoint.size], this.styles.airportIconSize[waypoint.size], this.styles.airportIconSize[waypoint.size]);
        }
        else if (waypoint instanceof FacilityWaypoint) {
            switch (ICAO.getFacilityType(waypoint.facility.icao)) {
                case FacilityType.VOR:
                    return new MapVorIcon(waypoint, this.styles.vorIconPriority, this.styles.vorIconSize, this.styles.vorIconSize);
                case FacilityType.NDB:
                    return new MapNdbIcon(waypoint, this.styles.ndbIconPriority, this.styles.ndbIconSize, this.styles.ndbIconSize);
                case FacilityType.Intersection:
                    return new MapIntersectionIcon(waypoint, this.styles.intIconPriority, this.styles.intIconSize, this.styles.intIconSize);
            }
        }
        return new MapBlankWaypointIcon(waypoint, 0);
    }
}
/**
 * A waypoint label factory.
 */
class WaypointLabelFactory$2 {
    /**
     * Constructor.
     * @param styles Icon styling options used by this factory.
     */
    constructor(styles) {
        this.styles = styles;
        this.cache = new Map();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getLabel(waypoint) {
        let existing = this.cache.get(waypoint.uid);
        if (!existing) {
            existing = this.createLabel(waypoint);
            this.cache.set(waypoint.uid, existing);
        }
        return existing;
    }
    /**
     * Creates a new icon for a waypoint.
     * @param waypoint The waypoint for which to create an icon.
     * @returns a waypoint icon.
     */
    createLabel(waypoint) {
        let text = '';
        let priority = 0;
        let options;
        if (waypoint instanceof FacilityWaypoint) {
            text = ICAO.getIdent(waypoint.facility.icao);
            switch (ICAO.getFacilityType(waypoint.facility.icao)) {
                case FacilityType.Airport:
                    priority = this.styles.airportLabelPriority[waypoint.size];
                    options = this.styles.airportLabelOptions[waypoint.size];
                    break;
                case FacilityType.VOR:
                    priority = this.styles.vorLabelPriority;
                    options = this.styles.vorLabelOptions;
                    break;
                case FacilityType.NDB:
                    priority = this.styles.ndbLabelPriority;
                    options = this.styles.ndbLabelOptions;
                    break;
                case FacilityType.Intersection:
                    priority = this.styles.intLabelPriority;
                    options = this.styles.intLabelOptions;
                    break;
            }
        }
        return new MapCullableLocationTextLabel(text, priority, waypoint.location, false, options);
    }
}

/**
 * A layer which draws airspaces.
 */
class MapAirspaceLayer extends MapCachedCanvasLayer {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.searchedAirspaces = [];
        this.lastSearchCenter = new GeoPoint(0, 0);
        this.lastScheduledSearchTime = 0;
        this.activeRenderProcess = null;
        this.searchDebounceTimer = 0;
        this.isSearchScheduled = false;
        this.renderDebounceTimer = 0;
        this.isRenderScheduled = false;
        this.needRefilterAirspaces = false;
        this.renderTaskQueueHandler = {
            // eslint-disable-next-line jsdoc/require-jsdoc
            onStarted() {
                // noop
            },
            // eslint-disable-next-line jsdoc/require-jsdoc
            canContinue(elapsedFrameCount, dispatchedTaskCount, timeElapsed) {
                return timeElapsed < MapAirspaceLayer.RENDER_TIME_BUDGET;
            },
            // eslint-disable-next-line jsdoc/require-jsdoc
            onPaused: this.onRenderPaused.bind(this),
            // eslint-disable-next-line jsdoc/require-jsdoc
            onFinished: this.onRenderFinished.bind(this),
            // eslint-disable-next-line jsdoc/require-jsdoc
            onAborted: this.onRenderAborted.bind(this)
        };
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.initModuleListeners();
        this.scheduleSearchAirspaces(0);
    }
    /**
     * Initializes this layer's airspace module property listeners.
     */
    initModuleListeners() {
        const rangeModule = this.props.model.getModule('range');
        rangeModule.nominalRange.sub(this.onNominalRangeChanged.bind(this));
        rangeModule.nominalRanges.sub(this.onNominalRangeArrayChanged.bind(this));
        const airspaceModule = this.props.model.getModule('airspace');
        airspaceModule.show.sub(this.onShowChanged.bind(this));
        for (const type of Object.values(AirspaceRangeType)) {
            airspaceModule.maxRangeIndex[type].sub(this.onMaxRangeIndexChanged.bind(this, type));
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        super.onMapProjectionChanged(mapProjection, changeFlags);
        const distance = mapProjection.getCenter().distance(this.lastSearchCenter);
        // sometimes the search will return no airspaces even when it should (usually at the very beginning of a flight),
        // so if the last search results were empty we will refresh the search periodically regardless of how far the last
        // search center is from the current map center.
        if ((this.searchedAirspaces.length === 0 && Date.now() - this.lastScheduledSearchTime >= MapAirspaceLayer.MIN_SEARCH_INTERVAL)
            || (MapAirspaceLayer.SEARCH_DISTANCE_THRESHOLD.compare(distance, UnitType.GA_RADIAN) <= 0)) {
            this.scheduleSearchAirspaces(MapAirspaceLayer.SEARCH_DEBOUNCE_DELAY);
        }
    }
    /**
     * Schedules an airspace search after a specified delay. If a search was previously scheduled but not yet executed,
     * this new scheduled search will replace the old one.
     * @param delay The delay, in milliseconds, before the search is executed.
     */
    scheduleSearchAirspaces(delay) {
        this.searchDebounceTimer = delay;
        this.isSearchScheduled = true;
        this.lastScheduledSearchTime = Date.now();
    }
    /**
     * Schedules a render. If a render was previously scheduled but not yet executed, this new scheduled search will
     * replace the old one.
     * @param delay The delay, in milliseconds, before the search is executed.
     */
    scheduleRender(delay) {
        this.renderDebounceTimer = delay;
        this.isRenderScheduled = true;
    }
    /**
     * Searches for airspaces around the map center. After the search is complete, the list of search results is filtered
     * and, if necessary, rendered.
     */
    async searchAirspaces() {
        const center = this.props.mapProjection.getCenter();
        this.lastSearchCenter.set(center);
        this.searchedAirspaces = await this.props.airspaceSearcher.search(center);
        this.refilterAirspaces();
    }
    /**
     * Filters the list of airspace search results to those that should be rendered and if necessary, renders the
     * filtered airspaces.
     */
    refilterAirspaces() {
        const airspaceModule = this.props.model.getModule('airspace');
        let needRender;
        if (airspaceModule.show.get()) {
            const mapRangeIndex = this.props.model.getModule('range').nominalRangeIndex.get();
            const airspaceMaxRangeIndex = airspaceModule.maxRangeIndex;
            const filteredAirspaces = this.searchedAirspaces.filter(airspace => {
                switch (airspace.type) {
                    case AirspaceType.ClassB:
                        return mapRangeIndex <= airspaceMaxRangeIndex[AirspaceRangeType.ClassB].get();
                    case AirspaceType.ClassC:
                        return mapRangeIndex <= airspaceMaxRangeIndex[AirspaceRangeType.ClassC].get();
                    case AirspaceType.ClassD:
                        return mapRangeIndex <= airspaceMaxRangeIndex[AirspaceRangeType.ClassD].get();
                    case AirspaceType.Restricted:
                        return mapRangeIndex <= airspaceMaxRangeIndex[AirspaceRangeType.Restricted].get();
                    case AirspaceType.MOA:
                        return mapRangeIndex <= airspaceMaxRangeIndex[AirspaceRangeType.MOA].get();
                    default:
                        return false;
                }
            });
            needRender = this.props.airspaceRenderManager.replaceRegisteredAirspaces(filteredAirspaces);
        }
        else {
            needRender = this.props.airspaceRenderManager.clearRegisteredAirspaces();
        }
        if (needRender && !this.isRenderScheduled) {
            this.scheduleRender(0);
        }
        this.needRefilterAirspaces = false;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        super.onUpdated(time, elapsed);
        this.updateFromInvalidation();
        this.updateRefilter();
        this.updateScheduledSearch(time, elapsed);
        this.updateScheduledRender(elapsed);
    }
    /**
     * Checks if the display and buffer canvases have been invalidated, and if so, clears them and schedules a render.
     */
    updateFromInvalidation() {
        const display = this.display;
        const buffer = this.buffer;
        const shouldScheduleRender = display.isInvalid || (buffer.isInvalid && this.activeRenderProcess);
        if (display.isInvalid) {
            display.clear();
            display.syncWithMapProjection(this.props.mapProjection, this.getReferenceMargin());
        }
        if (buffer.isInvalid) {
            buffer.clear();
            buffer.syncWithMapProjection(this.props.mapProjection, this.getReferenceMargin());
        }
        if (shouldScheduleRender) {
            this.scheduleRender(MapAirspaceLayer.RENDER_DEBOUNCE_DELAY);
        }
    }
    /**
     * Checks if airspaces need to be refiltered, and if so, executes a refilter.
     */
    updateRefilter() {
        if (!this.needRefilterAirspaces) {
            return;
        }
        this.refilterAirspaces();
    }
    /**
     * If a search is scheduled, decrements the delay timer and if necessary, executes the search.
     * @param time The current time, as a UNIX timestamp.
     * @param elapsed The time elapsed, in milliseconds, since the last update.
     */
    updateScheduledSearch(time, elapsed) {
        if (!this.isSearchScheduled) {
            return;
        }
        this.searchDebounceTimer = Math.max(0, this.searchDebounceTimer - elapsed);
        if (this.searchDebounceTimer === 0) {
            this.searchAirspaces();
            this.isSearchScheduled = false;
        }
    }
    /**
     * If a render is scheduled, decrements the delay timer and if necessary, executes the render.
     * @param elapsed The time elapsed, in milliseconds, since the last update.
     */
    updateScheduledRender(elapsed) {
        if (!this.isRenderScheduled) {
            return;
        }
        this.renderDebounceTimer = Math.max(0, this.renderDebounceTimer - elapsed);
        if (this.renderDebounceTimer === 0) {
            this.startRenderProcess(true);
            this.isRenderScheduled = false;
        }
    }
    /**
     * Syncs this layer's display canvas instance with the current map projection and renders this layer's airspaces to
     * the display.
     * @param clearDisplay Whether to clear the display canvas before rendering.
     */
    startRenderProcess(clearDisplay) {
        const display = this.display;
        if (clearDisplay) {
            display.clear();
        }
        if (this.activeRenderProcess) {
            this.activeRenderProcess.abort();
        }
        const buffer = this.buffer;
        buffer.clear();
        buffer.syncWithMapProjection(this.props.mapProjection, this.getReferenceMargin());
        display.syncWithCanvasInstance(buffer);
        this.activeRenderProcess = this.props.airspaceRenderManager.prepareRenderProcess(display.geoProjection, buffer.context, this.renderTaskQueueHandler);
        this.activeRenderProcess.start();
    }
    /**
     * Cleans up the active render process.
     */
    cleanUpRender() {
        this.buffer.reset();
        this.activeRenderProcess = null;
    }
    /**
     * Renders airspaces from the buffer to the display.
     */
    renderAirspacesToDisplay() {
        this.display.clear();
        this.copyBufferToDisplay();
    }
    /**
     * This method is called when the airspace render process pauses.
     */
    onRenderPaused() {
        this.renderAirspacesToDisplay();
    }
    /**
     * This method is called when the airspace render process finishes.
     */
    onRenderFinished() {
        this.renderAirspacesToDisplay();
        this.cleanUpRender();
    }
    /**
     * This method is called when the airspace render process is aborted.
     */
    onRenderAborted() {
        this.cleanUpRender();
    }
    /**
     * This method is called when the nominal map range changes.
     */
    onNominalRangeChanged() {
        this.needRefilterAirspaces = true;
    }
    /**
     * This method is called when the array of nominal map ranges changes.
     */
    onNominalRangeArrayChanged() {
        this.needRefilterAirspaces = true;
    }
    /**
     * This method is called when the show airspace property changes.
     */
    onShowChanged() {
        this.needRefilterAirspaces = true;
    }
    /**
     * This method is called when an airspace maximum range index property changes.
     */
    onMaxRangeIndexChanged() {
        this.needRefilterAirspaces = true;
    }
}
/**
 * The minimum distance between the current map center and the last search center required to initiate a new search.
 */
MapAirspaceLayer.SEARCH_DISTANCE_THRESHOLD = UnitType.NMILE.createNumber(10);
MapAirspaceLayer.MIN_SEARCH_INTERVAL = 5000; // milliseconds
MapAirspaceLayer.RENDER_TIME_BUDGET = 0.2; // milliseconds per frame
MapAirspaceLayer.SEARCH_DEBOUNCE_DELAY = 500; // milliseconds
MapAirspaceLayer.RENDER_DEBOUNCE_DELAY = 500; // milliseconds

/**
 * A map layer which displays a flight plan.
 */
class MapFlightPlanLayer extends MapLayer {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.flightPathLayerRef = FSComponent.createRef();
        this.waypointLayerRef = FSComponent.createRef();
        this.resampler = new GeodesicResampler(Math.PI / 12, 1, 8);
        this.facLoader = new FacilityLoader(FacilityRespository.getRepository(this.props.bus));
        this.facWaypointCache = FacilityWaypointCache.getCache();
        this.legWaypointRecords = new Map();
        this.isRefreshWaypointsBusy = false;
        this.isObsActive = false;
        this.obsCourse = 0;
        this.needDrawRoute = false;
        this.needRefreshWaypoints = false;
        this.needRepickWaypoints = false;
        this.iconFactoryInactive = this.createWaypointIconFactory(this.props.inactiveWaypointStyles);
        this.labelFactoryInactive = this.createWaypointLabelFactory(this.props.inactiveWaypointStyles);
        this.iconFactoryActive = this.createWaypointIconFactory(this.props.activeWaypointStyles);
        this.labelFactoryActive = this.createWaypointLabelFactory(this.props.activeWaypointStyles);
        this.vnavIconFactory = new VNavWaypointIconFactory();
        this.vnavLabelFactory = new VNavWaypointLabelFactory();
    }
    /**
     * Creates a waypoint icon factory.
     * @param styles Styles the factory should use.
     * @returns a waypoint icon factory.
     */
    createWaypointIconFactory(styles) {
        return new WaypointIconFactory$1({
            airportIconPriority: Object.assign({}, styles.airportIconPriority),
            vorIconPriority: styles.vorIconPriority,
            ndbIconPriority: styles.ndbIconPriority,
            intIconPriority: styles.intIconPriority,
            rwyIconPriority: styles.rwyIconPriority,
            userIconPriority: styles.userIconPriority,
            fpIconPriority: styles.fpIconPriority,
            airportIconSize: Object.assign({}, styles.airportIconSize),
            vorIconSize: styles.vorIconSize,
            ndbIconSize: styles.ndbIconSize,
            intIconSize: styles.intIconSize,
            rwyIconSize: styles.rwyIconSize,
            userIconSize: styles.userIconSize,
            fpIconSize: styles.fpIconSize,
        });
    }
    /**
     * Creates a waypoint label factory.
     * @param styles Styles the factory should use.
     * @returns a waypoint label factory.
     */
    createWaypointLabelFactory(styles) {
        return new WaypointLabelFactory$1({
            airportLabelPriority: Object.assign({}, styles.airportLabelPriority),
            vorLabelPriority: styles.vorLabelPriority,
            ndbLabelPriority: styles.ndbLabelPriority,
            intLabelPriority: styles.intLabelPriority,
            rwyLabelPriority: styles.rwyLabelPriority,
            userLabelPriority: styles.userLabelPriority,
            fpLabelPriority: styles.fpLabelPriority,
            airportLabelOptions: {
                [AirportSize.Large]: Object.assign({}, styles.airportLabelOptions[AirportSize.Large]),
                [AirportSize.Medium]: Object.assign({}, styles.airportLabelOptions[AirportSize.Medium]),
                [AirportSize.Small]: Object.assign({}, styles.airportLabelOptions[AirportSize.Small])
            },
            vorLabelOptions: Object.assign({}, styles.vorLabelOptions),
            ndbLabelOptions: Object.assign({}, styles.ndbLabelOptions),
            intLabelOptions: Object.assign({}, styles.intLabelOptions),
            rwyLabelOptions: Object.assign({}, styles.rwyLabelOptions),
            userLabelOptions: Object.assign({}, styles.userLabelOptions),
            fpLabelOptions: Object.assign({}, styles.fpLabelOptions)
        });
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.flightPathLayerRef.instance.onAttached();
        this.waypointLayerRef.instance.onAttached();
        this.initWaypointRenderer();
        this.initFlightPlanHandlers();
    }
    /**
     * Initializes the waypoint renderer.
     */
    initWaypointRenderer() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.props.waypointRenderer.setCanvasContext(MapWaypointRenderRole.FlightPlanInactive, this.waypointLayerRef.instance.display.context);
        this.props.waypointRenderer.setIconFactory(MapWaypointRenderRole.FlightPlanInactive, this.iconFactoryInactive);
        this.props.waypointRenderer.setLabelFactory(MapWaypointRenderRole.FlightPlanInactive, this.labelFactoryInactive);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.props.waypointRenderer.setCanvasContext(MapWaypointRenderRole.FlightPlanActive, this.waypointLayerRef.instance.display.context);
        this.props.waypointRenderer.setIconFactory(MapWaypointRenderRole.FlightPlanActive, this.iconFactoryActive);
        this.props.waypointRenderer.setLabelFactory(MapWaypointRenderRole.FlightPlanActive, this.labelFactoryActive);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.props.waypointRenderer.setCanvasContext(MapWaypointRenderRole.VNav, this.waypointLayerRef.instance.display.context);
        this.props.waypointRenderer.setIconFactory(MapWaypointRenderRole.VNav, this.vnavIconFactory);
        this.props.waypointRenderer.setLabelFactory(MapWaypointRenderRole.VNav, this.vnavLabelFactory);
    }
    /**
     * Initializes handlers to respond to flight plan events.
     */
    initFlightPlanHandlers() {
        this.props.drawEntirePlan.sub(() => { this.scheduleUpdates(true, true, true); });
        this.props.dataProvider.plan.sub(() => { this.scheduleUpdates(true, true, true); }, true);
        this.props.dataProvider.planModified.on(() => { this.scheduleUpdates(false, true, true); });
        this.props.dataProvider.planCalculated.on(() => {
            this.scheduleUpdates(true, true, false);
            this.onTodBodChanged();
        });
        this.props.dataProvider.activeLateralLegIndex.sub(() => { this.scheduleUpdates(true, true, true); });
        this.props.dataProvider.activeLNavLegVectorIndex.sub(() => { this.scheduleUpdates(true, false, false); });
        this.props.dataProvider.isLNavSuspended.sub(() => { this.scheduleUpdates(true, false, false); });
        this.props.dataProvider.vnavTodLegIndex.sub(() => { this.onTodBodChanged(); });
        this.props.dataProvider.vnavTodLegDistance.sub(() => { this.onTodBodChanged(); });
        this.props.dataProvider.vnavBodLegIndex.sub(() => { this.onTodBodChanged(); });
        this.props.dataProvider.obsCourse.sub((course) => {
            const isActive = course !== undefined;
            const needFullUpdate = isActive !== this.isObsActive;
            this.isObsActive = isActive;
            this.obsCourse = course !== null && course !== void 0 ? course : this.obsCourse;
            this.scheduleUpdates(this.isObsActive, needFullUpdate, needFullUpdate);
        });
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.flightPathLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        this.waypointLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        this.flightPathLayerRef.instance.onUpdated(time, elapsed);
        this.updateFromFlightPathLayerInvalidation();
        this.updateRedrawRoute();
        this.updateRefreshWaypoints();
    }
    /**
     * Checks if the flight path layer's display canvas has been invalidated, and if so, clears it and schedules a redraw.
     */
    updateFromFlightPathLayerInvalidation() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const display = this.flightPathLayerRef.instance.display;
        this.needDrawRoute || (this.needDrawRoute = display.isInvalid);
        if (display.isInvalid) {
            display.clear();
            display.syncWithMapProjection(this.props.mapProjection, this.flightPathLayerRef.instance.getReferenceMargin());
        }
    }
    /**
     * Redraws the flight path if a redraw is scheduled.
     */
    updateRedrawRoute() {
        if (this.needDrawRoute) {
            this.drawRoute();
            this.needDrawRoute = false;
        }
    }
    /**
     * Refreshes this layer's flight plan leg waypoint records if a refresh is scheduled.
     */
    updateRefreshWaypoints() {
        if (this.needRefreshWaypoints && !this.isRefreshWaypointsBusy) {
            this.refreshWaypoints();
            this.needRefreshWaypoints = false;
            this.needRepickWaypoints = false;
        }
    }
    /**
     * Draws the flight path route.
     */
    drawRoute() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const display = this.flightPathLayerRef.instance.display;
        const context = display.context;
        display.clear();
        const flightPlan = this.props.dataProvider.plan.get();
        if (!flightPlan) {
            return;
        }
        const activeLegIndex = this.props.dataProvider.activeLateralLegIndex.get();
        const baseRouteInitialIndex = this.props.drawEntirePlan.get()
            ? 0
            : activeLegIndex >= 0
                ? this.isObsActive ? activeLegIndex : activeLegIndex - 1
                : flightPlan.length;
        this.drawBaseRoute(flightPlan, baseRouteInitialIndex, context);
        if (this.isObsActive) {
            this.drawObs(flightPlan, context);
        }
        else {
            this.drawRouteWithTurns(flightPlan, context);
        }
    }
    /**
     * Draws the flight plan route, including leg to leg turns.
     * @param flightPlan The flight plan to draw.
     * @param context The context to draw to.
     */
    drawRouteWithTurns(flightPlan, context) {
        var _a, _b;
        let legIndex = 0;
        const activeLegIndex = this.props.dataProvider.activeLateralLegIndex.get();
        const drawnActiveLegIndex = activeLegIndex >= 0 ? activeLegIndex : flightPlan.length;
        const firstIndex = this.props.drawEntirePlan.get() ? 0 : drawnActiveLegIndex - 1;
        let isInMissedApproach = false;
        const isMissedApproachActive = drawnActiveLegIndex < flightPlan.length && flightPlan.getLeg(drawnActiveLegIndex).isInMissedApproachSequence;
        context.beginPath();
        context.lineWidth = MapFlightPlanLayer.ROUTE_PRIOR_STROKE_WIDTH;
        context.strokeStyle = MapFlightPlanLayer.ROUTE_PRIOR_STROKE_COLOR;
        let activeLeg = null;
        for (const leg of flightPlan.legs()) {
            if (legIndex >= firstIndex && (!leg.isInDirectToSequence || legIndex === drawnActiveLegIndex)) {
                if (legIndex < drawnActiveLegIndex) {
                    if (leg.leg.type === LegType.HM || ((leg.leg.type === LegType.HF || leg.leg.type === LegType.HA) && ((_b = (_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.flightPath.length) !== null && _b !== void 0 ? _b : 0) > 4)) {
                        this.drawLegWithTurns(leg, context, false, false, leg.calculated ? leg.calculated.flightPath.length - 4 : 0);
                    }
                    else {
                        this.drawLegWithTurns(leg, context);
                    }
                }
                else if (legIndex > drawnActiveLegIndex) {
                    if (!isInMissedApproach && !isMissedApproachActive && leg.isInMissedApproachSequence) {
                        context.stroke();
                        context.beginPath();
                        context.lineWidth = MapFlightPlanLayer.ROUTE_MISSED_APPROACH_STROKE_WIDTH;
                        context.strokeStyle = MapFlightPlanLayer.ROUTE_PRIOR_STROKE_COLOR;
                        isInMissedApproach = true;
                    }
                    if (leg.leg.type === LegType.HM) {
                        this.drawHold(leg, activeLeg, context);
                    }
                    else {
                        this.drawLegWithTurns(leg, context);
                    }
                }
                else {
                    context.stroke();
                    context.beginPath();
                    context.lineWidth = MapFlightPlanLayer.ROUTE_STROKE_WIDTH;
                    context.strokeStyle = 'white';
                    activeLeg = leg;
                }
            }
            legIndex++;
        }
        if (activeLeg) {
            context.stroke();
            context.beginPath();
            context.lineWidth = MapFlightPlanLayer.ROUTE_STROKE_WIDTH;
            context.strokeStyle = 'magenta';
            if (activeLeg.leg.type === LegType.HM) {
                this.drawHold(activeLeg, activeLeg, context);
            }
            else {
                this.drawLegWithTurns(activeLeg, context);
            }
        }
        context.stroke();
    }
    /**
     * Draws a flight plan leg, including leg to leg turns.
     * @param leg The leg to draw.
     * @param context The context to draw to.
     * @param skipIngress Skips drawing the ingress leg.
     * @param skipEgress Skips drawing the egress leg.
     * @param startIndex The index to start drawing the leg at.
     */
    drawLegWithTurns(leg, context, skipIngress = false, skipEgress = false, startIndex = 0) {
        const calculated = leg.calculated;
        if (calculated) {
            for (let i = startIndex; i < calculated.flightPath.length; i++) {
                const vector = calculated.flightPath[i];
                if (i === 0 && calculated.ingressTurn.radius !== 0) {
                    if (i === calculated.flightPath.length - 1 && calculated.egressTurn.radius !== 0) {
                        this.drawVectorSegment(vector, context, skipIngress ? undefined : calculated.ingressTurn, skipEgress ? undefined : calculated.egressTurn);
                    }
                    else {
                        this.drawVectorSegment(vector, context, skipIngress ? undefined : calculated.ingressTurn);
                    }
                }
                else if (i === calculated.flightPath.length - 1 && calculated.egressTurn.radius !== 0) {
                    this.drawVectorSegment(vector, context, undefined, skipEgress ? undefined : calculated.egressTurn);
                }
                else {
                    this.drawVectorSegment(vector, context);
                }
            }
        }
    }
    /**
     * Draws a hold leg.
     * @param leg The hold leg to draw.
     * @param activeLeg The current active leg.
     * @param context The context to draw to.
     */
    drawHold(leg, activeLeg, context) {
        var _a, _b;
        const inHold = leg.calculated !== undefined && this.props.dataProvider.activeLNavLegVectorIndex.get() >= leg.calculated.flightPath.length - 4;
        const isActiveLeg = leg === activeLeg;
        if (!isActiveLeg) {
            this.drawLegWithTurns(leg, context, false, true);
        }
        else {
            if (inHold && !this.props.dataProvider.isLNavSuspended.get()) {
                const startIndex = leg.calculated !== undefined ? ((_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.flightPath.length) - 4 : 0;
                this.drawLegWithTurns(leg, context, true, false, startIndex);
            }
            else if (inHold) {
                const startIndex = leg.calculated !== undefined ? ((_b = leg.calculated) === null || _b === void 0 ? void 0 : _b.flightPath.length) - 4 : 0;
                this.drawLegWithTurns(leg, context, true, true, startIndex);
            }
            else {
                this.drawLegWithTurns(leg, context, false, true);
            }
        }
    }
    /**
     * Draws the flight plan route, without any leg to leg turns.
     * @param flightPlan The flight plan to draw.
     * @param initialIndex The index of the first flight plan leg to draw.
     * @param context The context to draw to.
     */
    drawBaseRoute(flightPlan, initialIndex, context) {
        context.beginPath();
        context.lineWidth = MapFlightPlanLayer.BASE_ROUTE_STROKE_WIDTH;
        context.strokeStyle = MapFlightPlanLayer.BASE_ROUTE_STROKE_COLOR;
        let legIndex = 0;
        for (const leg of flightPlan.legs()) {
            if (legIndex >= initialIndex && (!leg.isInDirectToSequence || legIndex === flightPlan.activeLateralLeg)) {
                this.drawLegWithoutTurns(leg, context);
            }
            legIndex++;
        }
        context.stroke();
    }
    /**
     * Draws the OBS route.
     * @param flightPlan The active flight plan.
     * @param context The context to draw to.
     */
    drawObs(flightPlan, context) {
        var _a, _b;
        const activeLegIndex = this.props.dataProvider.activeLateralLegIndex.get();
        const activeLeg = activeLegIndex >= 0 && activeLegIndex < flightPlan.length
            ? flightPlan.getLeg(flightPlan.activeLateralLeg)
            : null;
        if (((_a = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.calculated) === null || _a === void 0 ? void 0 : _a.endLat) === undefined || ((_b = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.calculated) === null || _b === void 0 ? void 0 : _b.endLon) === undefined) {
            return;
        }
        context.lineWidth = MapFlightPlanLayer.ROUTE_STROKE_WIDTH;
        const obsFix = MapFlightPlanLayer.geoPointCache[0].set(activeLeg.calculated.endLat, activeLeg.calculated.endLon);
        const obsLat = obsFix.lat;
        const obsLon = obsFix.lon;
        const obsCourseTrue = MagVar.magneticToTrue(this.obsCourse, obsLat, obsLon);
        const obsPath = MapFlightPlanLayer.geoCircleCache[0].setAsGreatCircle(obsFix, obsCourseTrue);
        const start = obsPath.offsetDistanceAlong(obsFix, UnitType.NMILE.convertTo(-500, UnitType.GA_RADIAN), MapFlightPlanLayer.geoPointCache[1]);
        const startLat = start.lat;
        const startLon = start.lon;
        const end = obsPath.offsetDistanceAlong(obsFix, UnitType.NMILE.convertTo(500, UnitType.GA_RADIAN), MapFlightPlanLayer.geoPointCache[1]);
        const endLat = end.lat;
        const endLon = end.lon;
        context.strokeStyle = 'magenta';
        context.beginPath();
        this.drawTrack(startLat, startLon, obsLat, obsLon, context);
        context.stroke();
        context.strokeStyle = 'white';
        context.beginPath();
        this.drawTrack(obsLat, obsLon, endLat, endLon, context);
        context.stroke();
    }
    /**
     * Draws a flight plan leg, excluding leg to leg turns.
     * @param leg The leg to draw.
     * @param context The context to draw to.
     */
    drawLegWithoutTurns(leg, context) {
        const calculated = leg.calculated;
        if (calculated !== undefined) {
            for (let i = 0; i < calculated.flightPath.length; i++) {
                const vector = calculated.flightPath[i];
                this.drawVectorSegment(vector, context);
            }
        }
    }
    /**
     * Refreshes this layer's flight plan leg waypoint records, keeping them up to date with the active flight plan.
     */
    async refreshWaypoints() {
        this.isRefreshWaypointsBusy = true;
        const flightPlan = this.props.dataProvider.plan.get();
        if (!flightPlan) {
            // Remove all waypoint records.
            for (const record of this.legWaypointRecords.values()) {
                record.destroy();
            }
            this.legWaypointRecords.clear();
            this.isRefreshWaypointsBusy = false;
            return;
        }
        const activeLegIndex = this.props.dataProvider.activeLateralLegIndex.get();
        const activeLeg = activeLegIndex >= 0 && activeLegIndex < flightPlan.length
            ? flightPlan.getLeg(activeLegIndex)
            : null;
        if (this.needRepickWaypoints) {
            const legsToDisplay = new Set();
            // Gather all legs to display.
            const firstLegIndex = this.props.drawEntirePlan.get()
                ? 0
                : activeLegIndex >= 0
                    ? this.isObsActive ? activeLegIndex : activeLegIndex - 2
                    : flightPlan.length;
            let legIndex = 0;
            for (const leg of flightPlan.legs()) {
                if (legIndex >= firstLegIndex && (!leg.isInDirectToSequence || legIndex === flightPlan.activeLateralLeg)) {
                    legsToDisplay.add(leg);
                }
                legIndex++;
            }
            // Remove records of legs that are no longer in the set of legs to display.
            for (const record of this.legWaypointRecords.values()) {
                if (legsToDisplay.has(record.leg)) {
                    legsToDisplay.delete(record.leg);
                }
                else {
                    record.destroy();
                    this.legWaypointRecords.delete(record.leg);
                }
            }
            // Create new records for legs to display that don't already have records.
            for (const leg of legsToDisplay) {
                const record = this.createLegWaypointsRecord(leg);
                this.legWaypointRecords.set(leg, record);
            }
        }
        const waypointRefreshes = [];
        for (const record of this.legWaypointRecords.values()) {
            waypointRefreshes.push(record.refresh(record.leg === activeLeg));
        }
        await Promise.all(waypointRefreshes);
        this.isRefreshWaypointsBusy = false;
    }
    /**
     * Creates a FlightPlanLegWaypointsRecord for a specified flight plan leg.
     * @param leg A flight plan leg.
     * @returns A FlightPlanLegWaypointsRecord for the specified flight plan leg.
     */
    createLegWaypointsRecord(leg) {
        switch (leg.leg.type) {
            case LegType.CD:
            case LegType.VD:
            case LegType.CR:
            case LegType.VR:
            case LegType.FC:
            case LegType.FD:
            case LegType.FA:
            case LegType.CA:
            case LegType.VA:
            case LegType.FM:
            case LegType.VM:
            case LegType.CI:
            case LegType.VI:
                return new FlightPathTerminatorWaypointsRecord(leg, this.props.waypointRenderer, this.facLoader);
            case LegType.PI:
                return new ProcedureTurnLegWaypointsRecord(leg, this.props.waypointRenderer, this.facLoader, this.facWaypointCache);
            default:
                return new FixIcaoWaypointsRecord(leg, this.props.waypointRenderer, this.facLoader, this.facWaypointCache);
        }
    }
    /**
     * Draws a segment of a vector to the flight plan layer.
     * @param vector The vector to draw.
     * @param context The canvas context to draw to.
     * @param turnBefore A turn to draw before the vector, if any.
     * @param turnAfter A turn to draw after the vector, if any.
     */
    drawVectorSegment(vector, context, turnBefore, turnAfter) {
        let currentLat = vector.startLat;
        let currentLon = vector.startLon;
        if (turnBefore !== undefined) {
            const turnCircle = FlightPathUtils.setGeoCircleFromVector(turnBefore, MapFlightPlanLayer.geoCircleCache[0]);
            const turnCenter = FlightPathUtils.getTurnCenterFromCircle(turnCircle, MapFlightPlanLayer.geoPointCache[0]);
            this.drawArc(turnBefore.startLat, turnBefore.startLon, turnBefore.endLat, turnBefore.endLon, turnCenter.lat, turnCenter.lon, FlightPathUtils.getTurnDirectionFromCircle(turnCircle), context);
            currentLat = turnBefore.endLat;
            currentLon = turnBefore.endLon;
        }
        let endLat = vector.endLat;
        let endLon = vector.endLon;
        if (turnAfter !== undefined) {
            endLat = turnAfter.startLat;
            endLon = turnAfter.startLon;
        }
        const circle = FlightPathUtils.setGeoCircleFromVector(vector, MapFlightPlanLayer.geoCircleCache[0]);
        if (FlightPathUtils.isVectorGreatCircle(vector)) {
            const distanceRad = UnitType.METER.convertTo(vector.distance, UnitType.GA_RADIAN);
            if (distanceRad >= Math.PI - GeoPoint.EQUALITY_TOLERANCE) {
                const startPoint = GeoPoint.sphericalToCartesian(vector.startLat, vector.startLon, MapFlightPlanLayer.vec3Cache[0]);
                const midPoint = circle.offsetDistanceAlong(startPoint, distanceRad, MapFlightPlanLayer.geoPointCache[0]);
                const midLat = midPoint.lat;
                const midLon = midPoint.lon;
                this.drawTrack(currentLat, currentLon, midLat, midLon, context);
                this.drawTrack(midLat, midLon, endLat, endLon, context);
            }
            else {
                this.drawTrack(currentLat, currentLon, endLat, endLon, context);
            }
        }
        else {
            const turnCenter = FlightPathUtils.getTurnCenterFromCircle(circle, MapFlightPlanLayer.geoPointCache[0]);
            this.drawArc(currentLat, currentLon, endLat, endLon, turnCenter.lat, turnCenter.lon, FlightPathUtils.getTurnDirectionFromCircle(circle), context);
        }
        if (turnAfter !== undefined) {
            const turnCircle = FlightPathUtils.setGeoCircleFromVector(turnAfter, MapFlightPlanLayer.geoCircleCache[0]);
            const turnCenter = FlightPathUtils.getTurnCenterFromCircle(turnCircle, MapFlightPlanLayer.geoPointCache[0]);
            this.drawArc(turnAfter.startLat, turnAfter.startLon, turnAfter.endLat, turnAfter.endLon, turnCenter.lat, turnCenter.lon, FlightPathUtils.getTurnDirectionFromCircle(turnCircle), context);
        }
    }
    /**
     * Draws a track vector.
     * @param sLat The starting lat.
     * @param sLon The starting lon.
     * @param eLat The ending lat.
     * @param eLon The ending lon.
     * @param context The context to draw to.
     */
    drawTrack(sLat, sLon, eLat, eLon, context) {
        const start = MapFlightPlanLayer.geoPointCache[0].set(sLat, sLon);
        const end = MapFlightPlanLayer.geoPointCache[1].set(eLat, eLon);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.resampler.resample(this.flightPathLayerRef.instance.display.geoProjection, start, end, this.drawResampledTrack.bind(this, context));
    }
    /**
     * Draws the path for a resampled point along a track vector.
     * @param context The context to draw to.
     * @param point The resampled point to draw.
     * @param projected The projected resampled point to draw.
     * @param index The index of the resampled point.
     */
    drawResampledTrack(context, point, projected, index) {
        if (index === 0) {
            context.moveTo(projected[0], projected[1]);
        }
        else {
            context.lineTo(projected[0], projected[1]);
        }
    }
    /**
     * Draws an arc vector.
     * @param sLat The starting lat.
     * @param sLon The starting lon.
     * @param eLat The ending lat.
     * @param eLon The ending lon.
     * @param cLat The center lat.
     * @param cLon The center lon.
     * @param turnDirection The turn direction of the arc.
     * @param context The context to draw to.
     */
    drawArc(sLat, sLon, eLat, eLon, cLat, cLon, turnDirection, context) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const projection = this.flightPathLayerRef.instance.display.geoProjection;
        const start = MapFlightPlanLayer.geoPointCache[0].set(sLat, sLon);
        const startProjected = projection.project(start, MapFlightPlanLayer.vec2Cache[0]);
        const x1 = startProjected[0];
        const y1 = startProjected[1];
        const end = MapFlightPlanLayer.geoPointCache[0].set(eLat, eLon);
        const endProjected = projection.project(end, MapFlightPlanLayer.vec2Cache[0]);
        const x2 = endProjected[0];
        const y2 = endProjected[1];
        const center = MapFlightPlanLayer.geoPointCache[0].set(cLat, cLon);
        const centerProjected = projection.project(center, MapFlightPlanLayer.vec2Cache[0]);
        const cx = centerProjected[0];
        const cy = centerProjected[1];
        const radiusPixels = Math.sqrt(Math.pow(cx - x1, 2) + Math.pow(cy - y1, 2));
        const startRadians = Math.atan2(y1 - cy, x1 - cx);
        const endRadians = Math.atan2(y2 - cy, x2 - cx);
        context.moveTo(x1, y1);
        context.arc(cx, cy, radiusPixels, startRadians, endRadians, turnDirection === 'left');
    }
    /**
     * Schedules flight plan drawing updates.
     * @param scheduleRedrawRoute Whether to schedule a redraw of the flight path.
     * @param scheduleRefreshWaypoints Whether to schedule a refresh of waypoints records.
     * @param scheduleRepickWaypoints Whether to schedule a repick of waypoints records.
     */
    scheduleUpdates(scheduleRedrawRoute, scheduleRefreshWaypoints, scheduleRepickWaypoints) {
        this.needDrawRoute || (this.needDrawRoute = scheduleRedrawRoute);
        this.needRefreshWaypoints || (this.needRefreshWaypoints = scheduleRefreshWaypoints);
        this.needRepickWaypoints || (this.needRepickWaypoints = scheduleRepickWaypoints);
    }
    /**
     * Recreates the TOD and BOD leg indexes when any values change.
     */
    onTodBodChanged() {
        const plan = this.props.dataProvider.plan.get();
        if (!plan) {
            this.todWaypoint && this.props.waypointRenderer.deregister(this.todWaypoint, MapWaypointRenderRole.VNav, 'flightplan-layer');
            this.bodWaypoint && this.props.waypointRenderer.deregister(this.bodWaypoint, MapWaypointRenderRole.VNav, 'flightplan-layer');
            this.todWaypoint = undefined;
            this.bodWaypoint = undefined;
            return;
        }
        const vnavPathMode = this.props.dataProvider.vnavPathMode.get();
        const todLegIndex = this.props.dataProvider.vnavTodLegIndex.get();
        const todLegEndDistance = this.props.dataProvider.vnavTodLegDistance.get();
        const bodLegIndex = this.props.dataProvider.vnavBodLegIndex.get();
        let registerNewTodBod = true;
        if (plan.segmentCount < 1 || plan.getSegment(0).segmentType === FlightPlanSegmentType.RandomDirectTo) {
            registerNewTodBod = false;
        }
        if (todLegIndex >= 0) {
            this.todWaypoint && this.props.waypointRenderer.deregister(this.todWaypoint, MapWaypointRenderRole.VNav, 'flightplan-layer');
            if (registerNewTodBod && isFinite(todLegEndDistance.number) && todLegIndex >= 0 && vnavPathMode !== VNavPathMode.PathActive && plan.length > 0) {
                try {
                    const leg = plan.getLeg(todLegIndex);
                    this.todWaypoint = new VNavWaypoint(leg, todLegEndDistance.asUnit(UnitType.METER), 'tod');
                    this.props.waypointRenderer.register(this.todWaypoint, MapWaypointRenderRole.VNav, 'flightplan-layer');
                }
                catch (_a) {
                    console.warn(`Invalid tod leg at: ${todLegIndex}`);
                }
            }
            else if (!isFinite(todLegEndDistance.number)) {
                this.todWaypoint = undefined;
                console.warn(`Invalid TOD leg end distance: ${todLegEndDistance}`);
            }
        }
        if (bodLegIndex >= 0) {
            this.bodWaypoint && this.props.waypointRenderer.deregister(this.bodWaypoint, MapWaypointRenderRole.VNav, 'flightplan-layer');
            if (registerNewTodBod && bodLegIndex >= 0 && plan.length > 0) {
                try {
                    const leg = plan.getLeg(bodLegIndex);
                    this.bodWaypoint = new VNavWaypoint(leg, 0, 'bod');
                    this.props.waypointRenderer.register(this.bodWaypoint, MapWaypointRenderRole.VNav, 'flightplan-layer');
                }
                catch (_b) {
                    console.warn(`Invalid bod leg at: ${bodLegIndex}`);
                }
            }
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { style: 'position: absolute; left: 0; top: 0; width: 100%; height: 100%;' },
            FSComponent.buildComponent(MapCachedCanvasLayer, { ref: this.flightPathLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, useBuffer: true, overdrawFactor: Math.SQRT2 }),
            FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.waypointLayerRef, model: this.props.model, mapProjection: this.props.mapProjection })));
    }
}
MapFlightPlanLayer.BASE_ROUTE_STROKE_WIDTH = 2;
MapFlightPlanLayer.BASE_ROUTE_STROKE_COLOR = 'rgba(204, 204, 204, 0.5)';
MapFlightPlanLayer.ROUTE_PRIOR_STROKE_WIDTH = 2;
MapFlightPlanLayer.ROUTE_PRIOR_STROKE_COLOR = '#cccccc';
MapFlightPlanLayer.ROUTE_STROKE_WIDTH = 4;
MapFlightPlanLayer.ROUTE_MISSED_APPROACH_STROKE_WIDTH = 1;
MapFlightPlanLayer.vec2Cache = [new Float64Array(2)];
MapFlightPlanLayer.vec3Cache = [new Float64Array(3)];
MapFlightPlanLayer.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
MapFlightPlanLayer.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
/**
 * An abstract implementation of FlightPlanLegWaypointsRecord.
 */
class AbstractFlightPlanLegWaypointsRecord {
    /**
     * Constructor.
     * @param leg The flight plan leg associated with this record.
     * @param waypointRenderer The renderer used to render this record's waypoints.
     * @param facLoader The facility loader used by this waypoint.
     */
    constructor(leg, waypointRenderer, facLoader) {
        this.leg = leg;
        this.waypointRenderer = waypointRenderer;
        this.facLoader = facLoader;
        this.uid = `flightplan-layer-wptrecord-${AbstractFlightPlanLegWaypointsRecord.uidSource++}`;
        this.isActive = false;
    }
    /**
     * Registers a waypoint with this record's waypoint renderer.
     * @param waypoint A waypoint.
     * @param role The role(s) under which the waypoint should be registered.
     */
    registerWaypoint(waypoint, role) {
        this.waypointRenderer.register(waypoint, role, this.uid);
    }
    /**
     * Removes a registration for a waypoint from this record's waypoint renderer.
     * @param waypoint A waypoint.
     * @param role The role(s) from which the waypoint should be deregistered.
     */
    deregisterWaypoint(waypoint, role) {
        this.waypointRenderer.deregister(waypoint, role, this.uid);
    }
}
AbstractFlightPlanLegWaypointsRecord.uidSource = 0;
/**
 * A record with a single waypoint based on its flight plan leg's fixIcao property.
 */
class FixIcaoWaypointsRecord extends AbstractFlightPlanLegWaypointsRecord {
    /**
     * Constructor.
     * @param leg The flight plan leg associated with this record.
     * @param waypointRenderer The renderer used to render this record's waypoints.
     * @param facLoader The facility loader used by this waypoint.
     * @param facWaypointCache The facility waypoint cache used by this record.
     */
    constructor(leg, waypointRenderer, facLoader, facWaypointCache) {
        super(leg, waypointRenderer, facLoader);
        this.facWaypointCache = facWaypointCache;
        this._waypoint = null;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * This record's waypoint.
     */
    get waypoint() {
        return this._waypoint;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    async refresh(isActive) {
        const icao = this.leg.leg.fixIcao;
        if (!this._waypoint && icao !== '' && icao !== ICAO.emptyIcao) {
            this._waypoint = await this.getFacilityWaypoint(icao);
            if (this._waypoint) {
                this.registerWaypoint(this._waypoint, MapWaypointRenderRole.FlightPlanInactive);
                if (this.isActive) {
                    this.registerWaypoint(this._waypoint, MapWaypointRenderRole.FlightPlanActive);
                }
            }
        }
        if (isActive !== this.isActive) {
            if (this._waypoint) {
                isActive
                    ? this.registerWaypoint(this._waypoint, MapWaypointRenderRole.FlightPlanActive)
                    : this.deregisterWaypoint(this._waypoint, MapWaypointRenderRole.FlightPlanActive);
            }
            this.isActive = isActive;
        }
    }
    /**
     * Gets a facility waypoint from an ICAO string.
     * @param icao A facility ICAO string.
     * @returns a facility waypoint, or null if one could not be created.
     */
    async getFacilityWaypoint(icao) {
        try {
            const facility = await this.facLoader.getFacility(ICAO.getFacilityType(icao), icao);
            return this.facWaypointCache.get(facility);
        }
        catch (e) {
            // noop
        }
        return null;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    destroy() {
        if (!this._waypoint) {
            return;
        }
        this.deregisterWaypoint(this._waypoint, MapWaypointRenderRole.FlightPlanInactive);
        this.isActive && this.deregisterWaypoint(this._waypoint, MapWaypointRenderRole.FlightPlanActive);
    }
}
/**
 * A record with a single flight path waypoint representing its flight plan leg's terminator fix.
 */
class FlightPathTerminatorWaypointsRecord extends AbstractFlightPlanLegWaypointsRecord {
    constructor() {
        super(...arguments);
        this._waypoint = null;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * This record's flight path waypoint.
     */
    get waypoint() {
        return this._waypoint;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    async refresh(isActive) {
        var _a, _b;
        const lastVector = (_a = this.leg.calculated) === null || _a === void 0 ? void 0 : _a.flightPath[this.leg.calculated.flightPath.length - 1];
        if (lastVector) {
            if (!this._waypoint || !this._waypoint.location.equals(lastVector.endLat, lastVector.endLon)) {
                this.cleanUpWaypoint();
                this._waypoint = new FlightPathWaypoint(lastVector.endLat, lastVector.endLon, (_b = this.leg.name) !== null && _b !== void 0 ? _b : '');
                this.registerWaypoint(this._waypoint, MapWaypointRenderRole.FlightPlanInactive);
                if (this.isActive) {
                    this.registerWaypoint(this._waypoint, MapWaypointRenderRole.FlightPlanActive);
                }
            }
        }
        else {
            this.cleanUpWaypoint();
        }
        if (isActive !== this.isActive) {
            if (this._waypoint) {
                isActive
                    ? this.registerWaypoint(this._waypoint, MapWaypointRenderRole.FlightPlanActive)
                    : this.deregisterWaypoint(this._waypoint, MapWaypointRenderRole.FlightPlanActive);
            }
            this.isActive = isActive;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    destroy() {
        this.cleanUpWaypoint();
    }
    /**
     * Deregisters this record's waypoint, if it exists, from the waypoint renderer.
     */
    cleanUpWaypoint() {
        if (!this._waypoint) {
            return;
        }
        this.deregisterWaypoint(this._waypoint, MapWaypointRenderRole.FlightPlanInactive);
        this.isActive && this.deregisterWaypoint(this._waypoint, MapWaypointRenderRole.FlightPlanActive);
    }
}
/**
 * A record for procedure turn (PI) legs. Maintains two waypoints, both located at the PI leg's origin fix. The first
 * waypoint is a standard FacilityWaypoint which is never rendered in an active flight plan waypoint role. The second
 * is a ProcedureTurnWaypoint with an ident string equal to the PI leg's given name and which can be rendered in an
 * active flight plan waypoint role.
 */
class ProcedureTurnLegWaypointsRecord extends AbstractFlightPlanLegWaypointsRecord {
    /**
     * Constructor.
     * @param leg The flight plan leg associated with this record.
     * @param waypointRenderer The renderer used to render this record's waypoints.
     * @param facLoader The facility loader used by this waypoint.
     * @param facWaypointCache The facility waypoint cache used by this record.
     */
    constructor(leg, waypointRenderer, facLoader, facWaypointCache) {
        super(leg, waypointRenderer, facLoader);
        this.ptWaypoint = null;
        this.fixIcaoRecord = new FixIcaoWaypointsRecord(leg, waypointRenderer, facLoader, facWaypointCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    async refresh(isActive) {
        var _a;
        await this.fixIcaoRecord.refresh(false);
        if (!this.ptWaypoint && this.fixIcaoRecord.waypoint) {
            this.ptWaypoint = new ProcedureTurnLegWaypoint(this.fixIcaoRecord.waypoint.location.lat, this.fixIcaoRecord.waypoint.location.lon, (_a = this.leg.name) !== null && _a !== void 0 ? _a : '');
            this.registerWaypoint(this.ptWaypoint, MapWaypointRenderRole.FlightPlanInactive);
            if (this.isActive) {
                this.deregisterWaypoint(this.ptWaypoint, MapWaypointRenderRole.FlightPlanActive);
            }
        }
        if (isActive !== this.isActive) {
            if (this.ptWaypoint) {
                isActive
                    ? this.registerWaypoint(this.ptWaypoint, MapWaypointRenderRole.FlightPlanActive)
                    : this.deregisterWaypoint(this.ptWaypoint, MapWaypointRenderRole.FlightPlanActive);
            }
            this.isActive = isActive;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    destroy() {
        this.fixIcaoRecord.destroy();
        if (!this.ptWaypoint) {
            return;
        }
        this.deregisterWaypoint(this.ptWaypoint, MapWaypointRenderRole.FlightPlanInactive);
        this.isActive && this.deregisterWaypoint(this.ptWaypoint, MapWaypointRenderRole.FlightPlanActive);
    }
}
/**
 * A waypoint marking a procedure turn leg.
 */
class ProcedureTurnLegWaypoint extends CustomWaypoint {
    /**
     * Constructor.
     * @param lat The latitude of this waypoint.
     * @param lon The longitude of this waypoint.
     * @param ident The ident string of this waypoint.
     */
    constructor(lat, lon, ident) {
        super(lat, lon, `${ProcedureTurnLegWaypoint.UID_PREFIX}_${ident}`);
        this.ident = ident;
    }
}
ProcedureTurnLegWaypoint.UID_PREFIX = 'PI';
/**
 * A waypoint icon factory.
 */
class WaypointIconFactory$1 {
    /**
     * Constructor.
     * @param styles Icon styling options used by this factory.
     */
    constructor(styles) {
        this.styles = styles;
        this.cache = new Map();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getIcon(waypoint) {
        let existing = this.cache.get(waypoint.uid);
        if (!existing) {
            existing = this.createIcon(waypoint);
            this.cache.set(waypoint.uid, existing);
        }
        return existing;
    }
    /**
     * Creates a new icon for a waypoint.
     * @param waypoint The waypoint for which to create an icon.
     * @returns a waypoint icon.
     */
    createIcon(waypoint) {
        if (waypoint instanceof AirportWaypoint) {
            return new MapAirportIcon(waypoint, this.styles.airportIconPriority[waypoint.size], this.styles.airportIconSize[waypoint.size], this.styles.airportIconSize[waypoint.size]);
        }
        else if (waypoint instanceof FacilityWaypoint) {
            switch (ICAO.getFacilityType(waypoint.facility.icao)) {
                case FacilityType.VOR:
                    return new MapVorIcon(waypoint, this.styles.vorIconPriority, this.styles.vorIconSize, this.styles.vorIconSize);
                case FacilityType.NDB:
                    return new MapNdbIcon(waypoint, this.styles.ndbIconPriority, this.styles.ndbIconSize, this.styles.ndbIconSize);
                case FacilityType.Intersection:
                    return new MapIntersectionIcon(waypoint, this.styles.intIconPriority, this.styles.intIconSize, this.styles.intIconSize);
                case FacilityType.USR:
                    return new MapUserWaypointIcon(waypoint, this.styles.userIconPriority, this.styles.userIconSize, this.styles.userIconSize);
                case FacilityType.RWY:
                    return new MapRunwayWaypointIcon(waypoint, this.styles.rwyIconPriority, this.styles.rwyIconSize, this.styles.rwyIconSize);
                case FacilityType.VIS:
                    return new MapFlightPathWaypointIcon(waypoint, this.styles.fpIconPriority, this.styles.fpIconSize, this.styles.fpIconSize);
            }
        }
        else if (waypoint instanceof FlightPathWaypoint) {
            return new MapFlightPathWaypointIcon(waypoint, this.styles.fpIconPriority, this.styles.fpIconSize, this.styles.fpIconSize);
        }
        return new MapBlankWaypointIcon(waypoint, 0);
    }
}
/**
 * A waypoint label factory.
 */
class WaypointLabelFactory$1 {
    /**
     * Constructor.
     * @param styles Icon styling options used by this factory.
     */
    constructor(styles) {
        this.styles = styles;
        this.cache = new Map();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getLabel(waypoint) {
        let existing = this.cache.get(waypoint.uid);
        if (!existing) {
            existing = this.createLabel(waypoint);
            this.cache.set(waypoint.uid, existing);
        }
        return existing;
    }
    /**
     * Creates a new icon for a waypoint.
     * @param waypoint The waypoint for which to create an icon.
     * @returns a waypoint icon.
     */
    createLabel(waypoint) {
        let text = '';
        let priority = 0;
        let options;
        if (waypoint instanceof FacilityWaypoint) {
            text = ICAO.getIdent(waypoint.facility.icao);
            switch (ICAO.getFacilityType(waypoint.facility.icao)) {
                case FacilityType.Airport:
                    priority = this.styles.airportLabelPriority[waypoint.size];
                    options = this.styles.airportLabelOptions[waypoint.size];
                    break;
                case FacilityType.VOR:
                    priority = this.styles.vorLabelPriority;
                    options = this.styles.vorLabelOptions;
                    break;
                case FacilityType.NDB:
                    priority = this.styles.ndbLabelPriority;
                    options = this.styles.ndbLabelOptions;
                    break;
                case FacilityType.Intersection:
                    priority = this.styles.intLabelPriority;
                    options = this.styles.intLabelOptions;
                    break;
                case FacilityType.USR:
                    priority = this.styles.userLabelPriority;
                    options = this.styles.userLabelOptions;
                    break;
                case FacilityType.RWY:
                    priority = this.styles.rwyLabelPriority;
                    options = this.styles.rwyLabelOptions;
                    break;
                case FacilityType.VIS:
                    priority = this.styles.intLabelPriority;
                    options = this.styles.intLabelOptions;
                    break;
            }
        }
        else if (waypoint instanceof FlightPathWaypoint || waypoint instanceof ProcedureTurnLegWaypoint) {
            text = waypoint.ident;
            priority = this.styles.fpLabelPriority;
            options = this.styles.fpLabelOptions;
        }
        return new MapCullableLocationTextLabel(text, priority, waypoint.location, true, options);
    }
}
/**
 * A waypoint icon factory for VNAV waypoints.
 */
class VNavWaypointIconFactory {
    // eslint-disable-next-line jsdoc/require-jsdoc
    getIcon(waypoint) {
        return new MapVNavWaypointIcon(waypoint, 4, 32, 32);
    }
}
/**
 * A waypoint label factory for VNAV waypoints.
 */
class VNavWaypointLabelFactory {
    // eslint-disable-next-line jsdoc/require-jsdoc
    getLabel(waypoint) {
        return new MapCullableLocationTextLabel(waypoint.uid === 'vnav-tod' ? 'TOD' : 'BOD', 1, waypoint.location, true, { anchor: new Float64Array([-0.2, -0.2]), fontSize: 16 });
    }
}

/**
 * A map flight plan layer data provider which provides a displayed flight plan from a flight planner.
 */
class MapFlightPlannerPlanDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param planner The flight planner.
     */
    constructor(bus, planner) {
        this.bus = bus;
        this.planner = planner;
        this.planSub = Subject.create(null);
        this.plan = this.planSub;
        this.planModified = new SubEvent();
        this.planCalculated = new SubEvent();
        this.activeLegIndexSub = Subject.create(0);
        this.activeLateralLegIndex = this.activeLegIndexSub;
        this.activeLNavLegVectorIndexSub = Subject.create(0);
        this.activeLNavLegVectorIndex = this.activeLNavLegVectorIndexSub;
        this.isLNavSuspendedSub = Subject.create(false);
        this.isLNavSuspended = this.isLNavSuspendedSub;
        this.vnavPathModeSub = Subject.create(VNavPathMode.None);
        this.vnavPathMode = this.vnavPathModeSub;
        this.vnavTodLegIndexSub = Subject.create(-1);
        this.vnavTodLegIndex = this.vnavTodLegIndexSub;
        this.vnavTodLegDistanceSub = NumberUnitSubject.createFromNumberUnit(UnitType.METER.createNumber(0));
        this.vnavTodLegDistance = this.vnavTodLegDistanceSub;
        this.vnavBodLegIndexSub = Subject.create(-1);
        this.vnavBodLegIndex = this.vnavBodLegIndexSub;
        this.obsCourseSub = Subject.create(undefined);
        this.obsCourse = this.obsCourseSub;
        this.planIndex = -1;
        this.activeLNavLegVectorIndexValue = 0;
        this.isLNavSuspendedValue = false;
        this.vnavPathModeValue = VNavPathMode.None;
        this.vnavTodLegIndexValue = -1;
        this.vnavTodLegDistanceMeters = 0;
        this.vnavBodLegIndexValue = -1;
        this.isObsActive = false;
        this.obsCourseValue = 0;
        const plannerEvents = bus.getSubscriber();
        plannerEvents.on('fplCreated').handle(data => { data.planIndex === this.planIndex && this.updatePlan(); });
        plannerEvents.on('fplDeleted').handle(data => { data.planIndex === this.planIndex && this.updatePlan(); });
        plannerEvents.on('fplLoaded').handle(data => { data.planIndex === this.planIndex && this.updatePlan(); });
        plannerEvents.on('fplIndexChanged').handle(() => { this.updateActivePlanRelatedSubs(); });
        plannerEvents.on('fplLegChange').handle(data => { data.planIndex === this.planIndex && this.planModified.notify(this); });
        plannerEvents.on('fplSegmentChange').handle(data => { data.planIndex === this.planIndex && this.planModified.notify(this); });
        plannerEvents.on('fplOriginDestChanged').handle(data => { data.planIndex === this.planIndex && this.planModified.notify(this); });
        plannerEvents.on('fplActiveLegChange').handle(data => { data.planIndex === this.planIndex && data.type === ActiveLegType.Lateral && this.updateActiveLegIndex(); });
        plannerEvents.on('fplCalculated').handle(data => { data.planIndex === this.planIndex && this.planCalculated.notify(this); });
        const lnavEvents = bus.getSubscriber();
        lnavEvents.on('lnavCurrentVector').whenChanged().handle(index => {
            this.activeLNavLegVectorIndexValue = index;
            this.updateActiveLNavLegVectorIndex();
        });
        lnavEvents.on('suspChanged').whenChanged().handle(isSuspended => {
            this.isLNavSuspendedValue = isSuspended;
            this.updateIsLNavSuspended();
        });
        const vnavEvents = bus.getSubscriber();
        vnavEvents.on('vnavPathMode').whenChanged().handle(mode => {
            this.vnavPathModeValue = mode;
            this.updateVNavPathMode();
        });
        vnavEvents.on('vnavTodLegIndex').whenChanged().handle(legIndex => {
            this.vnavTodLegIndexValue = legIndex;
            this.updateVNavTodLegIndex();
        });
        vnavEvents.on('vnavTodLegDistance').withPrecision(0).handle(distance => {
            this.vnavTodLegDistanceMeters = distance;
            this.updateVNavTodLegDistance();
        });
        vnavEvents.on('vnavBodLegIndex').whenChanged().handle(legIndex => {
            this.vnavBodLegIndexValue = legIndex;
            this.updateVNavBodLegIndex();
        });
        const navEvents = this.bus.getSubscriber();
        navEvents.on('gps_obs_active').whenChanged().handle(isActive => {
            this.isObsActive = isActive;
            this.updateObsCourse();
        });
        navEvents.on('gps_obs_value').whenChanged().handle(course => {
            this.obsCourseValue = course;
            this.updateObsCourse();
        });
    }
    /**
     * Sets the index of the displayed plan.
     * @param index The index of the displayed plan.
     */
    setPlanIndex(index) {
        if (index === this.planIndex) {
            return;
        }
        this.planIndex = index;
        this.updatePlan();
        this.updateActivePlanRelatedSubs();
    }
    /**
     * Updates the displayed plan.
     */
    updatePlan() {
        if (this.planner.hasFlightPlan(this.planIndex)) {
            this.planSub.set(this.planner.getFlightPlan(this.planIndex));
        }
        else {
            this.planSub.set(null);
        }
    }
    /**
     * Updates subjects related to the active plan.
     */
    updateActivePlanRelatedSubs() {
        this.updateActiveLegIndex();
        this.updateActiveLNavLegVectorIndex();
        this.updateIsLNavSuspended();
        this.updateVNavPathMode();
        this.updateVNavTodLegIndex();
        this.updateVNavTodLegDistance();
        this.updateVNavBodLegIndex();
        this.updateObsCourse();
    }
    /**
     * Updates the active leg index.
     */
    updateActiveLegIndex() {
        const plan = this.plan.get();
        this.activeLegIndexSub.set(plan && this.planIndex === this.planner.activePlanIndex ? plan.activeLateralLeg : -1);
    }
    /**
     * Updates the active LNAV leg vector index.
     */
    updateActiveLNavLegVectorIndex() {
        this.activeLNavLegVectorIndexSub.set(this.planIndex === this.planner.activePlanIndex ? this.activeLNavLegVectorIndexValue : 0);
    }
    /**
     * Updates whether LNAV sequencing is suspended.
     */
    updateIsLNavSuspended() {
        this.isLNavSuspendedSub.set(this.planIndex === this.planner.activePlanIndex && this.isLNavSuspendedValue);
    }
    /**
     * Updates the current VNAV path mode.
     */
    updateVNavPathMode() {
        this.vnavPathModeSub.set(this.planIndex === this.planner.activePlanIndex ? this.vnavPathModeValue : VNavPathMode.None);
    }
    /**
     * Updates the index of the VNAV top-of-descent leg.
     */
    updateVNavTodLegIndex() {
        this.vnavTodLegIndexSub.set(this.planIndex === this.planner.activePlanIndex ? this.vnavTodLegIndexValue : -1);
    }
    /**
     * Updates the distance from the VNAV top-of-descent point to the end of the top-of-descent leg.
     */
    updateVNavTodLegDistance() {
        this.vnavTodLegDistanceSub.set(this.planIndex === this.planner.activePlanIndex ? this.vnavTodLegDistanceMeters : 0, UnitType.METER);
    }
    /**
     * Updates the index of the VNAV bottom-of-descent leg.
     */
    updateVNavBodLegIndex() {
        this.vnavBodLegIndexSub.set(this.planIndex === this.planner.activePlanIndex ? this.vnavBodLegIndexValue : -1);
    }
    /**
     * Updates the OBS course.
     */
    updateObsCourse() {
        this.obsCourseSub.set(this.planIndex === this.planner.activePlanIndex && this.isObsActive ? this.obsCourseValue : undefined);
    }
}

/**
 * A map flight plan layer data provider which provides the active flight plan to be displayed.
 */
class MapActiveFlightPlanDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param planner The flight planner.
     */
    constructor(bus, planner) {
        this.bus = bus;
        this.planner = planner;
        this.provider = new MapFlightPlannerPlanDataProvider(this.bus, this.planner);
        this.plan = this.provider.plan;
        this.planModified = this.provider.planModified;
        this.planCalculated = this.provider.planCalculated;
        this.activeLateralLegIndex = this.provider.activeLateralLegIndex;
        this.activeLNavLegVectorIndex = this.provider.activeLNavLegVectorIndex;
        this.isLNavSuspended = this.provider.isLNavSuspended;
        this.vnavPathMode = this.provider.vnavPathMode;
        this.vnavTodLegIndex = this.provider.vnavTodLegIndex;
        this.vnavTodLegDistance = this.provider.vnavTodLegDistance;
        this.vnavBodLegIndex = this.provider.vnavBodLegIndex;
        this.obsCourse = this.provider.obsCourse;
        const plannerEvents = bus.getSubscriber();
        plannerEvents.on('fplIndexChanged').handle(data => { this.provider.setPlanIndex(data.planIndex); });
        this.provider.setPlanIndex(planner.activePlanIndex);
    }
}

/**
 * Displays a map detail level indication.
 */
class MapDetailIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.rootRef = FSComponent.createRef();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        this.props.declutterMode.sub(this.onDeclutterModeChanged.bind(this), true);
    }
    /**
     * A callback which is called when the declutter mode setting value changes.
     * @param mode The new declutter mode setting value.
     */
    onDeclutterModeChanged(mode) {
        this.rootRef.instance.classList.remove('detail-4', 'detail-3', 'detail-2', 'detail-1');
        this.rootRef.instance.classList.add(MapDetailIndicator.MODE_CLASSES[mode]);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent("div", { ref: this.rootRef, class: 'map-detail' },
            this.props.showTitle ? FSComponent.buildComponent("div", null, "Detail") : null,
            FSComponent.buildComponent("div", { class: 'map-detail-icon' },
                FSComponent.buildComponent("div", { class: 'map-detail-block map-detail-top' }),
                FSComponent.buildComponent("div", { class: 'map-detail-block map-detail-middle' }),
                FSComponent.buildComponent("div", { class: 'map-detail-block map-detail-bottom' }),
                FSComponent.buildComponent("div", { class: 'map-detail-clip' }))));
    }
}
MapDetailIndicator.MODE_CLASSES = {
    [MapDeclutterMode.All]: 'detail-4',
    [MapDeclutterMode.Level3]: 'detail-3',
    [MapDeclutterMode.Level2]: 'detail-2',
    [MapDeclutterMode.Level1]: 'detail-1',
};

var MapTrafficIntruderOffScaleIndicatorMode;
(function (MapTrafficIntruderOffScaleIndicatorMode) {
    MapTrafficIntruderOffScaleIndicatorMode[MapTrafficIntruderOffScaleIndicatorMode["Off"] = 0] = "Off";
    MapTrafficIntruderOffScaleIndicatorMode[MapTrafficIntruderOffScaleIndicatorMode["TA"] = 1] = "TA";
    MapTrafficIntruderOffScaleIndicatorMode[MapTrafficIntruderOffScaleIndicatorMode["RA"] = 2] = "RA";
})(MapTrafficIntruderOffScaleIndicatorMode || (MapTrafficIntruderOffScaleIndicatorMode = {}));
/**
 * Displays a traffic off-scale indication.
 */
class MapTrafficIntruderOffScaleIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
        this.textSub = this.props.mode.map(mode => {
            return MapTrafficIntruderOffScaleIndicator.TEXT[mode];
        });
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        this.props.mode.sub(this.onModeChanged.bind(this), true);
    }
    /**
     * A callback which is called when the indicator mode changes.
     * @param mode The new mode.
     */
    onModeChanged(mode) {
        this.ref.instance.classList.remove(...Object.values(MapTrafficIntruderOffScaleIndicator.CLASSES));
        this.ref.instance.classList.add(MapTrafficIntruderOffScaleIndicator.CLASSES[mode]);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent("div", { ref: this.ref, class: 'map-traffic-offscale' }, this.textSub));
    }
}
MapTrafficIntruderOffScaleIndicator.CLASSES = {
    [MapTrafficIntruderOffScaleIndicatorMode.Off]: 'offscale-mode-off',
    [MapTrafficIntruderOffScaleIndicatorMode.TA]: 'offscale-mode-ta',
    [MapTrafficIntruderOffScaleIndicatorMode.RA]: 'offscale-mode-ra'
};
MapTrafficIntruderOffScaleIndicator.TEXT = {
    [MapTrafficIntruderOffScaleIndicatorMode.Off]: '',
    [MapTrafficIntruderOffScaleIndicatorMode.TA]: 'TA OFF SCALE',
    [MapTrafficIntruderOffScaleIndicatorMode.RA]: 'RA OFF SCALE'
};

/**
 * A map layer which displays traffic intruders.
 */
class MapTrafficIntruderLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.iconLayerRef = FSComponent.createRef();
        this.trafficModule = this.props.model.getModule('traffic');
        this.intruderViews = {
            [TCASAlertLevel.None]: new Map(),
            [TCASAlertLevel.ProximityAdvisory]: new Map(),
            [TCASAlertLevel.TrafficAdvisory]: new Map(),
            [TCASAlertLevel.ResolutionAdvisory]: new Map()
        };
        this.isInit = false;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onVisibilityChanged(isVisible) {
        var _a;
        if (!isVisible) {
            (_a = this.props.offScaleIndicatorMode) === null || _a === void 0 ? void 0 : _a.set(MapTrafficIntruderOffScaleIndicatorMode.Off);
            if (this.isInit) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.iconLayerRef.instance.display.clear();
            }
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAttached() {
        this.iconLayerRef.instance.onAttached();
        this.trafficModule.operatingMode.sub(this.updateVisibility.bind(this));
        this.trafficModule.show.sub(this.updateVisibility.bind(this), true);
        this.initCanvasStyles();
        this.initIntruders();
        this.initTCASHandlers();
        this.isInit = true;
    }
    /**
     * Initializes canvas styles.
     */
    initCanvasStyles() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const iconContext = this.iconLayerRef.instance.display.context;
        iconContext.textAlign = 'center';
        iconContext.font = `${this.props.fontSize}px Roboto-Bold`;
    }
    /**
     * Initializes all currently existing TCAS intruders.
     */
    initIntruders() {
        const intruders = this.trafficModule.tcas.getIntruders();
        const len = intruders.length;
        for (let i = 0; i < len; i++) {
            this.onIntruderAdded(intruders[i]);
        }
    }
    /**
     * Initializes handlers to respond to TCAS events.
     */
    initTCASHandlers() {
        const tcasSub = this.props.bus.getSubscriber();
        tcasSub.on('tcas_intruder_added').handle(this.onIntruderAdded.bind(this));
        tcasSub.on('tcas_intruder_removed').handle(this.onIntruderRemoved.bind(this));
        tcasSub.on('tcas_intruder_alert_changed').handle(this.onIntruderAlertLevelChanged.bind(this));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.iconLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.initCanvasStyles();
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        if (!this.isVisible()) {
            return;
        }
        this.redrawIntruders();
    }
    /**
     * Redraws all tracked intruders.
     */
    redrawIntruders() {
        const showLabel = this.trafficModule.showIntruderLabel.get();
        const offScaleRange = this.props.useOuterRangeMaxScale ?
            this.props.model.getModule('range').nominalRanges.get()[this.trafficModule.outerRangeIndex.get()]
            : undefined;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const iconDisplay = this.iconLayerRef.instance.display;
        iconDisplay.clear();
        let offScaleRACount = 0;
        let offScaleTACount = 0;
        this.intruderViews[TCASAlertLevel.None].forEach(view => {
            view.draw(this.props.mapProjection, iconDisplay.context, showLabel, offScaleRange);
        });
        this.intruderViews[TCASAlertLevel.ProximityAdvisory].forEach(view => {
            view.draw(this.props.mapProjection, iconDisplay.context, showLabel, offScaleRange);
        });
        this.intruderViews[TCASAlertLevel.TrafficAdvisory].forEach(view => {
            view.draw(this.props.mapProjection, iconDisplay.context, showLabel, offScaleRange);
            if (view.isOffScale) {
                offScaleTACount++;
            }
        });
        this.intruderViews[TCASAlertLevel.ResolutionAdvisory].forEach(view => {
            view.draw(this.props.mapProjection, iconDisplay.context, showLabel, offScaleRange);
            if (view.isOffScale) {
                offScaleRACount++;
            }
        });
        if (this.props.offScaleIndicatorMode) {
            if (offScaleRACount > 0) {
                this.props.offScaleIndicatorMode.set(MapTrafficIntruderOffScaleIndicatorMode.RA);
            }
            else if (offScaleTACount > 0) {
                this.props.offScaleIndicatorMode.set(MapTrafficIntruderOffScaleIndicatorMode.TA);
            }
            else {
                this.props.offScaleIndicatorMode.set(MapTrafficIntruderOffScaleIndicatorMode.Off);
            }
        }
    }
    /**
     * Updates this layer's visibility.
     */
    updateVisibility() {
        this.setVisible(this.trafficModule.tcas.getOperatingMode() !== TCASOperatingMode.Standby && this.trafficModule.show.get());
    }
    /**
     * A callback which is called when a TCAS intruder is added.
     * @param intruder The new intruder.
     */
    onIntruderAdded(intruder) {
        const view = new MapTrafficIntruderView(intruder, this.props.model.getModule('ownAirplaneProps'), this.trafficModule, this.props.fontSize, this.props.iconSize);
        this.intruderViews[intruder.alertLevel.get()].set(intruder, view);
    }
    /**
     * A callback which is called when a TCAS intruder is removed.
     * @param intruder The removed intruder.
     */
    onIntruderRemoved(intruder) {
        this.intruderViews[intruder.alertLevel.get()].delete(intruder);
    }
    /**
     * A callback which is called when the alert level of a TCAS intruder is changed.
     * @param intruder The intruder.
     */
    onIntruderAlertLevelChanged(intruder) {
        let oldAlertLevel;
        let view = this.intruderViews[oldAlertLevel = TCASAlertLevel.None].get(intruder);
        view !== null && view !== void 0 ? view : (view = this.intruderViews[oldAlertLevel = TCASAlertLevel.ProximityAdvisory].get(intruder));
        view !== null && view !== void 0 ? view : (view = this.intruderViews[oldAlertLevel = TCASAlertLevel.TrafficAdvisory].get(intruder));
        view !== null && view !== void 0 ? view : (view = this.intruderViews[oldAlertLevel = TCASAlertLevel.ResolutionAdvisory].get(intruder));
        if (view) {
            this.intruderViews[oldAlertLevel].delete(intruder);
            this.intruderViews[intruder.alertLevel.get()].set(intruder, view);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.iconLayerRef, model: this.props.model, mapProjection: this.props.mapProjection }));
    }
}
/**
 * A view representation of a TCAS intruder for MapTrafficIntruderLayer.
 */
class MapTrafficIntruderView {
    /**
     * Constructor.
     * @param intruder This view's associated intruder.
     * @param ownAirplaneProps The own airplane properties module for this view's parent map.
     * @param trafficModule The traffic module for this view's parent map.
     * @param fontSize This view's font size, in pixels.
     * @param iconSize This view's icon size, in pixels.
     */
    constructor(intruder, ownAirplaneProps, trafficModule, fontSize, iconSize) {
        this.intruder = intruder;
        this.ownAirplaneProps = ownAirplaneProps;
        this.trafficModule = trafficModule;
        this.fontSize = fontSize;
        this.iconSize = iconSize;
        this.projectedPos = new Float64Array(2);
        this._isOffScale = false;
        this.isVisible = false;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether this view is off-scale. */
    get isOffScale() {
        return this._isOffScale;
    }
    /**
     * Draws this view.
     * @param projection The map projection.
     * @param context The canvas rendering context to which to draw this view.
     * @param showLabel Whether to show this view's label.
     * @param offScaleRange The maximum distance from the own airplane this view's intruder can be before it is
     * considered off-scale. If not defined, the map projection boundaries will be used to determine whether this view's
     * intruder is off-scale.
     */
    draw(projection, context, showLabel, offScaleRange) {
        this.updatePosition(projection, offScaleRange);
        this.updateVisibility(!!offScaleRange);
        if (this.isVisible) {
            this.drawIcon(context, projection, showLabel);
        }
    }
    /**
     * Updates this view's intruder's projected position and off-scale status.
     * @param projection The map projection.
     * @param offScaleRange The maximum distance from the own airplane this view's intruder can be before it is
     * considered off-scale. If not defined, the map projection boundaries will be used to determine whether this view's
     * intruder is off-scale.
     */
    updatePosition(projection, offScaleRange) {
        const ownAirplanePos = this.ownAirplaneProps.position.get();
        if (offScaleRange) {
            this.handleOffScaleRange(projection, ownAirplanePos, offScaleRange);
        }
        else {
            this.handleOffScaleMapProjection(projection);
        }
    }
    /**
     * Updates this view's intruder's projected position and off-scale status using the map projection boundaries to
     * define off-scale.
     * @param projection The map projection.
     */
    handleOffScaleMapProjection(projection) {
        projection.project(this.intruder.position, this.projectedPos);
        this._isOffScale = !projection.isInProjectedBounds(this.projectedPos);
    }
    /**
     * Updates this view's intruder's projected position and off-scale status using a specific range from the own
     * airplane to define off-scale.
     * @param projection The map projection.
     * @param ownAirplanePos The position of the own airplane.
     * @param offScaleRange The maximum distance from the own airplane this intruder can be before it is considered
     * off-scale.
     */
    handleOffScaleRange(projection, ownAirplanePos, offScaleRange) {
        const intruderPos = this.intruder.position;
        const horizontalSeparation = intruderPos.distance(ownAirplanePos);
        const offscaleRangeRad = offScaleRange.asUnit(UnitType.GA_RADIAN);
        if (horizontalSeparation > offscaleRangeRad) {
            this._isOffScale = true;
            projection.project(ownAirplanePos.offset(ownAirplanePos.bearingTo(intruderPos), offscaleRangeRad, MapTrafficIntruderView.geoPointCache[0]), this.projectedPos);
        }
        else {
            this._isOffScale = false;
            projection.project(intruderPos, this.projectedPos);
        }
    }
    /**
     * Updates the visibility of this view.
     * @param useOffScaleRange Whether off-scale is defined by distance from the own airplane.
     */
    updateVisibility(useOffScaleRange) {
        let isVisible = false;
        const alertLevel = this.intruder.alertLevel.get();
        const alertLevelMode = this.trafficModule.alertLevelMode.get();
        switch (alertLevel) {
            case TCASAlertLevel.ResolutionAdvisory:
                isVisible = true;
                break;
            case TCASAlertLevel.TrafficAdvisory:
                if (alertLevelMode === MapTrafficAlertLevelMode.TA_RA) {
                    isVisible = true;
                    break;
                }
            // eslint-disable-next-line no-fallthrough
            case TCASAlertLevel.ProximityAdvisory:
                if (alertLevelMode === MapTrafficAlertLevelMode.Advisories) {
                    isVisible = true;
                    break;
                }
            // eslint-disable-next-line no-fallthrough
            case TCASAlertLevel.None:
                if (alertLevelMode === MapTrafficAlertLevelMode.All) {
                    isVisible = true;
                }
        }
        if (alertLevel === TCASAlertLevel.ResolutionAdvisory || alertLevel === TCASAlertLevel.TrafficAdvisory) {
            isVisible && (isVisible = useOffScaleRange || !this._isOffScale);
        }
        else {
            const altitudeMeters = this.intruder.relativePositionVec[2];
            const isWithinAltitude = altitudeMeters <= this.trafficModule.altitudeRestrictionAbove.get().asUnit(UnitType.METER)
                && altitudeMeters >= -this.trafficModule.altitudeRestrictionBelow.get().asUnit(UnitType.METER);
            isVisible && (isVisible = !this._isOffScale && isWithinAltitude);
        }
        this.isVisible = isVisible;
    }
    /**
     * Draws this view's icon.
     * @param context The canvas rendering context to which to draw the icon.
     * @param projection The map projection.
     * @param showLabel Whether to show the icon label.
     */
    drawIcon(context, projection, showLabel) {
        const alertLevel = this.intruder.alertLevel.get();
        context.translate(this.projectedPos[0], this.projectedPos[1]);
        if (showLabel) {
            this.drawIconVSArrow(context, alertLevel);
            this.drawIconAltitudeLabel(context, alertLevel);
        }
        this.drawMotionVector(context, projection);
        this.drawIconBackground(context, projection, alertLevel);
        this.drawIconArrow(context, projection, alertLevel);
        context.resetTransform();
    }
    /**
     * Draws the icon's background.
     * @param context The canvas rendering context to which to draw the icon.
     * @param projection The map projection.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawIconBackground(context, projection, alertLevel) {
        if (alertLevel === TCASAlertLevel.None || alertLevel === TCASAlertLevel.ProximityAdvisory) {
            return;
        }
        context.strokeStyle = '#1a1d21';
        context.fillStyle = alertLevel === TCASAlertLevel.ResolutionAdvisory ? MapTrafficIntruderView.RA_COLOR : MapTrafficIntruderView.TA_COLOR;
        context.beginPath();
        context.arc(0, 0, 0.45 * this.iconSize, 0, 2 * Math.PI);
        context.fill();
        context.stroke();
        if (this._isOffScale) {
            const projectedAngle = Vec2Math.theta(Vec2Math.sub(this.projectedPos, projection.getTargetProjected(), MapTrafficIntruderView.vec2Cache[0]));
            context.beginPath();
            context.arc(0, 0, 0.45 * this.iconSize, projectedAngle - Math.PI / 2, projectedAngle + Math.PI / 2);
            context.fillStyle = 'black';
            context.fill();
        }
    }
    /**
     * Draws the icon's directional arrow.
     * @param context The canvas rendering context to which to draw the icon.
     * @param projection The map projection.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawIconArrow(context, projection, alertLevel) {
        context.save();
        context.rotate(this.intruder.groundTrack * Avionics.Utils.DEG2RAD + projection.getRotation());
        this.drawIconArrowBackground(context, alertLevel);
        this.drawIconArrowOutline(context, alertLevel);
        context.restore();
    }
    /**
     * Draws the icon's directional arrow background.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawIconArrowBackground(context, alertLevel) {
        switch (alertLevel) {
            case TCASAlertLevel.None:
            case TCASAlertLevel.ProximityAdvisory:
                context.fillStyle = 'black';
                break;
            case TCASAlertLevel.TrafficAdvisory:
                context.fillStyle = MapTrafficIntruderView.TA_COLOR;
                break;
            case TCASAlertLevel.ResolutionAdvisory:
                context.fillStyle = MapTrafficIntruderView.RA_COLOR;
                break;
        }
        context.beginPath();
        context.moveTo(0, -0.3 * this.iconSize * 1.4);
        context.lineTo(0.212 * this.iconSize * 1.4, 0.212 * this.iconSize * 1.4);
        context.lineTo(0, 0.1 * this.iconSize * 1.4);
        context.lineTo(-0.212 * this.iconSize * 1.4, 0.212 * this.iconSize * 1.4);
        context.closePath();
        context.fill();
    }
    /**
     * Draws the icon's directional arrow outline.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawIconArrowOutline(context, alertLevel) {
        context.lineWidth = Math.max(1, this.iconSize * 0.05);
        switch (alertLevel) {
            case TCASAlertLevel.None:
                context.strokeStyle = 'white';
                context.fillStyle = 'black';
                break;
            case TCASAlertLevel.ProximityAdvisory:
                context.strokeStyle = 'transparent';
                context.fillStyle = 'white';
                break;
            case TCASAlertLevel.TrafficAdvisory:
                context.strokeStyle = 'black';
                context.fillStyle = MapTrafficIntruderView.TA_COLOR;
                break;
            case TCASAlertLevel.ResolutionAdvisory:
                context.strokeStyle = 'black';
                context.fillStyle = MapTrafficIntruderView.RA_COLOR;
                break;
        }
        context.beginPath();
        context.moveTo(0, -0.3 * this.iconSize);
        context.lineTo(0.212 * this.iconSize, 0.212 * this.iconSize);
        context.lineTo(0, 0.1 * this.iconSize);
        context.lineTo(-0.212 * this.iconSize, 0.212 * this.iconSize);
        context.closePath();
        context.fill();
        context.stroke();
    }
    /**
     * Draws the icon's vertical speed indicator arrow.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawIconVSArrow(context, alertLevel) {
        const showArrow = MapTrafficIntruderView.VERTICAL_SPEED_THRESHOLD.compare(Math.abs(this.intruder.velocityVec[2]), UnitType.MPS) <= 0;
        if (!showArrow) {
            return;
        }
        const vsSign = Math.sign(this.intruder.velocityVec[2]);
        context.beginPath();
        context.moveTo(0.67 * this.iconSize, -0.16 * this.iconSize * vsSign);
        context.lineTo(0.67 * this.iconSize, 0.16 * this.iconSize * vsSign);
        context.moveTo(0.55 * this.iconSize, -0.04 * this.iconSize * vsSign);
        context.lineTo(0.67 * this.iconSize, -0.18 * this.iconSize * vsSign);
        context.lineTo(0.79 * this.iconSize, -0.04 * this.iconSize * vsSign);
        context.lineWidth = Math.max(1, this.iconSize * 0.125);
        context.strokeStyle = 'black';
        context.stroke();
        context.lineWidth = Math.max(1, this.iconSize * 0.075);
        switch (alertLevel) {
            case TCASAlertLevel.None:
            case TCASAlertLevel.ProximityAdvisory:
                context.strokeStyle = 'white';
                break;
            case TCASAlertLevel.TrafficAdvisory:
                context.strokeStyle = MapTrafficIntruderView.TA_COLOR;
                break;
            case TCASAlertLevel.ResolutionAdvisory:
                context.strokeStyle = MapTrafficIntruderView.RA_COLOR;
                break;
        }
        context.stroke();
    }
    /**
     * Draws the icon's altitude label.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawIconAltitudeLabel(context, alertLevel) {
        const isRelative = this.trafficModule.isAltitudeRelative.get();
        const isAltitudeAbove = this.intruder.relativePositionVec[2] >= 0;
        const altitudeFeet = this.trafficModule.isAltitudeRelative.get()
            ? UnitType.METER.convertTo(this.intruder.relativePositionVec[2], UnitType.FOOT)
            : this.intruder.altitude.asUnit(UnitType.FOOT);
        const altitudeRounded = Math.round(altitudeFeet / 100);
        const altitudeAbs = Math.abs(altitudeRounded);
        const prefix = altitudeRounded < 0 ? '−'
            : isRelative ? '+' : '';
        const altitudeText = `${prefix}${altitudeAbs}`;
        const textWidth = context.measureText(altitudeText).width;
        const textHeight = this.fontSize;
        // draw background
        context.fillStyle = 'black';
        if (isAltitudeAbove) {
            context.fillRect(-textWidth / 2 - 2, -0.5 * this.iconSize - textHeight - 2, textWidth + 4, textHeight + 2);
        }
        else {
            context.fillRect(-textWidth / 2 - 2, 0.5 * this.iconSize, textWidth + 4, textHeight + 2);
        }
        // draw text
        switch (alertLevel) {
            case TCASAlertLevel.None:
            case TCASAlertLevel.ProximityAdvisory:
                context.fillStyle = 'white';
                break;
            case TCASAlertLevel.TrafficAdvisory:
                context.fillStyle = MapTrafficIntruderView.TA_COLOR;
                break;
            case TCASAlertLevel.ResolutionAdvisory:
                context.fillStyle = MapTrafficIntruderView.RA_COLOR;
                break;
        }
        if (isAltitudeAbove) {
            context.textBaseline = 'bottom';
            context.fillText(altitudeText, 0, -0.5 * this.iconSize);
        }
        else {
            context.textBaseline = 'top';
            context.fillText(altitudeText, 0, 0.5 * this.iconSize);
        }
    }
    /**
     * Draws this view's motion vector.
     * @param context The canvas rendering context to which to draw the vector.
     * @param projection The map projection.
     */
    drawMotionVector(context, projection) {
        const vectorMode = this.trafficModule.motionVectorMode.get();
        if (vectorMode === MapTrafficMotionVectorMode.Off) {
            return;
        }
        const vector = vectorMode === MapTrafficMotionVectorMode.Absolute
            ? this.intruder.velocityVec
            : this.intruder.relativeVelocityVec;
        const alertLevel = this.intruder.alertLevel.get();
        if (alertLevel === TCASAlertLevel.None || alertLevel === TCASAlertLevel.ProximityAdvisory) {
            const color = vectorMode === MapTrafficMotionVectorMode.Absolute
                ? MapTrafficIntruderView.VECTOR_ABS_COLOR
                : MapTrafficIntruderView.VECTOR_REL_COLOR;
            this.drawNormalVector(projection, context, color, vector);
        }
        else {
            const color = alertLevel === TCASAlertLevel.ResolutionAdvisory ? MapTrafficIntruderView.RA_COLOR : MapTrafficIntruderView.TA_COLOR;
            this.drawTCAVector(projection, context, color, vector);
        }
    }
    /**
     * Draws a normal motion vector.
     * @param projection The map projection.
     * @param context The canvas rendering context to which to draw the vector.
     * @param color The color of the vector.
     * @param vector The vector to draw.
     */
    drawNormalVector(projection, context, color, vector) {
        context.lineWidth = MapTrafficIntruderView.VECTOR_STROKE_WIDTH;
        context.strokeStyle = color;
        context.setLineDash(MapTrafficIntruderView.VECTOR_EMPTY_LINE_DASH);
        context.beginPath();
        const distance = Vec2Math.abs(vector) * this.trafficModule.motionVectorLookahead.get().asUnit(UnitType.SECOND);
        const distanceView = distance / UnitType.GA_RADIAN.convertTo(projection.getProjectedResolution(), UnitType.METER);
        const track = -Vec2Math.theta(vector);
        const angle = track + projection.getRotation();
        const end = Vec2Math.setFromPolar(distanceView, angle, MapTrafficIntruderView.vec2Cache[0]);
        context.moveTo(0, 0);
        context.lineTo(end[0], end[1]);
        context.stroke();
    }
    /**
     * Draws a motion vector projected to TCA.
     * @param projection The map projection.
     * @param context The canvas rendering context to which to draw the vector.
     * @param color The color of the vector.
     * @param vector The vector to draw.
     */
    drawTCAVector(projection, context, color, vector) {
        const distanceToEnd = Vec2Math.abs(projection.getProjectedSize());
        if (distanceToEnd > 0) {
            context.lineWidth = MapTrafficIntruderView.VECTOR_STROKE_WIDTH;
            context.strokeStyle = color;
            context.setLineDash(MapTrafficIntruderView.VECTOR_LINE_DASH);
            context.beginPath();
            const track = -Vec2Math.theta(vector);
            const angle = track + projection.getRotation();
            const end = Vec2Math.setFromPolar(distanceToEnd, angle, MapTrafficIntruderView.vec2Cache[0]);
            context.moveTo(0, 0);
            context.lineTo(end[0], end[1]);
            context.stroke();
            context.setLineDash(MapTrafficIntruderView.VECTOR_EMPTY_LINE_DASH);
            const distanceToTCA = Vec2Math.abs(vector) * this.intruder.tca.asUnit(UnitType.SECOND);
            const distanceToTCAProjected = distanceToTCA / UnitType.GA_RADIAN.convertTo(projection.getProjectedResolution(), UnitType.METER);
            if (distanceToTCAProjected > 0) {
                context.beginPath();
                const tca = Vec2Math.setFromPolar(distanceToTCAProjected, angle, MapTrafficIntruderView.vec2Cache[0]);
                context.moveTo(0, 0);
                context.lineTo(tca[0], tca[1]);
                context.stroke();
            }
        }
    }
}
MapTrafficIntruderView.VERTICAL_SPEED_THRESHOLD = UnitType.FPM.createNumber(500);
MapTrafficIntruderView.TA_COLOR = '#ffdc24';
MapTrafficIntruderView.RA_COLOR = 'red';
MapTrafficIntruderView.VECTOR_STROKE_WIDTH = 2;
MapTrafficIntruderView.VECTOR_ABS_COLOR = 'white';
MapTrafficIntruderView.VECTOR_REL_COLOR = '#4ecc3d';
MapTrafficIntruderView.VECTOR_LINE_DASH = [5, 5];
MapTrafficIntruderView.VECTOR_EMPTY_LINE_DASH = [];
MapTrafficIntruderView.geoPointCache = [new GeoPoint(0, 0)];
MapTrafficIntruderView.vec2Cache = [new Float64Array(2)];

/**
 * A map layer which displays a pointer.
 */
class MapPointerLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.pointerRef = FSComponent.createRef();
        this.pointerModule = this.props.model.getModule('pointer');
        this.positionHandler = () => { this.needRepositionPointer = true; };
        this.needRepositionPointer = false;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        this.pointerRef.getOrDefault() && this.updateFromVisibility();
    }
    /**
     * Updates this layer according to its current visibility.
     */
    updateFromVisibility() {
        const isVisible = this.isVisible();
        this.pointerRef.instance.style.display = isVisible ? '' : 'none';
        if (isVisible) {
            this.pointerModule.position.sub(this.positionHandler, true);
        }
        else {
            this.pointerModule.position.unsub(this.positionHandler);
        }
    }
    /** @inheritdoc */
    onAttached() {
        this.updateFromVisibility();
        this.pointerModule.isActive.sub(isActive => this.setVisible(isActive), true);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        if (!this.needRepositionPointer) {
            return;
        }
        this.repositionPointer();
        this.needRepositionPointer = false;
    }
    /**
     * Repositions this layer's pointer.
     */
    repositionPointer() {
        const position = this.pointerModule.position.get();
        this.pointerRef.instance.style.transform = `translate3d(${position[0]}px, ${position[1]}px, 0)`;
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("svg", { ref: this.pointerRef, class: 'map-pointer', viewBox: '0 0 100 100', style: 'position: absolute; left: 0; top: 0; transform: translate3d(0, 0, 0);' },
            FSComponent.buildComponent("polygon", { points: '78.93 95.46 49.48 66.01 41.18 84.57 4.54 4.54 84.57 41.18 66.01 49.48 95.46 78.93 78.93 95.46' })));
    }
}

/**
 * A map layer which displays a crosshair at the projected position of the map target.
 */
class MapCrosshairLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.crosshairRef = FSComponent.createRef();
        this.needReposition = true;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        this.crosshairRef.getOrDefault() && this.updateFromVisibility();
    }
    /**
     * Updates this layer according to its current visibility.
     */
    updateFromVisibility() {
        this.crosshairRef.instance.style.display = this.isVisible() ? '' : 'none';
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.model.getModule('crosshair').show.sub(show => { this.setVisible(show); }, true);
        this.updateFromVisibility();
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.needReposition || (this.needReposition = BitFlags.isAny(changeFlags, MapProjectionChangeType.TargetProjected));
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        if (!this.needReposition || !this.isVisible()) {
            return;
        }
        this.repositionCrosshair();
        this.needReposition = false;
    }
    /**
     * Repositions this layer's crosshair.
     */
    repositionCrosshair() {
        const position = this.props.mapProjection.getTargetProjected();
        this.crosshairRef.instance.style.transform = `translate(-50%, -50%) translate3d(${position[0]}px, ${position[1]}px, 0)`;
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("svg", { ref: this.crosshairRef, class: 'map-crosshair', viewBox: '0 0 100 100', style: 'position: absolute; left: 0; top: 0; transform: translate(-50%, -50%) translate3d(0, 0, 0);' },
            FSComponent.buildComponent("line", { class: 'map-crosshair-outline', x1: '50', y1: '0', x2: '50', y2: '100' }),
            FSComponent.buildComponent("line", { class: 'map-crosshair-outline', x1: '0', y1: '50', x2: '100', y2: '50' }),
            FSComponent.buildComponent("line", { class: 'map-crosshair-stroke', x1: '50', y1: '0', x2: '50', y2: '100' }),
            FSComponent.buildComponent("line", { class: 'map-crosshair-stroke', x1: '0', y1: '50', x2: '100', y2: '50' })));
    }
}

/**
 * A utility class for generating Garmin-based waypoint styles.
 */
class MapWaypointStyles {
    /**
     * Gets styles for waypoints rendered in a normal role.
     * @param baseIconPriority The base waypoint icon render priority. Icon priorities are guaranteed to fall in the
     * range `[baseIconPriority, baseIconPriority + 1)`.
     * @param baseLabelPriority The base waypoint label render priority. Label priorities are guaranteed to fall in the
     * range `[baseLabelPriority, baseLabelPriority + 1)`.
     * @param scale The linear scale of the styles. The larger the value, the larger the rendered icons and labels.
     * Defaults to 1.
     * @returns styles for waypoints rendered in a normal role.
     */
    static getNormalStyles(baseIconPriority, baseLabelPriority, scale = 1) {
        return {
            airportIconPriority: {
                [AirportSize.Large]: baseIconPriority + 0.8,
                [AirportSize.Medium]: baseIconPriority + 0.79,
                [AirportSize.Small]: baseIconPriority + 0.78
            },
            vorIconPriority: baseIconPriority + 0.7,
            ndbIconPriority: baseIconPriority + 0.6,
            intIconPriority: baseIconPriority + 0.5,
            airportIconSize: {
                [AirportSize.Large]: 26 * scale,
                [AirportSize.Medium]: 26 * scale,
                [AirportSize.Small]: 26 * scale
            },
            vorIconSize: 32 * scale,
            ndbIconSize: 32 * scale,
            intIconSize: 32 * scale,
            airportLabelPriority: {
                [AirportSize.Large]: baseLabelPriority + 0.8,
                [AirportSize.Medium]: baseLabelPriority + 0.79,
                [AirportSize.Small]: baseLabelPriority + 0.78
            },
            vorLabelPriority: baseLabelPriority + 0.7,
            ndbLabelPriority: baseLabelPriority + 0.6,
            intLabelPriority: baseLabelPriority + 0.5,
            airportLabelOptions: {
                [AirportSize.Large]: MapWaypointStyles.createNormalLabelOptions(new Float64Array([0, -12 * scale]), 20 * scale),
                [AirportSize.Medium]: MapWaypointStyles.createNormalLabelOptions(new Float64Array([0, -12 * scale]), 16 * scale),
                [AirportSize.Small]: MapWaypointStyles.createNormalLabelOptions(new Float64Array([0, -12 * scale]), 16 * scale)
            },
            vorLabelOptions: MapWaypointStyles.createNormalLabelOptions(new Float64Array([0, -8 * scale]), 16 * scale),
            ndbLabelOptions: MapWaypointStyles.createNormalLabelOptions(new Float64Array([0, -8 * scale]), 16 * scale),
            intLabelOptions: MapWaypointStyles.createNormalLabelOptions(new Float64Array([0, -5 * scale]), 16 * scale),
        };
    }
    /**
     * Creates initialization options for waypoint labels rendered in a normal role.
     * @param offset The label offset, in pixels.
     * @param fontSize The font size of the label, in pixels.
     * @returns initialization options for waypoint labels rendered in a normal role.
     */
    static createNormalLabelOptions(offset, fontSize) {
        return {
            anchor: new Float64Array([0.5, 1]),
            offset,
            fontSize,
            fontOutlineWidth: 6
        };
    }
    /**
     * Gets styles for waypoints rendered as part of a flight plan.
     * @param active Whether to get styles for active waypoints.
     * @param baseIconPriority The base waypoint icon render priority. Icon priorities are guaranteed to fall in the
     * range `[baseIconPriority, baseIconPriority + 1)`.
     * @param baseLabelPriority The base waypoint label render priority. Label priorities are guaranteed to fall in the
     * range `[baseLabelPriority, baseLabelPriority + 1)`.
     * @param scale The linear scale of the styles. The larger the value, the larger the rendered icons and labels.
     * Defaults to 1.
     * @returns styles for waypoints rendered as part of a flight plan.
     */
    static getFlightPlanStyles(active, baseIconPriority, baseLabelPriority, scale = 1) {
        const createLabelOptions = active
            ? MapWaypointStyles.createFlightPlanActiveLabelOptions.bind(this)
            : MapWaypointStyles.createFlightPlanInactiveLabelOptions.bind(this);
        return {
            airportIconPriority: {
                [AirportSize.Large]: baseIconPriority + 0.8,
                [AirportSize.Medium]: baseIconPriority + 0.79,
                [AirportSize.Small]: baseIconPriority + 0.78
            },
            vorIconPriority: baseIconPriority + 0.7,
            ndbIconPriority: baseIconPriority + 0.6,
            intIconPriority: baseIconPriority + 0.5,
            rwyIconPriority: baseIconPriority + 0.4,
            userIconPriority: baseIconPriority + 0.9,
            fpIconPriority: baseIconPriority + 0.1,
            airportIconSize: {
                [AirportSize.Large]: 26 * scale,
                [AirportSize.Medium]: 26 * scale,
                [AirportSize.Small]: 26 * scale
            },
            vorIconSize: 32 * scale,
            ndbIconSize: 32 * scale,
            intIconSize: 32 * scale,
            rwyIconSize: 32 * scale,
            userIconSize: 32 * scale,
            fpIconSize: 8 * scale,
            airportLabelPriority: {
                [AirportSize.Large]: baseLabelPriority + 0.8,
                [AirportSize.Medium]: baseLabelPriority + 0.79,
                [AirportSize.Small]: baseLabelPriority + 0.78
            },
            vorLabelPriority: baseLabelPriority + 0.7,
            ndbLabelPriority: baseLabelPriority + 0.6,
            intLabelPriority: baseLabelPriority + 0.5,
            rwyLabelPriority: baseLabelPriority + 0.4,
            userLabelPriority: baseLabelPriority + 0.9,
            fpLabelPriority: baseLabelPriority + 0.1,
            airportLabelOptions: {
                [AirportSize.Large]: createLabelOptions(new Float64Array([0, -15 * scale]), 20 * scale),
                [AirportSize.Medium]: createLabelOptions(new Float64Array([0, -15 * scale]), 16 * scale),
                [AirportSize.Small]: createLabelOptions(new Float64Array([0, -15 * scale]), 16 * scale)
            },
            vorLabelOptions: createLabelOptions(new Float64Array([0, -11 * scale]), 16 * scale),
            ndbLabelOptions: createLabelOptions(new Float64Array([0, -11 * scale]), 16 * scale),
            intLabelOptions: createLabelOptions(new Float64Array([0, -8 * scale]), 16 * scale),
            rwyLabelOptions: createLabelOptions(new Float64Array([0, -8 * scale]), 16 * scale),
            userLabelOptions: createLabelOptions(new Float64Array([0, -12 * scale]), 16 * scale),
            fpLabelOptions: createLabelOptions(new Float64Array([0, -8 * scale]), 16 * scale),
        };
    }
    /**
     * Creates initialization options for labels for inactive waypoints rendered as part of a flight plan.
     * @param offset The label offset, in pixels.
     * @param fontSize The font size of the label, in pixels.
     * @returns initialization options for labels for inactive waypoints rendered as part of a flight plan.
     */
    static createFlightPlanInactiveLabelOptions(offset, fontSize) {
        return {
            anchor: new Float64Array([0.5, 1]),
            offset,
            font: 'Roboto-Bold',
            fontSize,
            fontColor: 'black',
            fontOutlineWidth: 0,
            showBg: true,
            bgPadding: [1, 1, 1, 1],
            bgColor: 'white',
            bgOutlineWidth: 1,
            bgOutlineColor: 'black'
        };
    }
    /**
     * Creates initialization options for labels for inactive waypoints rendered as part of a flight plan.
     * @param offset The label offset, in pixels.
     * @param fontSize The font size of the label, in pixels.
     * @returns initialization options for labels for inactive waypoints rendered as part of a flight plan.
     */
    static createFlightPlanActiveLabelOptions(offset, fontSize) {
        return {
            anchor: new Float64Array([0.5, 1]),
            offset,
            font: 'Roboto-Bold',
            fontSize,
            fontColor: 'magenta',
            fontOutlineWidth: 0,
            showBg: true,
            bgPadding: [1, 1, 1, 1],
            bgOutlineWidth: 1
        };
    }
    /**
     * Gets styles for waypoints rendered as highlighted.
     * @param baseIconPriority The base waypoint icon render priority. Icon priorities are guaranteed to fall in the
     * range `[baseIconPriority, baseIconPriority + 1)`.
     * @param baseLabelPriority The base waypoint label render priority. Label priorities are guaranteed to fall in the
     * range `[baseLabelPriority, baseLabelPriority + 1)`.
     * @param scale The linear scale of the styles. The larger the value, the larger the rendered icons and labels.
     * Defaults to 1.
     * @returns styles for waypoints rendered as highlighted.
     */
    static getHighlightStyles(baseIconPriority, baseLabelPriority, scale = 1) {
        return {
            highlightRingRadiusBuffer: 0,
            highlightRingStrokeWidth: 2,
            highlightRingStrokeColor: 'white',
            highlightRingOutlineWidth: 0,
            highlightRingOutlineColor: 'black',
            highlightBgColor: '#3c3c3c',
            airportIconPriority: {
                [AirportSize.Large]: baseIconPriority + 0.8,
                [AirportSize.Medium]: baseIconPriority + 0.79,
                [AirportSize.Small]: baseIconPriority + 0.78
            },
            vorIconPriority: baseIconPriority + 0.7,
            ndbIconPriority: baseIconPriority + 0.6,
            intIconPriority: baseIconPriority + 0.5,
            userIconPriority: baseIconPriority + 0.9,
            airportIconSize: {
                [AirportSize.Large]: 26 * scale,
                [AirportSize.Medium]: 26 * scale,
                [AirportSize.Small]: 26 * scale
            },
            vorIconSize: 32 * scale,
            ndbIconSize: 32 * scale,
            intIconSize: 32 * scale,
            userIconSize: 32 * scale,
            airportLabelPriority: {
                [AirportSize.Large]: baseLabelPriority + 0.8,
                [AirportSize.Medium]: baseLabelPriority + 0.79,
                [AirportSize.Small]: baseLabelPriority + 0.78
            },
            vorLabelPriority: baseLabelPriority + 0.7,
            ndbLabelPriority: baseLabelPriority + 0.6,
            intLabelPriority: baseLabelPriority + 0.5,
            userLabelPriority: baseLabelPriority + 0.9,
            airportLabelOptions: {
                [AirportSize.Large]: MapWaypointStyles.createHighlightLabelOptions(new Float64Array([0, -17 * scale]), 20 * scale),
                [AirportSize.Medium]: MapWaypointStyles.createHighlightLabelOptions(new Float64Array([0, -17 * scale]), 16 * scale),
                [AirportSize.Small]: MapWaypointStyles.createHighlightLabelOptions(new Float64Array([0, -17 * scale]), 16 * scale)
            },
            vorLabelOptions: MapWaypointStyles.createHighlightLabelOptions(new Float64Array([0, -17 * scale]), 16 * scale),
            ndbLabelOptions: MapWaypointStyles.createHighlightLabelOptions(new Float64Array([0, -17 * scale]), 16 * scale),
            intLabelOptions: MapWaypointStyles.createHighlightLabelOptions(new Float64Array([0, -17 * scale]), 16 * scale),
            userLabelOptions: MapWaypointStyles.createHighlightLabelOptions(new Float64Array([0, -17 * scale]), 16 * scale)
        };
    }
    /**
     * Creates initialization options for labels for highlighted waypoints.
     * @param offset The label offset, in pixels.
     * @param fontSize The font size of the label, in pixels.
     * @returns initialization options for labels for highlighted waypoints.
     */
    static createHighlightLabelOptions(offset, fontSize) {
        return {
            anchor: new Float64Array([0.5, 1]),
            offset,
            font: 'Roboto-Bold',
            fontSize,
            fontColor: 'black',
            fontOutlineWidth: 0,
            showBg: true,
            bgPadding: [1, 1, 1, 1],
            bgColor: 'white',
            bgOutlineWidth: 1,
            bgOutlineColor: 'black'
        };
    }
}

/**
 *
 */
class MapTrafficStatusIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.rootRef = FSComponent.createRef();
        this.disabledRef = FSComponent.createRef();
        this.altitudeRestrictionTextSub = this.props.altitudeRestrictionMode.map(mode => {
            return MapTrafficStatusIndicator.ALT_RESTRICTION_TEXT[mode];
        });
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        this.props.show.sub(show => {
            this.rootRef.instance.style.display = show ? '' : 'none';
        }, true);
        this.props.operatingMode.sub(mode => {
            this.disabledRef.instance.style.display = mode === TCASOperatingMode.Standby ? 'inherit' : 'none';
        }, true);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent("div", { ref: this.rootRef, class: 'map-traffic-status' },
            this.props.showAltitudeRestrictionMode ? FSComponent.buildComponent("div", { class: 'traffic-status-alt' }, this.altitudeRestrictionTextSub) : null,
            FSComponent.buildComponent("svg", { class: 'traffic-status-symbol', viewBox: '0 0 150 100' },
                FSComponent.buildComponent("path", { d: 'M 50 5 L 95 50 L 50 95 L 5 50 Z' }),
                FSComponent.buildComponent("path", { d: 'M 115 10 L 135 35 L 122.5 35 L 122.5 80 L 107.5 80 L 107.5 35 L 95 35 Z' }),
                FSComponent.buildComponent("g", { ref: this.disabledRef, class: 'traffic-status-disabled' },
                    FSComponent.buildComponent("path", { class: 'traffic-status-disabledcross traffic-status-disabledcross-outline', d: 'M 10 10 L 140 90 M 10 90 L 140 10' }),
                    FSComponent.buildComponent("path", { class: 'traffic-status-disabledcross traffic-status-disabledcross-stroke', d: 'M 10 10 L 140 90 M 10 90 L 140 10' })))));
    }
}
MapTrafficStatusIndicator.ALT_RESTRICTION_TEXT = {
    [MapTrafficAltitudeRestrictionMode.Unrestricted]: 'UNRES',
    [MapTrafficAltitudeRestrictionMode.Above]: 'ABOVE',
    [MapTrafficAltitudeRestrictionMode.Normal]: 'NORM',
    [MapTrafficAltitudeRestrictionMode.Below]: 'BELOW'
};

/**
 * Controls the declutter mode of a map.
 */
class MapDeclutterController {
    /**
     * Creates an instance of the MapDeclutterController.
     * @param declutterModule The declutter module of the map associated with this controller.
     * @param settingManager The user settings manager for map settings.
     */
    constructor(declutterModule, settingManager) {
        this.declutterModule = declutterModule;
        this.settingManager = settingManager;
        this.declutterSettingConsumer = null;
        this.handler = this.onSettingChanged.bind(this);
        this.isInit = false;
        this.declutterSetting = settingManager.getSetting('mapDeclutter');
    }
    /**
     * Initializes this controller. Once initialized, this controller will automatically update the map declutter mode.
     */
    init() {
        if (this.isInit) {
            return;
        }
        this.declutterSettingConsumer = this.settingManager.whenSettingChanged(this.declutterSetting.definition.name);
        this.declutterSettingConsumer.handle(this.handler);
        this.isInit = true;
    }
    /**
     * A callback which is called when the map declutter setting value changes.
     * @param mode The new mp declutter setting mode.
     */
    onSettingChanged(mode) {
        this.declutterModule.mode.set(MapDeclutterController.MODE_MAP[mode]);
    }
    /**
     * Destroys this controller, freeing up resources associated with it. Once destroyed, this controller will no longer
     * automatically update the map declutter mode.
     */
    destroy() {
        var _a;
        (_a = this.declutterSettingConsumer) === null || _a === void 0 ? void 0 : _a.off(this.handler);
        this.declutterSettingConsumer = null;
    }
}
MapDeclutterController.MODE_MAP = {
    [MapDeclutterSettingMode.All]: MapDeclutterMode.All,
    [MapDeclutterSettingMode.Level3]: MapDeclutterMode.Level3,
    [MapDeclutterSettingMode.Level2]: MapDeclutterMode.Level2,
    [MapDeclutterSettingMode.Level1]: MapDeclutterMode.Level1,
};

/**
 * Controls the terrain mode and terrain scale of a map.
 */
class MapTerrainController {
    /**
     * Constructor.
     * @param mapModel The model of the map associated with this controller.
     * @param settingManager This controller's map settings manager.
     * @param allowRelative Whether this controller allows relative terrain colors to be displayed.
     */
    constructor(mapModel, settingManager, allowRelative = true) {
        this.settingManager = settingManager;
        this.allowRelative = allowRelative;
        this.modeSettingConsumer = null;
        this.rangeIndexSettingConsumer = null;
        this.showScaleSettingConsumer = null;
        this.colorsHandler = this.updateColors.bind(this);
        this.showScaleHandler = this.updateShowScale.bind(this);
        this.isInit = false;
        this.rangeModule = mapModel.getModule('range');
        this.ownAirplaneModule = mapModel.getModule('ownAirplaneProps');
        this.terrainModule = mapModel.getModule('terrain');
        this.modeSetting = settingManager.getSetting('mapTerrainMode');
        this.rangeIndexSetting = settingManager.getSetting('mapTerrainRangeIndex');
        this.showScaleSetting = settingManager.getSetting('mapTerrainScaleShow');
    }
    /**
     * Initializes this controller. Once initialized, this controller will automatically update the map terrain mode and scale.
     */
    init() {
        if (this.isInit) {
            return;
        }
        this.modeSettingConsumer = this.settingManager.whenSettingChanged(this.modeSetting.definition.name);
        this.rangeIndexSettingConsumer = this.settingManager.whenSettingChanged(this.rangeIndexSetting.definition.name);
        this.showScaleSettingConsumer = this.settingManager.whenSettingChanged(this.showScaleSetting.definition.name);
        this.modeSettingConsumer.handle(this.colorsHandler);
        this.rangeIndexSettingConsumer.handle(this.colorsHandler);
        this.rangeModule.nominalRangeIndex.sub(this.colorsHandler, true);
        this.ownAirplaneModule.isOnGround.sub(this.colorsHandler, true);
        this.showScaleSettingConsumer.handle(this.showScaleHandler);
        this.isInit = true;
    }
    /**
     * Updates the terrain mode.
     */
    updateColors() {
        let mode = MapTerrainMode.None;
        if (this.rangeModule.nominalRangeIndex.get() <= this.rangeIndexSetting.value) {
            switch (this.modeSetting.value) {
                case MapTerrainSettingMode.Absolute:
                    mode = MapTerrainMode.Absolute;
                    break;
                case MapTerrainSettingMode.Relative:
                    if (this.allowRelative && !this.ownAirplaneModule.isOnGround.get()) {
                        mode = MapTerrainMode.Relative;
                    }
                    break;
            }
        }
        this.terrainModule.terrainMode.set(mode);
    }
    /**
     * Updates whether to show the terrain scale.
     * @param show Whether to show the terrain scale.
     */
    updateShowScale(show) {
        this.terrainModule.showScale.set(show);
    }
    /**
     * Destroys this controller, freeing up resources associated with it. Once destroyed, this controller will no longer
     * automatically update the map terrain mode and scale.
     */
    destroy() {
        var _a, _b, _c;
        (_a = this.modeSettingConsumer) === null || _a === void 0 ? void 0 : _a.off(this.colorsHandler);
        (_b = this.rangeIndexSettingConsumer) === null || _b === void 0 ? void 0 : _b.off(this.colorsHandler);
        this.rangeModule.nominalRangeIndex.unsub(this.colorsHandler);
        this.ownAirplaneModule.isOnGround.unsub(this.colorsHandler);
        (_c = this.showScaleSettingConsumer) === null || _c === void 0 ? void 0 : _c.off(this.showScaleHandler);
        this.modeSettingConsumer = null;
        this.rangeIndexSettingConsumer = null;
        this.showScaleSettingConsumer = null;
    }
}

/**
 * Controls the visibility of a specific type of map symbol whose visibility is dependent on its own show and maximum
 * range index settings as well as the global map declutter setting.
 */
class MapSymbolVisController {
    /**
     * Constructor.
     * @param rangeModule The range module of the map associated with this controller.
     * @param declutterModule The declutter module of the map associated with this controller.
     * @param settingManager This controller's map settings manager.
     * @param showSettingName The name of the show setting associated with this controller.
     * @param rangeIndexSettingName The name of the range index setting associated with this controller.
     * @param declutterLevel The highest global declutter level at which the symbol controlled by this controller remains
     * visible.
     * @param setVisibilityFunc A function which sets the visibility of the symbol controlled by this controller.
     */
    constructor(rangeModule, declutterModule, settingManager, showSettingName, rangeIndexSettingName, declutterLevel, setVisibilityFunc) {
        this.rangeModule = rangeModule;
        this.declutterModule = declutterModule;
        this.settingManager = settingManager;
        this.declutterLevel = declutterLevel;
        this.setVisibilityFunc = setVisibilityFunc;
        this.showSettingConsumer = null;
        this.rangeIndexSettingConsumer = null;
        this.handler = this.updateVisibility.bind(this);
        this.isInit = false;
        this.showSetting = settingManager.getSetting(showSettingName);
        this.rangeIndexSetting = settingManager.getSetting(rangeIndexSettingName);
    }
    /**
     * Initializes this controller. Once initialized, this controller will automatically adjust the visibility of its
     * associated map symbol.
     */
    init() {
        if (this.isInit) {
            return;
        }
        this.showSettingConsumer = this.settingManager.whenSettingChanged(this.showSetting.definition.name);
        this.rangeIndexSettingConsumer = this.settingManager.whenSettingChanged(this.rangeIndexSetting.definition.name);
        this.showSettingConsumer.handle(this.handler);
        this.rangeIndexSettingConsumer.handle(this.handler);
        this.rangeModule.nominalRangeIndex.sub(this.handler);
        this.declutterModule.mode.sub(this.handler, true);
        this.isInit = true;
    }
    /**
     * Updates the visibility of this controller's associated map symbol.
     */
    updateVisibility() {
        let show = false;
        if (this.showSetting.value && this.declutterModule.mode.get() <= this.declutterLevel) {
            show = this.rangeModule.nominalRangeIndex.get() <= this.rangeIndexSetting.value;
        }
        this.setVisibilityFunc(show);
    }
    /**
     * Destroys this controller, freeing up resources associated with it. Once destroyed, this controller will no longer
     * automatically adjust the visibility of its associated map symbol.
     */
    destroy() {
        var _a, _b;
        (_a = this.showSettingConsumer) === null || _a === void 0 ? void 0 : _a.off(this.handler);
        (_b = this.rangeIndexSettingConsumer) === null || _b === void 0 ? void 0 : _b.off(this.handler);
        this.rangeModule.nominalRangeIndex.unsub(this.handler);
        this.declutterModule.mode.unsub(this.handler);
        this.showSettingConsumer = null;
        this.rangeIndexSettingConsumer = null;
    }
}

/**
 * Controls the visibility of map waypoint symbols.
 */
class MapWaypointsVisController {
    /**
     * Constructor.
     * @param mapModel The model of the map associated with this controller.
     * @param settingManager This controller's map settings manager.
     */
    constructor(mapModel, settingManager) {
        const rangeModule = mapModel.getModule('range');
        const declutterModule = mapModel.getModule('declutter');
        const waypointsModule = mapModel.getModule('waypoints');
        this.airportVisControllers = {
            [AirportSize.Large]: new MapSymbolVisController(rangeModule, declutterModule, settingManager, 'mapAirportLargeShow', 'mapAirportLargeRangeIndex', MapDeclutterMode.Level2, visibility => { waypointsModule.airportShow[AirportSize.Large].set(visibility); }),
            [AirportSize.Medium]: new MapSymbolVisController(rangeModule, declutterModule, settingManager, 'mapAirportMediumShow', 'mapAirportMediumRangeIndex', MapDeclutterMode.Level2, visibility => { waypointsModule.airportShow[AirportSize.Medium].set(visibility); }),
            [AirportSize.Small]: new MapSymbolVisController(rangeModule, declutterModule, settingManager, 'mapAirportSmallShow', 'mapAirportSmallRangeIndex', MapDeclutterMode.Level2, visibility => { waypointsModule.airportShow[AirportSize.Small].set(visibility); })
        };
        this.vorVisController = new MapSymbolVisController(rangeModule, declutterModule, settingManager, 'mapVorShow', 'mapVorRangeIndex', MapDeclutterMode.Level3, visibility => { waypointsModule.vorShow.set(visibility); });
        this.ndbVisController = new MapSymbolVisController(rangeModule, declutterModule, settingManager, 'mapNdbShow', 'mapNdbRangeIndex', MapDeclutterMode.Level3, visibility => { waypointsModule.ndbShow.set(visibility); });
        this.intersectionVisController = new MapSymbolVisController(rangeModule, declutterModule, settingManager, 'mapIntersectionShow', 'mapIntersectionRangeIndex', MapDeclutterMode.Level3, visibility => { waypointsModule.intShow.set(visibility); });
    }
    /**
     * Initializes this controller. Once initialized, this controller will automatically adjust the visibility of the map
     * waypoint symbols.
     */
    init() {
        this.airportVisControllers[AirportSize.Large].init();
        this.airportVisControllers[AirportSize.Medium].init();
        this.airportVisControllers[AirportSize.Small].init();
        this.vorVisController.init();
        this.ndbVisController.init();
        this.intersectionVisController.init();
    }
    /**
     * Destroys this controller, freeing up resources associated with it. Once destroyed, this controller will no longer
     * automatically adjust the visibility of the map waypoint symbols.
     */
    destroy() {
        this.airportVisControllers[AirportSize.Large].destroy();
        this.airportVisControllers[AirportSize.Medium].destroy();
        this.airportVisControllers[AirportSize.Small].destroy();
        this.vorVisController.destroy();
        this.ndbVisController.destroy();
        this.intersectionVisController.destroy();
    }
}

/** A controller for displaying NEXRAD. */
class MapNexradController {
    /**
     * Creates an instance of the MapNexradController.
     * @param mapModel The nav map data model.
     * @param settingManager The user settings manager for map settings.
     */
    constructor(mapModel, settingManager) {
        this.settingManager = settingManager;
        const nexradModule = mapModel.getModule('nexrad');
        const rangeModule = mapModel.getModule('range');
        const declutterModule = mapModel.getModule('declutter');
        this.nexradVisController = new MapSymbolVisController(rangeModule, declutterModule, settingManager, 'mapNexradShow', 'mapNexradRangeIndex', MapDeclutterMode.Level2, visibility => { nexradModule.showNexrad.set(visibility); });
    }
    /**
     * Initializes the NEXRAD controller.
     */
    init() {
        this.nexradVisController.init();
    }
    /**
     * Destroys this controller, freeing up resources associated with it. Once destroyed, this controller will no longer
     * automatically update the map terrain mode and scale.
     */
    destroy() {
        this.nexradVisController.destroy();
    }
}

/**
 * Displays a map orientation indication.
 */
class MapOrientationIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.rootRef = FSComponent.createRef();
        this.textSub = this.props.orientation.map(mode => {
            return this.props.text[mode];
        });
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.isVisible.sub(isVisible => { this.rootRef.instance.style.visibility = isVisible ? '' : 'hidden'; });
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { ref: this.rootRef, class: 'map-orientation' }, this.textSub));
    }
}

var TrafficOperatingModeSetting;
(function (TrafficOperatingModeSetting) {
    TrafficOperatingModeSetting[TrafficOperatingModeSetting["Standby"] = 0] = "Standby";
    TrafficOperatingModeSetting[TrafficOperatingModeSetting["Operating"] = 1] = "Operating";
    TrafficOperatingModeSetting[TrafficOperatingModeSetting["Test"] = 2] = "Test";
})(TrafficOperatingModeSetting || (TrafficOperatingModeSetting = {}));
var TrafficAltitudeModeSetting;
(function (TrafficAltitudeModeSetting) {
    TrafficAltitudeModeSetting[TrafficAltitudeModeSetting["Below"] = 0] = "Below";
    TrafficAltitudeModeSetting[TrafficAltitudeModeSetting["Normal"] = 1] = "Normal";
    TrafficAltitudeModeSetting[TrafficAltitudeModeSetting["Above"] = 2] = "Above";
    TrafficAltitudeModeSetting[TrafficAltitudeModeSetting["Unrestricted"] = 3] = "Unrestricted";
})(TrafficAltitudeModeSetting || (TrafficAltitudeModeSetting = {}));
var TrafficMotionVectorModeSetting;
(function (TrafficMotionVectorModeSetting) {
    TrafficMotionVectorModeSetting[TrafficMotionVectorModeSetting["Off"] = 0] = "Off";
    TrafficMotionVectorModeSetting[TrafficMotionVectorModeSetting["Absolute"] = 1] = "Absolute";
    TrafficMotionVectorModeSetting[TrafficMotionVectorModeSetting["Relative"] = 2] = "Relative";
})(TrafficMotionVectorModeSetting || (TrafficMotionVectorModeSetting = {}));
/**
 *
 */
class TrafficUserSettings extends DefaultUserSettingManager {
    /**
     * Gets an instance of the traffic user settings manager.
     * @param bus The event bus.
     * @returns An instance of the traffic user settings manager.
     */
    static getManager(bus) {
        var _a;
        return (_a = TrafficUserSettings.INSTANCE) !== null && _a !== void 0 ? _a : (TrafficUserSettings.INSTANCE = new DefaultUserSettingManager(bus, [
            {
                name: 'trafficOperatingMode',
                defaultValue: TrafficOperatingModeSetting.Standby
            },
            {
                name: 'trafficAltitudeMode',
                defaultValue: TrafficAltitudeModeSetting.Unrestricted
            },
            {
                name: 'trafficMotionVectorMode',
                defaultValue: TrafficMotionVectorModeSetting.Off
            },
            {
                name: 'trafficMotionVectorLookahead',
                defaultValue: 60
            }
        ]));
    }
}

/**
 * Controls the display of traffic on a map.
 */
class MapTrafficController {
    /**
     * Constructor.
     * @param mapModel The model of the map associated with this controller.
     * @param settingManager This controller's traffic settings manager.
     */
    constructor(mapModel, settingManager) {
        this.settingManager = settingManager;
        this.altitudeModeSettingConsumer = null;
        this.motionVectorModeSettingConsumer = null;
        this.motionVectorLookaheadSettingConsumer = null;
        this.altitudeModeHandler = this.updateAltitudeMode.bind(this);
        this.motionVectorModeHandler = this.updateMotionVectorMode.bind(this);
        this.motionVectorLookaheadHandler = this.updateMotionVectorLookahead.bind(this);
        this.isInit = false;
        this.trafficModule = mapModel.getModule('traffic');
        this.altitudeModeSetting = settingManager.getSetting('trafficAltitudeMode');
        this.motionVectorModeSetting = settingManager.getSetting('trafficMotionVectorMode');
        this.motionVectorLookaheadSetting = settingManager.getSetting('trafficMotionVectorLookahead');
    }
    /**
     * Initializes this controller. Once initialized, this controller will automatically update the map traffic module.
     */
    init() {
        if (this.isInit) {
            return;
        }
        this.altitudeModeSettingConsumer = this.settingManager.whenSettingChanged(this.altitudeModeSetting.definition.name);
        this.motionVectorModeSettingConsumer = this.settingManager.whenSettingChanged(this.motionVectorModeSetting.definition.name);
        this.motionVectorLookaheadSettingConsumer = this.settingManager.whenSettingChanged(this.motionVectorLookaheadSetting.definition.name);
        this.altitudeModeSettingConsumer.handle(this.altitudeModeHandler);
        this.motionVectorModeSettingConsumer.handle(this.motionVectorModeHandler);
        this.motionVectorLookaheadSettingConsumer.handle(this.motionVectorLookaheadHandler);
    }
    /**
     * Updates the traffic altitude restriction mode.
     */
    updateAltitudeMode() {
        this.trafficModule.altitudeRestrictionMode.set(MapTrafficController.ALT_MODE_MAP[this.altitudeModeSetting.value]);
    }
    /**
     * Updates the traffic motion vector mode.
     */
    updateMotionVectorMode() {
        this.trafficModule.motionVectorMode.set(MapTrafficController.MOTION_VECTOR_MODE_MAP[this.motionVectorModeSetting.value]);
    }
    /**
     * Updates the traffic motion vector lookahead time.
     */
    updateMotionVectorLookahead() {
        this.trafficModule.motionVectorLookahead.set(this.motionVectorLookaheadSetting.value, UnitType.SECOND);
    }
    /**
     * Destroys this controller, freeing up resources associated with it. Once destroyed, this controller will no longer
     * automatically update the map traffic module.
     */
    destroy() {
        var _a, _b, _c;
        (_a = this.altitudeModeSettingConsumer) === null || _a === void 0 ? void 0 : _a.handle(this.altitudeModeHandler);
        (_b = this.motionVectorModeSettingConsumer) === null || _b === void 0 ? void 0 : _b.handle(this.altitudeModeHandler);
        (_c = this.motionVectorLookaheadSettingConsumer) === null || _c === void 0 ? void 0 : _c.handle(this.motionVectorLookaheadHandler);
        this.altitudeModeSettingConsumer = null;
        this.motionVectorModeSettingConsumer = null;
        this.motionVectorLookaheadSettingConsumer = null;
    }
}
MapTrafficController.ALT_MODE_MAP = {
    [TrafficAltitudeModeSetting.Above]: MapTrafficAltitudeRestrictionMode.Above,
    [TrafficAltitudeModeSetting.Below]: MapTrafficAltitudeRestrictionMode.Below,
    [TrafficAltitudeModeSetting.Normal]: MapTrafficAltitudeRestrictionMode.Normal,
    [TrafficAltitudeModeSetting.Unrestricted]: MapTrafficAltitudeRestrictionMode.Unrestricted
};
MapTrafficController.MOTION_VECTOR_MODE_MAP = {
    [TrafficMotionVectorModeSetting.Off]: MapTrafficMotionVectorMode.Off,
    [TrafficMotionVectorModeSetting.Absolute]: MapTrafficMotionVectorMode.Absolute,
    [TrafficMotionVectorModeSetting.Relative]: MapTrafficMotionVectorMode.Relative
};

/**
 * Controls the display of traffic on a navigation map.
 */
class NavMapTrafficController extends MapTrafficController {
    /**
     * Constructor.
     * @param mapModel The model of the map associated with this controller.
     * @param trafficSettingManager This controller's traffic settings manager.
     * @param mapSettingManager This controller's map settings manager.
     */
    constructor(mapModel, trafficSettingManager, mapSettingManager) {
        super(mapModel, trafficSettingManager);
        this.mapSettingManager = mapSettingManager;
        this.showSettingConsumer = null;
        this.rangeIndexSettingConsumer = null;
        this.labelShowSettingConsumer = null;
        this.labelRangeIndexSettingConsumer = null;
        this.alertLevelModeSettingConsumer = null;
        this.showHandler = this.updateShow.bind(this);
        this.showLabelHandler = this.updateShowLabel.bind(this);
        this.alertLevelModeHandler = this.updateAlertLevelMode.bind(this);
        this.rangeModule = mapModel.getModule('range');
        this.showSetting = mapSettingManager.getSetting('mapTrafficShow');
        this.rangeIndexSetting = mapSettingManager.getSetting('mapTrafficRangeIndex');
        this.labelShowSetting = mapSettingManager.getSetting('mapTrafficLabelShow');
        this.labelRangeIndexSetting = mapSettingManager.getSetting('mapTrafficLabelRangeIndex');
        this.alertLevelModeSetting = mapSettingManager.getSetting('mapTrafficAlertLevelMode');
    }
    /**
     * Initializes this controller. Once initialized, this controller will automatically update the map traffic module.
     */
    init() {
        if (this.isInit) {
            return;
        }
        super.init();
        this.showSettingConsumer = this.mapSettingManager.whenSettingChanged(this.showSetting.definition.name);
        this.rangeIndexSettingConsumer = this.mapSettingManager.whenSettingChanged(this.rangeIndexSetting.definition.name);
        this.labelShowSettingConsumer = this.mapSettingManager.whenSettingChanged(this.labelShowSetting.definition.name);
        this.labelRangeIndexSettingConsumer = this.mapSettingManager.whenSettingChanged(this.labelRangeIndexSetting.definition.name);
        this.alertLevelModeSettingConsumer = this.mapSettingManager.whenSettingChanged(this.alertLevelModeSetting.definition.name);
        this.showSettingConsumer.handle(this.showHandler);
        this.rangeIndexSettingConsumer.handle(this.showHandler);
        this.rangeModule.nominalRangeIndex.sub(this.showHandler, true);
        this.labelShowSettingConsumer.handle(this.showLabelHandler);
        this.labelRangeIndexSettingConsumer.handle(this.showLabelHandler);
        this.rangeModule.nominalRangeIndex.sub(this.showLabelHandler, true);
        this.alertLevelModeSettingConsumer.handle(this.alertLevelModeHandler);
    }
    /**
     * Updates whether to show traffic.
     */
    updateShow() {
        this.trafficModule.show.set(this.showSetting.value && this.rangeModule.nominalRangeIndex.get() <= this.rangeIndexSetting.value);
    }
    /**
     * Updates whether to show traffic intruder labels.
     */
    updateShowLabel() {
        this.trafficModule.showIntruderLabel.set(this.labelShowSetting.value && this.rangeModule.nominalRangeIndex.get() <= this.labelRangeIndexSetting.value);
    }
    /**
     * Updates the traffic alert level mode.
     * @param mode The new alert level mode.
     */
    updateAlertLevelMode(mode) {
        this.trafficModule.alertLevelMode.set(mode);
    }
    /**
     * Destroys this controller, freeing up resources associated with it. Once destroyed, this controller will no longer
     * automatically update the map traffic module.
     */
    destroy() {
        var _a, _b, _c, _d, _e;
        super.destroy();
        (_a = this.showSettingConsumer) === null || _a === void 0 ? void 0 : _a.handle(this.showHandler);
        (_b = this.rangeIndexSettingConsumer) === null || _b === void 0 ? void 0 : _b.handle(this.showHandler);
        this.rangeModule.nominalRangeIndex.unsub(this.showHandler);
        (_c = this.labelShowSettingConsumer) === null || _c === void 0 ? void 0 : _c.handle(this.showLabelHandler);
        (_d = this.labelRangeIndexSettingConsumer) === null || _d === void 0 ? void 0 : _d.handle(this.showLabelHandler);
        this.rangeModule.nominalRangeIndex.unsub(this.showLabelHandler);
        (_e = this.alertLevelModeSettingConsumer) === null || _e === void 0 ? void 0 : _e.handle(this.alertLevelModeHandler);
        this.showSettingConsumer = null;
        this.rangeIndexSettingConsumer = null;
        this.labelShowSettingConsumer = null;
        this.labelRangeIndexSettingConsumer = null;
        this.alertLevelModeSettingConsumer = null;
    }
}

/**
 * Controls the map crosshair. Shows the crosshair when the map pointer is active, and hides the crosshair otherwise.
 */
class MapCrosshairController {
    /**
     * Constructor.
     * @param mapModel The model of the map associated with this controller.
     */
    constructor(mapModel) {
        this.mapModel = mapModel;
        this.handler = this.updateCrosshairShow.bind(this);
        this.isInit = false;
    }
    /**
     * Initializes this controller. Once initialized, this controller will automatically update the map crosshair
     * visibility.
     */
    init() {
        if (this.isInit) {
            return;
        }
        this.initListeners();
        this.updateCrosshairShow();
        this.isInit = true;
    }
    /**
     * Initializes this controller's listeners.
     */
    initListeners() {
        this.mapModel.getModule('pointer').isActive.sub(this.handler);
    }
    /**
     * Updates whether to show this controller's map crosshair.
     */
    updateCrosshairShow() {
        this.mapModel.getModule('crosshair').show.set(this.mapModel.getModule('pointer').isActive.get());
    }
    /**
     * Destroys this controller, freeing up resources associated with it. Once destroyed, this controller will no longer
     * automatically update the map crosshair visibility.
     */
    destroy() {
        this.mapModel.getModule('pointer').isActive.unsub(this.handler);
    }
}

/// <reference types="msfstypes/JS/Avionics" />
/**
 * A G1000 navigation map component.
 */
class NavMapComponent extends MapComponent {
    /**
     * Creates an instance of a NavMap.
     * @param props The properties of the nav map.
     */
    constructor(props) {
        super(props);
        this.rootRef = FSComponent.createRef();
        this.bingLayerRef = FSComponent.createRef();
        this.airspaceLayerRef = FSComponent.createRef();
        this.flightPlanLayerRef = FSComponent.createRef();
        this.navAidsLayerRef = FSComponent.createRef();
        this.textLayerRef = FSComponent.createRef();
        this.crosshairLayerRef = FSComponent.createRef();
        this.trafficIntruderLayerRef = FSComponent.createRef();
        this.ownAirplaneLayerRef = FSComponent.createRef();
        this.pointerLayerRef = FSComponent.createRef();
        this.deadZone = new Float64Array(4);
        this.pointerBoundsSub = VecNSubject.createFromVector(new Float64Array([0, 0, this.props.projectedWidth, this.props.projectedHeight]));
        this.textManager = new MapCullableTextLabelManager();
        this.waypointRenderer = new MapWaypointRenderer(this.textManager);
        this.trafficOffScaleModeSub = Subject.create(MapTrafficIntruderOffScaleIndicatorMode.Off);
        this.rangeSettingManager = MapRangeSettings.getManager(this.props.bus);
        this.declutterController = new MapDeclutterController(this.props.model.getModule('declutter'), this.props.settingManager);
        this.terrainColorController = new MapTerrainController(this.props.model, this.props.settingManager);
        this.waypointsVisController = new MapWaypointsVisController(this.props.model, this.props.settingManager);
        this.trafficController = new NavMapTrafficController(this.props.model, TrafficUserSettings.getManager(this.props.bus), this.props.settingManager);
        this.nexradController = new MapNexradController(this.props.model, this.props.settingManager);
        this.crosshairController = new MapCrosshairController(this.props.model);
        if (this.props.deadZone) {
            this.deadZone.set(this.props.deadZone);
        }
        this.updatePointerBounds();
        this.rangeTargetRotationController = this.createRangeTargetRotationController();
    }
    /**
     * Gets the size of the dead zone around this map's projected window, which is displayed but excluded in map range
     * calculations. Expressed as [left, top, right, bottom] in pixels.
     * @returns the size of the dead zone around this map's projected window.
     */
    getDeadZone() {
        return this.deadZone;
    }
    /**
     * Sets the size of the dead zone around this map's projected window. The dead zone is displayed but excluded in map
     * range calculations.
     * @param deadZone The new dead zone, expressed as [left, top, right, bottom] in pixels.
     */
    setDeadZone(deadZone) {
        if (this.deadZone.every((value, index) => value === deadZone[index])) {
            return;
        }
        this.deadZone.set(deadZone);
        this.onDeadZoneChanged();
    }
    /**
     * This method is called when the size of this map's dead zone changes.
     */
    onDeadZoneChanged() {
        this.rangeTargetRotationController.setDeadZone(this.deadZone);
        this.updatePointerBounds();
    }
    /** @inheritdoc */
    onAfterRender() {
        super.onAfterRender();
        this.setRootSize(this.mapProjection.getProjectedSize());
        this.initEventBusHandlers();
        this.rangeTargetRotationController.init();
        this.initControllers();
        this.initLayers();
    }
    /**
     * Sets the size of this map's root HTML element.
     * @param size The new size, in pixels.
     */
    setRootSize(size) {
        this.rootRef.instance.style.width = `${size[0]}px`;
        this.rootRef.instance.style.height = `${size[1]}px`;
    }
    /**
     * Initializes event bus handlers.
     */
    initEventBusHandlers() {
        this.props.model.getModule('ownAirplaneProps').beginSync(this.props.bus, this.props.updateFreq);
    }
    /**
     * Initializes model controllers.
     */
    initControllers() {
        this.declutterController.init();
        this.terrainColorController.init();
        this.waypointsVisController.init();
        this.trafficController.init();
        this.nexradController.init();
        this.crosshairController.init();
    }
    /**
     * Initializes this map's layers.
     */
    initLayers() {
        this.attachLayer(this.bingLayerRef.instance);
        this.attachLayer(this.airspaceLayerRef.instance);
        this.attachLayer(this.navAidsLayerRef.instance);
        this.attachLayer(this.flightPlanLayerRef.instance);
        this.attachLayer(this.textLayerRef.instance);
        this.attachLayer(this.crosshairLayerRef.instance);
        this.attachLayer(this.ownAirplaneLayerRef.instance);
        this.attachLayer(this.trafficIntruderLayerRef.instance);
        this.attachLayer(this.pointerLayerRef.instance);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onProjectedSizeChanged() {
        this.setRootSize(this.mapProjection.getProjectedSize());
        this.updatePointerBounds();
    }
    /**
     * Updates this map's pointer bounds.
     */
    updatePointerBounds() {
        const size = this.mapProjection.getProjectedSize();
        const minX = this.deadZone[0];
        const minY = this.deadZone[1];
        const maxX = size[0] - this.deadZone[2];
        const maxY = size[1] - this.deadZone[3];
        const width = maxX - minX;
        const height = maxY - minY;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        this.pointerBoundsSub.set(Math.min(centerX, minX + width * 0.1), Math.min(centerY, minY + height * 0.1), Math.max(centerX, maxX - height * 0.1), Math.max(centerY, maxY - height * 0.1));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        this.updateRangeTargetRotationController();
        this.waypointRenderer.update(this.mapProjection);
        super.onUpdated(time, elapsed);
    }
    /**
     * Updates this map's range/target/rotation controller.
     */
    updateRangeTargetRotationController() {
        this.rangeTargetRotationController.update();
    }
    /** @inheritdoc */
    render() {
        var _a;
        let className = 'nav-map-container';
        if (this.props.class !== undefined) {
            className += ` ${this.props.class}`;
        }
        return (FSComponent.buildComponent("div", { ref: this.rootRef, class: className },
            FSComponent.buildComponent(MapBingLayer, { ref: this.bingLayerRef, model: this.props.model, mapProjection: this.mapProjection, bingId: (_a = this.props.bingId) !== null && _a !== void 0 ? _a : this.props.id }),
            FSComponent.buildComponent(MapAirspaceLayer, { ref: this.airspaceLayerRef, model: this.props.model, mapProjection: this.mapProjection, useBuffer: true, overdrawFactor: 1.2, airspaceSearcher: this.props.airspaceSearcher, airspaceRenderManager: new AirspaceRenderManager() }),
            FSComponent.buildComponent(MapWaypointsLayer, { ref: this.navAidsLayerRef, model: this.props.model, mapProjection: this.mapProjection, bus: this.props.bus, waypointRenderer: this.waypointRenderer, textManager: this.textManager, styles: this.getWaypointsLayerStyles() }),
            this.renderFlightPlanLayer(),
            FSComponent.buildComponent(MapCullableTextLayer, { ref: this.textLayerRef, model: this.props.model, mapProjection: this.mapProjection, manager: this.textManager }),
            this.renderRangeRingLayer(),
            this.renderRangeCompassLayer(),
            FSComponent.buildComponent(MapCrosshairLayer, { ref: this.crosshairLayerRef, model: this.props.model, mapProjection: this.mapProjection }),
            FSComponent.buildComponent(MapTrafficIntruderLayer, { ref: this.trafficIntruderLayerRef, model: this.props.model, mapProjection: this.mapProjection, bus: this.props.bus, fontSize: this.props.trafficIntruderLayerProps.fontSize, iconSize: this.props.trafficIntruderLayerProps.iconSize, useOuterRangeMaxScale: false, offScaleIndicatorMode: this.trafficOffScaleModeSub }),
            FSComponent.buildComponent(MapOwnAirplaneLayer, { ref: this.ownAirplaneLayerRef, model: this.props.model, mapProjection: this.mapProjection, imageFilePath: this.props.ownAirplaneLayerProps.imageFilePath, iconSize: this.props.ownAirplaneLayerProps.iconSize, iconAnchor: this.props.ownAirplaneLayerProps.iconAnchor }),
            this.renderMiniCompassLayer(),
            this.renderPointerInfoLayer(),
            this.renderIndicatorGroups(),
            FSComponent.buildComponent(MapPointerLayer, { ref: this.pointerLayerRef, model: this.props.model, mapProjection: this.mapProjection })));
    }
    /**
     * Gets styles for the waypoints layer.
     * @returns styles for the waypoints layer.
     */
    getWaypointsLayerStyles() {
        return MapWaypointStyles.getNormalStyles(1, 10);
    }
    /**
     * Gets inactive waypoint styles for the flight plan layer.
     * @returns inactive waypoint styles for the flight plan layer.
     */
    getFlightPlanLayerInactiveWaypointsStyles() {
        return MapWaypointStyles.getFlightPlanStyles(false, 1, 20);
    }
    /**
     * Gets active waypoint styles for the flight plan layer.
     * @returns active waypoint styles for the flight plan layer.
     */
    getFlightPlanLayerActiveWaypointsStyles() {
        return MapWaypointStyles.getFlightPlanStyles(true, 2, 21);
    }
    /**
     * Renders this map's indicator groups.
     * @returns an array of this map's indicator groups.
     */
    renderIndicatorGroups() {
        return [
            this.renderTopLeftIndicatorGroup(),
            this.renderBottomLeftIndicatorGroup(),
            this.renderBottomRightIndicatorGroup()
        ];
    }
    /**
     * Renders the top-left indicator group.
     * @returns the top-left indicator group.
     */
    renderTopLeftIndicatorGroup() {
        return (FSComponent.buildComponent("div", { class: 'navmap-indicators-top-left' }, this.renderTopLeftIndicators()));
    }
    /**
     * Renders indicators in the top-left indicator group.
     * @returns indicators in the top-left indicator group.
     */
    renderTopLeftIndicators() {
        return [
            this.renderOrientationIndicator()
        ];
    }
    /**
     * Renders the bottom-left indicator group.
     * @returns the bottom-left indicator group.
     */
    renderBottomLeftIndicatorGroup() {
        return (FSComponent.buildComponent("div", { class: 'navmap-indicators-bottom-left' }, this.renderBottomLeftIndicators()));
    }
    /**
     * Renders indicators in the bottom-left indicator group.
     * @returns indicators in the bottom-left indicator group.
     */
    renderBottomLeftIndicators() {
        return [
            this.renderDetailIndicator(),
            this.renderTrafficOffScaleIndicator()
        ];
    }
    /**
     * Renders the bottom-right indicator group.
     * @returns the bottom-right indicator group.
     */
    renderBottomRightIndicatorGroup() {
        return (FSComponent.buildComponent("div", { class: 'navmap-indicators-bottom-right' }, this.renderBottomRightIndicators()));
    }
    /**
     * Renders indicators in the bottom-right indicator group.
     * @returns indicators in the bottom-right indicator group.
     */
    renderBottomRightIndicators() {
        return [
            this.renderTrafficStatusIndicator(true),
            this.renderTerrainScaleIndicator()
        ];
    }
    /**
     * Renders the flight plan layer.
     * @returns The rendered flight plan layer, as a VNode.
     */
    renderFlightPlanLayer() {
        return (FSComponent.buildComponent(MapFlightPlanLayer, { ref: this.flightPlanLayerRef, model: this.props.model, mapProjection: this.mapProjection, bus: this.props.bus, dataProvider: new MapActiveFlightPlanDataProvider(this.props.bus, this.props.flightPlanner), drawEntirePlan: this.props.drawEntireFlightPlan, waypointRenderer: this.waypointRenderer, textManager: this.textManager, inactiveWaypointStyles: this.getFlightPlanLayerInactiveWaypointsStyles(), activeWaypointStyles: this.getFlightPlanLayerActiveWaypointsStyles() }));
    }
    /**
     * Renders the range indicator.
     * @returns The range indicator.
     */
    renderRangeIndicator() {
        // TODO: Add customizable display unit support.
        const rangeModule = this.props.model.getModule('range');
        return (FSComponent.buildComponent(MapRangeDisplay, { range: rangeModule.nominalRange, displayUnit: Subject.create(UnitType.NMILE) }));
    }
    /**
     * Renders the orientation indicator.
     * @returns The orientation indicator.
     */
    renderOrientationIndicator() {
        const orientationModule = this.props.model.getModule('orientation');
        return (FSComponent.buildComponent(MapOrientationIndicator, { orientation: orientationModule.orientation, text: {
                [MapOrientation.NorthUp]: 'NORTH UP',
                [MapOrientation.TrackUp]: 'TRK UP',
                [MapOrientation.HeadingUp]: 'HDG UP'
            }, isVisible: this.props.model.getModule('pointer').isActive.map(isActive => !isActive) }));
    }
    /**
     * Renders the detail indicator.
     * @returns The detail indicator.
     */
    renderDetailIndicator() {
        return (FSComponent.buildComponent(MapDetailIndicator, { declutterMode: this.props.model.getModule('declutter').mode, showTitle: true }));
    }
    /**
     * Renders the traffic status indicator.
     * @param showAltitudeRestrictionMode Whether the indicator should show the altitude restriction mode.
     * @returns The traffic status indicator.
     */
    renderTrafficStatusIndicator(showAltitudeRestrictionMode) {
        const trafficModule = this.props.model.getModule('traffic');
        return (FSComponent.buildComponent(MapTrafficStatusIndicator, { showAltitudeRestrictionMode: showAltitudeRestrictionMode, show: trafficModule.show, operatingMode: trafficModule.operatingMode, altitudeRestrictionMode: trafficModule.altitudeRestrictionMode }));
    }
    /**
     * Renders the traffic off-scale indicator.
     * @returns The traffic off-scale indicator.
     */
    renderTrafficOffScaleIndicator() {
        return (FSComponent.buildComponent(MapTrafficIntruderOffScaleIndicator, { mode: this.trafficOffScaleModeSub }));
    }
}
/**
 * A controller for handling map range, target, and rotation changes.
 */
class NavMapRangeTargetRotationController {
    /**
     * Creates an instance of a MapRangeController.
     * @param mapModel The map model.
     * @param mapProjection The map projection.
     * @param deadZone The dead zone around the edge of the map projection window.
     * @param mapRanges An array of valid map ranges.
     * @param settingManager This controller's map settings manager.
     * @param rangeSettingManager This controller's map range settings manager.
     * @param rangeSettingName The name of this controller's map range setting.
     * @param pointerBounds A subscribable which provides the bounds of the area accessible to the map pointer. The
     * bounds should be expressed as `[left, top, right, bottom]` in pixels.
     */
    constructor(mapModel, mapProjection, deadZone, mapRanges, settingManager, rangeSettingManager, rangeSettingName, pointerBounds) {
        this.mapModel = mapModel;
        this.mapProjection = mapProjection;
        this.mapRanges = mapRanges;
        this.settingManager = settingManager;
        this.rangeSettingManager = rangeSettingManager;
        this.rangeSettingName = rangeSettingName;
        this.pointerBounds = pointerBounds;
        this.deadZone = new Float64Array(4);
        this.currentMapRangeIndex = NavMapRangeTargetRotationController.DEFAULT_MAP_RANGE_INDEX;
        this.needUpdateProjection = false;
        this.needUpdatePointerScroll = false;
        this.currentMapParameters = {
            range: 0,
            target: new GeoPoint(0, 0),
            targetProjectedOffset: new Float64Array(2),
            rotation: 0
        };
        this.airplanePropsModule = this.mapModel.getModule('ownAirplaneProps');
        this.orientationModule = this.mapModel.getModule('orientation');
        this.pointerModule = this.mapModel.getModule('pointer');
        this.rangeSetting = this.rangeSettingManager.getSetting(this.rangeSettingName);
        this.orientationSetting = this.settingManager.getSetting('mapOrientation');
        this.autoNorthUpActiveSetting = this.settingManager.getSetting('mapAutoNorthUpActive');
        this.autoNorthUpRangeIndexSetting = this.settingManager.getSetting('mapAutoNorthUpRangeIndex');
        this.airplanePositionChangedHandler = this.onAirplanePositionChanged.bind(this);
        this.airplaneOnGroundChangedHandler = this.onAirplaneOnGroundChanged.bind(this);
        this.airplaneRotationChangedHandler = this.onAirplaneRotationChanged.bind(this);
        this.pointerPositionChangedHandler = this.onPointerPositionChanged.bind(this);
        this.pointerTargetChangedHandler = this.onPointerTargetChanged.bind(this);
        this.pointerBoundsChangedHandler = this.onPointerBoundsChanged.bind(this);
        this.areAirplanePositionListenersActive = false;
        this.currentAirplaneRotationSub = null;
        this.deadZone.set(deadZone);
    }
    /**
     * Executes this controller's first-run initialization code.
     */
    init() {
        this.mapModel.getModule('range').nominalRanges.set(this.mapRanges);
        this.updateRangeFromIndex();
        this.mapProjection.addChangeListener(this.onMapProjectionChanged.bind(this));
        this.initSettingsListeners();
        this.initModuleListeners();
        this.initState();
        this.scheduleProjectionUpdate();
    }
    /**
     * Initializes settings listeners.
     */
    initSettingsListeners() {
        this.rangeSettingManager.whenSettingChanged(this.rangeSettingName).handle(this.onRangeSettingChanged.bind(this));
        this.settingManager.whenSettingChanged('mapOrientation').handle(this.onOrientationSettingChanged.bind(this));
        this.settingManager.whenSettingChanged('mapAutoNorthUpActive').handle(this.onAutoNorthUpSettingChanged.bind(this));
        this.settingManager.whenSettingChanged('mapAutoNorthUpRangeIndex').handle(this.onAutoNorthUpSettingChanged.bind(this));
    }
    /**
     * Initializes module listeners.
     */
    initModuleListeners() {
        this.orientationModule.orientation.sub(this.onOrientationChanged.bind(this), true);
        this.pointerModule.isActive.sub(this.onPointerActiveChanged.bind(this), true);
    }
    /**
     * Initializes this controller's state.
     */
    initState() {
        this.updateTargetFromPPos();
        this.updateTargetOffset();
    }
    /**
     * Sets the size of this controller's dead zone. The dead zone is the area around the edges of the map excluded in
     * range calculations.
     * @param deadZone The new dead zone, expressed as [left, top, right, bottom] in pixels.
     */
    setDeadZone(deadZone) {
        if (this.deadZone.every((value, index) => value === deadZone[index])) {
            return;
        }
        this.deadZone.set(deadZone);
        this.onDeadZoneChanged();
    }
    /**
     * This method is called when the size of the dead zone changes.
     */
    onDeadZoneChanged() {
        this.updateRangeFromIndex();
        this.updateTargetOffset();
        this.scheduleProjectionUpdate();
    }
    /**
     * Updates the range index.
     */
    updateRangeIndex() {
        const newIndex = Utils.Clamp(this.rangeSetting.value, 0, this.mapRanges.length - 1);
        if (newIndex !== this.currentMapRangeIndex) {
            this.currentMapRangeIndex = newIndex;
            if (this.autoNorthUpActiveSetting.value) {
                this.updateOrientation();
            }
            this.updateRangeFromIndex();
            this.scheduleProjectionUpdate();
        }
    }
    /**
     * Updates the current range from the current range index.
     */
    updateRangeFromIndex() {
        const nominalRange = this.mapRanges[this.currentMapRangeIndex];
        this.currentMapParameters.range = this.convertToTrueRange(nominalRange);
    }
    /**
     * Updates the map target based on the airplane's present position.
     */
    updateTargetFromPPos() {
        const ppos = this.mapModel.getModule('ownAirplaneProps').position.get();
        this.currentMapParameters.target.set(ppos);
    }
    /**
     * Updates the target offset.
     */
    updateTargetOffset() {
        this.currentMapParameters.targetProjectedOffset.set(this.getDesiredTargetOffset());
    }
    /**
     * Updates the map orientation.
     */
    updateOrientation() {
        const orientationSettingMode = this.orientationSetting.value;
        let orientation;
        if (orientationSettingMode === MapOrientationSettingMode.NorthUp
            || (this.autoNorthUpActiveSetting.value && this.currentMapRangeIndex > this.autoNorthUpRangeIndexSetting.value)) {
            orientation = MapOrientation.NorthUp;
        }
        else if (orientationSettingMode === MapOrientationSettingMode.TrackUp && !this.airplanePropsModule.isOnGround.get()) {
            orientation = MapOrientation.TrackUp;
        }
        else {
            orientation = MapOrientation.HeadingUp;
        }
        this.orientationModule.orientation.set(orientation);
    }
    /**
     * Responds to map projection changes.
     * @param mapProjection The map projection that changed.
     * @param changeFlags The types of changes made to the projection.
     */
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.onProjectedSizeChanged();
        }
    }
    /**
     * Responds to projected map window size changes.
     */
    onProjectedSizeChanged() {
        this.updateRangeFromIndex();
        this.updateTargetOffset();
        this.scheduleProjectionUpdate();
    }
    /**
     * Responds to range setting changes.
     */
    onRangeSettingChanged() {
        this.updateRangeIndex();
    }
    /**
     * Responds to orientation setting changes.
     */
    onOrientationSettingChanged() {
        this.updateOrientation();
    }
    /**
     * Responds to auto north up setting changes.
     */
    onAutoNorthUpSettingChanged() {
        this.updateOrientation();
    }
    /**
     * Responds to airplane position changes.
     */
    onAirplanePositionChanged() {
        this.updateTargetFromPPos();
        this.scheduleProjectionUpdate();
    }
    /**
     * Responds to airplane rotation changes.
     * @param angle The airplane rotation angle, in degrees.
     */
    onAirplaneRotationChanged(angle) {
        this.currentMapParameters.rotation = -angle * Avionics.Utils.DEG2RAD;
        this.scheduleProjectionUpdate();
    }
    /**
     * Responds to when the airplane is on the ground changes.
     */
    onAirplaneOnGroundChanged() {
        this.updateOrientation();
    }
    /**
     * Responds to map orientation changes.
     * @param orientation The map orientation.
     */
    onOrientationChanged(orientation) {
        if (orientation === MapOrientation.NorthUp) {
            this.currentMapParameters.rotation = 0;
        }
        this.updateAirplaneRotationListeners();
        this.updateRangeFromIndex();
        this.updateTargetOffset();
        this.scheduleProjectionUpdate();
    }
    /**
     * Responds to map pointer activation changes.
     * @param isActive Whether the map pointer is active.
     */
    onPointerActiveChanged(isActive) {
        this.updateAirplanePositionListeners();
        this.updateAirplaneRotationListeners();
        this.updatePointerListeners();
        this.scheduleProjectionUpdate();
        if (isActive) {
            this.onPointerActivated();
        }
        else {
            this.onPointerDeactivated();
        }
    }
    /**
     * Responds to map pointer activation.
     */
    onPointerActivated() {
        // noop
    }
    /**
     * Responds to map pointer deactivation.
     */
    onPointerDeactivated() {
        // noop
    }
    /**
     * Responds to map pointer position changes.
     */
    onPointerPositionChanged() {
        this.schedulePointerScrollUpdate();
    }
    /**
     * Responds to map pointer desired target changes.
     * @param target The desired target.
     */
    onPointerTargetChanged(target) {
        this.currentMapParameters.target.set(target);
        this.scheduleProjectionUpdate();
    }
    /**
     * Responds to map pointer bounds changes.
     */
    onPointerBoundsChanged() {
        const position = this.pointerModule.position.get();
        const bounds = this.pointerBounds.get();
        const clampedPositionX = Utils.Clamp(position[0], bounds[0], bounds[2]);
        const clampedPositionY = Utils.Clamp(position[1], bounds[1], bounds[3]);
        this.pointerModule.position.set(clampedPositionX, clampedPositionY);
    }
    /**
     * Updates listeners for airplane position and on ground status.
     */
    updateAirplanePositionListeners() {
        this.setAirplanePositionListenersActive(!this.pointerModule.isActive.get());
    }
    /**
     * Activates or deactivates airplane position listeners.
     * @param value Whether to activate airplane position listeners.
     */
    setAirplanePositionListenersActive(value) {
        if (value === this.areAirplanePositionListenersActive) {
            return;
        }
        if (value) {
            this.airplanePropsModule.position.sub(this.airplanePositionChangedHandler, true);
            this.airplanePropsModule.isOnGround.sub(this.airplaneOnGroundChangedHandler, true);
        }
        else {
            this.airplanePropsModule.position.unsub(this.airplanePositionChangedHandler);
            this.airplanePropsModule.isOnGround.unsub(this.airplaneOnGroundChangedHandler);
        }
        this.areAirplanePositionListenersActive = value;
    }
    /**
     * Updates listeners for airplane heading and ground track.
     */
    updateAirplaneRotationListeners() {
        var _a;
        if (this.currentAirplaneRotationSub) {
            this.currentAirplaneRotationSub.unsub(this.airplaneRotationChangedHandler);
            this.currentAirplaneRotationSub = null;
        }
        if (!this.pointerModule.isActive.get()) {
            const orientation = this.orientationModule.orientation.get();
            switch (orientation) {
                case MapOrientation.TrackUp:
                    this.currentAirplaneRotationSub = this.airplanePropsModule.trackTrue;
                    break;
                case MapOrientation.HeadingUp:
                    this.currentAirplaneRotationSub = this.airplanePropsModule.hdgTrue;
                    break;
            }
            (_a = this.currentAirplaneRotationSub) === null || _a === void 0 ? void 0 : _a.sub(this.airplaneRotationChangedHandler, true);
        }
    }
    /**
     * Updates the pointer position listener.
     */
    updatePointerListeners() {
        if (this.pointerModule.isActive.get()) {
            this.pointerBounds.sub(this.pointerBoundsChangedHandler);
            this.pointerModule.position.sub(this.pointerPositionChangedHandler);
            this.pointerModule.target.sub(this.pointerTargetChangedHandler, true);
        }
        else {
            this.pointerBounds.unsub(this.pointerBoundsChangedHandler);
            this.pointerModule.position.unsub(this.pointerPositionChangedHandler);
            this.pointerModule.target.unsub(this.pointerTargetChangedHandler);
        }
    }
    /**
     * Schedules an update to the map projection.
     */
    scheduleProjectionUpdate() {
        this.needUpdateProjection = true;
    }
    /**
     * Schedules an update to scrolling due to the pointer.
     */
    schedulePointerScrollUpdate() {
        this.needUpdatePointerScroll = true;
    }
    /**
     * Updates this controller.
     */
    update() {
        this.updateModules();
        this.updatePointerScroll();
        this.updateMapProjection();
    }
    /**
     * Updates map model modules.
     */
    updateModules() {
        this.mapModel.getModule('range').setNominalRangeIndex(this.currentMapRangeIndex);
    }
    /**
     * Updates the map projection with the latest range, target, and rotation values.
     */
    updateMapProjection() {
        if (!this.needUpdateProjection) {
            return;
        }
        this.mapProjection.set(this.currentMapParameters);
        this.needUpdateProjection = false;
    }
    /**
     * Updates scrolling due to the pointer.
     */
    updatePointerScroll() {
        if (!this.needUpdatePointerScroll) {
            return;
        }
        const position = this.pointerModule.position.get();
        const bounds = this.pointerBounds.get();
        const clampedPositionX = Utils.Clamp(position[0], bounds[0], bounds[2]);
        const clampedPositionY = Utils.Clamp(position[1], bounds[1], bounds[3]);
        const scrollDeltaX = position[0] - clampedPositionX;
        const scrollDeltaY = position[1] - clampedPositionY;
        if (scrollDeltaX === 0 && scrollDeltaY === 0) {
            return;
        }
        this.pointerModule.position.set(clampedPositionX, clampedPositionY);
        const newTargetProjected = Vec2Math.add(this.mapProjection.getTargetProjected(), Vec2Math.set(scrollDeltaX, scrollDeltaY, NavMapRangeTargetRotationController.vec2Cache[0]), NavMapRangeTargetRotationController.vec2Cache[0]);
        this.mapProjection.invert(newTargetProjected, this.currentMapParameters.target);
        this.scheduleProjectionUpdate();
        this.needUpdatePointerScroll = false;
    }
}
NavMapRangeTargetRotationController.DEFAULT_MAP_RANGES = MapRangeSettings.DEFAULT_RANGES;
NavMapRangeTargetRotationController.DEFAULT_MAP_RANGE_INDEX = 11;
NavMapRangeTargetRotationController.vec2Cache = [new Float64Array(2)];

/**
 * Map pointer information box size.
 */
var MapPointerInfoLayerSize;
(function (MapPointerInfoLayerSize) {
    MapPointerInfoLayerSize[MapPointerInfoLayerSize["Full"] = 0] = "Full";
    MapPointerInfoLayerSize[MapPointerInfoLayerSize["Medium"] = 1] = "Medium";
    MapPointerInfoLayerSize[MapPointerInfoLayerSize["Small"] = 2] = "Small";
})(MapPointerInfoLayerSize || (MapPointerInfoLayerSize = {}));
/**
 * A map layer which displays a pointer information box.
 */
class MapPointerInfoLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.rootRef = FSComponent.createRef();
        this.ownAirplanePropsModule = this.props.model.getModule('ownAirplaneProps');
        this.pointerModule = this.props.model.getModule('pointer');
        this.distanceSub = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(NaN));
        this.distanceUnitSub = Subject.create(UnitType.NMILE);
        this.bearingSub = ComputedSubject.create(NaN, bearing => {
            const rounded = Math.round(bearing);
            return `${isNaN(bearing) ? '___' : (rounded === 0 ? 360 : rounded).toString().padStart(3, '0')}°`;
        });
        this.latLonSub = GeoPointSubject.createFromGeoPoint(new GeoPoint(0, 0));
        this.scheduleUpdateHandler = () => { this.needUpdate = true; };
        this.needUpdate = false;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        this.rootRef.getOrDefault() && this.updateFromVisibility();
    }
    /**
     * Updates this layer according to its current visibility.
     */
    updateFromVisibility() {
        if (this.isVisible()) {
            this.rootRef.instance.style.display = '';
            this.ownAirplanePropsModule.position.sub(this.scheduleUpdateHandler);
            this.pointerModule.position.sub(this.scheduleUpdateHandler, true);
        }
        else {
            this.rootRef.instance.style.display = 'none';
            this.ownAirplanePropsModule.position.unsub(this.scheduleUpdateHandler);
            this.pointerModule.position.unsub(this.scheduleUpdateHandler);
        }
    }
    /** @inheritdoc */
    onAfterRender() {
        this.updateFromVisibility();
        this.pointerModule.isActive.sub(isActive => this.setVisible(isActive), true);
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.needUpdate || (this.needUpdate = this.isVisible() && BitFlags.isAny(changeFlags, MapProjectionChangeType.Center | MapProjectionChangeType.Rotation | MapProjectionChangeType.ProjectedResolution));
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        if (!this.needUpdate) {
            return;
        }
        this.updateInfo();
        this.needUpdate = false;
    }
    /**
     * Updates this layer's displayed information.
     */
    updateInfo() {
        const latLon = this.props.mapProjection.invert(this.pointerModule.position.get(), MapPointerInfoLayer.geoPointCache[0]);
        this.latLonSub.set(latLon);
        const airplanePos = this.ownAirplanePropsModule.position.get();
        this.distanceSub.set(airplanePos.distance(latLon), UnitType.GA_RADIAN);
        // TODO: Add support for metric
        if (this.distanceSub.get().compare(0.1) < 0) {
            this.distanceUnitSub.set(UnitType.FOOT);
        }
        else {
            this.distanceUnitSub.set(UnitType.NMILE);
        }
        this.bearingSub.set(MagVar.trueToMagnetic(airplanePos.bearingTo(latLon), airplanePos));
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { ref: this.rootRef, class: 'map-pointerinfolayer-box' },
            FSComponent.buildComponent("div", { class: 'map-pointerinfolayer-box-column map-pointerinfolayer-box-dis' },
                FSComponent.buildComponent("span", { class: 'map-pointerinfolayer-box-title', style: this.props.size === MapPointerInfoLayerSize.Small ? 'display: none;' : '' }, "DIS"),
                FSComponent.buildComponent(NumberUnitDisplay, { value: this.distanceSub, displayUnit: this.distanceUnitSub, formatter: NumberFormatter.create({ precision: 0.1, maxDigits: 3, forceDecimalZeroes: false, nanString: '__._' }), class: 'map-pointerinfolayer-box-title-value' })),
            FSComponent.buildComponent("div", { class: 'map-pointerinfolayer-box-column map-pointerinfolayer-box-brg', style: this.props.size === MapPointerInfoLayerSize.Small ? 'display: none;' : '' },
                FSComponent.buildComponent("span", { class: 'map-pointerinfolayer-box-title' }, "BRG"),
                FSComponent.buildComponent("span", { class: 'map-pointerinfolayer-box-title-value' }, this.bearingSub)),
            this.props.size === MapPointerInfoLayerSize.Full
                ? FSComponent.buildComponent(LatLonDisplay, { location: this.latLonSub, class: 'map-pointerinfolayer-box-column map-pointerinfolayer-box-title-value' })
                : null));
    }
}
MapPointerInfoLayer.geoPointCache = [new GeoPoint(0, 0)];

/**
 * The MFD navigation map.
 */
class MFDNavMapComponent extends NavMapComponent {
    constructor() {
        super(...arguments);
        this.miniCompassLayerRef = FSComponent.createRef();
        this.rangeRingLayerRef = FSComponent.createRef();
        this.rangeCompassLayerRef = FSComponent.createRef();
        this.pointerInfoLayerRef = FSComponent.createRef();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    createRangeTargetRotationController() {
        return new MFDNavMapRangeTargetRotationController(this.props.model, this.mapProjection, this.deadZone, NavMapRangeTargetRotationController.DEFAULT_MAP_RANGES, this.props.settingManager, this.rangeSettingManager, 'mfdMapRangeIndex', this.pointerBoundsSub);
    }
    /** @inheritdoc */
    initLayers() {
        super.initLayers();
        this.attachLayer(this.miniCompassLayerRef.instance);
        this.attachLayer(this.rangeRingLayerRef.instance);
        this.attachLayer(this.rangeCompassLayerRef.instance);
        this.attachLayer(this.pointerInfoLayerRef.instance);
    }
    /** @inheritdoc */
    renderRangeDisplayLayer() {
        return null;
    }
    /** @inheritdoc */
    renderMiniCompassLayer() {
        return (FSComponent.buildComponent(MapMiniCompassLayer, { ref: this.miniCompassLayerRef, class: 'minicompass-layer', model: this.props.model, mapProjection: this.mapProjection, imgSrc: 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/map_mini_compass.png' }));
    }
    /** @inheritdoc */
    renderRangeRingLayer() {
        return (FSComponent.buildComponent(MapRangeRingLayer, { ref: this.rangeRingLayerRef, model: this.props.model, mapProjection: this.mapProjection, showLabel: true, strokeWidth: 2, strokeStyle: 'white' }));
    }
    /** @inheritdoc */
    renderRangeCompassLayer() {
        return (FSComponent.buildComponent(MapRangeCompassLayer, { ref: this.rangeCompassLayerRef, model: this.props.model, mapProjection: this.mapProjection, bus: this.props.bus, showLabel: true, showHeadingBug: this.props.model.getModule('pointer').isActive.map(isActive => !isActive), arcStrokeWidth: 2, arcEndTickLength: 10, referenceArrowWidth: 15, referenceArrowHeight: 20, referenceTickWidth: 2, referenceTickHeight: 5, bearingTickMajorLength: 10, bearingTickMinorLength: 5, bearingLabelFont: 'Roboto-Bold', bearingLabelFontSize: 20, bearingLabelOutlineWidth: 6, bearingLabelRadialOffset: 0, headingBugWidth: 20, headingBugHeight: 10 }));
    }
    /** @inheritdoc */
    renderPointerInfoLayer() {
        return (FSComponent.buildComponent(MapPointerInfoLayer, { ref: this.pointerInfoLayerRef, model: this.props.model, mapProjection: this.mapProjection, size: MapPointerInfoLayerSize.Full }));
    }
    /** @inheritdoc */
    renderTerrainScaleIndicator() {
        const terrainModule = this.props.model.getModule('terrain');
        return (FSComponent.buildComponent(MapTerrainScaleIndicator, { show: terrainModule.showScale, terrainMode: terrainModule.terrainMode }));
    }
}
/**
 * A controller for handling map range, target, and rotation changes for the MFD navigation map.
 */
class MFDNavMapRangeTargetRotationController extends NavMapRangeTargetRotationController {
    // eslint-disable-next-line jsdoc/require-jsdoc
    convertToTrueRange(nominalRange) {
        const projectedHeight = this.mapProjection.getProjectedSize()[1];
        const correctedHeight = projectedHeight - this.deadZone[1] - this.deadZone[3];
        const orientation = this.mapModel.getModule('orientation').orientation.get();
        const factor = orientation === MapOrientation.NorthUp ? 4 : 3;
        return nominalRange.asUnit(UnitType.GA_RADIAN) * projectedHeight / correctedHeight * factor;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getDesiredTargetOffset() {
        const trueCenterOffsetX = (this.deadZone[0] - this.deadZone[2]) / 2;
        const trueCenterOffsetY = (this.deadZone[1] - this.deadZone[3]) / 2;
        const projectedSize = this.mapProjection.getProjectedSize();
        const relativeOffset = this.mapModel.getModule('orientation').orientation.get() === MapOrientation.NorthUp
            ? MFDNavMapRangeTargetRotationController.NORTH_UP_TARGET_OFFSET_REL
            : MFDNavMapRangeTargetRotationController.HDG_TRK_UP_TARGET_OFFSET_REL;
        return Vec2Math.set(relativeOffset[0] * projectedSize[0] + trueCenterOffsetX, relativeOffset[1] * projectedSize[1] + trueCenterOffsetY, MFDNavMapRangeTargetRotationController.tempVec2_1);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    updateModules() {
        super.updateModules();
        const isNorthUp = this.mapModel.getModule('orientation').orientation.get() === MapOrientation.NorthUp;
        this.mapModel.getModule('rangeRing').show.set(isNorthUp);
        this.mapModel.getModule('rangeCompass').show.set(!isNorthUp);
    }
}
MFDNavMapRangeTargetRotationController.NORTH_UP_TARGET_OFFSET_REL = new Float64Array(2);
MFDNavMapRangeTargetRotationController.HDG_TRK_UP_TARGET_OFFSET_REL = new Float64Array([0, 1 / 6]);
MFDNavMapRangeTargetRotationController.tempVec2_1 = new Float64Array(2);

/**
 * Controls the pointer of a map.
 */
class MapPointerController {
    /**
     * Constructor.
     * @param mapModel The model of the map associated with this controller.
     * @param mapProjection The map projection associated with this controller.
     */
    constructor(mapModel, mapProjection) {
        this.mapModel = mapModel;
        this.mapProjection = mapProjection;
        this.pointerModule = this.mapModel.getModule('pointer');
    }
    /**
     * Activates or deactivates the map pointer.
     * @param isActive Whether to activate the map pointer.
     */
    setPointerActive(isActive) {
        if (isActive === this.pointerModule.isActive.get()) {
            return;
        }
        if (isActive) {
            this.pointerModule.target.set(this.mapProjection.getTarget());
            this.pointerModule.position.set(this.mapProjection.getTargetProjected());
        }
        this.pointerModule.isActive.set(isActive);
    }
    /**
     * Toggles activation of the map pointer.
     * @returns Whether the map pointer is active after the toggle operation.
     */
    togglePointerActive() {
        this.setPointerActive(!this.pointerModule.isActive.get());
        return this.pointerModule.isActive.get();
    }
    /**
     * Moves the map pointer.
     * @param dx The horizontal displacement, in pixels.
     * @param dy The vertical dispacement, in pixels.
     */
    movePointer(dx, dy) {
        const currentPos = this.pointerModule.position.get();
        this.pointerModule.position.set(currentPos[0] + dx, currentPos[1] + dy);
    }
    /**
     * Sets the map target to the current position of the pointer. The pointer will also be moved to the
     */
    targetPointer() {
        const target = this.mapProjection.invert(this.pointerModule.position.get(), MapPointerController.geoPointCache[0]);
        this.pointerModule.target.set(target);
        this.pointerModule.position.set(this.mapProjection.getTargetProjected());
    }
}
MapPointerController.geoPointCache = [new GeoPoint(0, 0)];

/**
 * A page which displays the navigation map.
 */
class MFDNavMapPage extends MFDUiPage {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.mapRef = FSComponent.createRef();
        this.mapModel = NavMapModel.createModel(this.props.tas);
        this.pointerModule = this.mapModel.getModule('pointer');
        this.mapSettingManager = MapUserSettings.getMfdManager(this.props.bus);
        this.mapRangeSettingManager = MapRangeSettings.getManager(this.props.bus);
        this.mapRangeSetting = this.mapRangeSettingManager.getSetting('mfdMapRangeIndex');
        this.pageMenuItems = [
            {
                id: 'map-settings',
                renderContent: () => FSComponent.buildComponent("span", null, "Map Settings"),
                action: () => {
                    this.props.viewService.open('MapSettings', false);
                }
            },
            {
                id: 'declutter',
                renderContent: () => FSComponent.buildComponent("span", null,
                    "Declutter (Current Detail ",
                    MFDNavMapPage.DECLUTTER_TEXT[this.mapSettingManager.getSetting('mapDeclutter').value],
                    ")"),
                action: () => {
                    const setting = this.mapSettingManager.getSetting('mapDeclutter');
                    switch (setting.value) {
                        case MapDeclutterSettingMode.All:
                            setting.value = MapDeclutterSettingMode.Level3;
                            break;
                        case MapDeclutterSettingMode.Level3:
                            setting.value = MapDeclutterSettingMode.Level2;
                            break;
                        case MapDeclutterSettingMode.Level2:
                            setting.value = MapDeclutterSettingMode.Level1;
                            break;
                        case MapDeclutterSettingMode.Level1:
                            setting.value = MapDeclutterSettingMode.All;
                            break;
                    }
                }
            },
            {
                id: 'measure-brg-dist',
                renderContent: () => FSComponent.buildComponent("span", null, "Measure Bearing/Distance"),
                isEnabled: false
            },
            {
                id: 'charts',
                renderContent: () => FSComponent.buildComponent("span", null, "Charts"),
                isEnabled: false
            },
            {
                id: 'hide-vsd',
                renderContent: () => FSComponent.buildComponent("span", null, "Hide VSD"),
                isEnabled: false
            },
        ];
        this._title.set('Map – Navigation Map');
    }
    /** @inheritdoc */
    onAfterRender() {
        super.onAfterRender();
        this.mapPointerController = new MapPointerController(this.mapModel, this.mapRef.instance.mapProjection);
        this.mapRef.instance.sleep();
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        var _a;
        switch (evt) {
            case FmsHEvent.RANGE_DEC:
                this.changeMapRangeIndex(-1);
                return true;
            case FmsHEvent.RANGE_INC:
                this.changeMapRangeIndex(1);
                return true;
            case FmsHEvent.JOYSTICK_PUSH:
                (_a = this.mapPointerController) === null || _a === void 0 ? void 0 : _a.togglePointerActive();
                return true;
        }
        return this.handleMapPointerMoveEvent(evt) || super.onInteractionEvent(evt);
    }
    /**
     * Changes the MFD map range index setting.
     * @param delta The change in index to apply.
     */
    changeMapRangeIndex(delta) {
        var _a;
        const newIndex = Utils.Clamp(this.mapRangeSetting.value + delta, 0, MapRangeSettings.DEFAULT_RANGES.length - 1);
        if (this.mapRangeSetting.value !== newIndex) {
            (_a = this.mapPointerController) === null || _a === void 0 ? void 0 : _a.targetPointer();
            this.mapRangeSetting.value = newIndex;
        }
    }
    /**
     * Handles events that move the map pointer.
     * @param evt The event.
     * @returns Whether the event was handled.
     */
    handleMapPointerMoveEvent(evt) {
        var _a, _b, _c, _d;
        if (!this.pointerModule.isActive.get()) {
            return false;
        }
        switch (evt) {
            case FmsHEvent.JOYSTICK_LEFT:
                (_a = this.mapPointerController) === null || _a === void 0 ? void 0 : _a.movePointer(-MFDNavMapPage.POINTER_MOVE_INCREMENT, 0);
                return true;
            case FmsHEvent.JOYSTICK_UP:
                (_b = this.mapPointerController) === null || _b === void 0 ? void 0 : _b.movePointer(0, -MFDNavMapPage.POINTER_MOVE_INCREMENT);
                return true;
            case FmsHEvent.JOYSTICK_RIGHT:
                (_c = this.mapPointerController) === null || _c === void 0 ? void 0 : _c.movePointer(MFDNavMapPage.POINTER_MOVE_INCREMENT, 0);
                return true;
            case FmsHEvent.JOYSTICK_DOWN:
                (_d = this.mapPointerController) === null || _d === void 0 ? void 0 : _d.movePointer(0, MFDNavMapPage.POINTER_MOVE_INCREMENT);
                return true;
        }
        return false;
    }
    /** @inheritdoc */
    onViewOpened() {
        this.props.menuSystem.clear();
        this.props.menuSystem.pushMenu('navmap-root');
        this.mapRef.instance.wake();
    }
    /** @inheritdoc */
    onViewClosed() {
        var _a;
        super.onViewClosed();
        (_a = this.mapPointerController) === null || _a === void 0 ? void 0 : _a.setPointerActive(false);
        this.mapRef.instance.sleep();
    }
    /** @inheritdoc */
    onMenuPressed() {
        this.props.menuSystem.pushMenu('empty');
        const pageMenu = this.props.viewService.open('PageMenuDialog');
        pageMenu.setMenuItems(this.pageMenuItems);
        pageMenu.onClose.on(() => { this.props.menuSystem.back(); });
        return true;
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { ref: this.viewContainerRef, class: 'mfd-page' },
            FSComponent.buildComponent(MFDNavMapComponent, { ref: this.mapRef, model: this.mapModel, bus: this.props.bus, updateFreq: MFDNavMapPage.UPDATE_FREQ, projectedWidth: 876, projectedHeight: 734, deadZone: new Float64Array([0, 56, 0, 0]), flightPlanner: this.props.flightPlanner, airspaceSearcher: this.props.airspaceSearcher, id: 'mfd_navmap', bingId: 'mfd_page_map', settingManager: MapUserSettings.getMfdManager(this.props.bus), ownAirplaneLayerProps: {
                    imageFilePath: 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/own_airplane_icon.svg',
                    iconSize: 40,
                    iconAnchor: new Float64Array([0.5, 0])
                }, trafficIntruderLayerProps: {
                    fontSize: 16,
                    iconSize: 30
                }, drawEntireFlightPlan: Subject.create(false), class: 'mfd-navmap' })));
    }
}
MFDNavMapPage.DECLUTTER_TEXT = {
    [MapDeclutterSettingMode.All]: 'All',
    [MapDeclutterSettingMode.Level3]: '3',
    [MapDeclutterSettingMode.Level2]: '2',
    [MapDeclutterSettingMode.Level1]: '1',
};
MFDNavMapPage.UPDATE_FREQ = 30; // Hz
MFDNavMapPage.POINTER_MOVE_INCREMENT = 5; // pixels

/** The List component. */
class List extends UiControlGroup {
    constructor() {
        super(...arguments);
        this._listContainer = FSComponent.createRef();
        this._itemInstanceRefs = [];
        this.previousSelectedIndex = -1;
        this.previousSelectedItem = undefined;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.registerListItem = (ctrl) => {
            // noop here, we will refresh all registrations on our own
        };
    }
    /** @inheritdoc */
    onAfterRender() {
        this.renderList();
        if (this.props.scrollContainer) {
            this.scrollController.registerScrollContainer(this.props.scrollContainer.instance);
        }
        this.props.data.sub(this.onDataChanged.bind(this));
        this.scrollController.onScroll = this.onScroll.bind(this);
    }
    /**
     * A callback fired when the array subject data changes.
     * @param index The index of the change.
     * @param type The type of change.
     * @param item The item that was changed.
     */
    onDataChanged(index, type, item) {
        switch (type) {
            case SubscribableArrayEventType.Added:
                {
                    const el = this._listContainer.instance.children.item(index);
                    if (Array.isArray(item)) {
                        for (let i = 0; i < item.length; i++) {
                            this.addDomNode(item[i], index + i, el);
                        }
                    }
                    else {
                        this.addDomNode(item, index, el);
                    }
                    this.refreshRegistrations();
                }
                break;
            case SubscribableArrayEventType.Removed:
                {
                    if (Array.isArray(item)) {
                        for (let i = 0; i < item.length; i++) {
                            this.removeDomNode(index);
                        }
                    }
                    else {
                        this.removeDomNode(index);
                    }
                    this.refreshRegistrations();
                }
                break;
            case SubscribableArrayEventType.Cleared:
                this._itemInstanceRefs.length = 0;
                this._listContainer.instance.innerHTML = '';
                this.scrollController.resetCtrls();
                if (this.props.onItemSelected) {
                    this.props.onItemSelected(null, null, -1);
                }
                break;
        }
    }
    /**
     * Removes a dom node from the collection at the specified index.
     * @param index The index to remove.
     */
    removeDomNode(index) {
        const child = this._listContainer.instance.childNodes.item(index);
        this._listContainer.instance.removeChild(child);
        const removed = this._itemInstanceRefs.splice(index, 1)[0];
        removed.destroy();
    }
    /**
     * Adds a list rendered dom node to the collection.
     * @param item Item to render and add.
     * @param index The index to add at.
     * @param el The element to add to.
     */
    addDomNode(item, index, el) {
        const node = this.renderListItem(item, index);
        if (el !== null) {
            node && el && FSComponent.renderBefore(node, el);
        }
        else {
            el = this._listContainer.instance;
            node && el && FSComponent.render(node, el);
        }
        if (node !== undefined && node.instance !== null) {
            this._itemInstanceRefs.splice(index, 0, node.instance);
        }
    }
    /**
     * Refreshs control registrations of all list elements.
     */
    refreshRegistrations() {
        var _a;
        this.scrollController.resetCtrls();
        for (let i = 0; i < this._itemInstanceRefs.length; i++) {
            const instance = this._itemInstanceRefs[i];
            if (instance instanceof UiControlGroup) {
                this.register(instance);
            }
            else if (instance instanceof UiControl) {
                instance.props.onRegister = this.register;
                instance.onRegister();
                // this.register(instance);
            }
        }
        if (this.getIsFocused()) {
            if (this.previousSelectedIndex < 0
                ? this.scrollController.gotoFirst()
                : this.previousSelectedIndex >= this.props.data.length
                    ? this.scrollController.gotoLast()
                    : this.scrollController.scrollTo('prev', this.previousSelectedIndex + 1)) {
                return;
            }
            else {
                this.previousSelectedIndex = -1;
            }
        }
        if (this.previousSelectedIndex < 0 || this.previousSelectedIndex >= this.props.data.length) {
            this.previousSelectedIndex = -1;
        }
        const item = (_a = this.props.data.tryGet(this.previousSelectedIndex)) !== null && _a !== void 0 ? _a : null;
        if (item !== this.previousSelectedItem) {
            this.props.onItemSelected && this.props.onItemSelected(item, this.getListItemInstance(this.previousSelectedIndex), this.previousSelectedIndex);
        }
        this.previousSelectedItem = item;
    }
    /**
     * Scrolls to an item.
     * @param index is the index of the list item to scroll to.
     */
    scrollToIndex(index) {
        this.scrollController.gotoIndex(index);
    }
    /**
     * Ensures an indexed list item is in view.
     * @param index The index of the list item.
     */
    ensureIndexInView(index) {
        const el = this._listContainer.instance.children[index];
        if (el && this.props.scrollContainer) {
            ScrollUtils.ensureInView(el, this.props.scrollContainer.instance);
        }
    }
    /**
     * Gets the data object related to the selected DOM element.
     * @returns The selected item, if found.
     */
    getSelectedItem() {
        const selectedIndex = this.getSelectedIndex();
        if (selectedIndex > -1) {
            return this.props.data.get(selectedIndex);
        }
        return null;
    }
    /**
     * Get the selected HTMLElement.
     * @returns The selected element, if found.
     */
    getSelectedElement() {
        var _a;
        return (_a = this._listContainer.instance.children[this.getSelectedIndex()]) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * Gets the index of the currently selected element.
     * @returns Selected element index. Returns -1 if nothing found.
     */
    getSelectedIndex() {
        const focusedControl = this.scrollController.getFocusedUiControl();
        return focusedControl ? this._itemInstanceRefs.indexOf(focusedControl) : -1;
    }
    /**
     * Gets the instance of the node at the specified index.
     * @param index The index to get the instance for.
     * @returns The node instance of specified type.
     */
    getListItemInstance(index) {
        var _a;
        return (_a = this._itemInstanceRefs[index]) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * Gets index of a item in the list by its node instance.
     * @param nodeInstance The node instance to look for.
     * @returns list item index
     */
    getListItemIndex(nodeInstance) {
        return this._itemInstanceRefs.indexOf(nodeInstance);
    }
    /** @inheritdoc */
    onBlurred() {
        if (this.previousSelectedItem && this.props.onItemSelected) {
            this.props.onItemSelected(null, null, -1);
        }
        this.previousSelectedItem = null;
        this.previousSelectedIndex = -1;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onScroll(ctrl) {
        var _a;
        const el = this.getSelectedElement();
        if (el !== null && this.props.scrollContainer) {
            ScrollUtils.ensureInView(el, this.props.scrollContainer.instance);
        }
        const index = this.getSelectedIndex();
        const item = (_a = this.props.data.tryGet(index)) !== null && _a !== void 0 ? _a : null;
        if (this.props.onItemSelected) {
            item !== this.previousSelectedItem && this.props.onItemSelected(item, this.getListItemInstance(index), index);
        }
        this.previousSelectedItem = item;
        this.previousSelectedIndex = index;
    }
    /**
     * Renders a list item
     * @param dataItem The data item to render.
     * @param index The index to render at.
     * @returns list item vnode
     * @throws error when the resulting vnode is not a scrollable control
     */
    renderListItem(dataItem, index) {
        const renderedNode = this.props.renderItem(dataItem, this.registerListItem, index);
        if ((renderedNode.instance instanceof UiControl || renderedNode.instance instanceof UiControlGroup)) {
            return renderedNode;
        }
        else {
            throw new Error('A ListItem must be of type UiControl or UiControlGroup!');
        }
    }
    /** Renders the list of data items. */
    renderList() {
        // clear all items
        this._listContainer.instance.textContent = '';
        // render items
        const dataLen = this.props.data.length;
        for (let i = 0; i < dataLen; i++) {
            const vnode = this.renderListItem(this.props.data.get(i), i);
            if (vnode !== undefined) {
                FSComponent.render(vnode, this._listContainer.instance);
                this._itemInstanceRefs.push(vnode.instance);
            }
        }
        this.refreshRegistrations();
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', ref: this._listContainer }));
    }
}

/** FPL Active Leg States */
var ActiveLegStates;
(function (ActiveLegStates) {
    ActiveLegStates[ActiveLegStates["RANDOM_DIRECT"] = 0] = "RANDOM_DIRECT";
    ActiveLegStates[ActiveLegStates["EXISTING_DIRECT"] = 1] = "EXISTING_DIRECT";
    ActiveLegStates[ActiveLegStates["NORMAL"] = 2] = "NORMAL";
    ActiveLegStates[ActiveLegStates["NONE"] = 3] = "NONE";
})(ActiveLegStates || (ActiveLegStates = {}));
/**
 * The FplActiveLegArrow component.
 */
class FplActiveLegArrow extends DisplayComponent {
    constructor() {
        super(...arguments);
        /** The arrow refs for direct to existing and active leg */
        this.dtoArrowEl = FSComponent.createRef();
        this.fromLegArrow = FSComponent.createRef();
        this.legArrowRectangle = FSComponent.createRef();
        this.toLegArrow = FSComponent.createRef();
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        this.dtoArrowEl.instance.style.display = 'none';
        this.fromLegArrow.instance.style.display = 'none';
        this.toLegArrow.instance.style.display = 'none';
    }
    /**
     * Datermines the location and visibility of the active leg/direct to arrows on the FPL page.
     * @param state Is the ActiveLegState.
     * @param activeLeg Is the ActiveLegDefinition.
     * @param plan Is the flight plan.
     */
    updateArrows(state, activeLeg, plan) {
        try {
            switch (state) {
                case ActiveLegStates.NONE:
                case ActiveLegStates.RANDOM_DIRECT:
                    this.setDirectArrow(false);
                    this.setActiveLegArrow(false);
                    break;
                case ActiveLegStates.NORMAL:
                    this.setDirectArrow(false);
                    this.setActiveLegArrow(true, plan, activeLeg.segmentIndex, activeLeg.legIndex);
                    break;
                case ActiveLegStates.EXISTING_DIRECT:
                    this.setDirectArrow(true, activeLeg.segmentIndex, activeLeg.legIndex);
                    this.setActiveLegArrow(false);
                    break;
            }
        }
        catch (error) {
            console.warn(`updateArrows: ${error}`);
        }
    }
    /**
     * Sets the location and visibility of the direct to arrow in the flight plan display.
     * @param display whether to show or hide the arrow.
     * @param segmentIndex the segment index of the direct fix.
     * @param legIndex the leg index of the direct fix.
     */
    setDirectArrow(display, segmentIndex, legIndex) {
        this.dtoArrowEl.instance.style.display = display ? '' : 'none';
        if (display && segmentIndex !== undefined && legIndex !== undefined) {
            const top = this.props.getLegDomLocation(segmentIndex, legIndex);
            this.dtoArrowEl.instance.style.transform = `translate3d(0,${top}px,0)`;
        }
    }
    /**
     * Sets the location and visibility of the active leg arrow in the flight plan display.
     * @param display whether to show or hide the arrow.
     * @param plan the flight plan to process.
     * @param toSegmentIndex the segment index of the from leg.
     * @param tolegIndex the leg index of the from leg.
     */
    setActiveLegArrow(display, plan, toSegmentIndex = -1, tolegIndex = -1) {
        if (plan && display && ((toSegmentIndex > 0 && tolegIndex >= 0) || (toSegmentIndex == 0 && tolegIndex > 0))) {
            let fromSegmentIndex = -1;
            let fromLegIndex = -1;
            if (toSegmentIndex > 0 && tolegIndex == 0 && plan.getSegment(toSegmentIndex - 1).legs.length < 1 && toSegmentIndex < 2) {
                this.fromLegArrow.instance.style.display = 'none';
                this.toLegArrow.instance.style.display = 'none';
                return;
            }
            else if (tolegIndex == 0 && plan.getSegment(toSegmentIndex - 1).legs.length < 1) {
                fromSegmentIndex = toSegmentIndex - 2;
                fromLegIndex = plan.getSegment(fromSegmentIndex).legs.length - 1;
            }
            else if (tolegIndex == 0) {
                fromSegmentIndex = toSegmentIndex - 1;
                fromLegIndex = plan.getSegment(fromSegmentIndex).legs.length - 1;
            }
            else if (plan.directToData.segmentIndex > -1
                && plan.directToData.segmentLegIndex > -1
                && toSegmentIndex === plan.directToData.segmentIndex
                && tolegIndex === plan.directToData.segmentLegIndex + 4) {
                fromSegmentIndex = toSegmentIndex;
                fromLegIndex = tolegIndex - 4;
            }
            else {
                fromSegmentIndex = toSegmentIndex;
                fromLegIndex = tolegIndex - 1;
            }
            const top = this.props.getLegDomLocation(fromSegmentIndex, fromLegIndex);
            const bottom = this.props.getLegDomLocation(toSegmentIndex, tolegIndex);
            const height = bottom - top - 8;
            this.fromLegArrow.instance.style.transform = `translate3d(0,${top}px,0)`;
            this.legArrowRectangle.instance.setAttribute('height', `${height}`);
            this.toLegArrow.instance.style.transform = `translate3d(0,${bottom}px,0)`;
            this.fromLegArrow.instance.style.display = '';
            this.toLegArrow.instance.style.display = '';
        }
        else {
            this.fromLegArrow.instance.style.display = 'none';
            this.toLegArrow.instance.style.display = 'none';
        }
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", null,
            FSComponent.buildComponent("svg", { class: 'dto-arrow', ref: this.dtoArrowEl },
                FSComponent.buildComponent("path", { d: 'M 20 7 l -7 -7 l 0 5 l -8 0 l 0 4 l 8 0 l 0 5 l 7 -7 z', fill: "magenta" })),
            FSComponent.buildComponent("svg", { class: 'dynamic-from-arrow', ref: this.fromLegArrow },
                FSComponent.buildComponent("path", { d: 'M 20 -2 l -15 0 c -3 0 -5 2 -5 6 l 6 0 c 0 -1 1 -2 3 -2 l 11 0 l 0 -4', fill: "magenta" }),
                FSComponent.buildComponent("rect", { ref: this.legArrowRectangle, x: "0", y: "4", width: "6", height: "18", fill: "magenta" })),
            FSComponent.buildComponent("svg", { class: 'dynamic-to-arrow', ref: this.toLegArrow },
                FSComponent.buildComponent("path", { d: 'M 20 0 l -7 -7 l 0 5 l -4 0 c -2 0 -3 -1 -3 -2 l -6 0 c 0 4 2 6 5 6 l 8 0 l 0 5 l 7 -7', fill: "magenta" }))));
    }
}

/**
 * The Scrollbar.
 */
class ScrollBar extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
        this.scrollBarRef = FSComponent.createRef();
        this.scrollThumbRef = FSComponent.createRef();
        this.scrollBarContainerRef = FSComponent.createRef();
        this.scrollableContainer = null;
        this.scrollListener = this.onScroll.bind(this);
        this.sizeChangeTimer = null;
        this.arrowPadding = 6;
        this._containerScrollHeight = 0;
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        if (this.scrollBarContainerRef.instance !== null) {
            this.scrollableContainer = this.scrollBarContainerRef.instance.previousElementSibling;
            if (this.scrollableContainer !== null) {
                // bind scroll event
                this.scrollableContainer.addEventListener('scroll', this.scrollListener);
            }
            // HINT: ResizeObserver doesn't exist in Coherent. MutationObserver doesn't perform well.
            // So we do this crap
            /**
             * Checks if the scrollheight of the container has changed and calls adjust
             */
            const diffAndAdjust = () => {
                var _a;
                if (this._containerScrollHeight !== ((_a = this.scrollableContainer) === null || _a === void 0 ? void 0 : _a.scrollHeight)) {
                    this.adjustScrollbarDimensions();
                }
            };
            this.sizeChangeTimer = setInterval(diffAndAdjust, 150);
        }
        this.onScroll();
    }
    /**
     * Adjusts the dimensions of the scrollbar elements.
     * @private
     */
    adjustScrollbarDimensions() {
        if (this.scrollableContainer) {
            const parentTop = this.scrollableContainer.offsetTop;
            this.scrollBarContainerRef.instance.style.top = `${parentTop + 4}px`;
            this._containerScrollHeight = this.scrollableContainer.scrollHeight;
            const containerHeight = this.scrollableContainer.clientHeight;
            const scrollToClientRatio = (this._containerScrollHeight / this.scrollableContainer.clientHeight);
            if (this.scrollThumbRef.instance !== null) {
                this.scrollThumbRef.instance.style.height = `${containerHeight / scrollToClientRatio}`.toString();
            }
            this.scrollBarContainerRef.instance.style.height = `${containerHeight}px`;
            this.svgRef.instance.setAttribute('height', `${containerHeight - 4}px`);
            this.scrollBarRef.instance.setAttribute('d', `M 5 0 l 2 3 l -4 0 l 2 -3 m 0 6 l 0 ${containerHeight - 16} m 0 6 l 2 -3 l -4 0 l 2 3`);
            this.scrollBarContainerRef.instance.style.display = (scrollToClientRatio <= 1.0) ? 'none' : '';
            this.onScroll();
        }
    }
    // TODO needs a method to adjust things on the fly.
    // also put some dimensions into variables
    /**
     * Eventhandler called when a scroll event in the scrollable parent container happens.
     */
    onScroll() {
        if (this.scrollableContainer) {
            // TODO ratio could also take the paddings into account for a more accurate bar
            if (this.scrollBarRef.instance !== null) {
                const ratio = this.scrollThumbRef.instance.getBBox().height / ((this.scrollBarRef.instance.getBBox().height) + this.scrollThumbRef.instance.getBBox().height);
                const scrollY = (this.scrollableContainer.scrollTop * ratio) + this.arrowPadding;
                if (!isNaN(scrollY)) {
                    this.scrollThumbRef.instance.setAttribute('y', scrollY.toString());
                }
            }
        }
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "scroll-bar", ref: this.scrollBarContainerRef },
            FSComponent.buildComponent("svg", { ref: this.svgRef },
                FSComponent.buildComponent("path", { ref: this.scrollBarRef, d: "M 5 0 l 2 3 l -4 0 l 2 -3 m 0 6 l 0 135 m 0 6 l 2 -3 l -4 0 l 2 3", fill: "rgb(150,150,150)", stroke: "rgb(150,150,150)", "stroke-width": "1px" }),
                FSComponent.buildComponent("rect", { ref: this.scrollThumbRef, x: "3", y: "6", width: "4", fill: "rgb(150,150,150)" }))));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    destroy() {
        if (this.scrollableContainer) {
            this.scrollableContainer.removeEventListener('scroll', this.scrollListener);
        }
        if (this.sizeChangeTimer !== null) {
            clearInterval(this.sizeChangeTimer);
        }
    }
}

/// <reference types="msfstypes/JS/Avionics" />
/**
 * The scroll mode for FPL.
 */
var ScrollMode;
(function (ScrollMode) {
    ScrollMode[ScrollMode["MANUAL"] = 0] = "MANUAL";
    ScrollMode[ScrollMode["AUTO"] = 1] = "AUTO";
})(ScrollMode || (ScrollMode = {}));
/**
 * Controller for FPLDetails
 */
class FPLDetailsController {
    /**
     * Constructor
     * @param store the store instance
     * @param fms the fms
     * @param bus the bus
     * @param scrollToActiveLegCb the callback for scroll to active leg
     */
    constructor(store, fms, bus, scrollToActiveLegCb) {
        this.store = store;
        this.fms = fms;
        this.bus = bus;
        this.scrollToActiveLegCb = scrollToActiveLegCb;
        this.sectionRefs = [];
        this.originRef = FSComponent.createRef();
        this.legArrowRef = FSComponent.createRef();
        this.hasVnav = false;
        this.isInitialized = false;
        this.airwaysCollapsed = false;
        this.scrollMode = ScrollMode.MANUAL;
        /** First time this view is loaded, we need to force scroll to the active leg */
        this.didInitScroll = false;
        if (this.fms.autopilot) {
            this.hasVnav = true;
        }
    }
    /** Initializes fpldetails controller */
    initialize() {
        this.store.activeLegState.sub(() => {
            this.onActiveLegStateChange();
        });
        this.store.activeLeg.sub(() => {
            this.onActiveLegStateChange();
        });
        this.store.segments.sub((index, type) => {
            if (type === SubscribableArrayEventType.Removed) {
                this.sectionRefs.splice(index, 1);
            }
        });
        //Attempt to load the first flight plan on construction
        this.onFlightPlanLoaded({ planIndex: 0 });
        //this.initActiveLeg();
        this.isInitialized = true;
        this.bus.getSubscriber().on('alt').atFrequency(1).handle(alt => this.store.currentAltitude = alt);
        const ap = this.bus.getSubscriber();
        ap.on('alt_select').withPrecision(0).handle((sAlt) => {
            this.store.selectedAltitude = sAlt;
        });
        const fpl = this.bus.getSubscriber();
        fpl.on('fplSegmentChange').handle(this.onSegmentChange.bind(this));
        fpl.on('fplLegChange').handle(this.onLegChange.bind(this));
        fpl.on('fplActiveLegChange').handle(this.updateActiveLegState.bind(this));
        fpl.on('fplOriginDestChanged').handle(this.onOriginDestChanged.bind(this));
        fpl.on('fplCalculated').handle(this.onPlanCalculated.bind(this));
        fpl.on('fplLoaded').handle(this.onFlightPlanLoaded.bind(this));
        fpl.on('fplIndexChanged').handle(this.onPlanIndexChanged.bind(this));
        fpl.on('fplProcDetailsChanged').handle(this.onProcDetailsChanged.bind(this));
        fpl.on('vnavUpdated').handle(this.onVnavUpdated.bind(this));
        fpl.on('fplDirectToDataChanged').handle(this.updateActiveLegState.bind(this));
    }
    /**
     * A method to initialize the active leg.
     * TODO: REMOVE THIS WHEN THE ROOT PROBLEM IS FIXED
     */
    initActiveLeg() {
        this.updateActiveLegState();
    }
    /**
     * A method to initialize the dto leg.
     * TODO: REMOVE THIS WHEN THE ROOT PROBLEM IS FIXED
     */
    initDtoLeg() {
        if (this.fms.flightPlanner.activePlanIndex == 1) {
            const e = {
                planIndex: 1
            };
            this.onPlanIndexChanged(e);
        }
    }
    /**
     * A callback fired when a proc details event is received from the bus.
     * @param e The event that was captured.
     */
    onProcDetailsChanged(e) {
        var _a;
        if (e.planIndex == 0 && e.details.arrivalFacilityIcao !== ((_a = this.store.facilityInfo.arrivalFacility) === null || _a === void 0 ? void 0 : _a.icao)) {
            if (e.details.arrivalFacilityIcao !== undefined) {
                this.store.loader.getFacility(FacilityType.Airport, e.details.arrivalFacilityIcao)
                    .then(facility => {
                    this.store.facilityInfo.arrivalFacility = facility;
                    this.updateSectionsHeaderEmptyRow();
                });
            }
            else {
                this.store.facilityInfo.arrivalFacility = undefined;
                this.updateSectionsHeaderEmptyRow();
            }
        }
        else if (e.planIndex == 0) {
            this.updateSectionsHeaderEmptyRow();
        }
    }
    /**
     * A callback fired when a vnav updated message is recevied from the bus.
     * @param e The event that was captured.
     */
    onVnavUpdated(e) {
        var _a, _b;
        if (this.hasVnav && this.fms.autopilot !== undefined && e === true) {
            const vnav = this.fms.autopilot.directors.vnavDirector;
            const segments = vnav.calculator.getSegments();
            let maxAltitude = UnitType.FOOT.convertTo(Math.max(this.store.selectedAltitude, Math.round(this.store.currentAltitude / 100) * 100), UnitType.METER);
            let minAltitude = vnav.calculator.getFirstDescentConstraintAltitude();
            if (segments && segments.length > 0) {
                //start with segment 1 to skip departure segment for now
                for (let i = 1; i < (segments === null || segments === void 0 ? void 0 : segments.length); i++) {
                    const section = (_a = this.sectionRefs[i]) === null || _a === void 0 ? void 0 : _a.instance;
                    if (section !== undefined) {
                        for (let j = 0; j < segments[i].legs.length; j++) {
                            const segment = segments[i];
                            if (segment !== undefined) {
                                const vnavLeg = segments[i].legs[j];
                                if (vnavLeg) {
                                    if (vnavLeg.altitude && vnavLeg.isAdvisory && vnavLeg.altitude > maxAltitude) {
                                        const newAltitude = minAltitude ? Math.max(minAltitude, maxAltitude) : maxAltitude;
                                        section.setLegAltitude(j, vnavLeg, newAltitude);
                                    }
                                    else {
                                        section.setLegAltitude(j, vnavLeg);
                                    }
                                    if (!vnavLeg.isAdvisory) {
                                        maxAltitude = vnavLeg.altitude;
                                        minAltitude = 0;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (this.fms.getDirectToState() === DirectToState.TOEXISTING) {
                const plan = this.fms.getFlightPlan();
                const vnavLeg = vnav.calculator.getLeg(plan.activeLateralLeg);
                (_b = this.sectionRefs[plan.directToData.segmentIndex]) === null || _b === void 0 ? void 0 : _b.instance.setLegAltitude(plan.directToData.segmentLegIndex, vnavLeg);
            }
        }
    }
    /**
     * A callback fired when a new plan is loaded.
     * @param e The event that was captured.
     */
    onFlightPlanLoaded(e) {
        const plan = this.fms.flightPlanner.getFlightPlan(e.planIndex);
        if (plan.originAirport !== undefined) {
            this.onOriginDestChanged({ planIndex: e.planIndex, airport: plan.originAirport, type: OriginDestChangeType.OriginAdded });
        }
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            this.onSegmentChange({ planIndex: e.planIndex, segmentIndex: i, segment: segment, type: PlanChangeType.Added });
            for (let l = 0; l < segment.legs.length; l++) {
                this.onLegChange({
                    planIndex: e.planIndex,
                    segmentIndex: i, legIndex: l, leg: segment.legs[l], type: PlanChangeType.Added
                });
            }
        }
        if (plan.procedureDetails.arrivalIndex > -1) {
            this.onProcDetailsChanged({ planIndex: e.planIndex, details: plan.procedureDetails });
        }
        if (plan.destinationAirport !== undefined) {
            this.onOriginDestChanged({ planIndex: e.planIndex, airport: plan.destinationAirport, type: OriginDestChangeType.DestinationAdded });
        }
        if (e.planIndex === this.fms.flightPlanner.activePlanIndex) {
            this.updateActiveLegState();
        }
    }
    /**
     * A callback fired when the plan index changes (used for handling direct to display).
     * @param e The event that was captured.
     */
    onPlanIndexChanged(e) {
        if (e.planIndex === 1 && this.isInitialized) {
            const plan = this.fms.getDirectToFlightPlan();
            const segment = plan.getSegment(0);
            if (segment.segmentType === FlightPlanSegmentType.RandomDirectTo) {
                this.originRef.instance.onDirectToRandomActive(ICAO.getIdent(segment.legs[2].leg.fixIcao));
            }
            else {
                this.originRef.instance.removeDirectToRandom(this.fms.getFlightPlan(0));
            }
        }
        else if (this.isInitialized) {
            const plan = this.fms.getFlightPlan(0);
            this.originRef.instance.removeDirectToRandom(plan);
        }
        this.updateActiveLegState();
    }
    /**
     * A callback fired when the plan is calculated.
     * @param e The event that was captured.
     */
    onPlanCalculated(e) {
        var _a;
        if (e.planIndex !== 0) {
            return;
        }
        const plan = this.fms.flightPlanner.getFlightPlan(e.planIndex);
        let sectionIndex = 0;
        for (const segment of plan.segments()) {
            const section = (_a = this.sectionRefs[sectionIndex]) === null || _a === void 0 ? void 0 : _a.instance;
            if (section !== undefined) {
                for (let i = 0; i < segment.legs.length; i++) {
                    const calc = segment.legs[i].calculated;
                    calc && section.updateFromLegCalculations(i);
                }
            }
            else {
                console.warn(`onPlanCalculated: Found no section ref for segment ${segment.segmentIndex} !`);
            }
            sectionIndex++;
        }
        //this.updateActiveLegState();
    }
    /**
     * A callback fired when the origin or destination is updated.
     * @param e The event that was captured.
     */
    onOriginDestChanged(e) {
        if (e.planIndex !== 0) {
            return;
        }
        switch (e.type) {
            case OriginDestChangeType.OriginAdded:
                if (e.airport !== undefined) {
                    this.store.loader.getFacility(FacilityType.Airport, e.airport)
                        .then(facility => {
                        this.store.facilityInfo.originFacility = facility;
                        this.updateSectionsHeaderEmptyRow();
                    });
                }
                break;
            case OriginDestChangeType.DestinationAdded:
                if (e.airport !== undefined) {
                    this.store.loader.getFacility(FacilityType.Airport, e.airport)
                        .then(facility => {
                        this.store.facilityInfo.destinationFacility = facility;
                        this.updateSectionsHeaderEmptyRow();
                    });
                }
                break;
            case OriginDestChangeType.OriginRemoved:
                this.store.facilityInfo.originFacility = undefined;
                this.updateSectionsHeaderEmptyRow();
                break;
            case OriginDestChangeType.DestinationRemoved:
                this.store.facilityInfo.destinationFacility = undefined;
                this.updateSectionsHeaderEmptyRow();
                break;
        }
        this.originRef.instance.onOriginDestChanged(e);
    }
    /**
     * Manages the state of the active/direct leg indications based on the store.activeLegState subject state.
     */
    onActiveLegStateChange() {
        var _a;
        this.clearActiveWaypoints();
        const state = this.store.activeLegState.get();
        const plan = this.fms.getFlightPlan();
        const activeLeg = this.store.activeLeg.get();
        const section = (_a = this.sectionRefs[activeLeg.segmentIndex]) === null || _a === void 0 ? void 0 : _a.instance;
        this.legArrowRef.instance.updateArrows(state, activeLeg, plan);
        switch (state) {
            case ActiveLegStates.NORMAL:
            case ActiveLegStates.EXISTING_DIRECT:
                section && section.setActiveLeg(activeLeg.legIndex);
                break;
        }
        if (!this.didInitScroll || this.scrollMode === ScrollMode.AUTO) {
            this.scrollToActiveLegCb();
            this.didInitScroll = true;
        }
        this.manageCollapsedAirways(plan);
        this.notifyActiveLegState(plan);
    }
    /**
     * Updates the active leg state subjects.
     */
    updateActiveLegState() {
        const plan = this.fms.getFlightPlan();
        const directToState = this.fms.getDirectToState();
        if (directToState === DirectToState.TORANDOM) {
            this.store.activeLegState.set(ActiveLegStates.RANDOM_DIRECT);
            return;
        }
        else if (directToState === DirectToState.TOEXISTING) {
            this.store.activeLegState.set(ActiveLegStates.EXISTING_DIRECT);
            const activeLeg = { legIndex: plan.directToData.segmentLegIndex, segmentIndex: plan.directToData.segmentIndex };
            this.store.activeLeg.set(activeLeg);
            return;
        }
        else if (plan.activeLateralLeg < plan.length) {
            this.store.activeLegState.set(ActiveLegStates.NORMAL);
            const leg = plan.getLeg(plan.activeLateralLeg);
            const activeSegment = plan.getSegmentFromLeg(leg);
            if (activeSegment) {
                const activeLegIndexInSegment = plan.activeLateralLeg - activeSegment.offset;
                const activeLeg = { legIndex: activeLegIndexInSegment, segmentIndex: activeSegment.segmentIndex };
                this.store.activeLeg.set(activeLeg);
                return;
            }
        }
        this.store.activeLegState.set(ActiveLegStates.NONE);
    }
    /**
     * A callback fired when a flight plan leg changes.
     * @param e The event that was captured.
     */
    onLegChange(e) {
        var _a, _b;
        if (e.planIndex !== 0) {
            return;
        }
        const section = (_a = this.sectionRefs[e.segmentIndex]) === null || _a === void 0 ? void 0 : _a.instance;
        switch (e.type) {
            case PlanChangeType.Added: {
                const plan = this.fms.getFlightPlan();
                const segment = plan.getSegment(e.segmentIndex);
                const leg = segment.legs[e.legIndex];
                const isAirwayLeg = segment.airway !== undefined;
                const isExitLeg = isAirwayLeg && (leg === null || leg === void 0 ? void 0 : leg.name) === ((_b = segment.airway) === null || _b === void 0 ? void 0 : _b.split('.')[1]);
                if (this.hasVnav) {
                    section && leg && section.addLeg(e.legIndex, {
                        legDefinition: leg, isActive: false, isDirectTo: false,
                        targetAltitude: -1, isAdvisory: true, isAirwayFix: isAirwayLeg, isAirwayExitFix: isExitLeg
                    });
                }
                else {
                    section && leg && section.addLeg(e.legIndex, {
                        legDefinition: leg, isActive: false, isDirectTo: false,
                        isAirwayFix: isAirwayLeg, isAirwayExitFix: isExitLeg
                    });
                }
                break;
            }
            case PlanChangeType.Removed:
                section && section.removeLeg(e.legIndex);
                break;
        }
    }
    /**
     * A callback fired when a flight plan segment changes.
     * @param e The event that was captured.
     */
    onSegmentChange(e) {
        var _a, _b, _c, _d;
        if (e.planIndex !== 0) {
            return;
        }
        switch (e.type) {
            case PlanChangeType.Added: {
                if (e.segmentIndex < this.sectionRefs.length) {
                    this.store.segments.removeAt(e.segmentIndex);
                }
                e.segment && this.store.segments.insert(e.segment, e.segmentIndex);
                break;
            }
            case PlanChangeType.Inserted: {
                e.segment && this.store.segments.insert(e.segment, e.segmentIndex);
                for (let s = e.segmentIndex; s < this.store.segments.length; s++) {
                    const section = (_a = this.sectionRefs[s]) === null || _a === void 0 ? void 0 : _a.instance;
                    if (section !== undefined) {
                        section.segmentIndex.set(s);
                    }
                }
                break;
            }
            case PlanChangeType.Removed:
                this.store.segments.removeAt(e.segmentIndex);
                for (let s = e.segmentIndex; s < this.store.segments.length; s++) {
                    const section = (_b = this.sectionRefs[s]) === null || _b === void 0 ? void 0 : _b.instance;
                    if (section !== undefined) {
                        section.segmentIndex.set(s);
                    }
                }
                break;
            case PlanChangeType.Changed: {
                const section = (_c = this.sectionRefs[e.segmentIndex]) === null || _c === void 0 ? void 0 : _c.instance;
                if (section !== undefined && e.segment) {
                    section.segmentIndex.set(e.segmentIndex);
                }
                const prevSection = (_d = this.sectionRefs[e.segmentIndex - 1]) === null || _d === void 0 ? void 0 : _d.instance;
                if (prevSection !== undefined) {
                    prevSection.segmentIndex.set(e.segmentIndex - 1);
                }
                break;
            }
        }
        this.updateSectionsHeaderEmptyRow();
    }
    /**
     * Updates all section headers and empty rows.
     */
    updateSectionsHeaderEmptyRow() {
        for (let i = 0; i < this.sectionRefs.length; i++) {
            const sectionRef = this.sectionRefs[i];
            if (sectionRef) {
                sectionRef.instance.updateHeader();
                sectionRef.instance.updateEmptyRowVisibility();
            }
        }
    }
    /**
     * A method called to collapse the airways.
     */
    collapseAirways() {
        var _a;
        this.airwaysCollapsed = !this.airwaysCollapsed;
        const plan = this.fms.getFlightPlan();
        const activeSegmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
        for (let i = 1; i < plan.segmentCount; i++) {
            if (i === activeSegmentIndex) {
                continue;
            }
            const segment = plan.getSegment(i);
            if (segment.segmentType === FlightPlanSegmentType.Enroute && segment.airway !== undefined) {
                const section = (_a = this.sectionRefs[i]) === null || _a === void 0 ? void 0 : _a.instance;
                if (section !== undefined) {
                    section.collapseLegs(this.airwaysCollapsed);
                    continue;
                }
            }
        }
    }
    /**
     * A method called to manage collapsed airways when the active segment changes.
     * @param plan is the flight plan
     */
    manageCollapsedAirways(plan) {
        var _a, _b;
        const activeSegmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
        const fromSegmentIndex = plan.getSegmentIndex(plan.activeLateralLeg - 1);
        for (let i = 1; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            if ((i === activeSegmentIndex || i === fromSegmentIndex) && segment.segmentType === FlightPlanSegmentType.Enroute) {
                const section = (_a = this.sectionRefs[i]) === null || _a === void 0 ? void 0 : _a.instance;
                if (section !== undefined) {
                    section.collapseLegs(false);
                }
            }
            else if (segment.segmentType === FlightPlanSegmentType.Enroute && segment.airway !== undefined) {
                const section = (_b = this.sectionRefs[i]) === null || _b === void 0 ? void 0 : _b.instance;
                if (section !== undefined) {
                    section.collapseLegs(this.airwaysCollapsed);
                }
            }
        }
    }
    /**
     * Notifies this controller's sections of the flight plan's active leg state.
     * @param plan The flight plan.
     */
    notifyActiveLegState(plan) {
        var _a;
        if (plan.length > 0 && plan.segmentCount > 2) {
            const activeSegmentIndex = Utils.Clamp(plan.getSegmentIndex(plan.activeLateralLeg), 0, plan.segmentCount);
            let activeLegIndex = plan.activeLateralLeg - plan.getSegment(activeSegmentIndex).offset;
            if (this.fms.getDirectToState() === DirectToState.TOEXISTING) {
                activeLegIndex -= 3;
            }
            for (let i = 0; i < plan.segmentCount; i++) {
                const section = (_a = this.sectionRefs[i]) === null || _a === void 0 ? void 0 : _a.instance;
                if (section !== undefined) {
                    section.onActiveLegChanged(activeSegmentIndex, activeLegIndex);
                }
            }
        }
    }
    /**
     * Sets all legs in the displayed plan to inactive.
     */
    clearActiveWaypoints() {
        this.sectionRefs.forEach((section) => {
            section.instance.cancelAllActiveLegs();
        });
    }
}

/**
 * The store class for FPLDetails
 */
class FPLDetailsStore {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
        /** Information on our origin, arrival and destination facilities to save lookups. */
        this.facilityInfo = {
            originFacility: undefined,
            destinationFacility: undefined,
            arrivalFacility: undefined
        };
        this.segments = ArraySubject.create();
        this.activeLeg = Subject.create({ segmentIndex: 0, legIndex: 0 });
        this.activeLegState = Subject.create(ActiveLegStates.NONE);
        this.currentAltitude = 0;
        this.selectedAltitude = 0;
        this.loader = new FacilityLoader(FacilityRespository.getRepository(bus));
    }
}

/** A VNode representing a preformated rendering of an approach's name. */
class ApproachNameDisplay extends DisplayComponent {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.nameRef = FSComponent.createRef();
        this.airportRef = FSComponent.createRef();
        this.subTypeRef = FSComponent.createRef();
        this.suffixRef = FSComponent.createRef();
        this.runwayRef = FSComponent.createRef();
        this.flagsRef = FSComponent.createRef();
        this.nullRef = FSComponent.createRef();
        this.airportSub = (_b = (_a = this.props.airport) === null || _a === void 0 ? void 0 : _a.map(airport => airport ? ICAO.getIdent(airport.icao) : '')) !== null && _b !== void 0 ? _b : Subject.create('');
        this.namePartsSub = this.props.approach.map(approach => approach ? FmsUtils.getApproachNameAsParts(approach) : null);
        this.typeSub = this.namePartsSub.map(parts => { var _a; return (_a = parts === null || parts === void 0 ? void 0 : parts.type) !== null && _a !== void 0 ? _a : ''; });
        this.subTypeSub = this.namePartsSub.map(parts => { var _a; return (_a = parts === null || parts === void 0 ? void 0 : parts.subtype) !== null && _a !== void 0 ? _a : ''; });
        this.suffixConnectorSub = this.namePartsSub.map(parts => !parts || parts.runway ? ' ' : '–');
        this.suffixSub = this.namePartsSub.map(parts => { var _a; return (_a = parts === null || parts === void 0 ? void 0 : parts.suffix) !== null && _a !== void 0 ? _a : ''; });
        this.runwaySub = this.namePartsSub.map(parts => { var _a; return (_a = parts === null || parts === void 0 ? void 0 : parts.runway) !== null && _a !== void 0 ? _a : ''; });
        this.flagsSub = this.namePartsSub.map(parts => { var _a; return (_a = parts === null || parts === void 0 ? void 0 : parts.flags) !== null && _a !== void 0 ? _a : ''; });
    }
    /** @inheritdoc */
    onAfterRender() {
        this.namePartsSub.sub(parts => {
            this.nameRef.instance.style.display = parts ? '' : 'none';
            this.nullRef.instance.style.display = this.props.nullText === undefined || parts ? 'none' : '';
        }, true);
        this.airportSub.sub(value => { this.airportRef.instance.style.display = value === '' ? 'none' : ''; }, true);
        this.subTypeSub.sub(value => { this.subTypeRef.instance.style.display = value === '' ? 'none' : ''; }, true);
        this.suffixSub.sub(value => { this.suffixRef.instance.style.display = value === '' ? 'none' : ''; }, true);
        this.runwaySub.sub(value => { this.flagsRef.instance.style.display = value === '' ? 'none' : ''; }, true);
        this.flagsSub.sub(value => { this.flagsRef.instance.style.display = value === '' ? 'none' : ''; }, true);
    }
    /** @inheritdoc */
    render() {
        var _a, _b;
        return (FSComponent.buildComponent("div", { class: `appr-name ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}` },
            FSComponent.buildComponent("span", { ref: this.nameRef },
                FSComponent.buildComponent("span", { ref: this.airportRef },
                    this.airportSub,
                    "\u2013"),
                FSComponent.buildComponent("span", null, this.typeSub),
                FSComponent.buildComponent("span", { ref: this.subTypeRef, class: 'appr-name-subtype' }, this.subTypeSub),
                FSComponent.buildComponent("span", { ref: this.suffixRef },
                    this.suffixConnectorSub,
                    this.suffixSub),
                FSComponent.buildComponent("span", { ref: this.runwayRef },
                    " ",
                    this.runwaySub),
                FSComponent.buildComponent("span", { ref: this.flagsRef },
                    " ",
                    this.flagsSub)),
            FSComponent.buildComponent("span", { ref: this.nullRef }, (_b = this.props.nullText) !== null && _b !== void 0 ? _b : '')));
    }
    /** @inheritdoc */
    destroy() {
        this.namePartsSub.destroy();
    }
}

/**
 * A header for an FPL section.
 */
class FPLHeader extends UiControl {
    constructor() {
        super(...arguments);
        this.rootRef = FSComponent.createRef();
        this.estimatedNameWidth = 0;
        this._isCollapsed = false;
        this.isInit = false;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether this header is collapsed. */
    get isCollapsed() {
        return this._isCollapsed;
    }
    /** @inheritdoc */
    onAfterRender() {
        this.isInit = true;
        super.onAfterRender();
        this.update();
    }
    /** Updates this header */
    update() {
        if (!this.isInit) {
            return;
        }
        this.updateName();
    }
    /**
     * Sets the estimated width of this header's name text.
     * @param width The new estimated width, in pixels.
     */
    setEstimatedNameWidth(width) {
        if (width === this.estimatedNameWidth) {
            return;
        }
        this.estimatedNameWidth = width;
        this.updateNameFontSize();
    }
    /**
     * Updates the font size for this header's name text to ensure the text fits within this header's width.
     */
    updateNameFontSize() {
        if (this.rootRef.getOrDefault() !== null) {
            // fit size
            const clampedWidth = Utils.Clamp(this.estimatedNameWidth, this.rootRef.instance.offsetWidth, 500);
            const clientWidth = this.rootRef.instance.clientWidth;
            if (clientWidth !== 0) {
                this.rootRef.instance.style.fontSize = `${(this.rootRef.instance.clientWidth / clampedWidth) * 100}%`;
            }
        }
    }
    /** @inheritdoc */
    renderControl() {
        return (FSComponent.buildComponent("div", { ref: this.rootRef, class: 'header-name' }, this.renderName()));
    }
}

/**
 * An FPL section header for approaches.
 */
class FPLHeaderApproach extends FPLHeader {
    constructor() {
        super(...arguments);
        this.airportSub = Subject.create(null);
        this.approachSub = Subject.create(null);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setCollapsed(setCollapsed) {
        //noop
    }
    /** @inheritdoc */
    updateName() {
        const plan = this.props.fms.getPrimaryFlightPlan();
        const airport = this.props.facilities.destinationFacility;
        const approach = airport ? FmsUtils.getApproachFromPlan(plan, airport) : undefined;
        this.airportSub.set(airport !== null && airport !== void 0 ? airport : null);
        this.approachSub.set(approach !== null && approach !== void 0 ? approach : null);
        const nameLength = approach
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ? FmsUtils.getApproachNameAsString(approach).length + ICAO.getIdent(airport.icao).length + 1
            : 0;
        this.setEstimatedNameWidth(nameLength * FPLHeaderApproach.ESTIMATED_CHAR_WIDTH);
    }
    /** @inheritdoc */
    renderName() {
        return (FSComponent.buildComponent(ApproachNameDisplay, { approach: this.approachSub, airport: this.airportSub }));
    }
}
FPLHeaderApproach.ESTIMATED_CHAR_WIDTH = 13.2;

/**
 * The PopoutMenuItem component.
 */
class PopoutMenuItem extends UiControl {
    constructor() {
        super(...arguments);
        this.isEnabled = ComputedSubject.create(true, (v) => {
            return v ? 'popout-menu-item' : 'popout-menu-item text-disabled';
        });
        this.onIsEnabledChanged = (v, rv) => {
            this.setIsEnabled(rv);
        };
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        var _a;
        super.onAfterRender();
        this.isEnabled.sub(this.onIsEnabledChanged);
        this.isEnabled.set((_a = this.props.def.isEnabled) !== null && _a !== void 0 ? _a : true);
    }
    /** @inheritdoc */
    onEnter() {
        if (this.props.def.action) {
            this.props.def.action();
            if ((this.props.def.closeAfterAction === undefined || this.props.def.closeAfterAction) && Fms.viewService.getOpenViews().includes(this.props.parent)) {
                this.props.parent.close();
            }
            return true;
        }
        else if (this.props.onEnter) {
            return this.props.onEnter(this);
        }
        return false;
    }
    /** @inheritdoc */
    getHighlightElement() {
        var _a, _b;
        return (_b = (_a = this.containerRef.instance.firstElementChild) === null || _a === void 0 ? void 0 : _a.firstElementChild) !== null && _b !== void 0 ? _b : null;
    }
    /** @inheritdoc */
    renderControl() {
        return (FSComponent.buildComponent("div", { class: this.isEnabled }, this.props.def.renderContent()));
    }
}

/** The list menu popout. */
class ListMenuDialog extends UiView {
    constructor() {
        super(...arguments);
        this.listRef = FSComponent.createRef();
        this.listContainerRef = FSComponent.createRef();
        this.menuItems = this.buildMenuItems();
        this.menuItemsSubject = ArraySubject.create(this.menuItems);
        /**
         * A callback called to render the menu items.
         * @param d is the menu item
         * @param registerFn The register function.
         * @returns a vnode for display in the menu
         */
        this.renderItem = (d, registerFn) => {
            return FSComponent.buildComponent(PopoutMenuItem, { onRegister: registerFn, parent: this, def: d });
        };
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.CLR:
                this.close();
                return true;
        }
        return false;
    }
    /**
     * Gets the menu item definitions for the list.
     * @returns menu item definitions.
     */
    buildMenuItems() {
        return [];
    }
    /**
     * Sets the menu items for the list menu dialog.
     * @param items The items to set into the menu.
     */
    setMenuItems(items) {
        this.menuItems = items;
        this.menuItemsSubject.clear();
        this.menuItemsSubject.set(items);
        this.scrollController.gotoFirst();
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        let className = 'popout-dialog';
        if (this.props.isMfd) {
            className = 'MFD-' + className;
        }
        if (this.props.class !== undefined) {
            className += ` ${this.props.class}`;
        }
        return (FSComponent.buildComponent("div", { class: className, ref: this.viewContainerRef },
            FSComponent.buildComponent("h1", null, this.props.title),
            FSComponent.buildComponent("div", { class: "popout-menu-container", ref: this.listContainerRef },
                FSComponent.buildComponent(List, { ref: this.listRef, onRegister: this.register, data: this.menuItemsSubject, renderItem: this.renderItem, scrollContainer: this.listContainerRef })),
            FSComponent.buildComponent(ScrollBar, null)));
    }
}

/**
 * The GroupBox component.
 */
class GroupBox extends UiControlGroup {
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        var _a, _b, _c;
        return (FSComponent.buildComponent("div", { class: `groupbox-container ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}`, style: (_b = this.props.containerStyle) !== null && _b !== void 0 ? _b : '' },
            FSComponent.buildComponent("div", { class: "groupbox-content", style: (_c = this.props.contentStyle) !== null && _c !== void 0 ? _c : '' }, this.props.children),
            FSComponent.buildComponent("div", { class: "groupbox-title" }, this.props.title))
        // <div>
        //   <fieldset>
        //     <legend>{this.props.title}</legend>
        //     {this.props.children}
        //   </fieldset>
        // </div>
        );
    }
}

/**
 * Dialog used for displaying page menus.
 * @class PageMenuDialog
 * @augments {ListMenuDialog}
 */
class PageMenuDialog extends ListMenuDialog {
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        let className = 'popout-dialog';
        if (this.props.class !== undefined) {
            className += ` ${this.props.class}`;
        }
        return (FSComponent.buildComponent("div", { class: className, ref: this.viewContainerRef },
            FSComponent.buildComponent("div", { class: "popout-pagemenu-background" },
                FSComponent.buildComponent("h1", null, this.props.title),
                FSComponent.buildComponent(GroupBox, { title: "Options", containerStyle: "margin-top:50px;" },
                    FSComponent.buildComponent("div", { class: "popout-pagemenu-listcontainer", ref: this.listContainerRef },
                        FSComponent.buildComponent(List, { ref: this.listRef, onRegister: this.register, data: this.menuItemsSubject, renderItem: this.renderItem, scrollContainer: this.listContainerRef })),
                    FSComponent.buildComponent(ScrollBar, null)))));
    }
}

/** The FixInfo component. */
class FixInfo extends UiControl {
    constructor() {
        var _a, _b, _c, _d, _e, _f, _g;
        super(...arguments);
        this.fixEl = FSComponent.createRef();
        this.highlightElementRef = FSComponent.createRef();
        this.altitudeRef = FSComponent.createRef();
        this.ACTIVE_WPT_CLASS = 'active-wpt';
        this._dtk = ComputedSubject.create((_b = (_a = this.props.data.get().legDefinition.calculated) === null || _a === void 0 ? void 0 : _a.initialDtk) !== null && _b !== void 0 ? _b : -1, (v) => {
            if (v < 0 || this.props.data.get().legIsBehind) {
                return '___';
            }
            else {
                const rounded = Math.round(v);
                return (rounded === 0 ? 360 : rounded).toFixed(0).padStart(3, '0');
            }
        });
        this._distance = ComputedSubject.create((_d = (_c = this.props.data.get().legDefinition.calculated) === null || _c === void 0 ? void 0 : _c.distance) !== null && _d !== void 0 ? _d : -1, (v) => {
            if (v < 0.1 || this.props.data.get().legIsBehind) {
                return '____';
            }
            else {
                // const dis = (v / 1852);
                const dis = Units.Meters.toNauticalMiles(v);
                return dis.toFixed((dis < 100) ? 1 : 0);
            }
        });
        this._altitude = ComputedSubject.create((_e = this.props.data.get().targetAltitude) !== null && _e !== void 0 ? _e : -1, (v) => {
            if (v < 1 || isNaN(v) || this.props.data.get().legIsBehind) {
                return '';
            }
            else {
                return Units.Meters.toFeet(v).toFixed(0);
            }
        });
        this._altitudeUnits = ComputedSubject.create((_f = this.props.data.get().targetAltitude) !== null && _f !== void 0 ? _f : -1, (v) => {
            if (v < 1 || isNaN(v) || this.props.data.get().legIsBehind) {
                return ' ';
            }
            else {
                return 'FT';
            }
        });
        this._fixType = ComputedSubject.create((_g = this.props.data.get().legDefinition.leg.fixTypeFlags) !== null && _g !== void 0 ? _g : FixTypeFlags.None, (v) => {
            const leg = this.props.data.get().legDefinition;
            if (leg.name === 'MANSEQ' && (leg.leg.type === LegType.FM || leg.leg.type === LegType.VM)) {
                return ' hdg';
            }
            switch (v) {
                case FixTypeFlags.FAF:
                    return ' faf';
                case FixTypeFlags.IAF:
                    return ' iaf';
                case FixTypeFlags.MAP:
                    return ' map';
                case FixTypeFlags.MAHP:
                    return ' mahp';
                default:
                    return '';
            }
        });
    }
    /**
     * Resets highlight animation when the leg goes to/from active so the right color variable is used.
     * We need to trigger a reflow so the browser parses the animation again.
     */
    resetHighlightAnimation() {
        const animName = this.highlightElementRef.instance.style.animationName;
        this.highlightElementRef.instance.style.animationName = 'none';
        this.highlightElementRef.instance.offsetHeight;
        this.highlightElementRef.instance.style.animationName = animName;
    }
    /**
     * Gets the container element location
     * @returns An array of x,y.
     */
    getContainerElementLocation() {
        return [this.fixEl.instance.offsetLeft, this.fixEl.instance.offsetTop];
    }
    /** @inheritdoc */
    getHighlightElement() {
        return this.highlightElementRef.instance;
    }
    /** @inheritdoc */
    onAfterRender() {
        super.onAfterRender();
        this.props.data.sub((v) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
            if (v.isAirwayExitFix && v.isCollapsed) {
                this._dtk.set(-1);
                this._distance.set((_a = v.airwayDistance) !== null && _a !== void 0 ? _a : -1);
            }
            else if (v.legDefinition.leg.type === LegType.HF || v.legDefinition.leg.type === LegType.HM || v.legDefinition.leg.type === LegType.HA) {
                this._dtk.set(v.legDefinition.leg.course);
                const lastVectorIndex = ((_b = v.legDefinition.calculated) === null || _b === void 0 ? void 0 : _b.flightPath.length) ? ((_c = v.legDefinition.calculated) === null || _c === void 0 ? void 0 : _c.flightPath.length) - 1 : 0;
                this._distance.set((_e = (_d = v.legDefinition.calculated) === null || _d === void 0 ? void 0 : _d.flightPath[lastVectorIndex].distance) !== null && _e !== void 0 ? _e : 0);
            }
            else {
                this._dtk.set((_g = (_f = v.legDefinition.calculated) === null || _f === void 0 ? void 0 : _f.initialDtk) !== null && _g !== void 0 ? _g : -1);
                this._distance.set((_j = (_h = v.legDefinition.calculated) === null || _h === void 0 ? void 0 : _h.distance) !== null && _j !== void 0 ? _j : 0);
            }
            this._altitude.set((_k = v.targetAltitude) !== null && _k !== void 0 ? _k : -1);
            this._altitudeUnits.set((_l = v.targetAltitude) !== null && _l !== void 0 ? _l : -1);
            if (v.isActive) {
                this.fixEl.instance.classList.add(this.ACTIVE_WPT_CLASS);
                this.highlightElementRef.instance.classList.remove('fix-hold');
            }
            else {
                this.fixEl.instance.classList.remove(this.ACTIVE_WPT_CLASS);
            }
            if (this.getIsFocused()) {
                this.resetHighlightAnimation();
            }
            if ((v.isCollapsed && !v.isAirwayExitFix) || v.legDefinition.isInDirectToSequence) {
                this.setIsVisible(false);
            }
            else {
                this.setIsVisible(true);
            }
            if (v.isAirwayFix) {
                this.highlightElementRef.instance.style.marginLeft = v.isAirwayExitFix ? '5px' : '10px';
            }
            else {
                this.highlightElementRef.instance.style.marginLeft = '0px';
            }
            this._fixType.set((_m = v.legDefinition.leg.fixTypeFlags) !== null && _m !== void 0 ? _m : FixTypeFlags.None);
            if (v.legDefinition.leg.type === LegType.HF || v.legDefinition.leg.type === LegType.HM || v.legDefinition.leg.type === LegType.HA) {
                this.highlightElementRef.instance.classList.add('fix-hold');
            }
            else {
                this.highlightElementRef.instance.classList.remove('fix-hold');
            }
            if (this.props.isExtended && v.isAdvisory) {
                this.altitudeRef.instance.classList.add('alt-advisory');
            }
            else if (this.props.isExtended) {
                this.altitudeRef.instance.classList.remove('alt-advisory');
            }
        });
    }
    /** @inheritdoc */
    renderControl() {
        return (FSComponent.buildComponent("div", { class: 'fix-container', ref: this.fixEl },
            FSComponent.buildComponent("div", { class: 'fix-name' },
                FSComponent.buildComponent("span", { ref: this.highlightElementRef },
                    this.props.data.get().legDefinition.name,
                    FSComponent.buildComponent("span", { class: 'fix-type' }, this._fixType))),
            FSComponent.buildComponent("div", { class: this.props.isExtended ? 'mfd-dtk-value' : 'dtk-value' },
                this._dtk,
                "\u00B0"),
            FSComponent.buildComponent("div", { class: this.props.isExtended ? 'mfd-dis-value' : 'dis-value' },
                this._distance,
                FSComponent.buildComponent("span", { class: "smallText" }, "NM")),
            this.props.isExtended ? FSComponent.buildComponent("div", { ref: this.altitudeRef, class: 'mfd-alt-value' },
                this._altitude,
                FSComponent.buildComponent("span", { class: "smallText" }, this._altitudeUnits)) : null));
    }
}

/**
 * A flight plan detail section, representing a single phase of flight.
 *
 * Individual sections that need to render a dynamic list of fixes can extend
 * this for useful functionality.  They will need to, at the minimum, define
 * the type of segment they are by storing a FlightPlanSegmentType in the
 * segmentType variable.
 *
 * An additional hook is provided for a callback that can be used to render
 * the header for the section dynamically based on the section's needs, since
 * that is something that varies by section type.
 *
 * Descendents must remember to call super.onAfterRender() in their own
 * onAfterRender if they want the magic to happen.
 */
class FPLSection extends UiControlGroup {
    constructor() {
        super(...arguments);
        /** A reference to the header line for the section. */
        this.headerRef = FSComponent.createRef();
        this.emptyRowRef = FSComponent.createRef();
        this.segmentIndex = Subject.create(this.props.segmentIndex);
        this.legs = ArraySubject.create();
        this.listRef = FSComponent.createRef();
        /**
         * Callback for when UpperKnob event happens on a leg.
         * @param node The FixInfo element.
         */
        this.onUpperKnobLegBase = (node) => {
            const idx = (node instanceof FixInfo) ? this.listRef.instance.getListItemIndex(node) : undefined;
            Fms.viewService.open('WptInfo', true)
                .onAccept.on((sender, fac) => {
                this.props.fms.insertWaypoint(this.segmentIndex.get(), fac, idx);
            });
        };
        /**
         * Callback to onUpperKnob on legs for override by sections
         * @param node The FixInfo element.
         */
        this.onUpperKnobLeg = (node) => {
            this.onUpperKnobLegBase(node);
        };
        /**
         * Callback for when CLR event happens on a leg.
         * @param node The FixInfo element.
         * @returns A boolean indicating if the CLR was handled.
         */
        this.onClrLegBase = (node) => {
            const idx = this.listRef.instance.getListItemIndex(node);
            const displayLeg = this.legs.tryGet(idx);
            const isActive = displayLeg !== undefined && displayLeg.get().isActive;
            const selectedLeg = node.props.data.get().legDefinition;
            const isHoldOrPtLegType = [LegType.HM, LegType.HF, LegType.HA, LegType.PI].includes(selectedLeg.leg.type);
            if (selectedLeg !== undefined) {
                Fms.viewService.open('MessageDialog', true).setInput({ inputString: `Remove ${selectedLeg === null || selectedLeg === void 0 ? void 0 : selectedLeg.name}?`, hasRejectButton: true }).onAccept.on((sender, accept) => {
                    if (accept) {
                        if (isActive && !isHoldOrPtLegType && !Simplane.getIsGrounded()) {
                            this.props.fms.buildRandomDirectTo(selectedLeg.leg.fixIcao);
                        }
                        this.props.fms.deleteWaypoint(this.segmentIndex.get(), idx);
                        if (isActive && isHoldOrPtLegType) {
                            this.props.fms.activateLeg(this.segmentIndex.get(), idx);
                        }
                        return true;
                    }
                });
            }
            return false;
        };
        /**
         * Callback to onClr on legs for override by sections
         * @param node The FixInfo element.
         * @returns A boolean indicating if the CLR was handled.
         */
        this.onClrLeg = (node) => {
            return this.onClrLegBase(node);
        };
        /**
         * Renders a Leg in the flight plan.
         * @param data The data object for this leg.
         * @param registerFn The control register function.
         * @returns The rendered VNode.
         */
        this.renderItem = (data, registerFn) => {
            if (this.props.isExtendedView) {
                return FSComponent.buildComponent(FixInfo, { onRegister: registerFn, onUpperKnobInc: this.onUpperKnobLeg, onClr: this.onClrLeg, data: data, isExtended: true });
            }
            else {
                return FSComponent.buildComponent(FixInfo, { onRegister: registerFn, onUpperKnobInc: this.onUpperKnobLeg, onClr: this.onClrLeg, data: data });
            }
        };
    }
    /** @inheritdoc */
    onBeforeRender() {
        if (this.props.fms.getFlightPlan().getSegment(this.segmentIndex.get())) {
            this.segment = this.props.fms.getFlightPlan().getSegment(this.segmentIndex.get());
        }
        super.onBeforeRender();
        if (this.props.scrollContainer) {
            this.scrollController.registerScrollContainer(this.props.scrollContainer.instance);
        }
    }
    /**
     * Gets the ref to the list component for the section.
     * @returns list ref
     */
    getListRef() {
        return this.listRef;
    }
    /**
     * An event called when the dto button is pressed.
     * @returns True if the event was handled in this section.
     */
    onDirectTo() {
        try {
            if (this.hasSelection() && !this.isHeaderSelected() && this.segment !== undefined) {
                const canDirectTo = this.props.fms.canDirectTo(this.segmentIndex.get(), this.listRef.instance.getSelectedIndex());
                if (canDirectTo) {
                    const directToInputData = {
                        segmentIndex: this.segmentIndex.get(),
                        legIndex: this.listRef.instance.getSelectedIndex(),
                        icao: this.legs.get(this.listRef.instance.getSelectedIndex()).get().legDefinition.leg.fixIcao,
                    };
                    Fms.viewService.open('DirectTo', false).setInput(directToInputData);
                    return true;
                }
                else {
                    const selectedLeg = this.segment.legs[this.listRef.instance.getSelectedIndex()];
                    if (selectedLeg !== undefined) {
                        Fms.viewService.open('MessageDialog', true).setInput({ inputString: `Activate Leg to ${selectedLeg.name}?`, hasRejectButton: true }).onAccept.on((sender, accept) => {
                            if (accept) {
                                this.props.fms.activateLeg(this.segmentIndex.get(), this.listRef.instance.getSelectedIndex());
                            }
                        });
                    }
                    return true;
                }
            }
        }
        catch (error) {
            return false;
            // throw something?
        }
        return false;
    }
    /**
     * An event called when the menu button is pressed.
     * @returns True if the event was handled in this section.
     */
    onMenu() {
        if (this.hasSelection() && this.segment !== undefined) {
            const dialog = Fms.viewService.open(PageMenuDialog.name, true);
            const plan = this.props.fms.getFlightPlan();
            dialog.setMenuItems([
                {
                    id: 'activate-leg',
                    renderContent: () => FSComponent.buildComponent("span", null, "Activate Leg"),
                    isEnabled: !this.isHeaderSelected() && !this.isEmptyRowSelected(),
                    action: () => {
                        if (this.segment !== undefined) {
                            const selectedLegIndex = this.listRef.instance.getSelectedIndex();
                            const selectedLeg = this.segment.legs[selectedLegIndex];
                            if (selectedLeg !== undefined) {
                                Fms.viewService.open('MessageDialog', true).setInput({ inputString: `Activate Leg to ${selectedLeg.name}?`, hasRejectButton: true }).onAccept.on((sender, accept) => {
                                    if (accept) {
                                        this.props.fms.activateLeg(this.segmentIndex.get(), selectedLegIndex);
                                    }
                                });
                            }
                        }
                    }
                },
                {
                    id: 'load-airway',
                    renderContent: () => FSComponent.buildComponent("span", null, "Load Airway"),
                    isEnabled: this.canAirwayInsert(this.segmentIndex.get(), this.isEmptyRowSelected()),
                    action: () => {
                        const airwayInsertData = this.getAirwayInsertData(this.segmentIndex.get(), this.listRef.instance.getSelectedIndex(), this.isEmptyRowSelected());
                        Fms.viewService.open('SelectAirway', true).setInput(airwayInsertData);
                    }
                },
                {
                    id: 'collapse-airways',
                    renderContent: () => { var _a; return FSComponent.buildComponent("span", null, ((_a = this.props.detailsController) === null || _a === void 0 ? void 0 : _a.airwaysCollapsed) ? 'Expand Airways' : 'Collapse Airways'); },
                    isEnabled: true,
                    action: () => {
                        var _a;
                        (_a = this.props.detailsController) === null || _a === void 0 ? void 0 : _a.collapseAirways();
                    }
                },
                {
                    id: 'hold-waypoint', renderContent: () => FSComponent.buildComponent("span", null, "Hold At Waypoint"),
                    isEnabled: !this.isHeaderSelected() && !this.isEmptyRowSelected(),
                    action: () => {
                        Fms.viewService.open('HoldAt', true).setInput({ segmentIndex: this.segmentIndex.get(), legIndex: this.listRef.instance.getSelectedIndex() });
                    }
                },
                { id: 'hold-ppos', renderContent: () => FSComponent.buildComponent("span", null, "Hold At Present Position"), isEnabled: false },
                { id: 'create-atk', renderContent: () => FSComponent.buildComponent("span", null, "Create ATK Offset WPT"), isEnabled: false },
                {
                    id: 'delete-fpln', renderContent: () => FSComponent.buildComponent("span", null, "Delete Flight Plan"), isEnabled: true, action: () => {
                        this.props.fms.emptyPrimaryFlightPlan();
                    }
                },
                { id: 'store-fpln', renderContent: () => FSComponent.buildComponent("span", null, "Store Flight Plan"), isEnabled: false },
                {
                    id: 'invert-fpln', renderContent: () => FSComponent.buildComponent("span", null, "Invert Flight Plan"), isEnabled: true, action: () => {
                        this.props.fms.invertFlightplan();
                    }
                },
                { id: 'temp-comp', renderContent: () => FSComponent.buildComponent("span", null, "Temperature Compensation"), isEnabled: false },
                { id: 'usr-wpt', renderContent: () => FSComponent.buildComponent("span", null, "Create New User Waypoint"), isEnabled: false },
                {
                    id: 'remove-dep', renderContent: () => FSComponent.buildComponent("span", null, "Remove Departure"), isEnabled: plan.procedureDetails.departureIndex > -1, action: () => {
                        var _a;
                        const departure = (_a = this.props.facilities.originFacility) === null || _a === void 0 ? void 0 : _a.departures[plan.procedureDetails.departureIndex];
                        Fms.viewService.open('MessageDialog', true).setInput({ inputString: `Remove ${departure === null || departure === void 0 ? void 0 : departure.name} from flight plan?`, hasRejectButton: true }).onAccept.on((sender, accept) => {
                            if (accept) {
                                this.props.fms.removeDeparture();
                            }
                        });
                    }
                },
                {
                    id: 'remove-arr', renderContent: () => FSComponent.buildComponent("span", null, "Remove Arrival"), isEnabled: plan.procedureDetails.arrivalIndex > -1, action: () => {
                        var _a;
                        const arrival = (_a = this.props.facilities.arrivalFacility) === null || _a === void 0 ? void 0 : _a.arrivals[plan.procedureDetails.arrivalIndex];
                        Fms.viewService.open('MessageDialog', true).setInput({ inputString: `Remove ${arrival === null || arrival === void 0 ? void 0 : arrival.name} from flight plan?`, hasRejectButton: true }).onAccept.on((sender, accept) => {
                            if (accept) {
                                this.props.fms.removeArrival();
                            }
                        });
                    }
                },
                {
                    id: 'remove-app', renderContent: () => FSComponent.buildComponent("span", null, "Remove Approach"), isEnabled: this.isApproachLoaded(plan), action: () => {
                        Fms.viewService.open('MessageDialog', true).setInput({
                            renderContent: () => {
                                return (FSComponent.buildComponent("div", { style: 'display: inline-block;' },
                                    "Remove ",
                                    this.renderApproachName(plan),
                                    " from flight plan?"));
                            },
                            hasRejectButton: true
                        }).onAccept.on((sender, accept) => {
                            if (accept) {
                                this.props.fms.removeApproach();
                            }
                        });
                    }
                },
                { id: 'parallel-track', renderContent: () => FSComponent.buildComponent("span", null, "Parallel Track"), isEnabled: false },
                { id: 'closest-point', renderContent: () => FSComponent.buildComponent("span", null, "Closest Point Of FPL"), isEnabled: false }
            ]);
            return true;
        }
        return false;
    }
    // TODO Remove when all events converted
    /**
     * Checks if there is a highlighted element in this section
     * @protected
     * @returns A boolean indicating if an element is highlighted in this section.
     */
    hasSelection() {
        return this.isHeaderSelected() || this.listRef.instance.getSelectedIndex() > -1 || this.isEmptyRowSelected();
    }
    /**
     * Adds a leg to the flight plan display segment.
     * @param index The index to add at.
     * @param leg The leg to add.
     */
    addLeg(index, leg) {
        const currentLeg = this.legs.tryGet(index);
        if (currentLeg !== undefined && currentLeg.get().isActive) {
            currentLeg.apply({ isActive: false });
            leg.isActive = true;
        }
        this.legs.insert(Subject.create(leg), index);
        this.updateEmptyRowVisibility();
    }
    /**
     * Removes a leg from the flight plan display segment.
     * @param index The index to remove at.
     */
    removeLeg(index) {
        let currentLeg = this.legs.tryGet(index);
        const isActive = currentLeg !== undefined && currentLeg.get().isActive;
        this.legs.removeAt(index);
        currentLeg = this.legs.tryGet(index);
        if (currentLeg !== undefined && isActive) {
            currentLeg.apply({ isActive });
        }
        this.updateEmptyRowVisibility();
    }
    /**
     * Refreshes this section's header.
     */
    updateHeader() {
        this.headerRef.instance.update();
    }
    /**
     * Updates the visibility of this section's empty row.
     */
    updateEmptyRowVisibility() {
        const emptyRow = this.emptyRowRef.getOrDefault();
        if (emptyRow !== null) {
            emptyRow.setIsVisible(this.getEmptyRowVisbility());
        }
    }
    /**
     * A callback which responds to changes in the active flight plan leg.
     * @param activeSegmentIndex The index of the active leg segment.
     * @param activeLegIndex The index of the active leg in its segment.
     */
    onActiveLegChanged(activeSegmentIndex, activeLegIndex) {
        var _a;
        this.updateLegInfoVisibility(activeSegmentIndex, activeLegIndex);
        // Refresh flight plan focus if the header or empty row is focused
        if (this.headerRef.instance.getIsFocused()) {
            this.onHeaderFocused();
        }
        else if ((_a = this.emptyRowRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.getIsFocused()) {
            this.onEmptyRowFocused();
        }
    }
    /**
     * Updates this section's leg information visibility based on the current active flight plan leg.
     * @param activeSegmentIndex The index of the active leg segment.
     * @param activeLegIndex The index of the active leg in its segment.
     */
    updateLegInfoVisibility(activeSegmentIndex, activeLegIndex) {
        for (let l = 0; l < this.legs.length; l++) {
            const leg = this.legs.tryGet(l);
            if (leg) {
                if (this.segmentIndex.get() < activeSegmentIndex || (this.segmentIndex.get() === activeSegmentIndex && l < activeLegIndex)) {
                    leg.apply({ legIsBehind: true });
                }
                else if (leg.get().legIsBehind) {
                    leg.apply({ legIsBehind: false });
                }
                leg.notify();
            }
        }
    }
    /**
     * Sets the active leg in the flight plan display segment.
     * @param index The index of the leg to set as active.
     */
    setActiveLeg(index) {
        const legInfo = this.legs.tryGet(index);
        if (legInfo !== undefined) {
            legInfo.apply({ isActive: true });
        }
        // Set flight plan focus
        if (legInfo && this.listRef.instance.getSelectedItem() === legInfo && this.props.onFlightPlanFocusSelected) {
            this.props.onFlightPlanFocusSelected(this.getFlightPlanFocusFromLeg(legInfo.get().legDefinition));
        }
    }
    /**
     * Cancels an active leg display in the flight plan display segment.
     * @param index The index of the leg to set as inactive.
     */
    cancelActiveLeg(index) {
        const leg = this.legs.tryGet(index);
        if (leg !== undefined && leg.get().isActive) {
            leg.apply({ isActive: false });
        }
    }
    /**
     * Cancels all active leg displays in section.
     */
    cancelAllActiveLegs() {
        for (let i = 0; i < this.legs.length; i++) {
            const leg = this.legs.tryGet(i);
            if (leg !== undefined && leg.get().isActive) {
                leg.apply({ isActive: false });
            }
        }
    }
    /**
     * Returns the index of the active leg in this section.
     * @returns the index of the active lege, otherwise -1
     */
    getActiveLegIndex() {
        return this.legs.getArray().findIndex(leg => leg.get().isActive);
    }
    /**
     * Scrolls to the active leg.
     */
    scrollToActiveLeg() {
        this.scrollController.gotoIndex(1);
        this.listRef.instance.scrollToIndex(this.getActiveLegIndex());
    }
    /**
     * Ensures the active leg is in view.
     */
    ensureActiveLegInView() {
        this.listRef.instance.ensureIndexInView(this.getActiveLegIndex());
    }
    /**
     * Updates a given leg's row from the leg's current calculations.
     * @param index The index of the leg.
     */
    updateFromLegCalculations(index) {
        var _a;
        const leg = this.legs.tryGet(index);
        if (leg !== undefined) {
            if (((_a = this.segment) === null || _a === void 0 ? void 0 : _a.airway) && index === this.legs.length - 1) {
                leg.apply({ airwayDistance: this.props.fms.getAirwayDistance(this.segment.segmentIndex) });
            }
            else {
                leg.notify();
            }
        }
    }
    /**
     * Sets the leg altitude for a given leg.
     * @param index The index of the leg.
     * @param vnavLeg The vnav leg data.
     * @param revisedAltitude The optional replacement display altitude.
     */
    setLegAltitude(index, vnavLeg, revisedAltitude) {
        const leg = this.legs.tryGet(index);
        if (leg !== undefined) {
            leg.apply({ targetAltitude: revisedAltitude ? revisedAltitude : vnavLeg.altitude, isAdvisory: vnavLeg.isAdvisory });
        }
    }
    /**
     * Gets the number of legs in this section.
     * @returns the number of legs in this section.
     */
    getLegsLength() {
        if (this.legs) {
            return this.legs.length;
        }
        else {
            return 0;
        }
    }
    /**
     * Creates the SelectAirwayInputData when insert airway is selected.
     * @param segmentIndex The index of the segment.
     * @param selectedIndex The selected item index.
     * @param emptyRowSelected Whether the empty row is selected.
     * @returns the SelectAirwayInputData object
     */
    getAirwayInsertData(segmentIndex, selectedIndex, emptyRowSelected) {
        const plan = this.props.fms.getFlightPlan();
        if (emptyRowSelected) {
            const segment = plan.getSegment(segmentIndex);
            if (segment.legs && segment.legs.length < 1) {
                const previousSegment = plan.getSegment(segmentIndex - 1);
                const previousSegmentLastLeg = previousSegment.legs.length - 1;
                return { segmentIndex: segmentIndex - 1, legIndex: previousSegmentLastLeg };
            }
            else {
                const segmentLastLeg = segment.legs.length - 1;
                return { segmentIndex: segmentIndex, legIndex: segmentLastLeg };
            }
        }
        else if (selectedIndex === 0 && segmentIndex > 0) {
            const previousSegment = plan.getSegment(segmentIndex - 1);
            const previousSegmentLastLeg = previousSegment.legs.length - 1;
            return { segmentIndex: segmentIndex - 1, legIndex: previousSegmentLastLeg };
        }
        return { segmentIndex: segmentIndex, legIndex: selectedIndex - 1 };
    }
    /**
     * Checks whether an airway can be inserted from this selected index.
     * @param segmentIndex The index of the segment.
     * @param isEmptyRowSelected If an empty row is selected.
     * @returns the SelectAirwayInputData object
     */
    canAirwayInsert(segmentIndex, isEmptyRowSelected) {
        if (this.isHeaderSelected()) {
            return false;
        }
        const plan = this.props.fms.getFlightPlan();
        if (plan.getSegment(segmentIndex).segmentType !== FlightPlanSegmentType.Enroute) {
            return false;
        }
        if (isEmptyRowSelected) {
            const segment = plan.getSegment(segmentIndex);
            if (segment.legs.length > 0) {
                return true;
            }
        }
        const lastSegment = plan.getSegment(segmentIndex - 1);
        if (lastSegment.legs.length < 1 || lastSegment.legs[lastSegment.legs.length - 1].leg.fixIcao[0] === ' ') {
            return false;
        }
        return true;
    }
    /**
     * Checks if an approach is loaded.
     * @param plan The Flight Plan.
     * @returns A boolean indicating if an approach is loaded.
     */
    isApproachLoaded(plan) {
        if (plan.procedureDetails.approachIndex > -1) {
            return true;
        }
        if (plan.getUserData('visual_approach') && plan.destinationAirport) {
            return true;
        }
        return false;
    }
    /**
     * Gets the loaded approach name.
     * @param plan The Flight Plan.
     * @returns The approach name as a string.
     */
    renderApproachName(plan) {
        const approach = this.props.facilities.destinationFacility ? FmsUtils.getApproachFromPlan(plan, this.props.facilities.destinationFacility) : undefined;
        return (FSComponent.buildComponent(ApproachNameDisplay, { approach: Subject.create(approach !== null && approach !== void 0 ? approach : null) }));
    }
    // TODO remove when all events converted
    /**
     * Checks if the header of this section is selected.
     * @protected
     * @returns A boolean indicating if the header is selected.
     */
    isHeaderSelected() {
        var _a, _b;
        return (_b = (_a = this.headerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.getIsFocused()) !== null && _b !== void 0 ? _b : false;
    }
    // TODO remove when all events converted
    /**
     * Checks if the empty row of this section is selected.
     * @protected
     * @returns A boolean indicating if the empty row is selected.
     */
    isEmptyRowSelected() {
        var _a, _b;
        return (_b = (_a = this.emptyRowRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.getIsFocused()) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * A callback which is called when a leg selection changes.
     * @param item The selected item.
     */
    onLegItemSelected(item) {
        // If selection is null because this section has no existing legs, force focus the empty leg row if it exists.
        if (this.emptyRowRef.getOrDefault() && !item && this.listRef.instance.getIsFocused() && this.legs.length === 0) {
            this.scrollController.gotoIndex(2);
        }
        // Notify flight plan element selection
        if (item && this.props.onFlightPlanElementSelected) {
            this.props.onFlightPlanElementSelected(item.get().legDefinition);
        }
        // Notify flight plan focus
        if (item && this.props.onFlightPlanFocusSelected) {
            this.props.onFlightPlanFocusSelected(this.getFlightPlanFocusFromLeg(item.get().legDefinition));
        }
    }
    /**
     * Gets a flight plan focus from a selected flight plan leg.
     * @param leg The selected flight plan leg.
     * @returns The flight plan focus given the selected leg.
     */
    getFlightPlanFocusFromLeg(leg) {
        const plan = this.props.fms.getFlightPlan();
        if (plan.directToData.segmentIndex >= 0) {
            const dtoSegment = plan.getSegment(plan.directToData.segmentIndex);
            // If the DTO target leg is selected and the DTO is active, focus on the DTO leg instead to show the DTO path.
            if (dtoSegment.legs[plan.directToData.segmentLegIndex] === leg && dtoSegment.offset + plan.directToData.segmentLegIndex + 3 === plan.activeLateralLeg) {
                leg = dtoSegment.legs[plan.directToData.segmentLegIndex + 3];
            }
        }
        return [leg];
    }
    /**
     * A callback which is called when this section's header is focused.
     */
    onHeaderFocused() {
        var _a;
        this.props.onFlightPlanElementSelected && this.props.onFlightPlanElementSelected((_a = this.segment) !== null && _a !== void 0 ? _a : null);
    }
    /**
     * A callback which is called when this section's empty row is focused.
     */
    onEmptyRowFocused() {
        this.props.onFlightPlanElementSelected && this.props.onFlightPlanElementSelected(null);
        this.props.onFlightPlanFocusSelected && this.props.onFlightPlanFocusSelected(this.getFlightPlanFocusWhenEmpty());
    }
    /**
     * Gets a flight plan focus when empty.
     * @returns A flight plan focus.
     */
    getFlightPlanFocusWhenEmpty() {
        var _a;
        if (!this.segment) {
            return [];
        }
        // Try to focus on the leg immediately after where the empty leg row would insert a leg into the plan.
        // If such a leg does not exist, try to focus on the leg immediately before that position.
        const flightPlan = this.props.fms.getFlightPlan();
        const legToFocus = (_a = flightPlan.getNextLeg(this.segment.segmentIndex, this.segment.legs.length - 1)) !== null && _a !== void 0 ? _a : flightPlan.getPrevLeg(this.segment.segmentIndex, this.segment.legs.length);
        return legToFocus ? [legToFocus] : null;
    }
}

/**
 * Render the approach phase of a flight plan.
 */
class FPLApproach extends FPLSection {
    constructor() {
        super(...arguments);
        /**
         * Callback for when CLR is pressed on the header.
         * @returns true if event was handled, false otherwise.
         */
        this.onClrHeader = () => {
            const plan = this.props.fms.getPrimaryFlightPlan();
            const airport = this.props.facilities.destinationFacility;
            const approach = airport ? FmsUtils.getApproachFromPlan(plan, airport) : undefined;
            if (approach) {
                Fms.viewService.open('MessageDialog', true).setInput({
                    renderContent: () => {
                        return (FSComponent.buildComponent("div", { style: 'display: inline-block;' },
                            "Remove ",
                            FSComponent.buildComponent(ApproachNameDisplay, { approach: Subject.create(approach) }),
                            " from flight plan?"));
                    },
                    hasRejectButton: true
                })
                    .onAccept.on((sender, accept) => {
                    if (accept) {
                        this.props.fms.removeApproach();
                        return true;
                    }
                });
            }
            return false;
        };
    }
    /** @inheritdoc */
    getEmptyRowVisbility() {
        return false;
    }
    /** @inheritdoc */
    onHeaderFocused() {
        var _a;
        super.onHeaderFocused();
        const focus = ((_a = this.segment) === null || _a === void 0 ? void 0 : _a.legs.length) ? this.segment.legs : this.getFlightPlanFocusWhenEmpty();
        this.props.onFlightPlanFocusSelected && this.props.onFlightPlanFocusSelected(focus);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    collapseLegs(setHidden) {
        //noop
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { id: 'fpln-approach' },
            FSComponent.buildComponent(FPLHeaderApproach, { ref: this.headerRef, onRegister: this.register, onClr: this.onClrHeader, fms: this.props.fms, facilities: this.props.facilities, onFocused: this.onHeaderFocused.bind(this) }),
            FSComponent.buildComponent(List, { ref: this.listRef, onRegister: this.register, data: this.legs, renderItem: this.renderItem, onItemSelected: this.onLegItemSelected.bind(this), scrollContainer: this.props.scrollContainer })));
    }
}

/**
 * An FPL section header which displays simple strings.
 */
class FPLStringHeader extends FPLHeader {
    constructor() {
        super(...arguments);
        this.textSub = Subject.create('');
        this.textLengthSub = this.textSub.map(text => text.length);
    }
    /** @inheritdoc */
    onAfterRender() {
        super.onAfterRender();
        this.textLengthSub.sub(length => this.setEstimatedNameWidth(length * FPLStringHeader.ESTIMATED_CHAR_WIDTH));
    }
    /** @inheritdoc */
    renderName() {
        return (FSComponent.buildComponent("span", null, this.textSub));
    }
}
FPLStringHeader.ESTIMATED_CHAR_WIDTH = 13.2;

/**
 * An FPL section header for arrivals.
 */
class FPLHeaderArrival extends FPLStringHeader {
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setCollapsed(setCollapsed) {
        //noop
    }
    /** @inheritdoc */
    updateName() {
        var _a;
        let name;
        const plan = this.props.fms.getPrimaryFlightPlan();
        const arrival = (_a = this.props.facilities.arrivalFacility) === null || _a === void 0 ? void 0 : _a.arrivals[plan.procedureDetails.arrivalIndex];
        if (arrival) {
            name = FmsUtils.getArrivalNameAsString(
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.props.facilities.arrivalFacility, arrival, plan.procedureDetails.arrivalTransitionIndex, plan.procedureDetails.destinationRunway);
        }
        else {
            name = '';
        }
        this.textSub.set(name);
    }
}

/**
 * Render the arrival phase of a flight plan.
 */
class FPLArrival extends FPLSection {
    constructor() {
        super(...arguments);
        /**
         * Callback for when CLR is pressed on the header.
         * @returns true if event was handled, false otherwise.
         */
        this.onClrHeader = () => {
            const plan = this.props.fms.getPrimaryFlightPlan();
            const airport = this.props.facilities.arrivalFacility;
            const arrival = airport === null || airport === void 0 ? void 0 : airport.arrivals[plan.procedureDetails.arrivalIndex];
            if (arrival) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const name = FmsUtils.getArrivalNameAsString(airport, arrival, plan.procedureDetails.arrivalTransitionIndex, plan.procedureDetails.destinationRunway);
                Fms.viewService.open('MessageDialog', true).setInput({ inputString: `Remove ${name} from flight plan?`, hasRejectButton: true })
                    .onAccept.on((sender, accept) => {
                    if (accept) {
                        this.props.fms.removeArrival();
                        return true;
                    }
                });
            }
            return false;
        };
    }
    /** @inheritdoc */
    getEmptyRowVisbility() {
        return false;
    }
    /** @inheritdoc */
    onHeaderFocused() {
        var _a;
        super.onHeaderFocused();
        const focus = ((_a = this.segment) === null || _a === void 0 ? void 0 : _a.legs.length) ? this.segment.legs : this.getFlightPlanFocusWhenEmpty();
        this.props.onFlightPlanFocusSelected && this.props.onFlightPlanFocusSelected(focus);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    collapseLegs(setHidden) {
        //noop
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { id: 'fpln-arrival' },
            FSComponent.buildComponent(FPLHeaderArrival, { ref: this.headerRef, onRegister: this.register, onClr: this.onClrHeader, fms: this.props.fms, facilities: this.props.facilities, onFocused: this.onHeaderFocused.bind(this) }),
            FSComponent.buildComponent(List, { ref: this.listRef, onRegister: this.register, data: this.legs, renderItem: this.renderItem, onItemSelected: this.onLegItemSelected.bind(this), scrollContainer: this.props.scrollContainer })));
    }
}

/** The FPLEmptyRow component. */
class FPLEmptyRow extends UiControl {
    constructor() {
        super(...arguments);
        this.nameContainerRef = FSComponent.createRef();
    }
    /** @inheritdoc */
    getHighlightElement() {
        return this.nameContainerRef.instance;
    }
    /** @inheritdoc */
    renderControl() {
        return (FSComponent.buildComponent("div", { class: 'fix-container' },
            FSComponent.buildComponent("div", { class: 'fix-name', ref: this.nameContainerRef },
                FSComponent.buildComponent("span", { style: 'padding-right:5em' }, "______"))));
    }
}

/**
 * An FPL section header for departures.
 */
class FPLHeaderDeparture extends FPLStringHeader {
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setCollapsed(setCollapsed) {
        //noop
    }
    /** @inheritdoc */
    updateName() {
        var _a;
        let name;
        const plan = this.props.fms.getPrimaryFlightPlan();
        const origin = plan.originAirport;
        const hasRunway = plan.procedureDetails.originRunway != undefined;
        const departure = (_a = this.props.facilities.originFacility) === null || _a === void 0 ? void 0 : _a.departures[plan.procedureDetails.departureIndex];
        if (departure && origin !== undefined) {
            name = FmsUtils.getDepartureNameAsString(
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.props.facilities.originFacility, departure, plan.procedureDetails.departureTransitionIndex, plan.procedureDetails.originRunway);
        }
        else if (origin !== undefined && origin != '' && !hasRunway) {
            name = 'Origin – RW _ _';
        }
        else if (origin && origin !== undefined && hasRunway) {
            name = 'Origin – ' + ICAO.getIdent(origin);
        }
        else {
            name = 'Origin – _ _ _ _';
        }
        this.textSub.set(name);
    }
}

/**
 * Render the departure phase of the flight plan.
 */
class FPLDeparture extends FPLSection {
    constructor() {
        super(...arguments);
        /** @inheritdoc */
        this.onUpperKnobLeg = (node) => {
            const legIndex = this.listRef.instance.getListItemIndex(node);
            const plan = this.props.fms.getFlightPlan();
            const origin = plan.originAirport;
            if (origin && legIndex === 0) {
                Fms.viewService.open('SetRunway', true).setInput(this.props.facilities.originFacility)
                    .onAccept.on((sender, data) => {
                    this.props.fms.setOrigin(this.props.facilities.originFacility, data);
                });
            }
            else {
                this.onUpperKnobLegBase(node);
            }
        };
        /** Callback firing when upper knob event on the header is fired. */
        this.onUpperKnobEmptyRow = () => {
            const plan = this.props.fms.getFlightPlan();
            const origin = plan.originAirport;
            if (!origin || origin === undefined) {
                Fms.viewService.open('WptInfo', true)
                    .onAccept.on((sender, fac) => {
                    // check if its airportfacility interface
                    if ('bestApproach' in fac) {
                        this.props.fms.setOrigin(fac);
                        Fms.viewService.open('SetRunway', true).setInput(fac)
                            .onAccept.on((subSender, data) => {
                            this.props.fms.setOrigin(this.props.facilities.originFacility, data);
                        });
                    }
                    else {
                        const firstEnrSegment = this.props.fms.getFlightPlan().segmentsOfType(FlightPlanSegmentType.Enroute).next().value;
                        if (firstEnrSegment) {
                            this.props.fms.insertWaypoint(firstEnrSegment.segmentIndex, fac, 0);
                        }
                    }
                });
            }
        };
        /**
         * Callback firing when CLR on the header is pressed.
         * @returns true if CLR is handeled, false if not.
         */
        this.onClrHeader = () => {
            const plan = this.props.fms.getPrimaryFlightPlan();
            const airport = this.props.facilities.originFacility;
            const departure = airport === null || airport === void 0 ? void 0 : airport.departures[plan.procedureDetails.departureIndex];
            if (departure) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const name = FmsUtils.getDepartureNameAsString(airport, departure, plan.procedureDetails.departureTransitionIndex, plan.procedureDetails.originRunway);
                Fms.viewService.open('MessageDialog', true).setInput({ inputString: `Remove ${name} from flight plan?`, hasRejectButton: true })
                    .onAccept.on((sender, accept) => {
                    if (accept) {
                        this.props.fms.removeDeparture();
                        return true;
                    }
                });
            }
            return false;
        };
        /** @inheritdoc */
        this.onClrLeg = (node) => {
            const legIndex = this.listRef.instance.getListItemIndex(node);
            const plan = this.props.fms.getFlightPlan();
            const origin = plan.originAirport;
            if (origin && legIndex == 0) {
                Fms.viewService.open('MessageDialog', true).setInput({ inputString: `Remove ${ICAO.getIdent(origin)}?`, hasRejectButton: true })
                    .onAccept.on((sender, accept) => {
                    if (accept) {
                        this.props.fms.setOrigin(undefined);
                        return true;
                    }
                });
            }
            else {
                return this.onClrLegBase(node);
            }
            return false;
        };
    }
    /** @inheritdoc */
    getEmptyRowVisbility() {
        const plan = this.props.fms.getFlightPlan(0);
        const origin = plan.originAirport;
        const hasRunway = plan.procedureDetails.originRunway != undefined;
        return !hasRunway && (!origin || origin == '');
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    collapseLegs(setHidden) {
        //noop
    }
    /** @inheritdoc */
    onHeaderFocused() {
        var _a;
        super.onHeaderFocused();
        let focus;
        if (this.segment && this.segment.segmentType === FlightPlanSegmentType.Departure) {
            focus = ((_a = this.segment) === null || _a === void 0 ? void 0 : _a.legs.length) ? this.segment.legs : this.getFlightPlanFocusWhenEmpty();
        }
        else {
            // Only an origin airport exists.
            const origin = this.props.facilities.originFacility;
            focus = origin !== null && origin !== void 0 ? origin : this.getFlightPlanFocusWhenEmpty();
        }
        this.props.onFlightPlanFocusSelected && this.props.onFlightPlanFocusSelected(focus);
    }
    /**
     * Render the departure section.
     * @returns A VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { id: 'fpln-departure' },
            FSComponent.buildComponent(FPLHeaderDeparture, { ref: this.headerRef, onRegister: this.register, facilities: this.props.facilities, fms: this.props.fms, onClr: this.onClrHeader, onFocused: this.onHeaderFocused.bind(this) }),
            FSComponent.buildComponent(List, { ref: this.listRef, onRegister: this.register, data: this.legs, renderItem: this.renderItem, onItemSelected: this.onLegItemSelected.bind(this), scrollContainer: this.props.scrollContainer }),
            FSComponent.buildComponent(FPLEmptyRow, { onRegister: this.register, ref: this.emptyRowRef, onUpperKnobInc: this.onUpperKnobEmptyRow, onFocused: this.onEmptyRowFocused.bind(this) })));
    }
}

/**
 * An FPL section header for destination segments.
 */
class FPLHeaderDestination extends FPLStringHeader {
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setCollapsed(setCollapsed) {
        //noop
    }
    /** @inheritdoc */
    updateName() {
        let name;
        const plan = this.props.fms.getFlightPlan();
        const destination = plan.destinationAirport;
        const hasRunway = plan.procedureDetails.destinationRunway != undefined;
        if (destination && destination !== undefined && (plan.procedureDetails.arrivalIndex > -1 || plan.procedureDetails.approachIndex > -1)) {
            name = 'Destination – ' + ICAO.getIdent(destination);
        }
        else if (destination && destination !== undefined && !hasRunway) {
            name = 'Destination – RW _ _';
        }
        else if (destination && destination !== undefined && hasRunway) {
            name = 'Destination – ' + ICAO.getIdent(destination);
        }
        else {
            name = 'Destination – _ _ _ _';
        }
        this.textSub.set(name);
    }
}

/**
 * Render the destination info for a flight plan.
 */
class FPLDestination extends FPLSection {
    constructor() {
        super(...arguments);
        /** @inheritdoc */
        this.onUpperKnobLegBase = (node) => {
            const legIndex = this.listRef.instance.getListItemIndex(node);
            const plan = this.props.fms.getFlightPlan();
            const destination = plan.destinationAirport;
            if (destination && legIndex == 0) {
                Fms.viewService.open('SetRunway', true).setInput(this.props.facilities.destinationFacility)
                    .onAccept.on((subSender, data) => {
                    this.props.fms.setDestination(this.props.facilities.destinationFacility, data);
                });
            }
        };
        /** Callback firing when upper knob event on the header is fired. */
        this.onUpperKnobEmptyRow = () => {
            const plan = this.props.fms.getFlightPlan();
            const destination = plan.destinationAirport;
            if (!destination || destination === undefined) {
                // EMPTY ROW
                Fms.viewService.open('WptInfo', true)
                    .onAccept.on((sender, fac) => {
                    this.props.fms.setDestination(fac);
                    Fms.viewService.open('SetRunway', true).setInput(fac).onAccept.on((subSender, data) => {
                        this.props.fms.setDestination(this.props.facilities.destinationFacility, data);
                    });
                });
            }
        };
        /** @inheritdoc */
        this.onClrLeg = (node) => {
            const legIndex = this.listRef.instance.getListItemIndex(node);
            const plan = this.props.fms.getFlightPlan();
            const destination = plan.destinationAirport;
            if (destination && legIndex == 0) {
                Fms.viewService.open('MessageDialog', true).setInput({ inputString: `Remove ${ICAO.getIdent(destination)}?`, hasRejectButton: true }).onAccept.on((sender, accept) => {
                    if (accept) {
                        this.props.fms.setDestination(undefined);
                        return true;
                    }
                });
            }
            else {
                return this.onClrLegBase(node);
            }
            return false;
        };
    }
    /** @inheritdoc */
    getEmptyRowVisbility() {
        const plan = this.props.fms.getFlightPlan();
        const destination = plan.destinationAirport;
        const hasRunway = plan.procedureDetails.destinationRunway != undefined;
        const noAppArr = plan.procedureDetails.arrivalIndex < 0 && plan.procedureDetails.approachIndex < 0;
        return noAppArr && !hasRunway && (!destination || destination == '');
    }
    /** @inheritdoc */
    onHeaderFocused() {
        super.onHeaderFocused();
        const destination = this.props.facilities.destinationFacility;
        const focus = destination !== null && destination !== void 0 ? destination : this.getFlightPlanFocusWhenEmpty();
        this.props.onFlightPlanFocusSelected && this.props.onFlightPlanFocusSelected(focus);
    }
    /** @inheritdoc */
    collapseLegs() {
        //noop
    }
    /**
     * Render a destination line.
     * @returns a VNode
     */
    render() {
        return (FSComponent.buildComponent("div", { id: 'fpln-destination' },
            FSComponent.buildComponent(FPLHeaderDestination, { ref: this.headerRef, onRegister: this.register, fms: this.props.fms, facilities: this.props.facilities, onFocused: this.onHeaderFocused.bind(this) }),
            FSComponent.buildComponent(List, { ref: this.listRef, onRegister: this.register, data: this.legs, renderItem: this.renderItem, onItemSelected: this.onLegItemSelected.bind(this), scrollContainer: this.props.scrollContainer }),
            FSComponent.buildComponent(FPLEmptyRow, { onRegister: this.register, ref: this.emptyRowRef, onUpperKnobInc: this.onUpperKnobEmptyRow, onFocused: this.onEmptyRowFocused.bind(this) })));
    }
}

/**
 * An FPL section header for enroute segments.
 */
class FPLHeaderEnroute extends FPLStringHeader {
    /** @inheritdoc */
    setCollapsed(setCollapsed) {
        this._isCollapsed = setCollapsed;
        this.updateName();
    }
    /** @inheritdoc */
    updateName() {
        var _a;
        const segment = this.props.fms.getFlightPlan().getSegment((_a = this.props.segmentIndex) === null || _a === void 0 ? void 0 : _a.get());
        this.setIsVisible(segment.airway !== undefined || this.props.fms.isFirstEnrouteSegment(segment.segmentIndex));
        let name = '';
        if (segment !== undefined) {
            if (segment.airway !== undefined) {
                name = 'Airway - ' + segment.airway;
            }
            else {
                name = 'Enroute';
            }
            if (this.isCollapsed) {
                name += ' (collapsed)';
            }
        }
        this.textSub.set(name);
    }
}

/** Render the enroute phase of the flight plan. */
class FPLEnroute extends FPLSection {
    constructor() {
        super(...arguments);
        this.isCollapsed = false;
        /**
         * Callback firing when CLR on the header is pressed.
         * @returns true if CLR is handeled, false if not.
         */
        this.onClrHeader = () => {
            if (this.segment !== undefined && this.segment.airway !== undefined) {
                Fms.viewService.open('MessageDialog', true).setInput({ inputString: `Remove ${this.segment.airway} from flight plan?`, hasRejectButton: true })
                    .onAccept.on((sender, accept) => {
                    if (accept) {
                        this.props.fms.removeAirway(this.segmentIndex.get());
                        return true;
                    }
                });
            }
            return false;
        };
    }
    /** @inheritdoc */
    getEmptyRowVisbility() {
        var _a;
        let showEmptyRow = true;
        const plan = this.props.fms.getFlightPlan();
        const segmentIndex = this.segmentIndex.get();
        if (((_a = this.segment) === null || _a === void 0 ? void 0 : _a.airway) !== undefined) {
            showEmptyRow = false;
        }
        else if (segmentIndex + 1 < plan.segmentCount && plan.getSegment(segmentIndex + 1).airway !== undefined) {
            showEmptyRow = false;
        }
        return showEmptyRow;
    }
    /**
     * Adds a leg to the flight plan display segment.
     * @param index The index to add at.
     * @param leg The leg to add.
     */
    addLeg(index, leg) {
        super.addLeg(index, leg);
        this.updateHeader();
        this.updateAirwayLegs();
    }
    /**
     * Removes a leg from the flight plan display segment.
     * @param index The index to remove at.
     */
    removeLeg(index) {
        super.removeLeg(index);
        this.updateHeader();
        this.updateAirwayLegs();
    }
    /**
     * Updates this section's airway legs.
     */
    updateAirwayLegs() {
        var _a, _b;
        if (((_a = this.segment) === null || _a === void 0 ? void 0 : _a.airway) === undefined) {
            return;
        }
        for (let l = 0; l < this.legs.length; l++) {
            const leg = this.legs.tryGet(l);
            if (leg) {
                const info = { isAirwayFix: true };
                leg.apply({ isAirwayFix: true });
                if (leg.get().legDefinition.name == ((_b = this.segment) === null || _b === void 0 ? void 0 : _b.airway.split('.')[1])) {
                    info.isAirwayExitFix = true;
                }
                leg.apply(info);
            }
        }
    }
    /**
     * Method called to collapse or uncollapse this section.
     * @param setCollapsed is whether to set the legs hidden or not
     */
    collapseLegs(setCollapsed) {
        for (let i = 0; i < this.legs.getArray().length; i++) {
            const leg = this.legs.tryGet(i);
            if (leg !== undefined) {
                leg.apply({ isCollapsed: setCollapsed });
            }
        }
        this.isCollapsed = setCollapsed;
        this.headerRef.instance.setCollapsed(setCollapsed);
    }
    /** @inheritdoc */
    onHeaderFocused() {
        var _a, _b, _c;
        super.onHeaderFocused();
        let focus = null;
        if (((_a = this.segment) === null || _a === void 0 ? void 0 : _a.airway) === undefined) {
            const plan = this.props.fms.getFlightPlan();
            for (const segment of plan.segmentsOfType(FlightPlanSegmentType.Enroute)) {
                if (segment.legs.length > 0) {
                    (focus !== null && focus !== void 0 ? focus : (focus = [])).push(...segment.legs);
                }
            }
        }
        else {
            focus = (_c = (_b = this.segment) === null || _b === void 0 ? void 0 : _b.legs) !== null && _c !== void 0 ? _c : null;
        }
        this.props.onFlightPlanFocusSelected && this.props.onFlightPlanFocusSelected(focus);
    }
    /**
     * Render an enroute container.
     * @returns a VNode
     */
    render() {
        return (FSComponent.buildComponent("div", { id: 'fpln-enroute' },
            FSComponent.buildComponent(FPLHeaderEnroute, { ref: this.headerRef, onRegister: this.register, facilities: this.props.facilities, fms: this.props.fms, onClr: this.onClrHeader, segmentIndex: this.segmentIndex, onFocused: this.onHeaderFocused.bind(this) }),
            FSComponent.buildComponent(List, { ref: this.listRef, onRegister: this.register, data: this.legs, renderItem: this.renderItem, onItemSelected: this.onLegItemSelected.bind(this), scrollContainer: this.props.scrollContainer }),
            FSComponent.buildComponent(FPLEmptyRow, { onRegister: this.register, ref: this.emptyRowRef, onUpperKnobInc: this.onUpperKnobLegBase, onFocused: this.onEmptyRowFocused.bind(this) })));
    }
}

/**
 * Represent the origin segment of a flight plan listing.
 */
class FPLOrigin extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.origin = Subject.create('_____');
        this.destination = Subject.create('_____');
        this.fplDirectTo = FSComponent.createRef();
        this.origDestRef = FSComponent.createRef();
    }
    /**
     * Handles a origin/dest change event.
     * @param e The change event itself.
     */
    onOriginDestChanged(e) {
        switch (e.type) {
            case OriginDestChangeType.OriginAdded:
                e.airport && this.origin.set(ICAO.getIdent(e.airport) + ' /');
                break;
            case OriginDestChangeType.OriginRemoved:
                this.origin.set('_____ /');
                break;
            case OriginDestChangeType.DestinationAdded:
                e.airport && this.destination.set(ICAO.getIdent(e.airport));
                break;
            case OriginDestChangeType.DestinationRemoved:
                this.destination.set('_____');
                break;
        }
    }
    /**
     * Handles when a random direct to is active and the FPL header should indicate such.
     * @param dtoIdent The ident for the direct to waypoint.
     */
    onDirectToRandomActive(dtoIdent) {
        this.origin.set('');
        this.destination.set(dtoIdent);
        this.fplDirectTo.instance.style.display = '';
        this.origDestRef.instance.style.color = 'white';
    }
    /**
     * Handles when a random direct to is canceled.
     * @param plan is the Flightplan
     */
    removeDirectToRandom(plan) {
        this.fplDirectTo.instance.style.display = 'none';
        this.origDestRef.instance.style.color = 'cyan';
        const origin = plan.originAirport;
        if (origin !== undefined) {
            this.setOrigin(ICAO.getIdent(origin));
        }
        else {
            this.setOrigin('_____');
        }
        const destination = plan.destinationAirport;
        if (destination !== undefined) {
            this.setDestination(ICAO.getIdent(destination));
        }
        else {
            this.setDestination('_____');
        }
    }
    /**
     * Handles setting the origin string.
     * @param origin The ident for the origin.
     */
    setOrigin(origin) {
        this.origin.set(origin + ' /');
    }
    /**
     * Handles setting the destination string.
     * @param destination The ident for the origin.
     */
    setDestination(destination) {
        this.destination.set(destination);
    }
    /**
     * Initializes the Direct To symbol to hidden
     */
    onAfterRender() {
        this.fplDirectTo.instance.style.display = 'none';
    }
    /**
     * Render an origin block.
     * @returns a VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { id: "origDest", ref: this.origDestRef },
            FSComponent.buildComponent("span", null, this.origin),
            FSComponent.buildComponent("span", null, this.destination),
            FSComponent.buildComponent("div", { class: "fpl-directTo", ref: this.fplDirectTo },
                FSComponent.buildComponent("svg", null,
                    FSComponent.buildComponent("path", { d: 'm 27 13 l -7.2 -7.2 l 0 5.04 l -19.04 0 l 0 4.32 l 19.04 0 l 0 5.04 l 7.2 -7.2 z', fill: "magenta", scale: "1" }),
                    FSComponent.buildComponent("text", { x: "4", y: "20", fill: "magenta", size: "12" }, "D")))));
    }
}

/// <reference types="msfstypes/JS/Avionics" />
/**
 * FPLDetails holds the core logic of the flight plan display and interacts with button events.
 */
class FPLDetails extends DisplayComponent {
    /**
     * Constructor
     * @param props the props
     */
    constructor(props) {
        super(props);
        this.isExtendedView = false;
        /** The complete flight plan container, including origin and destination info. */
        this.fplnContainer = FSComponent.createRef();
        /** The departure through arrival phases, all of the FPLSections. */
        this.fplDetailsContainer = FSComponent.createRef();
        this.sectionListRef = FSComponent.createRef();
        /**
         * Gets the top location of the list element for the specified segment and leg.
         * @param segmentIndex The segment index.
         * @param legIndex The leg index.
         * @returns list element y coordinate
         */
        this.getListElementTopLocation = (segmentIndex, legIndex) => {
            const section = this.controller.sectionRefs[segmentIndex];
            if (section) {
                if (section.instance.getLegsLength() > 0) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    return section.instance.getListRef().instance.getListItemInstance(legIndex).getContainerElementLocation()[1] + 4;
                }
                else {
                    console.warn('getListElementTopLocation: Section exists, but there are no legs in this segment');
                    return -1;
                }
            }
            else {
                console.error('getListElementTopLocation: Section Ref could not be found');
                return -1;
            }
        };
        this.store = new FPLDetailsStore(props.bus);
        this.controller = new FPLDetailsController(this.store, props.fms, props.bus, this.scrollToActiveLeg.bind(this));
    }
    /**
     * Do stuff after rendering.
     */
    onAfterRender() {
        super.onAfterRender();
        this.controller.initialize();
    }
    /** Called when the fpl view is resumed. */
    fplViewResumed() {
        this.controller.initDtoLeg();
    }
    /** Called when the fpl view is opened. */
    fplViewOpened() {
        this.scrollToActiveLeg();
    }
    /**
     * A method called when the view scroll is toggled.
     * @param enabled if the scroll is enabled.
     */
    onScrollToggled(enabled) {
        this.controller.scrollMode = enabled ? ScrollMode.MANUAL : ScrollMode.AUTO;
        this.scrollToActiveLeg();
    }
    /** Scrolls to the active leg in the flight plan. */
    scrollToActiveLeg() {
        for (let i = 0; i < this.controller.sectionRefs.length; i++) {
            const section = this.controller.sectionRefs[i];
            const activeLegIndex = section.instance.getActiveLegIndex();
            if (activeLegIndex > -1) {
                if (this.controller.scrollMode === ScrollMode.MANUAL) {
                    this.sectionListRef.instance.scrollToIndex(i);
                    section.instance.scrollToActiveLeg();
                }
                else {
                    section.instance.ensureActiveLegInView();
                }
                return;
            }
        }
        // No active leg was found.
        if (this.controller.scrollMode === ScrollMode.MANUAL && !this.sectionListRef.instance.getSelectedElement()) {
            this.sectionListRef.instance.scrollToIndex(0);
        }
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.MENU:
                this.sendActionToSections(s => s.instance.onMenu());
                return true;
            case FmsHEvent.DIRECTTO: {
                this.sendActionToSections((s) => { return s.instance.onDirectTo(); });
                return true;
            }
        }
        return false;
    }
    /**
     * Calls all sections with the specified function.
     * @param fn A function returning a boolean indicating if the calls to other sections should continue.
     */
    sendActionToSections(fn) {
        const sectionLen = this.controller.sectionRefs.length;
        for (let i = 0; i < sectionLen; i++) {
            if (fn(this.controller.sectionRefs[i])) {
                break;
            }
        }
    }
    /**
     * Responds to a flight plan element selections.
     * @param selection The selection that was made.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onFlightPlanElementSelected(selection) {
        // noop
    }
    /**
     * Responds to flight plan focus selections.
     * @param focus The focus selection that was made.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onFlightPlanFocusSelected(focus) {
        // noop
    }
    /**
     * Renders a section in the flight plan.
     * @param data The data object for this section.
     * @param registerFn The control register function.
     * @param index The index.
     * @returns The rendered VNode.
     */
    renderItem(data, registerFn, index) {
        let section;
        const ref = FSComponent.createRef();
        // select datatemplate
        switch (data.segmentType) {
            case FlightPlanSegmentType.Departure:
                section = (FSComponent.buildComponent(FPLDeparture, { onRegister: registerFn, ref: ref, fms: this.props.fms, detailsController: this.controller, facilities: this.store.facilityInfo, segmentIndex: data.segmentIndex, scrollContainer: this.fplnContainer, isExtendedView: this.isExtendedView, onFlightPlanElementSelected: this.onFlightPlanElementSelected.bind(this), onFlightPlanFocusSelected: this.onFlightPlanFocusSelected.bind(this) }));
                break;
            case FlightPlanSegmentType.Arrival:
                section = (FSComponent.buildComponent(FPLArrival, { onRegister: registerFn, ref: ref, fms: this.props.fms, detailsController: this.controller, facilities: this.store.facilityInfo, segmentIndex: data.segmentIndex, scrollContainer: this.fplnContainer, isExtendedView: this.isExtendedView, onFlightPlanElementSelected: this.onFlightPlanElementSelected.bind(this), onFlightPlanFocusSelected: this.onFlightPlanFocusSelected.bind(this) }));
                break;
            case FlightPlanSegmentType.Approach:
                section = (FSComponent.buildComponent(FPLApproach, { onRegister: registerFn, ref: ref, fms: this.props.fms, detailsController: this.controller, facilities: this.store.facilityInfo, segmentIndex: data.segmentIndex, scrollContainer: this.fplnContainer, isExtendedView: this.isExtendedView, onFlightPlanElementSelected: this.onFlightPlanElementSelected.bind(this), onFlightPlanFocusSelected: this.onFlightPlanFocusSelected.bind(this) }));
                break;
            case FlightPlanSegmentType.Destination:
                section = (FSComponent.buildComponent(FPLDestination, { onRegister: registerFn, ref: ref, fms: this.props.fms, detailsController: this.controller, facilities: this.store.facilityInfo, segmentIndex: data.segmentIndex, scrollContainer: this.fplnContainer, isExtendedView: this.isExtendedView, onFlightPlanElementSelected: this.onFlightPlanElementSelected.bind(this), onFlightPlanFocusSelected: this.onFlightPlanFocusSelected.bind(this) }));
                break;
            default:
                section = (FSComponent.buildComponent(FPLEnroute, { onRegister: registerFn, ref: ref, fms: this.props.fms, detailsController: this.controller, facilities: this.store.facilityInfo, segmentIndex: data.segmentIndex, scrollContainer: this.fplnContainer, isExtendedView: this.isExtendedView, onFlightPlanElementSelected: this.onFlightPlanElementSelected.bind(this), onFlightPlanFocusSelected: this.onFlightPlanFocusSelected.bind(this) }));
        }
        this.controller.sectionRefs.splice(index, 0, section);
        return section;
    }
    /**
     * A callback which is called when a flight plan segment is selected.
     * @param segment The selected segment.
     */
    onSegmentSelected(segment) {
        if (!segment && this.store.segments.length > 0 && this.sectionListRef.instance.getIsFocused()) {
            this.sectionListRef.instance.scrollToIndex(0);
        }
    }
    /**
     * Render the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { id: 'fpl-details-container', ref: this.fplDetailsContainer },
            FSComponent.buildComponent(FPLOrigin, { onRegister: this.props.onRegister, ref: this.controller.originRef, fms: this.props.fms, facilities: this.store.facilityInfo, segmentIndex: -1 }),
            FSComponent.buildComponent("hr", null),
            FSComponent.buildComponent("div", null,
                FSComponent.buildComponent("span", { id: "dtk", class: "smallText white" }, "DTK"),
                FSComponent.buildComponent("span", { id: "dis", class: "smallText white" }, "DIS")),
            FSComponent.buildComponent("div", { class: 'fpln-container', ref: this.fplnContainer },
                FSComponent.buildComponent(List, { ref: this.sectionListRef, onRegister: this.props.onRegister, data: this.store.segments, renderItem: this.renderItem.bind(this), onItemSelected: this.onSegmentSelected.bind(this), scrollContainer: this.fplnContainer }),
                FSComponent.buildComponent(FplActiveLegArrow, { ref: this.controller.legArrowRef, getLegDomLocation: this.getListElementTopLocation })),
            FSComponent.buildComponent(ScrollBar, null)));
    }
}

/**
 * FPLDetails holds the core logic of the flight plan display and interacts with button events.
 */
class MFDFPLDetails extends FPLDetails {
    constructor() {
        super(...arguments);
        this.isExtendedView = true;
    }
    /** Called when the fpl view is opened. */
    fplViewOpened() {
        super.fplViewOpened();
        this.controller.legArrowRef.instance.updateArrows(this.store.activeLegState.get(), this.store.activeLeg.get(), this.props.fms.getFlightPlan());
    }
    /** @inheritdoc */
    onFlightPlanElementSelected(selection) {
        this.props.selection.set(selection);
    }
    /** @inheritdoc */
    onFlightPlanFocusSelected(focus) {
        this.props.focus.set(focus);
    }
    /**
     * Render the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { ref: this.fplDetailsContainer },
            FSComponent.buildComponent(GroupBox, { title: "Active Flight Plan" },
                FSComponent.buildComponent(FPLOrigin, { onRegister: this.props.onRegister, ref: this.controller.originRef, fms: this.props.fms, facilities: this.store.facilityInfo, segmentIndex: FlightPlanSegment.Empty.segmentIndex }),
                FSComponent.buildComponent("br", null),
                FSComponent.buildComponent("div", null,
                    FSComponent.buildComponent("span", { id: "dtk", class: "smallText white" }, "DTK"),
                    FSComponent.buildComponent("span", { id: "dis", class: "smallText white" }, "DIS"),
                    FSComponent.buildComponent("span", { id: "alt", class: "smallText white" }, "ALT")),
                FSComponent.buildComponent("hr", { class: "mfd-flightplan-hr" }),
                FSComponent.buildComponent("div", { class: 'mfd-fpln-container', style: "height:320px;", ref: this.fplnContainer },
                    FSComponent.buildComponent(List, { ref: this.sectionListRef, onRegister: this.props.onRegister, data: this.store.segments, renderItem: this.renderItem.bind(this), onItemSelected: this.onSegmentSelected.bind(this), scrollContainer: this.fplnContainer }),
                    FSComponent.buildComponent(FplActiveLegArrow, { ref: this.controller.legArrowRef, getLegDomLocation: this.getListElementTopLocation })),
                FSComponent.buildComponent(ScrollBar, null))));
    }
}

/**
 * A component that displays the active VNAV profile on the MFD flight plan page.
 */
class MFDFPLVNavProfile extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.waypointSubject = ComputedSubject.create(undefined, this.renderWaypoint.bind(this));
        this.todBodLabel = Subject.create('TOD');
        this.fpaSubject = ComputedSubject.create(undefined, this.renderFpa.bind(this));
        this.targetAltSub = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(0));
        this.todTimeSub = NumberUnitSubject.createFromNumberUnit(UnitType.SECOND.createNumber(0));
        this.vsTargetSub = NumberUnitSubject.createFromNumberUnit(UnitType.FPM.createNumber(0));
        this.vsRequiredSub = NumberUnitSubject.createFromNumberUnit(UnitType.FPM.createNumber(0));
        this.vdevSub = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(0));
        this.currentGroundSpeed = 30;
        this.currentAltitude = 0;
        this.todDistance = -1;
        this.bodDistance = -1;
        this.showPathDetails = false;
    }
    /** @inheritdoc */
    onAfterRender() {
        const vnav = this.props.bus.getSubscriber();
        this.props.bus.getSubscriber().on('ground_speed').withPrecision(1).handle(gs => this.currentGroundSpeed = gs);
        this.props.bus.getSubscriber().on('alt').withPrecision(0).handle(alt => this.currentAltitude = alt);
        vnav.on('vnavFpa').atFrequency(1).handle(fpa => {
            const val = fpa === 0 ? undefined : fpa;
            this.fpaSubject.set(val);
            this.setVsTarget(val);
        });
        vnav.on('vnavConstraintLegIndex').whenChanged().handle(legIndex => {
            let leg;
            try {
                leg = this.props.flightPlanner.getFlightPlan(0).getLeg(legIndex);
            }
            catch ( /* Continue */_a) { /* Continue */ }
            if (leg !== undefined) {
                this.waypointSubject.set(leg.name);
            }
            else {
                this.waypointSubject.set(undefined);
            }
        });
        vnav.on('vnavNextConstraintAltitude').whenChanged().handle(alt => this.targetAltSub.set(alt <= this.currentAltitude && alt > 0 ? alt : NaN));
        vnav.on('vnavRequiredVs').atFrequency(1).handle(reqVs => this.setVsRequired(reqVs));
        vnav.on('vnavTodDistance').atFrequency(1).handle(distance => {
            this.todDistance = distance;
            this.setTodBod();
        });
        vnav.on('vnavBodDistance').atFrequency(1).handle(distance => {
            this.bodDistance = distance;
            this.setTodBod();
        });
        vnav.on('vnavVDev').atFrequency(1).handle(deviation => {
            if (!this.showPathDetails || Math.abs(deviation) > 10000) {
                this.vdevSub.set(NaN);
            }
            else {
                this.vdevSub.set(-deviation);
            }
        });
        this.props.bus.getSubscriber().on('lnavDis').atFrequency(1).handle(dis => {
            if (!isNaN(dis) && dis > 0) {
                this.setVsRequired(dis);
            }
        });
    }
    /**
     * Sets whether to display the path details in the window or blank them.
     */
    setShowPathDetails() {
        const constraintAlt = this.targetAltSub.get().asUnit(UnitType.FOOT);
        let showPathDetails = false;
        if (!isNaN(constraintAlt) && this.currentAltitude > constraintAlt - 100 && this.currentGroundSpeed > 30) {
            if ((this.todDistance > 0 && this.todDistance < 999999 && UnitType.METER.convertTo(this.todDistance, UnitType.NMILE) / (this.currentGroundSpeed / 60) <= 1)
                || (this.bodDistance > 0 && this.todDistance <= 0)) {
                showPathDetails = true;
            }
        }
        this.showPathDetails = showPathDetails;
    }
    /**
     * Sets the TodBod fields.
     */
    setTodBod() {
        let distance = NaN;
        let label = 'TOD';
        this.setShowPathDetails();
        if (this.showPathDetails) {
            if (this.todDistance > 100) {
                label = 'TOD';
                distance = this.todDistance;
            }
            else {
                label = 'BOD';
                distance = this.bodDistance;
            }
        }
        else if (this.todDistance < 999999 && this.todDistance > 0) {
            label = 'TOD';
            distance = this.todDistance;
        }
        this.todBodLabel.set(label);
        this.todTimeSub.set(isNaN(distance) ? distance : UnitType.METER.convertTo(distance, UnitType.NMILE) / this.currentGroundSpeed, UnitType.HOUR);
    }
    /**
     * Renders the waypoint field.
     * @param name The ICAO to render.
     * @returns The rendered field.
     */
    renderWaypoint(name) {
        if (name !== undefined) {
            return name;
        }
        else {
            return '_ _ _ _ _ _ _ _ _ _ _ _';
        }
    }
    /**
     * Sets the current vertical speed target.
     * @param fpa The current flight path angle.
     */
    setVsTarget(fpa) {
        if (fpa === undefined || (this.todDistance <= 0 && this.bodDistance <= 0) || this.currentGroundSpeed < 30) {
            this.vsTargetSub.set(NaN);
        }
        else {
            this.vsTargetSub.set(this.currentGroundSpeed * Math.tan(UnitType.DEGREE.convertTo(-fpa, UnitType.RADIAN)), UnitType.KNOT);
        }
    }
    /**
     * Renders the target FPA field.
     * @param fpa The FPA to render
     * @returns The rendered field.
     */
    renderFpa(fpa) {
        if (fpa !== undefined) {
            return `-${fpa.toFixed(1)}°`;
        }
        else {
            return '_ _ _ _°';
        }
    }
    /**
     * Sets the current required vertical speed.
     * @param vs is the vs required value in fpm.
     */
    setVsRequired(vs) {
        if (vs < 0 && this.showPathDetails) {
            this.vsRequiredSub.set(vs, UnitType.FPM);
        }
        else {
            this.vsRequiredSub.set(NaN);
        }
    }
    /**
     * Renders the component.
     * @returns The rendered VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", null,
            FSComponent.buildComponent("div", { class: "mfd-fpl-vnav row-1" },
                FSComponent.buildComponent("div", { class: 'mfd-fpl-vnav-wpt' },
                    FSComponent.buildComponent("label", null, "WPT"),
                    FSComponent.buildComponent("span", null, this.waypointSubject)),
                FSComponent.buildComponent(NumberUnitDisplay, { value: this.targetAltSub, displayUnit: Subject.create(UnitType.FOOT), formatter: NumberFormatter.create({ precision: 1, nanString: '_ _ _ _ _' }), class: 'mfd-fpl-vnav-tgtalt' }),
                FSComponent.buildComponent("div", { class: 'mfd-fpl-vnav-tod' },
                    FSComponent.buildComponent("label", null, this.todBodLabel),
                    FSComponent.buildComponent(DurationDisplay, { value: this.todTimeSub, options: { format: DurationDisplayFormat.hh_mm_or_mm_ss, delim: DurationDisplayDelim.ColonOrCross, nanString: '_ _ : _ _' }, class: 'mfd-fpl-vnav-value' }))),
            FSComponent.buildComponent("div", { class: "mfd-fpl-vnav row-2" },
                FSComponent.buildComponent("div", { class: 'mfd-fpl-vnav-tgtvs' },
                    FSComponent.buildComponent("label", null, "VS TGT"),
                    FSComponent.buildComponent(NumberUnitDisplay, { value: this.vsTargetSub, displayUnit: Subject.create(UnitType.FPM), formatter: NumberFormatter.create({ precision: 1, nanString: '_ _ _ _ _' }), class: 'mfd-fpl-vnav-value supplied-value' })),
                FSComponent.buildComponent("div", { class: 'mfd-fpl-vnav-fpa' },
                    FSComponent.buildComponent("label", null, "FPA"),
                    FSComponent.buildComponent("span", { class: 'supplied-value' }, this.fpaSubject))),
            FSComponent.buildComponent("div", { class: "mfd-fpl-vnav row-3" },
                FSComponent.buildComponent("div", { class: 'mfd-fpl-vnav-vsreq' },
                    FSComponent.buildComponent("label", null, "VS REQ"),
                    FSComponent.buildComponent(NumberUnitDisplay, { value: this.vsRequiredSub, displayUnit: Subject.create(UnitType.FPM), formatter: NumberFormatter.create({ precision: 1, nanString: '_ _ _ _ _' }), class: 'mfd-fpl-vnav-value' })),
                FSComponent.buildComponent("div", { class: 'mfd-fpl-vnav-vdev' },
                    FSComponent.buildComponent("label", null, "V DEV"),
                    FSComponent.buildComponent(NumberUnitDisplay, { value: this.vdevSub, displayUnit: Subject.create(UnitType.FOOT), formatter: NumberFormatter.create({ precision: 1, nanString: '_ _ _ _ _' }), class: 'mfd-fpl-vnav-value' })))));
    }
}

/**
 * Displays METAR information based on the currently selected flight plan element.
 */
class MFDFPLWeather extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.textSub = ComputedSubject.create(undefined, metar => {
            var _a;
            return (_a = metar === null || metar === void 0 ? void 0 : metar.metarString) !== null && _a !== void 0 ? _a : '';
        });
        this.opId = 0;
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.selection.sub(selection => {
            var _a, _b;
            let icao = '';
            if (selection) {
                if ('leg' in selection) {
                    // selection is a LegDefinition
                    icao = this.getNominalIcaoFromLeg(selection);
                }
                else {
                    // selection is a FlightPlanSegment
                    const plan = this.props.fms.getPrimaryFlightPlan();
                    if (selection.segmentType === FlightPlanSegmentType.Departure && plan.procedureDetails.departureIndex < 0) {
                        icao = (_a = plan.originAirport) !== null && _a !== void 0 ? _a : '';
                    }
                    else if (selection.segmentType === FlightPlanSegmentType.Destination) {
                        icao = (_b = plan.destinationAirport) !== null && _b !== void 0 ? _b : '';
                    }
                }
            }
            if (ICAO.isFacility(icao) && ICAO.getFacilityType(icao) === FacilityType.Airport) {
                this.updateMetarFromAirport(ICAO.getIdent(icao));
            }
            else {
                this.updateMetarFromAirport('');
            }
        }, true);
    }
    /**
     * Gets the ICAO of a flight plan leg's nominal facility.
     * @param leg A flight plan leg.
     * @returns The ICAO of the flight plan leg's nominal facility.
     */
    getNominalIcaoFromLeg(leg) {
        switch (leg.leg.type) {
            case LegType.IF:
            case LegType.TF:
            case LegType.CF:
            case LegType.DF:
            case LegType.RF:
                return leg.leg.fixIcao;
            default:
                return '';
        }
    }
    /**
     * Updates this component's METAR with one from a specified airport.
     * @param ident The ident of the airport from which to retrieve a METAR, or an empty string if no METAR should be
     * retrieved.
     */
    async updateMetarFromAirport(ident) {
        if (ident === '') {
            this.textSub.set(undefined);
            return;
        }
        const opId = ++this.opId;
        const metar = await this.props.facLoader.getMetar(ident);
        if (opId !== this.opId) {
            return;
        }
        this.textSub.set(metar);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: 'mfd-fpl-weather' }, this.textSub));
    }
}

/**
 * The FPL popup container encapsulates the actual popup logic.
 */
class MFDFPL extends UiControlGroup {
    constructor() {
        super(...arguments);
        this.fplDetailsRef = FSComponent.createRef();
        this.selectionSub = Subject.create(null);
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        return this.fplDetailsRef.instance.onInteractionEvent(evt);
    }
    /** Called when the view is resumed. */
    onViewResumed() {
        if (this.fplDetailsRef.instance !== undefined) {
            this.fplDetailsRef.instance.fplViewResumed();
        }
    }
    /** Called when the view is opened. */
    onViewOpened() {
        if (this.fplDetailsRef.instance !== undefined) {
            this.fplDetailsRef.instance.fplViewOpened();
        }
    }
    /**
     * A method called when the control group scroll is toggled.
     * @param enabled if the scroll is enabled.
     */
    onScrollToggled(enabled) {
        this.fplDetailsRef.instance.onScrollToggled(enabled);
        if (!enabled) {
            this.selectionSub.set(null);
        }
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: 'mfd-dark-background wide' },
            FSComponent.buildComponent(MFDFPLDetails, { onRegister: this.register, ref: this.fplDetailsRef, bus: this.props.bus, fms: this.props.fms, selection: this.selectionSub, focus: this.props.focus }),
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Active VNV Profile" },
                FSComponent.buildComponent(MFDFPLVNavProfile, { bus: this.props.bus, flightPlanner: this.props.fms.flightPlanner })),
            FSComponent.buildComponent(GroupBox, { title: "Selected Waypoint Weather" },
                FSComponent.buildComponent(MFDFPLWeather, { facLoader: new FacilityLoader(FacilityRespository.getRepository(this.props.bus)), fms: this.props.fms, selection: this.selectionSub })),
            FSComponent.buildComponent("div", { class: "mfd-fpl-bottom-prompt" }, "Press the \"FPL\" key to view the previous page")));
    }
}

/**
 * Calculates map projection parameters to fit flight plan foci.
 */
class MapFlightPlanFocusCalculator {
    /**
     * Constructor.
     * @param mapProjection This calculator's map projection.
     */
    constructor(mapProjection) {
        this.mapProjection = mapProjection;
        this.tempProjection = new MapProjection(100, 100);
    }
    /**
     * Calculates a maximum range and target center for a given flight plan focus such that the terminators of all legs
     * in the focus are visible in this calculator's map projection. If there is only one leg terminator in the specified
     * focus, the calculated range will be equal to 0. If a range and target could not be calculated, NaN will be written
     * to the results.
     * @param focus The array of legs on which to focus.
     * @param margins The margins around the projected map boundaries to respect. Expressed as [left, top, right, bottom].
     * @param out The object to which to write the results.
     * @returns The calculated range and target for the specified focus.
     */
    calculateRangeTarget(focus, margins, out) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        out.range = NaN;
        out.target.set(NaN, NaN);
        if (!focus) {
            return out;
        }
        if (!(focus instanceof Array)) {
            out.range = 0;
            out.target.set(focus);
            return out;
        }
        focus = focus;
        const targetWidth = this.mapProjection.getProjectedSize()[0] - margins[0] - margins[2];
        const targetHeight = this.mapProjection.getProjectedSize()[1] - margins[1] - margins[3];
        if (targetWidth * targetHeight <= 0) {
            return out;
        }
        let minX;
        let minY;
        let maxX;
        let maxY;
        let currentLat = NaN;
        let currentLon = NaN;
        const len = focus.length;
        for (let i = 0; i < len; i++) {
            const leg = focus[i];
            if (((_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.startLat) !== undefined && ((_b = leg.calculated) === null || _b === void 0 ? void 0 : _b.startLon) !== undefined
                && ((_c = leg.calculated) === null || _c === void 0 ? void 0 : _c.startLat) !== currentLat && ((_d = leg.calculated) === null || _d === void 0 ? void 0 : _d.startLon) !== currentLon) {
                currentLat = leg.calculated.startLat;
                currentLon = leg.calculated.startLon;
                const projected = this.mapProjection.project(MapFlightPlanFocusCalculator.geoPointCache[0].set(currentLat, currentLon), MapFlightPlanFocusCalculator.vec2Cache[0]);
                minX = Math.min(projected[0], minX !== null && minX !== void 0 ? minX : Infinity);
                minY = Math.min(projected[1], minY !== null && minY !== void 0 ? minY : Infinity);
                maxX = Math.max(projected[0], maxX !== null && maxX !== void 0 ? maxX : -Infinity);
                maxY = Math.max(projected[1], maxY !== null && maxY !== void 0 ? maxY : -Infinity);
            }
            if (((_e = leg.calculated) === null || _e === void 0 ? void 0 : _e.endLat) !== undefined && ((_f = leg.calculated) === null || _f === void 0 ? void 0 : _f.endLon) !== undefined
                && ((_g = leg.calculated) === null || _g === void 0 ? void 0 : _g.endLat) !== currentLat && ((_h = leg.calculated) === null || _h === void 0 ? void 0 : _h.endLon) !== currentLon) {
                currentLat = leg.calculated.endLat;
                currentLon = leg.calculated.endLon;
                const projected = this.mapProjection.project(MapFlightPlanFocusCalculator.geoPointCache[0].set(currentLat, currentLon), MapFlightPlanFocusCalculator.vec2Cache[0]);
                minX = Math.min(projected[0], minX !== null && minX !== void 0 ? minX : Infinity);
                minY = Math.min(projected[1], minY !== null && minY !== void 0 ? minY : Infinity);
                maxX = Math.max(projected[0], maxX !== null && maxX !== void 0 ? maxX : -Infinity);
                maxY = Math.max(projected[1], maxY !== null && maxY !== void 0 ? maxY : -Infinity);
            }
        }
        if (minX === undefined || minY === undefined || maxX === undefined || maxY === undefined) {
            return out;
        }
        let focusWidth = maxX - minX;
        let focusHeight = maxY - minY;
        this.mapProjection.invert(Vec2Math.set((minX + maxX) / 2, (minY + maxY) / 2, MapFlightPlanFocusCalculator.vec2Cache[0]), out.target);
        if (focusWidth === 0 && focusHeight === 0) {
            out.range = 0;
            return out;
        }
        let widthRatio = focusWidth / targetWidth;
        let heightRatio = focusHeight / targetHeight;
        let constrainedRatio = Math.max(widthRatio, heightRatio);
        const range = out.range = this.mapProjection.getRange();
        const topLeft = this.mapProjection.invert(Vec2Math.set(minX, minY, MapFlightPlanFocusCalculator.vec2Cache[0]), MapFlightPlanFocusCalculator.geoPointCache[0]);
        const bottomRight = this.mapProjection.invert(Vec2Math.set(maxX, maxY, MapFlightPlanFocusCalculator.vec2Cache[0]), MapFlightPlanFocusCalculator.geoPointCache[1]);
        this.tempProjection.set({ projectedSize: this.mapProjection.getProjectedSize(), rotation: this.mapProjection.getRotation(), target: out.target, range });
        // Iteratively solve for exact range
        let iterCount = 0;
        const rangeParam = { range };
        let ratioError = Math.abs(constrainedRatio - 1);
        let deltaRatioError = MapFlightPlanFocusCalculator.RANGE_TOLERANCE + 1;
        while (iterCount++ < MapFlightPlanFocusCalculator.MAX_ITER
            && ratioError > MapFlightPlanFocusCalculator.RANGE_TOLERANCE
            && deltaRatioError > MapFlightPlanFocusCalculator.RANGE_TOLERANCE) {
            rangeParam.range = out.range = this.tempProjection.getRange() * constrainedRatio;
            if (out.range <= GeoPoint.EQUALITY_TOLERANCE) {
                // if the estimated range is too small, iteratively solving for the range will be unreliable due to floating
                // point errors
                out.range = GeoPoint.EQUALITY_TOLERANCE;
                return out;
            }
            this.tempProjection.set(rangeParam);
            const topLeftProjected = this.tempProjection.project(topLeft, MapFlightPlanFocusCalculator.vec2Cache[0]);
            const bottomRightProjected = this.tempProjection.project(bottomRight, MapFlightPlanFocusCalculator.vec2Cache[1]);
            focusWidth = bottomRightProjected[0] - topLeftProjected[0];
            focusHeight = bottomRightProjected[1] - topLeftProjected[1];
            widthRatio = focusWidth / targetWidth;
            heightRatio = focusHeight / targetHeight;
            constrainedRatio = Math.max(widthRatio, heightRatio);
            const newRatioError = Math.abs(constrainedRatio - 1);
            deltaRatioError = Math.abs(newRatioError - ratioError);
            ratioError = newRatioError;
        }
        return out;
    }
}
MapFlightPlanFocusCalculator.MAX_ITER = 20;
MapFlightPlanFocusCalculator.RANGE_TOLERANCE = 0.01;
MapFlightPlanFocusCalculator.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
MapFlightPlanFocusCalculator.vec2Cache = [new Float64Array(2), new Float64Array(2)];

/**
 * Controls the map crosshair. Shows the crosshair when the map pointer or flight plan focus is active, and hides the
 * crosshair otherwise.
 */
class MFDFPLMapCrosshairController extends MapCrosshairController {
    /** @inheritdoc */
    initListeners() {
        super.initListeners();
        const focusModule = this.mapModel.getModule('focus');
        focusModule.isActive.sub(this.handler);
        focusModule.focus.sub(this.handler);
    }
    /** @inheritdoc */
    updateCrosshairShow() {
        const focusModule = this.mapModel.getModule('focus');
        const isPointerActive = this.mapModel.getModule('pointer').isActive.get();
        const isFocusActive = focusModule.isActive.get();
        const doesFocusExist = focusModule.focus.get() !== null;
        this.mapModel.getModule('crosshair').show.set(isPointerActive || (isFocusActive && doesFocusExist));
    }
    /** @inheritdoc */
    destroy() {
        super.destroy();
        const focusModule = this.mapModel.getModule('focus');
        focusModule.isActive.unsub(this.handler);
        focusModule.focus.unsub(this.handler);
    }
}

/**
 * The MFD flight plan map.
 */
class MFDFPLMapComponent extends NavMapComponent {
    constructor() {
        super(...arguments);
        this.dtoFlightPlanLayerRef = FSComponent.createRef();
        this.miniCompassLayerRef = FSComponent.createRef();
        this.rangeRingLayerRef = FSComponent.createRef();
        this.rangeCompassLayerRef = FSComponent.createRef();
        this.pointerInfoLayerRef = FSComponent.createRef();
        this.dtoPlanDataProvider = new MapFlightPlannerPlanDataProvider(this.props.bus, this.props.flightPlanner);
        this.crosshairController = new MFDFPLMapCrosshairController(this.props.model);
    }
    /** @inheritdoc */
    createRangeTargetRotationController() {
        this.primaryPlanDataProvider = new MapFlightPlannerPlanDataProvider(this.props.bus, this.props.flightPlanner);
        return new MFDFPLMapRangeTargetRotationController(this.props.model, this.mapProjection, this.deadZone, NavMapRangeTargetRotationController.DEFAULT_MAP_RANGES, this.props.settingManager, this.rangeSettingManager, 'mfdMapRangeIndex', this.pointerBoundsSub, this.primaryPlanDataProvider, MFDFPLMapComponent.FLIGHT_PLAN_FOCUS_DEFAULT_RANGE_INDEX);
    }
    /** @inheritdoc */
    initEventBusHandlers() {
        super.initEventBusHandlers();
        const planProviderHandler = this.updateFlightPlanDataProviders.bind(this);
        const flightPlanEvents = this.props.bus.getSubscriber();
        flightPlanEvents.on('fplIndexChanged').handle(planProviderHandler);
        this.props.model.getModule('focus').isFocused.sub(planProviderHandler, true);
    }
    /** @inheritdoc */
    initLayers() {
        super.initLayers();
        this.attachLayer(this.dtoFlightPlanLayerRef.instance);
        this.attachLayer(this.miniCompassLayerRef.instance);
        this.attachLayer(this.rangeRingLayerRef.instance);
        this.attachLayer(this.rangeCompassLayerRef.instance);
        this.attachLayer(this.pointerInfoLayerRef.instance);
    }
    /**
     * Changes this map's range index.
     * @param delta The change in index to apply.
     * @returns The range index after the change.
     */
    changeRangeIndex(delta) {
        return this.rangeTargetRotationController.changeRangeIndex(delta);
    }
    /**
     * Updates this map's flight plan layer data providers.
     */
    updateFlightPlanDataProviders() {
        const activePlanIndex = this.props.flightPlanner.activePlanIndex;
        const isFlightPlanFocused = this.props.model.getModule('focus').isFocused.get();
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.primaryPlanDataProvider.setPlanIndex(activePlanIndex === Fms.PRIMARY_PLAN_INDEX || isFlightPlanFocused ? Fms.PRIMARY_PLAN_INDEX : -1);
        this.dtoPlanDataProvider.setPlanIndex(activePlanIndex === Fms.DTO_RANDOM_PLAN_INDEX ? Fms.DTO_RANDOM_PLAN_INDEX : -1);
    }
    /**
     * Renders the flight plan layer.
     * @returns The rendered flight plan layer, as a VNode.
     */
    renderFlightPlanLayer() {
        const inactiveWaypointStyles = this.getFlightPlanLayerInactiveWaypointsStyles();
        const activeWaypointStyles = this.getFlightPlanLayerActiveWaypointsStyles();
        return (FSComponent.buildComponent("div", { style: 'position: absolute; left: 0; top: 0; width: 100%; height: 100%;' },
            FSComponent.buildComponent(MapFlightPlanLayer, { ref: this.flightPlanLayerRef, model: this.props.model, mapProjection: this.mapProjection, 
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                bus: this.props.bus, dataProvider: this.primaryPlanDataProvider, drawEntirePlan: this.props.drawEntireFlightPlan, waypointRenderer: this.waypointRenderer, textManager: this.textManager, inactiveWaypointStyles: inactiveWaypointStyles, activeWaypointStyles: activeWaypointStyles }),
            FSComponent.buildComponent(MapFlightPlanLayer, { ref: this.dtoFlightPlanLayerRef, model: this.props.model, mapProjection: this.mapProjection, bus: this.props.bus, dataProvider: this.dtoPlanDataProvider, drawEntirePlan: Subject.create(false), waypointRenderer: this.waypointRenderer, textManager: this.textManager, inactiveWaypointStyles: inactiveWaypointStyles, activeWaypointStyles: activeWaypointStyles })));
    }
    /** @inheritdoc */
    renderMiniCompassLayer() {
        return (FSComponent.buildComponent(MapMiniCompassLayer, { ref: this.miniCompassLayerRef, class: 'minicompass-layer', model: this.props.model, mapProjection: this.mapProjection, imgSrc: 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/map_mini_compass.png' }));
    }
    /** @inheritdoc */
    renderRangeRingLayer() {
        return (FSComponent.buildComponent(MapRangeRingLayer, { ref: this.rangeRingLayerRef, model: this.props.model, mapProjection: this.mapProjection, showLabel: true, strokeWidth: 2, strokeStyle: 'white' }));
    }
    /** @inheritdoc */
    renderRangeCompassLayer() {
        return (FSComponent.buildComponent(MapRangeCompassLayer, { ref: this.rangeCompassLayerRef, model: this.props.model, mapProjection: this.mapProjection, bus: this.props.bus, showLabel: true, showHeadingBug: this.props.model.getModule('pointer').isActive.map(isActive => !isActive), arcStrokeWidth: 2, arcEndTickLength: 10, referenceArrowWidth: 15, referenceArrowHeight: 20, referenceTickWidth: 2, referenceTickHeight: 5, bearingTickMajorLength: 10, bearingTickMinorLength: 5, bearingLabelFont: 'Roboto-Bold', bearingLabelFontSize: 20, bearingLabelOutlineWidth: 6, bearingLabelRadialOffset: 0, headingBugWidth: 20, headingBugHeight: 10 }));
    }
    /** @inheritdoc */
    renderPointerInfoLayer() {
        return (FSComponent.buildComponent(MapPointerInfoLayer, { ref: this.pointerInfoLayerRef, model: this.props.model, mapProjection: this.mapProjection, size: MapPointerInfoLayerSize.Medium }));
    }
    /** @inheritdoc */
    renderTerrainScaleIndicator() {
        return null;
    }
}
MFDFPLMapComponent.FLIGHT_PLAN_FOCUS_DEFAULT_RANGE_INDEX = 17;
/**
 * A controller for handling map range, target, and rotation changes for the MFD navigation map.
 */
class MFDFPLMapRangeTargetRotationController extends NavMapRangeTargetRotationController {
    /**
     * Creates an instance of a MapRangeController.
     * @param mapModel The map model.
     * @param mapProjection The map projection.
     * @param deadZone The dead zone around the edge of the map projection window.
     * @param mapRanges An array of valid map ranges.
     * @param settingManager This controller's map settings manager.
     * @param rangeSettingManager This controller's map range settings manager.
     * @param rangeSettingName The name of this controller's map range setting.
     * @param pointerBounds A subscribable which provides the bounds of the area accessible to the map pointer. The
     * bounds should be expressed as `[left, top, right, bottom]` in pixels.
     * @param flightPlanDataProvider A provider of flight plan data for this controller.
     * @param flightPlanFocusDefaultRangeIndex The index of the map range to which this controller defaults when focusing
     * on the flight plan with a calculated focus range of zero.
     */
    constructor(mapModel, mapProjection, deadZone, mapRanges, settingManager, rangeSettingManager, rangeSettingName, pointerBounds, flightPlanDataProvider, flightPlanFocusDefaultRangeIndex) {
        super(mapModel, mapProjection, deadZone, mapRanges, settingManager, rangeSettingManager, rangeSettingName, pointerBounds);
        this.flightPlanDataProvider = flightPlanDataProvider;
        this.flightPlanFocusDefaultRangeIndex = flightPlanFocusDefaultRangeIndex;
        this.focusModule = this.mapModel.getModule('focus');
        this.focusCalculator = new MapFlightPlanFocusCalculator(this.mapProjection);
        this.focusRangeTarget = { range: 0, target: new GeoPoint(0, 0) };
        this.focusDebounceTimer = new DebounceTimer();
        this.focusMargins = new Float64Array([20, 20, 20, 20]);
        this.isFlightPlanFocusedChangedHandler = this.onIsFlightPlanFocusChanged.bind(this);
        this.flightPlanFocusChangedHandler = this.onFlightPlanFocusChanged.bind(this);
        this.flightPlanCalculatedHandler = this.onFlightPlanCalculated.bind(this);
        this.isIsFlightPlanFocusedListenerActive = false;
        this.areFlightPlanFocusListenersActive = false;
        this.skipFlightPlanFocusDebounce = false;
        this.useMapRangeSetting = true;
        this.updateRangeTargetFromFocusBound = this.updateRangeTargetFromFocus.bind(this);
        this.updateFocusMargins();
        this.focusModule.isActive.sub(this.onIsFlightPlanFocusActiveChanged.bind(this));
    }
    /**
     * Changes this controller's map range index.
     * @param delta The change in index to apply.
     * @returns The range index after the change.
     */
    changeRangeIndex(delta) {
        if (this.useMapRangeSetting) {
            const newIndex = Utils.Clamp(this.rangeSetting.value + delta, 0, this.mapRanges.length - 1);
            this.rangeSetting.value = newIndex;
            return newIndex;
        }
        else {
            const newIndex = Utils.Clamp(this.currentMapRangeIndex + delta, 0, this.mapRanges.length - 1);
            if (newIndex !== this.currentMapRangeIndex) {
                this.currentMapRangeIndex = newIndex;
                this.updateRangeFromIndex();
                this.scheduleProjectionUpdate();
            }
            return newIndex;
        }
    }
    /** @inheritdoc */
    onDeadZoneChanged() {
        super.onDeadZoneChanged();
        this.updateFocusMargins();
    }
    /**
     * Updates the flight plan focus margins.
     */
    updateFocusMargins() {
        this.focusMargins[0] = this.deadZone[0] + 20;
        this.focusMargins[1] = this.deadZone[1] + 20;
        this.focusMargins[2] = this.deadZone[2] + 20;
        this.focusMargins[3] = this.deadZone[3] + 20;
    }
    /** @inheritdoc */
    updateRangeIndex() {
        if (!this.useMapRangeSetting) {
            return;
        }
        super.updateRangeIndex();
    }
    /** @inheritdoc */
    convertToTrueRange(nominalRange) {
        const projectedHeight = this.mapProjection.getProjectedSize()[1];
        const correctedHeight = projectedHeight - this.deadZone[1] - this.deadZone[3];
        const orientation = this.mapModel.getModule('orientation').orientation.get();
        const factor = orientation === MapOrientation.NorthUp ? 4 : 3;
        return nominalRange.asUnit(UnitType.GA_RADIAN) * projectedHeight / correctedHeight * factor;
    }
    /** @inheritdoc */
    getDesiredTargetOffset() {
        const trueCenterOffsetX = (this.deadZone[0] - this.deadZone[2]) / 2;
        const trueCenterOffsetY = (this.deadZone[1] - this.deadZone[3]) / 2;
        const projectedSize = this.mapProjection.getProjectedSize();
        const relativeOffset = this.mapModel.getModule('orientation').orientation.get() === MapOrientation.NorthUp
            ? MFDFPLMapRangeTargetRotationController.NORTH_UP_TARGET_OFFSET_REL
            : MFDFPLMapRangeTargetRotationController.HDG_TRK_UP_TARGET_OFFSET_REL;
        return Vec2Math.set(relativeOffset[0] * projectedSize[0] + trueCenterOffsetX, relativeOffset[1] * projectedSize[1] + trueCenterOffsetY, MFDFPLMapRangeTargetRotationController.tempVec2_1);
    }
    /** @inheritdoc */
    updateOrientation() {
        if (this.focusModule.isFocused.get()) {
            this.orientationModule.orientation.set(MapOrientation.NorthUp);
        }
        else {
            super.updateOrientation();
        }
    }
    /**
     * Sets whether to sync the map range to the map range user setting.
     * @param use Whether to sync the map range to the map range user setting.
     */
    setUseMapRangeSetting(use) {
        if (use === this.useMapRangeSetting) {
            return;
        }
        this.useMapRangeSetting = use;
        if (use) {
            this.updateRangeIndex();
        }
    }
    /** @inheritdoc */
    onPointerActivated() {
        super.onPointerActivated();
        this.focusModule.isActive.set(false);
        this.updateIsFlightPlanFocusedListener();
    }
    /** @inheritdoc */
    onPointerDeactivated() {
        super.onPointerDeactivated();
        this.setUseMapRangeSetting(true);
        this.updateIsFlightPlanFocusedListener();
    }
    /**
     * Responds to changes in whether flight plan focus is active.
     * @param isActive Whether flight plan focus is active.
     */
    onIsFlightPlanFocusActiveChanged(isActive) {
        this.updateOrientation();
        this.updateAirplanePositionListeners();
        this.updateFlightPlanFocusListeners();
        this.setUseMapRangeSetting(!isActive && !this.pointerModule.isActive.get());
        if (!isActive) {
            this.focusDebounceTimer.clear();
        }
        this.scheduleProjectionUpdate();
    }
    /**
     * Responds to changes in whether the flight plan is focused.
     * @param isFocused Whether the flight plan is focused.
     */
    onIsFlightPlanFocusChanged(isFocused) {
        this.focusModule.isActive.set(isFocused);
    }
    /** @inheritdoc */
    updateAirplanePositionListeners() {
        this.setAirplanePositionListenersActive(!this.pointerModule.isActive.get() && !this.focusModule.isActive.get());
    }
    /**
     * Updates is flight plan focused listener.
     */
    updateIsFlightPlanFocusedListener() {
        this.setIsFlightPlanFocusedListenerActive(!this.pointerModule.isActive.get());
    }
    /**
     * Updates flight plan focus listeners.
     */
    updateFlightPlanFocusListeners() {
        this.setFlightPlanFocusListenersActive(this.focusModule.isActive.get());
    }
    /**
     * Activates or deactivates the is flight plan focused listener.
     * @param value Whether to activate the is flight plan focused listener.
     */
    setIsFlightPlanFocusedListenerActive(value) {
        if (value === this.isIsFlightPlanFocusedListenerActive) {
            return;
        }
        if (value) {
            this.focusModule.isFocused.sub(this.isFlightPlanFocusedChangedHandler, true);
        }
        else {
            this.focusModule.isFocused.unsub(this.isFlightPlanFocusedChangedHandler);
        }
        this.isIsFlightPlanFocusedListenerActive = value;
    }
    /**
     * Activates or deactivates flight plan focus listeners.
     * @param value Whether to activate flight plan focus listeners.
     */
    setFlightPlanFocusListenersActive(value) {
        if (value === this.areFlightPlanFocusListenersActive) {
            return;
        }
        if (value) {
            this.skipFlightPlanFocusDebounce = true;
            this.focusModule.focus.sub(this.flightPlanFocusChangedHandler, true);
            this.skipFlightPlanFocusDebounce = false;
            this.flightPlanDataProvider.planCalculated.on(this.flightPlanCalculatedHandler);
        }
        else {
            this.focusModule.focus.unsub(this.flightPlanFocusChangedHandler);
            this.flightPlanDataProvider.planCalculated.off(this.flightPlanCalculatedHandler);
        }
        this.areFlightPlanFocusListenersActive = value;
    }
    /**
     * Responds to changes in the flight plan focus.
     */
    onFlightPlanFocusChanged() {
        if (this.skipFlightPlanFocusDebounce) {
            this.updateRangeTargetFromFocus();
        }
        else {
            this.scheduleUpdateRangeTargetFromFocus();
        }
    }
    /**
     * A callback which is called when the flight plan is calculated.
     */
    onFlightPlanCalculated() {
        // only update from flight plan focus if the focus is not null and a valid range and target do not already exist.
        if (this.focusModule.isFocused.get() && this.focusModule.focus.get() !== null && isNaN(this.focusRangeTarget.range)) {
            this.updateRangeTargetFromFocus();
        }
    }
    /**
     * Schedules an update of the map target and range from the current flight plan focus after a debounce delay.
     */
    scheduleUpdateRangeTargetFromFocus() {
        this.focusDebounceTimer.schedule(this.updateRangeTargetFromFocusBound, MFDFPLMapRangeTargetRotationController.FOCUS_DEBOUNCE_DELAY);
    }
    /**
     * Updates the map target and range from the current flight plan focus.
     */
    updateRangeTargetFromFocus() {
        const targetRange = this.focusCalculator.calculateRangeTarget(this.focusModule.focus.get(), this.focusMargins, this.focusRangeTarget);
        if (isNaN(targetRange.range)) {
            return;
        }
        this.currentMapParameters.target.set(targetRange.target);
        // when flight plan is focused, we are guaranteed to be in North Up mode, so true range = nominal range * 4.
        const rangeIndex = targetRange.range > 0
            ? this.mapRanges.findIndex(range => range.asUnit(UnitType.GA_RADIAN) * 4 >= targetRange.range)
            : this.flightPlanFocusDefaultRangeIndex;
        this.currentMapRangeIndex = rangeIndex < 0 ? this.mapRanges.length - 1 : rangeIndex;
        this.updateRangeFromIndex();
        this.scheduleProjectionUpdate();
    }
    /** @inheritdoc */
    updateModules() {
        super.updateModules();
        const isNorthUp = this.mapModel.getModule('orientation').orientation.get() === MapOrientation.NorthUp;
        this.mapModel.getModule('rangeRing').show.set(isNorthUp);
        this.mapModel.getModule('rangeCompass').show.set(!isNorthUp);
    }
}
MFDFPLMapRangeTargetRotationController.NORTH_UP_TARGET_OFFSET_REL = new Float64Array(2);
MFDFPLMapRangeTargetRotationController.HDG_TRK_UP_TARGET_OFFSET_REL = new Float64Array([0, 1 / 6]);
MFDFPLMapRangeTargetRotationController.FOCUS_DEBOUNCE_DELAY = 500; // milliseconds
MFDFPLMapRangeTargetRotationController.tempVec2_1 = new Float64Array(2);

/**
 *
 */
class MapFlightPlanFocusModule {
    constructor() {
        /**
         * Whether focus is active.
         */
        this.isActive = Subject.create(false);
        /**
         * Whether the flight plan has focus.
         */
        this.isFocused = Subject.create(false);
        /**
         * The flight plan focus.
         */
        this.focus = Subject.create(null);
    }
}

/**
 * Class for creating MFD FPL map models.
 */
class MFDFPLMapModel {
    /**
     * Creates an instance of an MFD FPL map model.
     * @param tcas A TCAS to use to get traffic avoidance information.
     * @param options Initialization options for the new model.
     * @returns a navmap model instance.
     */
    static createModel(tcas, options) {
        const model = NavMapModel.createModel(tcas, options);
        model.addModule('focus', new MapFlightPlanFocusModule());
        return model;
    }
}

/**
 * A page which displays the flight plan map and active flight plan information.
 */
class MFDFPLPage extends MFDUiPage {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.mapRef = FSComponent.createRef();
        this.fplRef = FSComponent.createRef();
        this.mapModel = MFDFPLMapModel.createModel(this.props.tas);
        this.pointerModule = this.mapModel.getModule('pointer');
        this.focusModule = this.mapModel.getModule('focus');
        this._title.set('FPL – Active Flight Plan');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        super.onAfterRender();
        this.mapPointerController = new MapPointerController(this.mapModel, this.mapRef.instance.mapProjection);
        this.mapRef.instance.sleep();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onInteractionEvent(evt) {
        var _a;
        // TODO: Move the close operations out of here into their respective views.
        switch (evt) {
            case FmsHEvent.UPPER_PUSH:
                this.toggleScroll();
                return true;
            case FmsHEvent.RANGE_DEC:
                this.changeMapRangeIndex(-1);
                return true;
            case FmsHEvent.RANGE_INC:
                this.changeMapRangeIndex(1);
                return true;
            case FmsHEvent.JOYSTICK_PUSH:
                (_a = this.mapPointerController) === null || _a === void 0 ? void 0 : _a.togglePointerActive();
                return true;
        }
        return this.handleMapPointerMoveEvent(evt) || super.onInteractionEvent(evt);
    }
    /**
     * Changes the MFD map range index setting.
     * @param delta The change in index to apply.
     */
    changeMapRangeIndex(delta) {
        var _a;
        const currentIndex = this.mapModel.getModule('range').nominalRangeIndex.get();
        const newIndex = this.mapRef.instance.changeRangeIndex(delta);
        if (currentIndex !== newIndex) {
            (_a = this.mapPointerController) === null || _a === void 0 ? void 0 : _a.targetPointer();
        }
    }
    /**
     * Handles events that move the map pointer.
     * @param evt The event.
     * @returns Whether the event was handled.
     */
    handleMapPointerMoveEvent(evt) {
        var _a, _b, _c, _d;
        if (!this.pointerModule.isActive.get()) {
            return false;
        }
        switch (evt) {
            case FmsHEvent.JOYSTICK_LEFT:
                (_a = this.mapPointerController) === null || _a === void 0 ? void 0 : _a.movePointer(-MFDFPLPage.POINTER_MOVE_INCREMENT, 0);
                return true;
            case FmsHEvent.JOYSTICK_UP:
                (_b = this.mapPointerController) === null || _b === void 0 ? void 0 : _b.movePointer(0, -MFDFPLPage.POINTER_MOVE_INCREMENT);
                return true;
            case FmsHEvent.JOYSTICK_RIGHT:
                (_c = this.mapPointerController) === null || _c === void 0 ? void 0 : _c.movePointer(MFDFPLPage.POINTER_MOVE_INCREMENT, 0);
                return true;
            case FmsHEvent.JOYSTICK_DOWN:
                (_d = this.mapPointerController) === null || _d === void 0 ? void 0 : _d.movePointer(0, MFDFPLPage.POINTER_MOVE_INCREMENT);
                return true;
        }
        return false;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewOpened() {
        this.props.menuSystem.clear();
        this.props.menuSystem.pushMenu('navmap-root');
        this.mapRef.instance.wake();
        this.fplRef.instance.onViewOpened();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewClosed() {
        var _a;
        super.onViewClosed();
        (_a = this.mapPointerController) === null || _a === void 0 ? void 0 : _a.setPointerActive(false);
        this.mapRef.instance.sleep();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewResumed() {
        super.onViewResumed();
        this.fplRef.instance.onViewResumed();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onFPLPressed() {
        this.props.viewService.open('NavMapPage');
        return true;
    }
    /** @inheritdoc */
    onScrollToggled(enabled) {
        this.focusModule.isFocused.set(enabled);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent("div", { ref: this.viewContainerRef, class: 'mfd-page' },
            FSComponent.buildComponent(MFDFPLMapComponent, { ref: this.mapRef, model: this.mapModel, bus: this.props.bus, updateFreq: MFDFPLPage.UPDATE_FREQ, projectedWidth: 440, projectedHeight: 734, deadZone: new Float64Array([0, 56, 0, 0]), flightPlanner: this.props.fms.flightPlanner, airspaceSearcher: this.props.airspaceSearcher, id: 'mfd_fplmap', bingId: 'mfd_page_map', settingManager: MapUserSettings.getMfdManager(this.props.bus), ownAirplaneLayerProps: {
                    imageFilePath: 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/own_airplane_icon.svg',
                    iconSize: 40,
                    iconAnchor: new Float64Array([0.5, 0])
                }, trafficIntruderLayerProps: {
                    fontSize: 16,
                    iconSize: 30
                }, drawEntireFlightPlan: this.focusModule.isFocused, class: 'mfd-fplmap' }),
            FSComponent.buildComponent(MFDFPL, { ref: this.fplRef, onRegister: this.register, bus: this.props.bus, fms: this.props.fms, focus: this.focusModule.focus })));
    }
}
MFDFPLPage.UPDATE_FREQ = 30; // Hz
MFDFPLPage.POINTER_MOVE_INCREMENT = 5; // pixels

/**
 * The PFD procedures popout.
 */
class MFDProc extends UiView {
    constructor() {
        super(...arguments);
        this.listRef = FSComponent.createRef();
        this.listContainerRef = FSComponent.createRef();
        this.menuItems = this.buildMenuItems();
        this.menuItemsSubject = ArraySubject.create(this.menuItems);
        this.arrival = Subject.create('_ _ _ _-');
        this.departure = Subject.create('_ _ _ _-');
        this.destinationAirportSub = Subject.create(null);
        this.approachSub = Subject.create(null);
        /**
         * A callback called to render the menu items.
         * @param d is the menu item
         * @param registerFn The register function.
         * @returns a vnode for display in the menu
         */
        this.renderItem = (d, registerFn) => {
            return FSComponent.buildComponent(PopoutMenuItem, { onRegister: registerFn, parent: this, def: d });
        };
    }
    /**
     * A local method to get the ident from an ICAO.
     * @param icao is icao to get the ident from.
     * @returns an ident string or an empty string.
     */
    getIdent(icao) {
        if (icao !== undefined) {
            return ICAO.getIdent(icao);
        }
        return '';
    }
    /** @inheritdoc */
    onViewOpened() {
        this.departure.set('_ _ _ _-');
        this.arrival.set('_ _ _ _-');
        this.destinationAirportSub.set(null);
        this.approachSub.set(null);
        const plan = this.props.fms.getPrimaryFlightPlan();
        if (plan && plan.procedureDetails.departureIndex > -1 && plan.originAirport !== undefined) {
            this.props.fms.facLoader.getFacility(FacilityType.Airport, plan.originAirport).then((fac) => {
                let depStr = fac.departures[plan.procedureDetails.departureIndex].name;
                if (plan.procedureDetails.departureTransitionIndex > -1) {
                    depStr += '.' + fac.departures[plan.procedureDetails.departureIndex].enRouteTransitions[plan.procedureDetails.departureTransitionIndex].name;
                }
                this.departure.set(this.getIdent(plan.originAirport) + '-' + depStr);
            });
        }
        if (plan && plan.destinationAirport !== undefined
            && (plan.procedureDetails.arrivalIndex > -1 || plan.procedureDetails.approachIndex > -1 || plan.getUserData('visual_approach') !== undefined)) {
            this.props.fms.facLoader.getFacility(FacilityType.Airport, plan.destinationAirport).then((fac) => {
                if (plan.procedureDetails.arrivalIndex > -1) {
                    let arrStr = fac.arrivals[plan.procedureDetails.arrivalIndex].name;
                    if (plan.procedureDetails.arrivalTransitionIndex > -1) {
                        arrStr = fac.arrivals[plan.procedureDetails.arrivalIndex].enRouteTransitions[plan.procedureDetails.arrivalTransitionIndex].name + '.' + arrStr;
                    }
                    this.arrival.set(this.getIdent(plan.destinationAirport) + '-' + arrStr);
                }
                const approach = FmsUtils.getApproachFromPlan(plan, fac);
                this.destinationAirportSub.set(fac);
                this.approachSub.set(approach !== null && approach !== void 0 ? approach : null);
            });
        }
        const menuItems = this.buildMenuList();
        this.setMenuItems(menuItems);
    }
    /**
     * Sets the menu items for the list menu dialog.
     * @param items The items to set into the menu.
     */
    setMenuItems(items) {
        this.menuItems = items;
        this.menuItemsSubject.clear();
        this.menuItemsSubject.set(items);
        this.scrollController.gotoFirst();
    }
    /**
     * Method to dynamically build the menu list
     * @returns an array of menu item definitions
     */
    buildMenuList() {
        var _a, _b, _c, _d;
        const approachLoaded = (_b = (_a = this.props.fms) === null || _a === void 0 ? void 0 : _a.canApproachActivate()) !== null && _b !== void 0 ? _b : false;
        const canMissedActivate = (_d = (_c = this.props.fms) === null || _c === void 0 ? void 0 : _c.canMissedApproachActivate()) !== null && _d !== void 0 ? _d : false;
        const menuItems = [
            {
                id: 'activate-vector-to-final', renderContent: () => FSComponent.buildComponent("span", null, "Activate Vector-to-Final"), isEnabled: false,
                action: () => {
                }
            },
            {
                id: 'activate-approach', renderContent: () => FSComponent.buildComponent("span", null, "Activate Approach"), isEnabled: approachLoaded,
                action: () => {
                    this.props.fms.activateApproach();
                }
            },
            {
                id: 'activate-missed', renderContent: () => FSComponent.buildComponent("span", null, "Activate Missed Approach"), isEnabled: canMissedActivate,
                action: () => {
                    this.props.fms.activateMissedApproach();
                }
            },
            {
                id: 'select-approach', renderContent: () => FSComponent.buildComponent("span", null, "Select Approach"), isEnabled: true,
                action: () => {
                    this.props.viewService.open('SelectApproach', false);
                }, closeAfterAction: false
            },
            {
                id: 'select-arrival', renderContent: () => FSComponent.buildComponent("span", null, "Select Arrival"), isEnabled: true,
                action: () => {
                    this.props.viewService.open('SelectArrival', false);
                }, closeAfterAction: false
            },
            {
                id: 'select-departure', renderContent: () => FSComponent.buildComponent("span", null, "Select Departure"), isEnabled: true,
                action: () => {
                    this.props.viewService.open('SelectDeparture', false);
                }, closeAfterAction: false
            },
        ];
        return menuItems;
    }
    /** @inheritdoc */
    buildMenuItems() {
        return this.buildMenuList();
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.PROC:
            case FmsHEvent.CLR:
                this.close();
                return true;
        }
        return false;
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        let className = 'popout-dialog';
        if (this.props.class !== undefined) {
            className += ` ${this.props.class}`;
        }
        return (FSComponent.buildComponent("div", { class: className, ref: this.viewContainerRef },
            FSComponent.buildComponent("h1", null, this.props.title),
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Options", ref: this.listContainerRef },
                FSComponent.buildComponent(List, { ref: this.listRef, onRegister: this.register, data: this.menuItemsSubject, renderItem: this.renderItem })),
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Loaded" },
                FSComponent.buildComponent("div", { class: "white mfd-proc-loaded" },
                    FSComponent.buildComponent("div", { class: "gray" }, "Approach:"),
                    FSComponent.buildComponent(ApproachNameDisplay, { approach: this.approachSub, airport: this.destinationAirportSub, nullText: '_ _ _ _-' }),
                    FSComponent.buildComponent("div", { class: "gray" }, "Arrival:"),
                    FSComponent.buildComponent("div", null, this.arrival),
                    FSComponent.buildComponent("div", { class: "gray" }, "Departure:"),
                    FSComponent.buildComponent("div", null, this.departure))),
            FSComponent.buildComponent("div", { class: "mfd-bottom-menu-prompt" }, "Press the \"PROC\" key to view the previous page")));
    }
}

/**
 * A class to define an arrow toggle/select UI element
 */
class ArrowToggle extends UiControl {
    /**
     * Ctor
     * @param props The props.
     */
    constructor(props) {
        var _a, _b;
        super(props);
        this.valueContainerRef = FSComponent.createRef();
        this.selectedOption = ComputedSubject.create((_b = (_a = this.props.dataref) === null || _a === void 0 ? void 0 : _a.get()) !== null && _b !== void 0 ? _b : 0, (v) => {
            return this.props.options[v];
        });
        this.leftArrEnabled = ComputedSubject.create(false, (v) => {
            return v ? 'rgb(0,255,0)' : 'rgb(50,50,50)';
        });
        this.rightArrEnabled = ComputedSubject.create(true, (v) => {
            return v ? 'rgb(0,255,0)' : 'rgb(50,50,50)';
        });
        this.setArrows();
        this.selectedOption.sub(() => {
            this.setArrows();
        });
        if (this.props.dataref) {
            this.props.dataref.sub((v) => {
                this.selectedOption.set(v);
            });
        }
    }
    /** @inheritdoc */
    onUpperKnobInc() {
        this.scrollOption('next');
    }
    /** @inheritdoc */
    onUpperKnobDec() {
        this.scrollOption('prev');
    }
    /**
     * Sets the next option in the direction.
     * @param direction is the direction to scroll
     */
    scrollOption(direction) {
        var _a;
        let idx = this.selectedOption.getRaw();
        idx = Math.max(0, Math.min(this.props.options.length - 1, ((direction === 'next') ? idx + 1 : idx - 1)));
        this.selectedOption.set(idx);
        (_a = this.props.dataref) === null || _a === void 0 ? void 0 : _a.set(idx);
        if (this.props.onOptionSelected !== undefined) {
            this.props.onOptionSelected(idx);
        }
    }
    /** Enables/Disables the arrows. */
    setArrows() {
        this.leftArrEnabled.set(this.selectedOption.getRaw() > 0);
        this.rightArrEnabled.set(this.selectedOption.getRaw() < this.props.options.length - 1);
    }
    /** @inheritdoc */
    getHighlightElement() {
        return this.valueContainerRef.instance;
    }
    /** @inheritdoc */
    renderControl() {
        return (FSComponent.buildComponent("div", { class: "arrow-toggle-container" },
            FSComponent.buildComponent("svg", { width: "5", height: "10" },
                FSComponent.buildComponent("path", { d: 'M 0 0 l 0 10 l 5 -5 z', fill: this.rightArrEnabled })),
            FSComponent.buildComponent("div", { ref: this.valueContainerRef, class: "arrow-toggle-value" }, this.selectedOption),
            FSComponent.buildComponent("svg", { width: "5", height: "10" },
                FSComponent.buildComponent("path", { d: 'M 0 0 m 5 0 l 0 10 l -5 -5 z', fill: this.leftArrEnabled }))));
    }
}

/**
 * The ActionButton component.
 */
class ActionButton extends UiControl {
    /** @inheritdoc */
    onEnter() {
        this.props.onExecute();
        return true;
    }
    /** @inheritdoc */
    renderControl() {
        return (FSComponent.buildComponent("div", { class: "action-button" }, this.props.text));
    }
}

/** The Procedure Sequence component. */
class ProcSequenceItem extends UiControl {
    /**
     * Creates an instance of FixInfo.
     * @param props The props of the component.
     */
    constructor(props) {
        var _a, _b, _c, _d, _e;
        super(props);
        this.fixEl = FSComponent.createRef();
        this._distanceUnits = Subject.create('NM');
        this._fixType = ComputedSubject.create((_a = this.props.data.get().leg.fixTypeFlags) !== null && _a !== void 0 ? _a : FixTypeFlags.None, (v) => {
            if (this.props.data.get().name === 'MANSEQ') {
                return ' hdg';
            }
            switch (v) {
                case FixTypeFlags.FAF:
                    return ' faf';
                case FixTypeFlags.IAF:
                    return ' iaf';
                case FixTypeFlags.MAP:
                    return ' map';
                case FixTypeFlags.MAHP:
                    return ' mahp';
                default:
                    return '';
            }
        });
        this._dtk = ComputedSubject.create((_c = (_b = this.props.data.get().calculated) === null || _b === void 0 ? void 0 : _b.initialDtk) !== null && _c !== void 0 ? _c : -1, (v) => {
            if (v < 0) {
                return '';
            }
            else {
                const rounded = Math.round(v);
                return `${(rounded === 0 ? 360 : rounded).toFixed(0).padStart(3, '0')}°`;
            }
        });
        this._distance = ComputedSubject.create((_e = (_d = this.props.data.get().calculated) === null || _d === void 0 ? void 0 : _d.distance) !== null && _e !== void 0 ? _e : -1, (v) => {
            if (isNaN(v) || v < 0.1) {
                this._distanceUnits.set('');
                return '';
            }
            else {
                this._distanceUnits.set('NM');
                const dis = (v / 1852);
                return dis.toFixed((dis < 100) ? 1 : 0);
            }
        });
        this.props.data.sub((v) => {
            var _a, _b, _c, _d, _e;
            const dtk = (_b = (_a = v.calculated) === null || _a === void 0 ? void 0 : _a.initialDtk) !== null && _b !== void 0 ? _b : -1;
            this._dtk.set(dtk);
            this._distance.set((_d = (_c = v.calculated) === null || _c === void 0 ? void 0 : _c.distance) !== null && _d !== void 0 ? _d : 0);
            this._fixType.set((_e = v.leg.fixTypeFlags) !== null && _e !== void 0 ? _e : 0);
        });
    }
    /**
     * Gets the container element location
     * @returns An array of x,y.
     */
    getContainerElementLocation() {
        return [this.fixEl.instance.offsetLeft, this.fixEl.instance.offsetTop];
    }
    /** @inheritdoc */
    getHighlightElement() {
        return this.fixEl.instance.firstElementChild;
    }
    /** @inheritdoc */
    renderControl() {
        return (FSComponent.buildComponent("div", { class: 'sequence-item-container', ref: this.fixEl },
            FSComponent.buildComponent("div", null,
                this.props.data.get().name,
                FSComponent.buildComponent("span", { class: 'sequence-fix-type' }, this._fixType)),
            FSComponent.buildComponent("div", { style: 'color: whitesmoke;' }, this._dtk),
            FSComponent.buildComponent("div", { style: 'color: whitesmoke;' },
                this._distance,
                FSComponent.buildComponent("span", { class: "smallText" }, this._distanceUnits))));
    }
}

/** Select approach store */
class SelectApproachStore {
    /**
     * Constructor.
     */
    constructor() {
        this.minimumsSubject = Subject.create(0);
        this.frequencySubject = ComputedSubject.create(undefined, (v) => {
            if (v !== undefined && v.freqMHz) {
                return v.freqMHz.toFixed(2);
            }
            return '___.__';
        });
        this.minsToggleOptions = ['Off', 'BARO']; //, 'TEMP COMP'];
        this.minimumsMode = Subject.create(0);
        this.selectedApproach = Subject.create(undefined);
        this.selectedTransIndex = Subject.create(-1);
        this._approaches = ArraySubject.create();
        this.approaches = this._approaches;
        this._transitions = ArraySubject.create();
        this.transitions = this._transitions;
        this.inputValue = Subject.create('');
        this.sequence = ArraySubject.create();
        this.selectedApproach.sub(this.onSelectedApproachChanged.bind(this));
    }
    /**
     * Sets the data to display the facility.
     * @param facility The airport facility to be shown.
     */
    loadFacility(facility) {
        this.selectedFacility = facility;
        this._approaches.clear();
        this._transitions.clear();
        this._approaches.set(this.getApproaches());
    }
    /**
     * Empties the display content when no facility is selected
     */
    clearFacility() {
        this.selectedFacility = undefined;
        this._approaches.clear();
        this._transitions.clear();
    }
    /**
     * Gets the approaches array.
     * @returns The approaches.
     */
    getApproaches() {
        if (this.selectedFacility !== undefined) {
            const ilsFound = new Set();
            for (const approach of this.selectedFacility.approaches) {
                if (approach.approachType == ApproachType.APPROACH_TYPE_ILS) {
                    ilsFound.add(approach.runway);
                }
            }
            const approaches = [];
            this.selectedFacility.approaches.forEach((approach, index) => {
                if (approach.approachType !== ApproachType.APPROACH_TYPE_LOCALIZER || !ilsFound.has(approach.runway)) {
                    approaches.push({
                        approach,
                        index,
                        isVisualApproach: false
                    });
                }
            });
            this.getVisualApproaches(this.selectedFacility).forEach(va => {
                approaches.push({
                    approach: va,
                    index: -1,
                    isVisualApproach: true
                });
            });
            return approaches;
        }
        return [];
    }
    /**
     * Gets the visual approaches for the facility.
     * @param facility is the facility.
     * @returns The Approach Procedures.
     */
    getVisualApproaches(facility) {
        const runways = [];
        for (let i = 0; i < facility.runways.length; i++) {
            RunwayUtils.getOneWayRunways(facility.runways[i], i).forEach(rw => { runways.push(rw); });
        }
        const approaches = [];
        runways.forEach(r => {
            approaches.push({
                name: `VISUAL ${r.designation}`,
                runway: r.designation,
                icaos: [],
                transitions: [],
                finalLegs: [],
                missedLegs: [],
                approachType: AdditionalApproachType.APPROACH_TYPE_VISUAL,
                approachSuffix: '',
                runwayDesignator: r.runwayDesignator,
                runwayNumber: r.direction,
                rnavTypeFlags: RnavTypeFlags.None
            });
        });
        return approaches;
    }
    /**
     * Responds to changes in the selected approach.
     */
    onSelectedApproachChanged() {
        this.refreshTransitions();
        this.refreshApproachFrequencyText();
    }
    /**
     * Refreshes the transitions array to reflect the transition list of the currently selected approach.
     */
    refreshTransitions() {
        var _a;
        const approach = (_a = this.selectedApproach.get()) === null || _a === void 0 ? void 0 : _a.approach;
        const transitions = [];
        if (approach) {
            for (let i = 0; i < approach.transitions.length; i++) {
                const listItems = FmsUtils.getOffsetTransitions(approach, i);
                listItems.forEach(item => transitions.push(item));
            }
            transitions.splice(0, 0, { name: 'VECTORS', transitionIndex: -1 });
        }
        this._transitions.set(transitions);
    }
    /**
     * Refreshes the approach frequency text to reflect the frequency of the currently selected approach.
     */
    refreshApproachFrequencyText() {
        const selectedApproach = this.selectedApproach.get();
        if (this.selectedFacility && selectedApproach) {
            this.frequencySubject.set(FmsUtils.getApproachFrequency(this.selectedFacility, selectedApproach.index));
        }
        else {
            this.frequencySubject.set(undefined);
        }
    }
}

/**
 * The NumberInput component.
 */
class NumberInput extends UiControl {
    constructor() {
        super(...arguments);
        this.displaySubject = Subject.create('');
        // If increment doesn't divide evenly into range, this will have unexpected behavior!
        this.range = this.props.maxValue - this.props.minValue + this.props.increment;
    }
    /** @inheritdoc */
    onAfterRender() {
        super.onAfterRender();
        this.displaySubject.set(this.getDisplaySubject());
        this.props.dataSubject.sub(() => {
            this.displaySubject.set(this.getDisplaySubject());
        });
    }
    /**
     * Method to get the display subject
     * @returns a string to set the display subject
     */
    getDisplaySubject() {
        if (this.props.defaultDisplayValue !== undefined && this.props.dataSubject.get() == 0) {
            return this.props.defaultDisplayValue;
        }
        else {
            if (this.props.formatter) {
                return this.props.formatter(this.props.dataSubject.get());
            }
            else {
                return `${this.props.dataSubject.get()}`;
            }
        }
    }
    /** @inheritdoc */
    onUpperKnobInc() {
        const newValue = this.props.wrap
            ? ((this.props.dataSubject.get() + this.props.increment) - this.props.minValue) % this.range + this.props.minValue
            : Math.min(this.props.dataSubject.get() + this.props.increment, this.props.maxValue);
        this.props.dataSubject.set(newValue);
        if (this.props.onValueChanged !== undefined) {
            this.props.onValueChanged(this.props.dataSubject.get());
            this.displaySubject.set(this.getDisplaySubject());
        }
    }
    /** @inheritdoc */
    onUpperKnobDec() {
        const newValue = this.props.wrap
            ? this.props.maxValue - (this.props.maxValue - (this.props.dataSubject.get() - this.props.increment)) % this.range
            : Math.max(this.props.dataSubject.get() - this.props.increment, this.props.minValue);
        this.props.dataSubject.set(newValue);
        if (this.props.onValueChanged !== undefined) {
            this.props.onValueChanged(this.props.dataSubject.get());
            this.displaySubject.set(this.getDisplaySubject());
        }
    }
    /** @inheritdoc */
    renderControl() {
        return (FSComponent.buildComponent("div", null, this.displaySubject));
    }
}

/** The context menu position. */
var ContextMenuPosition;
(function (ContextMenuPosition) {
    // TOP = 0,
    ContextMenuPosition[ContextMenuPosition["BOTTOM"] = 1] = "BOTTOM";
    ContextMenuPosition[ContextMenuPosition["LEFT"] = 2] = "LEFT";
    // RIGHT = 3,
    ContextMenuPosition[ContextMenuPosition["CENTER"] = 4] = "CENTER";
})(ContextMenuPosition || (ContextMenuPosition = {}));
/** A dialog that displays a context menu. */
class ContextMenuDialog extends UiView {
    /**
     * Constructor
     * @param props The view props.
     */
    constructor(props) {
        super(props);
        this.listRef = FSComponent.createRef();
        this.listContainerRef = FSComponent.createRef();
        this.popoutContainerBgRef = FSComponent.createRef();
        this.menuItemsSubject = ArraySubject.create();
        this.assumedWidth = 0;
        this.assumedHeight = 0;
        this.viewport = {
            height: Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0),
            width: Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0)
        };
        this.SAFETY_MARGIN = 28;
        this.CHAR_WIDTH = 12;
        this.ROW_HEIGHT = 26;
        this.MAX_WIDTH = 320;
        this.MAX_HEIGHT = 260;
        this.onItemSelected = (sender) => {
            this.accept(this.listRef.instance.getListItemIndex(sender), true);
            return true;
        };
        /**
         * A callback called to render the menu items.
         * @param d is the menu item
         * @param registerFn The control register function.
         * @returns a vnode for display in the menu
         */
        this.renderItem = (d, registerFn) => {
            return FSComponent.buildComponent(PopoutMenuItem, { onRegister: registerFn, onEnter: this.onItemSelected, parent: this, def: d });
        };
        this.inputData.sub((v) => {
            this.menuItemsSubject.clear();
            if (v !== undefined) {
                if (v.items.length > 0) {
                    this.menuItemsSubject.insertRange(0, v.items);
                }
                this.scrollController.gotoFirst();
            }
        });
    }
    /** @inheritdoc */
    onInputDataSet(data) {
        if (data) {
            if (data.element) {
                this.containerRect = data.outerContainer.getBoundingClientRect();
                this.assumedWidth = MathUtils.clamp(data.items.reduce((maxWidth, item) => item.estimatedWidth > maxWidth ? item.estimatedWidth : maxWidth, 0) + this.SAFETY_MARGIN, 0, this.containerRect.width);
                this.assumedHeight = MathUtils.clamp(this.menuItemsSubject.length * this.ROW_HEIGHT + this.SAFETY_MARGIN, 0, Math.min(this.containerRect.height, this.MAX_HEIGHT));
                // just center it there for now
                const selectElRect = data.element.getBoundingClientRect();
                switch (data.position) {
                    case ContextMenuPosition.LEFT:
                        // position dialog left of element
                        this.viewContainerRef.instance.style.top = `${((this.containerRect.height / 2) - (this.assumedHeight / 2)) + this.containerRect.top + 12}px`;
                        this.setContainerLeftPos(selectElRect.left - this.assumedWidth - 8, data);
                        break;
                    case ContextMenuPosition.CENTER:
                        this.viewContainerRef.instance.style.top = `${((this.containerRect.height / 2) - (this.assumedHeight / 2)) + this.containerRect.top + 12}px`;
                        this.setContainerLeftPos(this.containerRect.left + (this.containerRect.width / 2) - (this.assumedWidth / 2), data);
                        break;
                    case ContextMenuPosition.BOTTOM:
                    default:
                        // position dialog below the element
                        this.viewContainerRef.instance.style.top = `${selectElRect.bottom + 10}px`;
                        this.setContainerLeftPos(selectElRect.left + 8, data);
                        break;
                }
                const viewContainerRect = this.viewContainerRef.instance.getBoundingClientRect();
                const remHeight = this.containerRect.bottom - viewContainerRect.top;
                this.popoutContainerBgRef.instance.style.maxHeight = `${MathUtils.clamp(remHeight - this.SAFETY_MARGIN, this.ROW_HEIGHT + this.SAFETY_MARGIN, this.MAX_HEIGHT)}px`;
            }
            if (data.initialScrollPosition) {
                this.listRef.instance.scrollToIndex(data.initialScrollPosition);
            }
        }
    }
    /**
     * Sets and clamps the left position of the container.
     * @param left The desired left position.
     * @param data The context menu options data.
     */
    setContainerLeftPos(left, data) {
        const minLeft = data.outerContainer ? data.outerContainer.getBoundingClientRect().left + 10 : 0;
        this.viewContainerRef.instance.style.left = `${MathUtils.clamp(left, minLeft, this.viewport.width - this.assumedWidth)}px`;
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.CLR:
                this.close();
                return true;
        }
        return false;
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: 'popout-contextmenu-dialog', ref: this.viewContainerRef },
            FSComponent.buildComponent("div", { class: 'popout-contextmenu-background', ref: this.popoutContainerBgRef },
                FSComponent.buildComponent("div", { class: "popout-contextmenu-container", ref: this.listContainerRef },
                    FSComponent.buildComponent(List, { onRegister: this.register, ref: this.listRef, data: this.menuItemsSubject, renderItem: this.renderItem, upperKnobCanScroll: this.props.upperKnobCanScroll, scrollContainer: this.popoutContainerBgRef }))),
            FSComponent.buildComponent(ScrollBar, null)));
    }
}
ContextMenuDialog.CHAR_WIDTH = 12;

/**
 * A control which allows the user to select one of multiple items through a pop-up dialog and which also displays the
 * currently selected value.
 */
class SelectControl extends UiControl {
    constructor() {
        super(...arguments);
        this.valueRef = FSComponent.createRef();
        this.renderedValueNode = null;
        this.MenuItems = [];
        this.SelectedValue = Subject.create(-1);
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        super.onAfterRender();
        this.SelectedValue.sub(this.renderSelectedItem.bind(this));
        this.props.data.sub(() => {
            this.MenuItems = this.buildMenuItems();
            this.SelectedValue.set((this.MenuItems.length > 0) ? 0 : -1);
            this.setIsEnabled(this.MenuItems.length > 0);
            const selectedIndex = this.SelectedValue.get();
            this.renderSelectedItem(selectedIndex);
            this.props.onItemSelected(selectedIndex, this.props.data.tryGet(selectedIndex), true);
        }, true);
        this.isEnabledSubject.sub((v) => {
            if (v) {
                this.valueRef.instance.classList.add('cyan');
            }
            else {
                this.valueRef.instance.classList.remove('cyan');
            }
        });
    }
    /** @inheritdoc */
    onUpperKnob() {
        var _a, _b, _c;
        // open dialog
        if (this.MenuItems.length > 0) {
            const selectCb = (sender, index) => {
                this.SelectedValue.set(index);
                this.props.onItemSelected(index, this.props.data.tryGet(index), false);
            };
            this.activate();
            const dialogOptions = {
                items: this.MenuItems,
                element: this.valueRef.instance,
                position: (_a = this.props.dialogPosition) !== null && _a !== void 0 ? _a : ContextMenuPosition.BOTTOM,
                outerContainer: this.props.outerContainer.instance,
                initialScrollPosition: (_c = (_b = this.props.dialogScrollStartIndex) === null || _b === void 0 ? void 0 : _b.get()) !== null && _c !== void 0 ? _c : this.SelectedValue.get()
            };
            const dialog = Fms.viewService.open(ContextMenuDialog.name, true).setInput(dialogOptions);
            dialog.onAccept.on(selectCb);
            dialog.onClose.on(() => {
                this.deactivate();
            });
        }
    }
    /**
     * Builds the menu item definitions.
     * @returns An array of menu item definitions.
     */
    buildMenuItems() {
        const defs = [];
        const dataLen = this.props.data.length;
        for (let i = 0; i < dataLen; i++) {
            defs.push(this.props.buildMenuItem(this.props.data.get(i), i));
        }
        return defs;
    }
    /**
     * Renders the selected item.
     * @param index The index of the selected item.
     */
    renderSelectedItem(index) {
        var _a, _b;
        while (this.valueRef.instance.firstChild) {
            this.valueRef.instance.removeChild(this.valueRef.instance.firstChild);
        }
        if (this.renderedValueNode) {
            if (this.renderedValueNode.instance instanceof DisplayComponent) {
                this.renderedValueNode.instance.destroy();
            }
            this.renderedValueNode = null;
        }
        const item = this.props.data.tryGet(index);
        const node = item === undefined
            ? FSComponent.buildComponent("span", null, (_b = (_a = this.props.nullSelectionText) === null || _a === void 0 ? void 0 : _a.get()) !== null && _b !== void 0 ? _b : 'NONE')
            : this.props.renderSelectedItem
                ? this.props.renderSelectedItem(item, index)
                : this.MenuItems[index].renderContent();
        FSComponent.render(node, this.valueRef.instance);
        this.renderedValueNode = node;
    }
    /** @inheritdoc */
    renderControl() {
        return (FSComponent.buildComponent("div", { ref: this.valueRef }));
    }
}

/**
 * Input Component Class
 */
class InputComponent extends UiControl {
    constructor() {
        super(...arguments);
        this.textBoxRef = FSComponent.createRef();
        this.keyboardIconRef = FSComponent.createRef();
        this.inputValueContainerRef = FSComponent.createRef();
        this.selectedSpanRef = FSComponent.createRef();
        this.keyboardInputHandler = this.handleTextboxInput.bind(this);
        this.dataEntry = {
            text: '',
            highlightIndex: 0,
            beforeSelected: Subject.create(''),
            selected: Subject.create(''),
            afterSelected: Subject.create(''),
        };
        this.characterMap = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
        this.isKeyboardActive = false;
        this.inputCharacterIndex = 0;
        this.previousValue = '';
        /**
         * Method to handle when the virtual keyboard button is clicked
         */
        this.handleKeyboardClicked = () => {
            if (this.getIsFocused()) {
                if (!this.isKeyboardActive) {
                    this.activateKeyboardInput();
                }
                else {
                    this.deactivateKeyboardInput();
                }
            }
        };
        /**
         * Method to handle when input focus is set
         * @param e The focus event.
         */
        this.onInputFocus = (e) => {
            e.preventDefault();
            Coherent.trigger('FOCUS_INPUT_FIELD', '', '', '', '', false);
            Coherent.on('mousePressOutsideView', () => {
                this.textBoxRef.instance.blur();
            });
            this.textBoxRef.instance.focus({ preventScroll: true });
            this.textBoxRef.instance.value = this.dataEntry.text.substr(0, this.dataEntry.highlightIndex);
            this.textBoxRef.instance.disabled = false;
            this.textBoxRef.instance.addEventListener('input', this.keyboardInputHandler);
            this.keyboardIconRef.instance.classList.add('active');
        };
        /**
         * Method to handle on input blur
         */
        this.onInputBlur = () => {
            this.textBoxRef.instance.disabled = true;
            this.textBoxRef.instance.value = '';
            Coherent.trigger('UNFOCUS_INPUT_FIELD', '');
            Coherent.off('mousePressOutsideView');
            if (this.keyboardInputHandler) {
                this.textBoxRef.instance.removeEventListener('input', this.keyboardInputHandler);
            }
            this.keyboardIconRef.instance.classList.remove('active');
        };
    }
    /**
     * Method to set the initial text value when the component is made active.
     * @param value is a string containing the start text value
     * @param highlightIndex The new index of the highlighted character. The index will remain unchanged if this
     * argument is undefined.
     * @param emitEvent Whether a text changed event should be emitted.
     */
    setText(value, highlightIndex, emitEvent = true) {
        this.dataEntry.text = value.padEnd(this.props.maxLength, '_').substr(0, this.props.maxLength);
        this.dataEntry.highlightIndex = Utils.Clamp(highlightIndex !== null && highlightIndex !== void 0 ? highlightIndex : this.dataEntry.highlightIndex, 0, this.dataEntry.text.length - 1);
        this.textBoxRef.instance.value = value.substr(0, this.dataEntry.highlightIndex);
        this.updateDataEntryElement(undefined, emitEvent);
    }
    /**
     * Gets the current input.
     * @returns the data entry text
     */
    getText() {
        return this.dataEntry.text;
    }
    /**
     * Gets the raw input without blank fills.
     * @returns the data entry text without blank fills
     */
    getRawText() {
        return this.dataEntry.text.replace(/_/g, ' ').trim();
    }
    /**
     * Clears the input.
     * @param emitEvent A boolean indicating if an event should be emitted after clearing the input value.
     */
    clear(emitEvent = true) {
        this.setText('', 0, emitEvent);
    }
    /**
     * Method to select a character for data entry. TODO: Make part of component
     * @param increment is a bool for whether to increment or decrement the input character when the method is called
     * @returns a character to input into the data entry element
     */
    updateSelectedCharacter(increment = true) {
        this.inputCharacterIndex += increment ? 1 : -1;
        if (this.inputCharacterIndex > (this.characterMap.length - 1)) {
            this.inputCharacterIndex = 0;
        }
        else if (this.inputCharacterIndex < 0) {
            this.inputCharacterIndex = (this.characterMap.length - 1);
        }
        return this.characterMap[this.inputCharacterIndex];
    }
    /**
     * Method to update data entry field. TODO: Make part of component
     * @param newCharacter is the new string character to input
     * @param [emitEvent] A boolean indicating if a text changed event should be emitted.
     */
    updateDataEntryElement(newCharacter = undefined, emitEvent = true) {
        let beforeText = '';
        let selectedChar = '';
        let afterText = '';
        const text = this.dataEntry.text;
        if (this.dataEntry.highlightIndex !== undefined) {
            beforeText = text.substr(0, this.dataEntry.highlightIndex);
            selectedChar = text.substr(this.dataEntry.highlightIndex, 1);
            afterText = text.substr(this.dataEntry.highlightIndex + 1);
        }
        else {
            afterText = text;
        }
        if (newCharacter) {
            selectedChar = newCharacter;
            // clear chars after this
            const blankFill = this.props.maxLength - (this.dataEntry.highlightIndex + 1);
            if (blankFill > 1) {
                afterText = ''.padStart(blankFill, '_');
            }
        }
        this.inputCharacterIndex = this.characterMap.indexOf(selectedChar);
        const updatedText = beforeText + selectedChar + afterText;
        this.dataEntry.text = updatedText;
        if (emitEvent) {
            this.props.onTextChanged(this.dataEntry.text.replace(/_/g, ' ').trim());
        }
        this.dataEntry.beforeSelected.set(beforeText);
        this.dataEntry.selected.set(selectedChar);
        this.dataEntry.afterSelected.set(afterText);
    }
    /**
     * Handles the input from the hidden textbox
     */
    handleTextboxInput() {
        const targetChars = this.textBoxRef.instance.value.trimRight().length;
        this.dataEntry.text = this.textBoxRef.instance.value.toUpperCase().padEnd(6, '_');
        this.dataEntry.highlightIndex = Utils.Clamp(targetChars, 0, this.dataEntry.text.length - 1);
        this.updateDataEntryElement(undefined, true);
    }
    /**
     * Activates keyboard input. If this control is not active, activating keyboard input will activate this control as
     * well.
     */
    activateKeyboardInput() {
        if (!this.isActivated) {
            this.activate();
        }
        this.textBoxRef.instance.disabled = false;
        this.textBoxRef.instance.focus();
        this.isKeyboardActive = true;
    }
    /**
     * Deactivates keyboard input.
     */
    deactivateKeyboardInput() {
        this.textBoxRef.instance.blur();
        this.textBoxRef.instance.disabled = true;
        this.isKeyboardActive = false;
    }
    /** @inheritdoc */
    onUpperKnobInc() {
        if (!this.getIsActivated()) {
            this.activate();
            if (this.getRawText() === '') {
                this.inputCharacterIndex = 9;
                this.updateDataEntryElement(this.updateSelectedCharacter(true));
            }
        }
        else {
            this.updateDataEntryElement(this.updateSelectedCharacter(true));
        }
    }
    /** @inheritdoc */
    onUpperKnobDec() {
        if (!this.getIsActivated()) {
            this.activate();
            if (this.getRawText() === '') {
                this.inputCharacterIndex = 11;
                this.updateDataEntryElement(this.updateSelectedCharacter(false));
            }
        }
        else {
            this.updateDataEntryElement(this.updateSelectedCharacter(false));
        }
    }
    /** @inheritdoc */
    onLowerKnobInc() {
        if (this.dataEntry.highlightIndex < 5) {
            this.dataEntry.highlightIndex++;
            this.updateDataEntryElement();
            if (this.isKeyboardActive) {
                this.textBoxRef.instance.value = this.dataEntry.text.substr(0, this.dataEntry.highlightIndex);
            }
        }
    }
    /** @inheritdoc */
    onLowerKnobDec() {
        if (this.dataEntry.highlightIndex < 1) {
            this.dataEntry.highlightIndex = 0;
        }
        else {
            this.dataEntry.highlightIndex--;
            this.updateDataEntryElement();
            if (this.isKeyboardActive) {
                this.textBoxRef.instance.value = this.dataEntry.text.substr(0, this.dataEntry.highlightIndex);
            }
        }
    }
    /** @inheritdoc */
    onEnter() {
        if (this.getIsActivated()) {
            this.deactivate();
            if (this.props.onEnter) {
                this.props.onEnter(this);
            }
            return true;
        }
        else if (this.getIsFocused()) {
            if (this.props.onEnter) {
                this.props.onEnter(this);
            }
        }
        return false;
    }
    /** @inheritdoc */
    onClr() {
        if (this.getIsActivated()) {
            this.setText(this.previousValue);
            this.deactivate();
            return true;
        }
        return false;
    }
    /** @inheritdoc */
    getHighlightElement() {
        return this.inputValueContainerRef.instance;
    }
    /** @inheritdoc */
    onAfterRender() {
        super.onAfterRender();
        this.clear();
        this.inputValueContainerRef.instance.style.width = `${this.props.maxLength * 15}px`;
        this.keyboardIconRef.instance.onmouseup = this.handleKeyboardClicked;
        this.inputValueContainerRef.instance.onmouseup = this.handleKeyboardClicked;
        this.textBoxRef.instance.onfocus = this.onInputFocus;
        this.textBoxRef.instance.onblur = this.onInputBlur;
        this.textBoxRef.instance.blur();
        // Make sure we deactivate ourselves if we lose focus.
        this.focusSubject.sub((v, rv) => { !rv && this.isActivated && this.deactivate(); });
    }
    /** @inheritdoc */
    onActivated() {
        var _a;
        this.dataEntry.highlightIndex = 0;
        this.updateDataEntryElement();
        this.previousValue = this.getText();
        this.selectedSpanRef.instance.classList.add(UiControl.FOCUS_CLASS);
        (_a = this.getHighlightElement()) === null || _a === void 0 ? void 0 : _a.classList.remove(UiControl.FOCUS_CLASS);
    }
    /** @inheritdoc */
    onDeactivated() {
        var _a;
        this.previousValue = this.getText();
        this.textBoxRef.instance.blur();
        this.selectedSpanRef.instance.classList.remove(UiControl.FOCUS_CLASS);
        if (this.getIsFocused()) {
            (_a = this.getHighlightElement()) === null || _a === void 0 ? void 0 : _a.classList.add(UiControl.FOCUS_CLASS);
        }
    }
    /** @inheritdoc */
    renderControl() {
        return (FSComponent.buildComponent("div", { class: "input-component-scroller" },
            FSComponent.buildComponent("div", { ref: this.inputValueContainerRef, class: "input-component-value", style: "display:inline-block;" },
                this.dataEntry.beforeSelected,
                FSComponent.buildComponent("span", { ref: this.selectedSpanRef }, this.dataEntry.selected),
                this.dataEntry.afterSelected),
            FSComponent.buildComponent("input", { tabindex: "-1", ref: this.textBoxRef, width: "5px", style: "border:1px; background-color:black; opacity:0;", type: "text", size: "1", maxLength: "6" }),
            FSComponent.buildComponent("img", { ref: this.keyboardIconRef, src: 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/keyboard_icon.png', class: 'input-component-keyboard-icon' })));
    }
}

/**
 * Confirmation dialog for generic messages.
 */
class MessageDialog extends UiView {
    constructor() {
        super(...arguments);
        this.closeOnAccept = true;
        this.contentRef = FSComponent.createRef();
        this.confirmButtonText = Subject.create('');
        this.rejectButtonText = Subject.create('');
        this.orDivRef = FSComponent.createRef();
        this.rejectButtonRef = FSComponent.createRef();
        this.renderedContent = null;
        /** Callback for when the first button is pressed. */
        this.onButton1Pressed = () => {
            //this.close();
            this.accept(true, this.closeOnAccept);
        };
        /** Callback for when the second button is pressed. */
        this.onButton2Pressed = () => {
            this.accept(false, this.closeOnAccept);
        };
    }
    /** @inheritdoc */
    onInputDataSet(input) {
        if (input) {
            this.rejectButtonRef.instance.setIsVisible(input.hasRejectButton ? true : false);
            this.orDivRef.instance.style.display = input.hasRejectButton ? '' : 'none';
            this.closeOnAccept = input.closeOnAccept !== undefined ? input.closeOnAccept : true;
            this.renderContent(input);
        }
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        // noop
        switch (evt) {
            case FmsHEvent.CLR:
                this.close();
                return true;
        }
        return false;
    }
    /**
     * Renders the dialog content.
     * @param input The input data
     **/
    renderContent(input) {
        var _a, _b;
        this.cleanUpRenderedContent();
        if (input) {
            this.confirmButtonText.set((_a = input.confirmButtonText) !== null && _a !== void 0 ? _a : 'OK');
            this.rejectButtonText.set((_b = input.rejectButtonText) !== null && _b !== void 0 ? _b : 'CANCEL');
        }
        if (input.inputString !== undefined) {
            // we use innerHTML rather than textContent so we can provide pre-formatted strings.
            this.contentRef.instance.innerHTML = input.inputString;
        }
        else {
            // render items
            if (input.renderContent) {
                this.renderedContent = input.renderContent();
                FSComponent.render(this.renderedContent, this.contentRef.instance);
            }
        }
    }
    /**
     * Cleans up any rendered content.
     */
    cleanUpRenderedContent() {
        var _a;
        this.contentRef.instance.innerHTML = '';
        if (((_a = this.renderedContent) === null || _a === void 0 ? void 0 : _a.instance) instanceof DisplayComponent) {
            this.renderedContent.instance.destroy();
        }
        this.renderedContent = null;
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: 'popout-dialog msgdialog', ref: this.viewContainerRef },
            FSComponent.buildComponent("div", { class: 'msgdialog-popout-background' },
                FSComponent.buildComponent("div", { class: 'msgdialog-container' },
                    FSComponent.buildComponent("div", { class: 'msgdialog-content msgdialog-center', ref: this.contentRef }),
                    FSComponent.buildComponent("hr", { class: 'msgdialog-hr' }),
                    FSComponent.buildComponent("div", { class: "msgdialog-action-buttons" },
                        FSComponent.buildComponent(ActionButton, { onRegister: this.register, onExecute: this.onButton1Pressed, text: this.confirmButtonText }),
                        FSComponent.buildComponent("div", { ref: this.orDivRef }, "or"),
                        FSComponent.buildComponent(ActionButton, { ref: this.rejectButtonRef, onRegister: this.register, onExecute: this.onButton2Pressed, text: this.rejectButtonText }))))));
    }
}

/**
 * Waypoint input controller
 */
class WaypointInputController {
    /**
     * Creates an instance of waypoint input controller.
     * @param store The store associated with this controller.
     * @param selectedIcao A subject which provides an ICAO string for this controller's input component to bind.
     * @param onInputTextValueOverride A function which is called when the input text value needs to be overridden.
     */
    constructor(store, selectedIcao, onInputTextValueOverride) {
        this.store = store;
        this.selectedIcao = selectedIcao;
        this.onInputTextValueOverride = onInputTextValueOverride;
        this.icaoSearchDebounceTimer = null;
        this.searchOpId = 0;
        this.ignoreSelectedIcao = false;
        this.store.selectedWaypoint.sub((waypoint) => {
            var _a;
            this.ignoreSelectedIcao = true;
            const icao = (_a = waypoint === null || waypoint === void 0 ? void 0 : waypoint.facility.icao) !== null && _a !== void 0 ? _a : '';
            this.selectedIcao.set(icao);
            if (waypoint) {
                const ident = ICAO.getIdent(icao);
                // check if the current input value is a prefix of the suggested ident.
                if (ident.indexOf(this.store.inputValue.get()) === 0) {
                    this.store.inputValue.set(ident);
                    this.onInputTextValueOverride && this.onInputTextValueOverride(ident);
                }
            }
            this.ignoreSelectedIcao = false;
        });
        this.selectedIcao.sub((icao) => {
            if (this.ignoreSelectedIcao) {
                return;
            }
            this.searchOpId++;
            if (icao === '') {
                this.onInputTextValueOverride && this.onInputTextValueOverride('');
                this.store.loadIcaoData([]);
                this.store.inputValue.set('');
            }
            else {
                this.onInputTextValueOverride && this.onInputTextValueOverride(ICAO.getIdent(icao));
                this.store.loadIcaoData([icao]);
            }
        });
    }
    /**
     * Handler method to handle the input text from the input component.
     * @param value is the updated text from the input component.
     */
    onInputChanged(value) {
        this.store.inputValue.set(value);
        this.scheduleICAOSearch(value);
    }
    /**
     * Schedules an ICAO search. Cancels any pending ICAO searches which were scheduled earlier.
     * @param text The text to search against.
     */
    scheduleICAOSearch(text) {
        if (this.icaoSearchDebounceTimer !== null) {
            clearTimeout(this.icaoSearchDebounceTimer);
        }
        const opId = ++this.searchOpId;
        this.icaoSearchDebounceTimer = setTimeout(() => {
            this.icaoSearchDebounceTimer = null;
            this.executeICAOSearch(text, opId);
        }, WaypointInputController.ICAO_SEARCH_DEBOUNCE_DELAY);
    }
    /**
     * Executes an ICAO search.
     * @param text The text to search against.
     * @param opId The id of the search to complete.
     */
    async executeICAOSearch(text, opId) {
        if (this.isIcaoValid(text)) {
            try {
                if (opId === this.searchOpId) {
                    const searchText = text.trim();
                    let icaos = await this.store.doSearch(searchText);
                    if (opId !== this.searchOpId) {
                        return;
                    }
                    //One or more exact matches
                    let exactMatches = 0;
                    if (ICAO.getIdent(icaos[0]) === searchText) {
                        for (let i = 0; i < icaos.length; i++) {
                            if (ICAO.getIdent(icaos[i]) === searchText) {
                                exactMatches++;
                            }
                            else {
                                break;
                            }
                        }
                    }
                    if (exactMatches !== 0) {
                        icaos = icaos.slice(0, exactMatches);
                    }
                    else {
                        icaos.splice(1, icaos.length - 1);
                    }
                    this.store.loadIcaoData(icaos.length > 1 ? Array.from(new Set(icaos)) : icaos);
                }
            }
            catch (e) {
                // noop
            }
        }
        else {
            if (opId === this.searchOpId) {
                this.store.loadIcaoData([]);
            }
        }
    }
    /**
     * Validates the ICAO search input.
     * @param icao The value coming from the ICAO input.
     * @returns A {boolean} indicating if the input is valid for search.
     */
    isIcaoValid(icao) {
        if (icao.length > 0 && !icao.startsWith(' ')) {
            // check if there comes another whitespace before a letter
            let prevCharBlank = false;
            for (let i = 1; i < icao.length; i++) {
                const char = icao[i];
                const currentCharBlank = char === ' ';
                if (prevCharBlank && !currentCharBlank) {
                    return false;
                }
                prevCharBlank = currentCharBlank;
            }
            return true;
        }
        return false;
    }
}
WaypointInputController.ICAO_SEARCH_DEBOUNCE_DELAY = 250; // milliseconds

/**
 * Waypoint input store
 */
class WaypointInputStore {
    /**
     * Creates an instance of waypoint input store.
     * @param bus The event bus.
     * @param searchFilter This store's search filter for ICAOSearch.
     * @param onWaypointChanged A function which is called when this store's selected waypoint changes.
     * @param onFacilityChanged A function which is called when this store's selected facility changes.
     * @param onMatchedWaypointsChanged A function which is called when this store's matched waypoints changes.
     */
    constructor(bus, searchFilter, onWaypointChanged, onFacilityChanged, onMatchedWaypointsChanged) {
        this.searchFilter = searchFilter;
        this.onWaypointChanged = onWaypointChanged;
        this.onFacilityChanged = onFacilityChanged;
        this.onMatchedWaypointsChanged = onMatchedWaypointsChanged;
        this.nameEmptyStr = '_______________';
        this.cityEmptyStr = '________________';
        this.displayWaypoint = {
            icao: '',
            name: ComputedSubject.create(this.nameEmptyStr, (v) => {
                return (v === '') ? this.nameEmptyStr : Utils.Translate(v);
            }),
            city: ComputedSubject.create('', (v) => {
                if (v === '') {
                    return this.cityEmptyStr;
                }
                const separatedCity = v.split(', ');
                return separatedCity.length > 1 ? Utils.Translate(separatedCity[0]) + ' ' + Utils.Translate(separatedCity[1]).substr(0, 2).toUpperCase() : Utils.Translate(v);
            }),
        };
        /** A subject which provides the currently selected waypoint. */
        this.selectedWaypoint = Subject.create(null);
        /** A subject which provides the input text value which should be displayed. */
        this.inputValue = Subject.create('');
        this._matchedIcaos = [];
        this._matchedWaypoints = [];
        this.loadIcaosOpId = 0;
        this.facRepo = FacilityRespository.getRepository(bus);
        this.facLoader = new FacilityLoader(this.facRepo);
        this.facWaypointCache = FacilityWaypointCache.getCache();
        this.selectedWaypoint.sub(waypoint => {
            this.onWaypointChanged && this.onWaypointChanged(waypoint);
            this.onFacilityChanged && this.onFacilityChanged(waypoint === null || waypoint === void 0 ? void 0 : waypoint.facility);
        });
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** An array of ICAO strings which have matched the input. */
    get matchedIcaos() {
        return this._matchedIcaos;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** An array of facilities which have matched the input. */
    get matchedWaypoints() {
        return this._matchedWaypoints;
    }
    /**
     * Executes the icao search.
     * @param searchStr The search string.
     * @returns An array of the found ICAOs.
     */
    doSearch(searchStr) {
        return this.facLoader.searchByIdent(this.searchFilter, searchStr);
    }
    /**
     * Loads and display the facility data for the currently found ICAO
     * @param icaos The ICAO to load.
     * @returns a Promise which fulfills with whether the ICAO data was successfully loaded.
     */
    async loadIcaoData(icaos) {
        if (icaos.length === this._matchedIcaos.length && icaos.every((icao, index) => icao === this._matchedIcaos[index])) {
            return false;
        }
        const opId = ++this.loadIcaosOpId;
        let matchedWaypoints;
        try {
            matchedWaypoints = await Promise.all(icaos.map(async (icao) => this.facWaypointCache.get(await this.facLoader.getFacility(ICAO.getFacilityType(icao), icao))));
        }
        catch (e) {
            icaos = [];
        }
        if (opId !== this.loadIcaosOpId) {
            return false;
        }
        this._matchedIcaos = [...icaos];
        this._matchedWaypoints = matchedWaypoints !== null && matchedWaypoints !== void 0 ? matchedWaypoints : [];
        this.onMatchedWaypointsChanged && this.onMatchedWaypointsChanged(this.matchedWaypoints);
        if (this._matchedWaypoints.length > 0) {
            this.setWaypoint(this._matchedWaypoints[0]);
        }
        else {
            this.clearWaypoint();
        }
        return true;
    }
    /**
     * Sets the selected and displayed waypoint.
     * @param waypoint A facility waypoint.
     */
    setWaypoint(waypoint) {
        this.selectedWaypoint.set(waypoint);
        this.displayWaypoint.icao = waypoint.facility.icao;
        this.displayWaypoint.city.set(waypoint.facility.city);
        this.displayWaypoint.name.set(waypoint.facility.name);
    }
    /**
     * Clears the selected and displayed waypoint.
     */
    clearWaypoint() {
        this.selectedWaypoint.set(null);
        if (this.displayWaypoint.icao !== '') {
            this.displayWaypoint.icao = '';
            this.displayWaypoint.city.set('');
            this.displayWaypoint.name.set('');
        }
    }
}

/**
 * An abstract component which is bound to a waypoint.
 */
class WaypointComponent extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.waypointChangedHandler = this.onWaypointChanged.bind(this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        this.props.waypoint.sub(this.waypointChangedHandler, true);
    }
    /**
     * A callback which is called when this component's waypoint changes.
     * @param waypoint The new waypoint.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onWaypointChanged(waypoint) {
        // noop
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    destroy() {
        this.props.waypoint.unsub(this.waypointChangedHandler);
    }
}

/**
 * A waypoint icon.
 */
class WaypointIcon extends WaypointComponent {
    constructor() {
        super(...arguments);
        this.imgRef = FSComponent.createRef();
        this.planeHeadingChangedHandler = this.onPlaneHeadingChanged.bind(this);
        this.srcSub = ComputedSubject.create(null, (waypoint) => {
            if (!waypoint) {
                return '';
            }
            if (waypoint instanceof FacilityWaypoint) {
                return this.getFacilityIconSrc(waypoint);
            }
            return '';
        });
        this.needUpdateAirportSpriteSub = ComputedSubject.create(null, (waypoint) => {
            if (!waypoint) {
                return false;
            }
            return !!this.props.planeHeading && waypoint instanceof AirportWaypoint;
        });
        this.imgFrameRowCount = 1;
        this.imgFrameColCount = 1;
        this.imgOffset = '0px 0px';
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        this.initImageLoadListener();
        super.onAfterRender();
        this.initPlaneHeadingListener();
    }
    /**
     * Initializes the image onload listener.
     */
    initImageLoadListener() {
        this.imgRef.instance.onload = this.onImageLoaded.bind(this);
    }
    /**
     * Initializes the plane heading listener.
     */
    initPlaneHeadingListener() {
        if (this.props.planeHeading) {
            this.props.planeHeading.sub(this.planeHeadingChangedHandler, true);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onWaypointChanged(waypoint) {
        this.srcSub.set(waypoint);
        this.needUpdateAirportSpriteSub.set(waypoint);
    }
    /**
     * A callback which is called when this component's image element finishes loading an image.
     */
    onImageLoaded() {
        const img = this.imgRef.instance;
        this.imgFrameRowCount = Math.floor(img.naturalHeight / 32);
        this.imgFrameColCount = Math.floor(img.naturalWidth / 32);
    }
    /**
     * A callback which is called when plane heading changes.
     * @param planeHeading The true heading of the airplane, in degrees.
     */
    onPlaneHeadingChanged(planeHeading) {
        if (this.needUpdateAirportSpriteSub.get()) {
            this.updateAirportSprite(planeHeading);
        }
    }
    /**
     * Updates this icon's airport sprite.
     * @param planeHeading The true heading of the airplane, in degrees.
     */
    updateAirportSprite(planeHeading) {
        const waypoint = this.props.waypoint.get();
        if (!(waypoint instanceof AirportWaypoint) || !waypoint.longestRunway) {
            return;
        }
        const headingDelta = waypoint.longestRunway.direction - planeHeading;
        const frame = Math.round(NavMath.normalizeHeading(headingDelta) / 22.5) % 8;
        const row = Math.min(Math.floor(frame / 4), this.imgFrameRowCount - 1);
        const col = Math.min(frame % 4, this.imgFrameColCount - 1);
        const xOffset = col * -32;
        const yOffset = row * -32;
        this.setImgOffset(`${xOffset}px ${yOffset}px`);
    }
    /**
     * Sets the object offset of this icon's image element.
     * @param offset The new offset.
     */
    setImgOffset(offset) {
        if (offset === this.imgOffset) {
            return;
        }
        this.imgOffset = offset;
        this.imgRef.instance.style.objectPosition = offset;
    }
    /**
     * Gets the appropriate icon src for a facility waypoint.
     * @param waypoint A facility waypoint.
     * @returns the appropriate icon src for the facility waypoint.
     */
    getFacilityIconSrc(waypoint) {
        switch (ICAO.getFacilityType(waypoint.facility.icao)) {
            case FacilityType.Airport:
                return this.getAirportIconSrc(waypoint);
            case FacilityType.VOR:
                return this.getVorIconSrc(waypoint);
            case FacilityType.NDB:
                return this.getNdbIconSrc();
            case FacilityType.Intersection:
                return this.getIntersectionIconSrc();
            case FacilityType.USR:
                return this.getUserIconSrc();
            case FacilityType.RWY:
                return this.getRunwayIconSrc();
            default:
                return '';
        }
    }
    /**
     * Gets the appropriate icon src for an airport waypoint.
     * @param waypoint An airport waypoint.
     * @returns the appropriate icon src for the airport waypoint.
     */
    getAirportIconSrc(waypoint) {
        const airport = waypoint.facility;
        const serviced = (airport.fuel1 !== '' || airport.fuel2 !== '') || airport.airportClass === 1;
        if (airport.airportPrivateType !== AirportPrivateType.Public) {
            return `${WaypointIcon.PATH}/airport_r.png`;
        }
        else if (serviced) {
            if (airport.towered) {
                return `${WaypointIcon.PATH}/airport_large_blue.png`;
            }
            else if (airport.airportClass === 1) {
                return `${WaypointIcon.PATH}/airport_large_magenta.png`;
            }
            else {
                return `${WaypointIcon.PATH}/airport_small_b.png`;
            }
        }
        else {
            if (airport.towered) {
                return `${WaypointIcon.PATH}/airport_med_blue.png`;
            }
            else if (airport.airportClass === 1) {
                return `${WaypointIcon.PATH}/airport_med_magenta.png`;
            }
            else {
                return `${WaypointIcon.PATH}/airport_small_a.png`;
            }
        }
    }
    /**
     * Gets the appropriate icon src for a VOR waypoint.
     * @param waypoint A VOR waypoint.
     * @returns the appropriate icon src for the VOR waypoint.
     */
    getVorIconSrc(waypoint) {
        switch (waypoint.facility.type) {
            case VorType.DME:
                return `${WaypointIcon.PATH}/dme.png`;
            case VorType.ILS:
            case VorType.VORDME:
                return `${WaypointIcon.PATH}/vor_dme.png`;
            case VorType.VORTAC:
            case VorType.TACAN:
                return `${WaypointIcon.PATH}/vortac.png`;
            default:
                return `${WaypointIcon.PATH}/vor.png`;
        }
    }
    /**
     * Gets the appropriate icon src for an NDB waypoint.
     * @returns the appropriate icon src for the NDB waypoint.
     */
    getNdbIconSrc() {
        return `${WaypointIcon.PATH}/ndb.png`;
    }
    /**
     * Gets the appropriate icon src for an intersection waypoint.
     * @returns the appropriate icon src for the intersection waypoint.
     */
    getIntersectionIconSrc() {
        return `${WaypointIcon.PATH}/intersection_cyan.png`;
    }
    /**
     * Gets the appropriate icon src for an intersection waypoint.
     * @returns the appropriate icon src for the intersection waypoint.
     */
    getUserIconSrc() {
        return `${WaypointIcon.PATH}/user.png`;
    }
    /**
     * Gets the appropriate icon src for a runway waypoint.
     * @returns the appropriate icon src for the runway waypoint.
     */
    getRunwayIconSrc() {
        return `${WaypointIcon.PATH}/intersection_cyan.png`;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        var _a;
        return (FSComponent.buildComponent("img", { ref: this.imgRef, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', src: this.srcSub, style: `width: 32px; height: 32px; object-fit: none; object-position: ${this.imgOffset};` }));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    destroy() {
        super.destroy();
        if (this.props.planeHeading) {
            this.props.planeHeading.unsub(this.planeHeadingChangedHandler);
        }
    }
}
WaypointIcon.PATH = 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map';

/** The WaypointInput component. */
class WaypointInput extends UiControlGroup {
    constructor() {
        super(...arguments);
        this.inputComponentRef = FSComponent.createRef();
        this.store = new WaypointInputStore(this.props.bus, this.props.filter, this.props.onWaypointChanged, this.props.onFacilityChanged, this.props.onMatchedWaypointsChanged);
        this.controller = new WaypointInputController(this.store, this.props.selectedIcao, this.onInputTextValueOverride.bind(this));
    }
    /**
     * A callback which is called when the input text value needs to be overridden.
     * @param value The new input text value.
     */
    onInputTextValueOverride(value) {
        this.inputComponentRef.instance.setText(value, value === '' ? 0 : undefined, false);
    }
    /**
     * A callback which is called when Enter is pressed on this component's InputComponent child.
     * @returns whether the Enter event was handled.
     */
    onInputEnterPressed() {
        const facilityWaypoint = this.store.selectedWaypoint.get();
        if (!facilityWaypoint && this.store.inputValue.get() !== '') {
            Fms.viewService.open(MessageDialog.name, true).setInput({ inputString: `${this.store.inputValue.get().replace(/^_+|_+$/g, '')} does not exist.` }).onClose.on(() => {
                this.inputComponentRef.instance.activate();
            });
        }
        else {
            if (this.props.onInputEnterPressed !== undefined && facilityWaypoint !== null) {
                this.props.onInputEnterPressed(facilityWaypoint.facility);
            }
        }
        return true;
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "wpt-entry" },
            FSComponent.buildComponent(InputComponent, { onRegister: this.register, ref: this.inputComponentRef, maxLength: 6, onTextChanged: this.controller.onInputChanged.bind(this.controller), onEnter: this.onInputEnterPressed.bind(this) }),
            FSComponent.buildComponent(WaypointIcon, { waypoint: this.store.selectedWaypoint, planeHeading: this.props.planeHeading, class: 'wpt-entry-icon' }),
            FSComponent.buildComponent("div", { class: "wpt-entry-location" }, this.store.displayWaypoint.city),
            FSComponent.buildComponent("div", { class: "wpt-entry-name" }, this.store.displayWaypoint.name)));
    }
}

/**
 * A view for selecting approaches.
 */
class SelectApproach extends UiView {
    constructor() {
        super(...arguments);
        this.store = new SelectApproachStore();
        this.controller = this.createController();
        this.sortedApproachSub = SortedMappedSubscribableArray.create(this.store.approaches, this.sortApproaches.bind(this));
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.CLR:
                this.close();
                return true;
        }
        return false;
    }
    /** @inheritdoc */
    onViewOpened() {
        this.controller.initialize();
    }
    /** Goto and activate next select control. */
    gotoNextSelect() {
        this.scrollController.gotoNext();
        setTimeout(() => {
            const focusedCtrl = this.scrollController.getFocusedUiControl();
            if (focusedCtrl instanceof SelectControl) {
                if (focusedCtrl.MenuItems.length > 1) {
                    focusedCtrl.onUpperKnob();
                }
                else {
                    this.gotoNextSelect();
                }
            }
        }, 50);
    }
    /** @inheritdoc */
    onAfterRender() {
        super.onAfterRender();
        const g1000Events = this.props.bus.getSubscriber();
        g1000Events.on('set_minimums').handle((set) => {
            if (set !== this.store.minimumsSubject.get()) {
                this.store.minimumsSubject.set(set);
            }
        });
        g1000Events.on('show_minimums').handle((mode) => {
            const option = mode ? 1 : 0;
            this.store.minimumsMode.set(option);
        });
    }
    /**
     * Sorts approaches into the order they should appear in the approach list.
     * @param a An approach list item.
     * @param b An approach list item.
     * @returns 0 if the two approaches are to be sorted identically, a negative number if approach `a` is to be sorted
     * before `b`, or a positive number if approach `a` is to be sorted after `b`.
     */
    sortApproaches(a, b) {
        // sort first by approach type (ILS, LOC, RNAV, etc)
        let compare = SelectApproach.APPROACH_TYPE_PRIORITIES[a.approach.approachType] - SelectApproach.APPROACH_TYPE_PRIORITIES[b.approach.approachType];
        if (compare === 0) {
            // then sort by runway (circling approaches go last)
            compare = (a.approach.runwayNumber === 0 ? 37 : a.approach.runwayNumber) - (b.approach.runwayNumber === 0 ? 37 : b.approach.runwayNumber);
            if (compare === 0) {
                // then sort by L, C, R (order depends on if runway number is <= 18)
                const priorities = a.approach.runwayNumber <= 18
                    ? SelectApproach.APPROACH_RUNWAY_DESIGNATOR_PRIORITIES_FWD
                    : SelectApproach.APPROACH_RUNWAY_DESIGNATOR_PRIORITIES_REV;
                compare = priorities[a.approach.runwayDesignator] - priorities[b.approach.runwayDesignator];
                if (compare === 0) {
                    // finally sort by approach suffix
                    compare = a.approach.approachSuffix.localeCompare(b.approach.approachSuffix);
                }
            }
        }
        return compare;
    }
    /**
     * Renders the waypoint input component.
     * @returns The rendered waypoint input component, as a VNode.
     */
    renderWaypointInput() {
        return (FSComponent.buildComponent(WaypointInput, { bus: this.props.bus, onRegister: this.register, onInputEnterPressed: this.gotoNextSelect.bind(this), selectedIcao: this.controller.inputIcao, onFacilityChanged: this.controller.facilityChangedHandler, filter: FacilitySearchType.Airport }));
    }
    /**
     * Renders the approach select control component.
     * @param dialogPosition The position of the pop-up context menu dialog spawned by the select control.
     * @returns The rendered approach select control component, as a VNode.
     */
    renderApproachSelectControl(dialogPosition) {
        return (FSComponent.buildComponent(SelectControl, { onRegister: this.register, outerContainer: this.viewContainerRef, data: this.sortedApproachSub, onItemSelected: this.controller.onApproachSelected, buildMenuItem: this.controller.buildApprMenuItem, dialogPosition: dialogPosition, class: 'slct-appr-value' }));
    }
    /**
     * Renders the transition select control component.
     * @param dialogPosition The position of the pop-up context menu dialog spawned by the select control.
     * @returns The rendered transition select control component, as a VNode.
     */
    renderTransitionSelectControl(dialogPosition) {
        return (FSComponent.buildComponent(SelectControl, { onRegister: this.register, outerContainer: this.viewContainerRef, data: this.store.transitions, onItemSelected: this.controller.onTransSelected, buildMenuItem: this.controller.buildTransMenuItem, dialogPosition: dialogPosition, class: 'slct-appr-trans-value' }));
    }
    /**
     * Renders the minimums number input component.
     * @param cssClass CSS class(es) to apply to the number input component.
     * @returns The minimums number input component, as a VNode.
     */
    renderMinimumsNumberInput(cssClass) {
        return (FSComponent.buildComponent(NumberInput, { onRegister: this.register, onValueChanged: this.controller.updateMinimumsValue, dataSubject: this.store.minimumsSubject, minValue: -1000, maxValue: 10000, increment: 10, wrap: false, defaultDisplayValue: '_ _ _ _ _', class: cssClass }));
    }
}
SelectApproach.APPROACH_TYPE_PRIORITIES = {
    [ApproachType.APPROACH_TYPE_ILS]: 0,
    [ApproachType.APPROACH_TYPE_LOCALIZER]: 1,
    [ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE]: 2,
    [ApproachType.APPROACH_TYPE_LDA]: 3,
    [ApproachType.APPROACH_TYPE_SDF]: 4,
    [ApproachType.APPROACH_TYPE_RNAV]: 5,
    [ApproachType.APPROACH_TYPE_GPS]: 6,
    [ApproachType.APPROACH_TYPE_VORDME]: 7,
    [ApproachType.APPROACH_TYPE_VOR]: 8,
    [ApproachType.APPROACH_TYPE_NDBDME]: 9,
    [ApproachType.APPROACH_TYPE_NDB]: 10,
    [AdditionalApproachType.APPROACH_TYPE_VISUAL]: 11,
    [ApproachType.APPROACH_TYPE_UNKNOWN]: 12
};
SelectApproach.APPROACH_RUNWAY_DESIGNATOR_PRIORITIES_FWD = {
    [RunwayDesignator.RUNWAY_DESIGNATOR_NONE]: 0,
    [RunwayDesignator.RUNWAY_DESIGNATOR_CENTER]: 1,
    [RunwayDesignator.RUNWAY_DESIGNATOR_LEFT]: 2,
    [RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT]: 3,
    [RunwayDesignator.RUNWAY_DESIGNATOR_WATER]: 4,
    [RunwayDesignator.RUNWAY_DESIGNATOR_B]: 5,
    [RunwayDesignator.RUNWAY_DESIGNATOR_A]: 6,
};
SelectApproach.APPROACH_RUNWAY_DESIGNATOR_PRIORITIES_REV = {
    [RunwayDesignator.RUNWAY_DESIGNATOR_NONE]: 0,
    [RunwayDesignator.RUNWAY_DESIGNATOR_CENTER]: 1,
    [RunwayDesignator.RUNWAY_DESIGNATOR_LEFT]: 3,
    [RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT]: 2,
    [RunwayDesignator.RUNWAY_DESIGNATOR_WATER]: 4,
    [RunwayDesignator.RUNWAY_DESIGNATOR_B]: 5,
    [RunwayDesignator.RUNWAY_DESIGNATOR_A]: 6,
};

/** Select approach controller */
class SelectApproachController {
    /**
     * Creates an instance of select approach controller.
     * @param store The store.
     * @param selectNextCb Callback when the next control should be focused.
     * @param fms Instance of FMS.
     * @param fplKey The FPL ViewService Key.
     * @param hasSequence If this instance of the controller should support a sequence display.
     */
    constructor(store, selectNextCb, fms, fplKey, hasSequence = false) {
        this.store = store;
        this.selectNextCb = selectNextCb;
        this.fms = fms;
        this.fplKey = fplKey;
        this.hasSequence = hasSequence;
        this.inputIcao = Subject.create('');
        this.canLoad = Subject.create(false);
        this.canActivate = Subject.create(false);
        this.canLoadOrText = ComputedSubject.create(false, (v) => { return v ? 'OR' : ''; });
        this.skipCourseReversal = false;
        /**
         * Handler method to handle when the facility in wpt input changed.
         * @param facility The facility selected in wpt input.
         */
        this.facilityChangedHandler = async (facility) => {
            this.store.clearFacility();
            if (facility !== undefined) {
                this.store.loadFacility(facility);
                this.skipCourseReversal = false;
            }
        };
        /**
         * Evaluates if the next select should be focused.
         * @param isRefresh If select event happened based on a data refresh.
         */
        this.gotoNextSelect = (isRefresh) => {
            if (!isRefresh) {
                this.selectNextCb();
            }
        };
        /**
         * Callback handler for when a minimums option is selected.
         * @param index The index of the option selected.
         */
        this.onMinimumsOptionSelected = (index) => {
            this.store.minimumsMode.set(index);
            Fms.g1000EvtPub.publishEvent('show_minimums', index === 1);
        };
        /** Callback handler for  when a minimums value is selected. */
        this.updateMinimumsValue = () => {
            Fms.g1000EvtPub.publishEvent('set_minimums', this.store.minimumsSubject.get());
        };
        /**
         * Callback handler for when a approach procedure is selected.
         * @param index The index of the procedure selected.
         * @param item The item selected.
         * @param isRefresh If select event happened based on a data refresh.
         */
        this.onApproachSelected = (index, item, isRefresh) => {
            this.store.selectedApproach.set(item);
            const validApproachSelected = !!item;
            this.canActivate.set(validApproachSelected);
            this.canLoad.set(validApproachSelected && this.fms.canApproachLoad());
            this.gotoNextSelect(isRefresh);
            this.buildSequence();
        };
        /**
         * Builds a approach procedure menu item.
         * @param proc The approach procedure.
         * @param index The index of the procedure.
         * @returns A menu item definition.
         */
        this.buildApprMenuItem = (proc, index) => {
            return {
                id: index.toString(), renderContent: () => (FSComponent.buildComponent(ApproachNameDisplay, { approach: Subject.create(proc.approach) })),
                estimatedWidth: proc.approach.name.length * ContextMenuDialog.CHAR_WIDTH
            };
        };
        /**
         * Callback handler for when a transition is selected.
         * @param index The index of the transition selected.
         * @param item The item selected.
         * @param isRefresh If select event happened based on a data refresh.
         */
        this.onTransSelected = (index, item, isRefresh) => {
            var _a;
            this.store.selectedTransIndex.set(index);
            this.buildSequence();
            if (this.hasSequence && this.checkForCourseReversal()) {
                const icao = (_a = this.store.sequence.tryGet(1)) === null || _a === void 0 ? void 0 : _a.get().leg.fixIcao;
                Fms.viewService.open('MessageDialog', true).setInput(this.getCourseReversalDialogDef(ICAO.getIdent(icao !== null && icao !== void 0 ? icao : ''))).onAccept.on((sender, accept) => {
                    this.skipCourseReversal = !accept;
                    if (this.skipCourseReversal) {
                        this.store.sequence.removeAt(1);
                    }
                    this.gotoNextSelect(isRefresh);
                });
            }
            else {
                this.gotoNextSelect(isRefresh);
            }
        };
        /**
         * Builds a trans menu item.
         * @param trans The transition.
         * @param index The index of the transition.
         * @returns A menu item definition.
         */
        this.buildTransMenuItem = (trans, index) => {
            var _a;
            const transition = (_a = this.store.selectedApproach.get()) === null || _a === void 0 ? void 0 : _a.approach.transitions[trans.transitionIndex];
            const name = !transition ? 'VECTORS' : transition.legs.length == 0 ? 'NOLEGS' : trans.name && trans.name.length > 0 ? trans.name : 'NONAME';
            return { id: index.toString(), renderContent: () => FSComponent.buildComponent("span", null, name), estimatedWidth: name.length * ContextMenuDialog.CHAR_WIDTH };
        };
        /** Callback handler for when load is pressed. */
        this.onLoadExecuted = () => {
            const selectedFacility = this.store.selectedFacility;
            const approach = this.store.selectedApproach.get();
            if (selectedFacility && approach) {
                const transIndex = this.store.transitions.get(this.store.selectedTransIndex.get()).transitionIndex;
                const legOffset = this.store.transitions.get(this.store.selectedTransIndex.get()).startIndex;
                this.handleExecute(false, selectedFacility, approach, transIndex, legOffset);
            }
        };
        /** Callback handler for when activate is pressed. */
        this.onActivateExecuted = () => {
            const selectedFacility = this.store.selectedFacility;
            const approach = this.store.selectedApproach.get();
            if (selectedFacility && approach) {
                const transIndex = this.store.transitions.get(this.store.selectedTransIndex.get()).transitionIndex;
                const legOffset = this.store.transitions.get(this.store.selectedTransIndex.get()).startIndex;
                this.handleExecute(true, selectedFacility, approach, transIndex, legOffset);
            }
        };
        /**
         * Renders the procedure warning vnode (when we need to pass HTML).
         * @param warningMessage The dialog message content.
         * @param warningTitle The dialog message title content.
         * @returns A VNode to be rendered in the MessageDialog.
         */
        this.renderProcedureWarningDialogContent = (warningMessage, warningTitle) => {
            return (FSComponent.buildComponent("div", null,
                warningTitle,
                FSComponent.buildComponent("p", null),
                warningMessage));
        };
        const fpl = this.fms.bus.getSubscriber();
        fpl.on('fplCalculated').handle((e) => {
            if (e.planIndex == 2) {
                const plan = this.fms.flightPlanner.getFlightPlan(2);
                if (plan.segmentCount > 0) {
                    const segment = plan.getSegment(0);
                    for (let i = 0; i < segment.legs.length; i++) {
                        const leg = this.store.sequence.tryGet(i);
                        if (leg !== undefined) {
                            leg.get().calculated = segment.legs[i].calculated;
                            leg.notify();
                        }
                    }
                }
            }
        });
        this.canLoad.sub(v => this.canLoadOrText.set(v));
    }
    /** Initialize the controller. */
    initialize() {
        var _a;
        const initIcao = (_a = this.getInitialICAO()) !== null && _a !== void 0 ? _a : '';
        this.inputIcao.set(initIcao);
        if (initIcao !== '') {
            setTimeout(() => {
                this.gotoNextSelect(false);
            }, 100);
        }
    }
    /** @inheritdoc */
    getInitialICAO() {
        let icao;
        const dtoTargetIcao = this.fms.getDirectToTargetIcao();
        if (dtoTargetIcao !== undefined && ICAO.isFacility(dtoTargetIcao) && ICAO.getFacilityType(dtoTargetIcao) === FacilityType.Airport) {
            icao = dtoTargetIcao;
        }
        else if (this.fms.hasPrimaryFlightPlan()) {
            const plan = this.fms.getPrimaryFlightPlan();
            icao = plan.destinationAirport;
            if (icao === undefined) {
                // get the LAST airport in the flight plan.
                // TODO: would be nice to be able to iterate thru legs in reverse order
                for (const leg of plan.legs()) {
                    if (leg.isInDirectToSequence) {
                        continue;
                    }
                    switch (leg.leg.type) {
                        case LegType.IF:
                        case LegType.TF:
                        case LegType.DF:
                        case LegType.CF:
                        case LegType.AF:
                        case LegType.RF:
                            if (ICAO.isFacility(leg.leg.fixIcao) && ICAO.getFacilityType(leg.leg.fixIcao) === FacilityType.Airport) {
                                icao = leg.leg.fixIcao;
                            }
                            break;
                    }
                }
            }
        }
        return icao;
    }
    /**
     * Builds the sequence list for the approach preview
     */
    buildSequence() {
        const approach = this.store.selectedApproach.get();
        if (!approach) {
            return;
        }
        const legs = [];
        if (this.store.selectedFacility !== undefined) {
            let previewPlanIndex = -1;
            if (approach.isVisualApproach) {
                previewPlanIndex = this.fms.buildProcedurePreviewPlan(this.store.selectedFacility, ProcedureType.VISUALAPPROACH, -1, -1, undefined, undefined, approach.approach.runwayNumber, approach.approach.runwayDesignator);
            }
            else {
                const selectedTransIndex = this.store.selectedTransIndex.get();
                const transIndex = selectedTransIndex > -1 ? this.store.transitions.get(selectedTransIndex).transitionIndex : -1;
                const legOffset = selectedTransIndex > -1 ? this.store.transitions.get(selectedTransIndex).startIndex : 0;
                previewPlanIndex = this.fms.buildProcedurePreviewPlan(this.store.selectedFacility, ProcedureType.APPROACH, approach.index, transIndex, undefined, undefined, undefined, legOffset !== undefined ? legOffset : 0);
            }
            const previewPlan = this.fms.getFlightPlan(previewPlanIndex);
            previewPlan.getSegment(0).legs.forEach((l) => {
                legs.push(Subject.create(l));
            });
            this.store.sequence.set(legs);
        }
    }
    /**
     * Checks for a course reversal in the procedure.
     * @returns true if there is an optional course reversal.
     */
    checkForCourseReversal() {
        const legs = this.store.sequence.getArray();
        if (legs && legs.length > 0) {
            const leg = legs[1].get();
            switch (leg.leg.type) {
                case LegType.HA:
                case LegType.HF:
                case LegType.HM:
                    return true;
            }
        }
        return false;
    }
    /**
     * Handles loading and executing the approach with appropriate warning messages.
     * @param activate Whether or not to activate this approach.
     * @param facility The facility for the approach.
     * @param approach The Approach List Item to execute with.
     * @param approachTransitionIndex The transition index for the approach procedure.
     * @param transStartIndex The transition start index, if specified.
     */
    handleExecute(activate, facility, approach, approachTransitionIndex, transStartIndex) {
        var _a;
        const trueApproachIndex = approach.index;
        if (!approach.isVisualApproach) {
            const procedure = approach.approach;
            const insertApproach = (skipReversal) => {
                if (!FmsUtils.isGpsApproach(procedure)) {
                    const input = {
                        renderContent: () => this.renderProcedureWarningDialogContent('GPS guidance is for monitoring only. Load approach?', '- NOT APPROVED FOR GPS -'),
                        confirmButtonText: 'YES',
                        hasRejectButton: true,
                        rejectButtonText: 'NO'
                    };
                    Fms.viewService.open('MessageDialog', true).setInput(input).onAccept.on((sender, accept) => {
                        if (accept) {
                            this.fms.insertApproach(facility, trueApproachIndex, approachTransitionIndex, undefined, undefined, transStartIndex, skipReversal);
                            if (activate) {
                                this.fms.activateApproach();
                            }
                            Fms.viewService.open(this.fplKey);
                        }
                    });
                }
                else {
                    this.fms.insertApproach(facility, trueApproachIndex, approachTransitionIndex, undefined, undefined, transStartIndex, skipReversal);
                    if (activate) {
                        this.fms.activateApproach();
                    }
                    Fms.viewService.open(this.fplKey);
                }
            };
            if (this.checkForCourseReversal() && !this.hasSequence) {
                const icao = (_a = this.store.sequence.tryGet(1)) === null || _a === void 0 ? void 0 : _a.get().leg.fixIcao;
                const input = this.getCourseReversalDialogDef(ICAO.getIdent(icao !== null && icao !== void 0 ? icao : ''));
                input.closeOnAccept = false;
                Fms.viewService.open('MessageDialog', true).setInput(input).onAccept.on((sender, accept) => {
                    const skipReversal = !accept;
                    insertApproach(skipReversal);
                });
            }
            else if (this.hasSequence) {
                insertApproach(this.skipCourseReversal);
            }
            else {
                insertApproach(false);
            }
        }
        else {
            const runwayNumber = approach.approach.runwayNumber;
            const RunwayDesignator = approach.approach.runwayDesignator;
            Fms.viewService.open('MessageDialog', true).setInput({ inputString: 'Obstacle clearance is not provided for visual approaches', hasRejectButton: true })
                .onAccept.on((sender, accept) => {
                if (accept) {
                    this.fms.insertApproach(facility, -1, -1, runwayNumber, RunwayDesignator);
                    if (activate) {
                        this.fms.activateApproach();
                    }
                    Fms.viewService.open(this.fplKey);
                }
            });
        }
    }
    /**
     * Gets the MenuDialogDefinition for a course reversal dialog message.
     * @param fixName The name of the fix where the course reversal is.
     * @returns A MessageDialogDefinition.
     */
    getCourseReversalDialogDef(fixName) {
        return { inputString: `Fly Course Reversal at ${fixName}?`, confirmButtonText: 'YES', hasRejectButton: true, rejectButtonText: 'NO' };
    }
}

/**
 * An MFD view for selecting approaches.
 */
class MFDSelectApproach extends SelectApproach {
    constructor() {
        super(...arguments);
        this.sequenceListContainerRef = FSComponent.createRef();
        this.buildLegItem = (data, registerFn) => {
            return FSComponent.buildComponent(ProcSequenceItem, { onRegister: registerFn, data: data });
        };
    }
    /** @inheritdoc */
    createController() {
        return new SelectApproachController(this.store, this.gotoNextSelect.bind(this), this.props.fms, 'FPLPage', true);
    }
    /**
     * A callback which is called when the Load action is executed.
     */
    onLoadExecuted() {
        this.controller.onLoadExecuted();
    }
    /**
     * A callback which is called when the Activate action is executed.
     */
    onActivateExecuted() {
        this.controller.onActivateExecuted();
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: 'mfd-dark-background mfd-select-approach', ref: this.viewContainerRef },
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Airport" }, this.renderWaypointInput()),
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Approach Channel" },
                FSComponent.buildComponent("div", null, "Channel _ _ _ _ _ ID _ _ _ _ _")),
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Approach" }, this.renderApproachSelectControl()),
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Transition" }, this.renderTransitionSelectControl()),
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Minimums" },
                FSComponent.buildComponent("div", { class: 'mfd-select-approach-mins' },
                    FSComponent.buildComponent(ArrowToggle, { onRegister: this.register, onOptionSelected: this.controller.onMinimumsOptionSelected, options: this.store.minsToggleOptions, dataref: this.store.minimumsMode }),
                    FSComponent.buildComponent("div", null,
                        this.renderMinimumsNumberInput('mfd-select-approach-mins-number'),
                        FSComponent.buildComponent("span", { class: "size12" }, "FT")))),
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Primary frequency" },
                FSComponent.buildComponent("div", { "data-id": "select-freq", class: "cyan size18" }, this.store.frequencySubject)),
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Sequence" },
                FSComponent.buildComponent("div", { style: 'height: 160px; overflow:hidden', ref: this.sequenceListContainerRef },
                    FSComponent.buildComponent(List, { onRegister: this.register, data: this.store.sequence, renderItem: this.buildLegItem, scrollContainer: this.sequenceListContainerRef })),
                FSComponent.buildComponent(ScrollBar, null)),
            FSComponent.buildComponent("div", { class: "mfd-action-buttons mfd-select-approach-action-buttons" },
                FSComponent.buildComponent(ActionButton, { onRegister: this.register, isVisible: this.controller.canLoad, onExecute: this.onLoadExecuted.bind(this), text: "Load?" }),
                FSComponent.buildComponent("div", null, this.controller.canLoadOrText),
                FSComponent.buildComponent(ActionButton, { onRegister: this.register, isVisible: this.controller.canActivate, onExecute: this.onActivateExecuted.bind(this), text: "Activate?" }))));
    }
}

/** A control publisher that handles G1000 events too. */
class G1000ControlPublisher extends BasePublisher {
    /**
     * Create a ControlPublisher.
     * @param bus The EventBus to publish to.
     */
    constructor(bus) {
        super(bus);
    }
    /**
     * Publish a control event.
     * @param event The event from ControlEvents.
     * @param value The value of the event.
     */
    publishEvent(event, value) {
        this.publish(event, value, true);
    }
}

/** The controller for SelectProcedure views. */
class SelectProcedureController {
    /**
     * Ctor
     * @param store The store.
     * @param selectNextCb Callback when the next control should be focused.
     * @param fms The FMS instance.
     * @param procType is the procedure type for this controller.
     */
    constructor(store, selectNextCb, fms, procType) {
        this.store = store;
        this.selectNextCb = selectNextCb;
        this.fms = fms;
        this.procType = procType;
        this.inputIcao = Subject.create('');
        this.canLoad = Subject.create(false);
        /**
         * Handler method to handle when the facility in wpt input changed.
         * @param facility The facility selected in wpt input.
         */
        this.facilityChangedHandler = async (facility) => {
            this.store.clearFacility();
            if (facility !== undefined) {
                this.store.loadFacility(facility);
            }
        };
        /**
         * Evaluates if the next select should be focused.
         * @param isRefresh If select event happened based on a data refresh.
         */
        this.gotoNextSelect = (isRefresh) => {
            if (!isRefresh) {
                this.selectNextCb();
            }
        };
        /**
         * Callback handler for when a procedure is selected.
         * @param index The index of the selected procedure.
         * @param item The procedure selected.
         * @param isRefresh If select event happened based on a data refresh.
         */
        this.onProcSelected = (index, item, isRefresh) => {
            this.store.selectedProcIndex.set(index);
            this.store.runways.set((index > -1) ? this.store.getRunways() : []);
            this.store.transitions.set((index > -1) ? this.store.getTransitions() : []);
            this.canLoad.set(this.store.selectedProcIndex.get() !== -1);
            this.buildSequence();
            this.gotoNextSelect(isRefresh);
        };
        /**
         * Builds a procedure menu item.
         * @param proc The procedure to build the menu item for.
         * @param index The index of the procedure.
         * @returns A menu item definition.
         */
        this.buildProcMenuItem = (proc, index) => {
            return { id: index.toString(), renderContent: () => FSComponent.buildComponent("span", null, proc.name), estimatedWidth: proc.name.length * ContextMenuDialog.CHAR_WIDTH };
        };
        /**
         * Callback handler for when a runway transition is selected.
         * @param index The index of the selected transition.
         * @param item The transition selected.
         * @param isRefresh If select event happened based on a data refresh.
         */
        this.onRwySelected = (index, item, isRefresh) => {
            this.store.selectedRwyIndex.set(index);
            this.buildSequence();
            this.gotoNextSelect(isRefresh);
        };
        /**
         * Builds a runway transition menu item.
         * @param rwyTrans The runway transition to build the menu item for.
         * @param index The index of the runway transition.
         * @returns A menu item definition.
         **/
        this.buildRwyMenuItem = (rwyTrans, index) => {
            const name = this.store.getRunwayString(rwyTrans);
            return { id: index.toString(), renderContent: () => FSComponent.buildComponent("span", null, name), estimatedWidth: name.length * ContextMenuDialog.CHAR_WIDTH };
        };
        /**
         * Callback handler for when an enroute transition is selected.
         * @param index The index of the selected transition.
         * @param item The transition selected.
         * @param isRefresh If select event happened based on a data refresh.
         */
        this.onTransSelected = (index, item, isRefresh) => {
            this.store.selectedTransIndex.set(index - 1);
            this.buildSequence();
            this.gotoNextSelect(isRefresh);
        };
        /**
         * Builds a enroute transition menu item.
         * @param trans The transition to build the menu item for.
         * @param index The index of the transition.
         * @returns A menu item definition.
         */
        this.buildTransMenuItem = (trans, index) => {
            const name = trans.name.trim().length < 1 ? 'NONE' : trans.name;
            return {
                id: index.toString(),
                renderContent: () => FSComponent.buildComponent("span", null, name),
                estimatedWidth: name.length * ContextMenuDialog.CHAR_WIDTH
            };
        };
        /** Callback handler for when load is pressed. */
        this.onLoadSelected = () => {
            this.onLoadExecute();
        };
        const fpl = this.fms.bus.getSubscriber();
        fpl.on('fplCalculated').handle((e) => {
            if (e.planIndex == 2) {
                const plan = this.fms.flightPlanner.getFlightPlan(2);
                if (plan.segmentCount > 0) {
                    const segment = plan.getSegment(0);
                    for (let i = 0; i < segment.legs.length; i++) {
                        const leg = this.store.sequence.tryGet(i);
                        if (leg !== undefined) {
                            leg.get().calculated = segment.legs[i].calculated;
                            leg.notify();
                        }
                    }
                }
            }
        });
    }
    /** Initialize the controller. */
    initialize() {
        var _a;
        this.canLoad.set(false);
        const initIcao = (_a = this.getInitialICAO()) !== null && _a !== void 0 ? _a : '';
        this.inputIcao.set(initIcao);
        if (initIcao !== '') {
            setTimeout(() => {
                this.gotoNextSelect(false);
            }, 100);
        }
    }
    /**
     * Builds the sequence list for the approach preview
     */
    buildSequence() {
        if (this.store.selectedProcIndex.get() > -1) {
            const legs = [];
            if (this.store.selectedFacility !== undefined) {
                const previewPlanIndex = this.fms.buildProcedurePreviewPlan(this.store.selectedFacility, this.procType, this.store.selectedProcIndex.get(), this.store.selectedTransIndex.get(), this.store.getOneWayRunway(), this.store.selectedRwyIndex.get());
                const previewPlan = this.fms.getFlightPlan(previewPlanIndex);
                previewPlan.getSegment(0).legs.forEach((l) => {
                    legs.push(Subject.create(l));
                });
                this.store.sequence.set(legs);
            }
        }
    }
}

/** The data store for SelectProcedure pages */
class SelectProcedureStore {
    constructor() {
        this.selectedProcIndex = Subject.create(-1);
        this.selectedRwyIndex = Subject.create(-1);
        this.selectedTransIndex = Subject.create(-1);
        this.procedures = ArraySubject.create();
        this.runways = ArraySubject.create();
        this.transitions = ArraySubject.create();
        this.sequence = ArraySubject.create();
        // /**
        //  * Gets the enroute transitions of the selected procedure.
        //  * @returns The enroute transitions.
        //  */
        // public abstract getTransitions(): readonly EnrouteTransition[];
    }
    /**
     * Sets the data to display the facility.
     * @param facility The airport facility to be shown.
     */
    loadFacility(facility) {
        this.selectedFacility = facility;
        this.procedures.clear();
        this.runways.clear();
        this.transitions.clear();
        this.procedures.set(this.getProcedures());
    }
    /**
     * Empties the display content when no facility is selected
     */
    clearFacility() {
        this.selectedFacility = undefined;
        this.procedures.clear();
        this.runways.clear();
        this.transitions.clear();
    }
    /**
     * Gets the one-way runway from the selected procedure runway
     * @returns the OneWayRunway object or undefined
     */
    getOneWayRunway() {
        if (this.selectedFacility !== undefined && this.selectedRwyIndex.get() > -1) {
            const procRunway = this.getRunwayString(this.procedures.get(this.selectedProcIndex.get()).runwayTransitions[this.selectedRwyIndex.get()]);
            const oneWayRunway = RunwayUtils.matchOneWayRunwayFromDesignation(this.selectedFacility, procRunway);
            if (oneWayRunway !== undefined) {
                return oneWayRunway;
            }
        }
        return undefined;
    }
    /**
     * Gets a runway designation string from the runway transition.
     * @param runwayTransition is the runway transition object
     * @returns The runway designation string.
     */
    getRunwayString(runwayTransition) {
        if (runwayTransition !== undefined) {
            return RunwayUtils.getRunwayNameString(runwayTransition.runwayNumber, runwayTransition.runwayDesignation);
        }
        return '';
    }
    /**
     * Gets the runways of the selected procedure.
     * @returns The runways.
     */
    getRunways() {
        const rwys = this.procedures.get(this.selectedProcIndex.get()).runwayTransitions;
        return rwys;
    }
    /**
     * Gets the enroute transitions of the selected procedure.
     * @returns The enroute transitions.
     */
    getTransitions() {
        const transitions = [];
        const defaultTranstion = { name: this.getTransitionName(-1), legs: [] };
        transitions.push(defaultTranstion);
        const procedureTransitions = this.procedures.get(this.selectedProcIndex.get()).enRouteTransitions;
        for (let i = 0; i < procedureTransitions.length; i++) {
            const transition = procedureTransitions[i];
            transitions.push({ name: this.getTransitionName(i), legs: transition.legs });
        }
        return transitions;
    }
}

/** Controller for SelectArrival */
class SelectArrivalController extends SelectProcedureController {
    constructor() {
        super(...arguments);
        this.onLoadExecute = () => {
            if (this.store.selectedFacility !== undefined) {
                this.fms.insertArrival(this.store.selectedFacility, this.store.selectedProcIndex.get(), this.store.selectedRwyIndex.get(), this.store.selectedTransIndex.get(), this.store.getOneWayRunway());
            }
        };
    }
    /** @inheritdoc */
    getInitialICAO() {
        let icao;
        const dtoTargetIcao = this.fms.getDirectToTargetIcao();
        if (dtoTargetIcao !== undefined && ICAO.isFacility(dtoTargetIcao) && ICAO.getFacilityType(dtoTargetIcao) === FacilityType.Airport) {
            icao = dtoTargetIcao;
        }
        else if (this.fms.hasPrimaryFlightPlan()) {
            const plan = this.fms.getPrimaryFlightPlan();
            icao = plan.destinationAirport;
            if (icao === undefined) {
                // get the LAST airport in the flight plan.
                // TODO: would be nice to be able to iterate thru legs in reverse order
                for (const leg of plan.legs()) {
                    if (leg.isInDirectToSequence) {
                        continue;
                    }
                    switch (leg.leg.type) {
                        case LegType.IF:
                        case LegType.TF:
                        case LegType.DF:
                        case LegType.CF:
                        case LegType.AF:
                        case LegType.RF:
                            if (ICAO.isFacility(leg.leg.fixIcao) && ICAO.getFacilityType(leg.leg.fixIcao) === FacilityType.Airport) {
                                icao = leg.leg.fixIcao;
                            }
                            break;
                    }
                }
            }
        }
        return icao;
    }
}
/** Store for SelectArrival */
class SelectArrivalStore extends SelectProcedureStore {
    /** @inheritdoc */
    getProcedures() {
        var _a, _b;
        return (_b = (_a = this.selectedFacility) === null || _a === void 0 ? void 0 : _a.arrivals) !== null && _b !== void 0 ? _b : [];
    }
    /** @inheritdoc */
    getTransitionName(transitionIndex) {
        if (this.selectedFacility !== undefined) {
            const procedure = this.procedures.get(this.selectedProcIndex.get());
            if (transitionIndex == -1) {
                if (procedure.commonLegs.length > 0) {
                    /** For Arrivals, default transition name should be first leg icao - override in child method */
                    return ICAO.getIdent(procedure.commonLegs[0].fixIcao);
                }
                else {
                    const rwyTrans = procedure.runwayTransitions[this.selectedRwyIndex.get()];
                    /** For Arrivals, default transition name should be first leg icao - override in child method */
                    return ICAO.getIdent(rwyTrans.legs[0].fixIcao);
                }
            }
            else {
                const enrTrans = procedure.enRouteTransitions[transitionIndex];
                if (enrTrans.name.length > 0) {
                    return enrTrans.name;
                }
                else {
                    /** For Arrivals, default transition name should be first leg icao - override in child method */
                    return ICAO.getIdent(enrTrans.legs[0].fixIcao);
                }
            }
        }
        return 'NONE';
    }
}

/** Controller for SelectDeparture */
class SelectDepartureController extends SelectProcedureController {
    constructor() {
        super(...arguments);
        this.onLoadExecute = () => {
            if (this.store.selectedFacility !== undefined) {
                this.fms.insertDeparture(this.store.selectedFacility, this.store.selectedProcIndex.get(), this.store.selectedRwyIndex.get(), this.store.selectedTransIndex.get(), this.store.getOneWayRunway());
            }
        };
    }
    /** @inheritdoc */
    getInitialICAO() {
        let icao;
        if (this.fms.hasPrimaryFlightPlan()) {
            const plan = this.fms.getPrimaryFlightPlan();
            icao = plan.originAirport;
            if (icao === undefined) {
                // get the FIRST airport in the flight plan.
                for (const leg of plan.legs()) {
                    if (leg.isInDirectToSequence) {
                        continue;
                    }
                    switch (leg.leg.type) {
                        case LegType.IF:
                        case LegType.TF:
                        case LegType.DF:
                        case LegType.CF:
                        case LegType.AF:
                        case LegType.RF:
                            if (ICAO.isFacility(leg.leg.fixIcao) && ICAO.getFacilityType(leg.leg.fixIcao) === FacilityType.Airport) {
                                icao = leg.leg.fixIcao;
                            }
                            break;
                    }
                    if (icao !== undefined) {
                        break;
                    }
                }
            }
        }
        return icao;
    }
}
/** Store for SelectDeparture */
class SelectDepartureStore extends SelectProcedureStore {
    /** @inheritdoc */
    getProcedures() {
        var _a, _b;
        return (_b = (_a = this.selectedFacility) === null || _a === void 0 ? void 0 : _a.departures) !== null && _b !== void 0 ? _b : [];
    }
    /** @inheritdoc */
    getTransitionName(transitionIndex) {
        if (this.selectedFacility !== undefined) {
            const procedure = this.procedures.get(this.selectedProcIndex.get());
            if (transitionIndex == -1) {
                if (procedure.commonLegs.length > 0) {
                    const legsLen = procedure.commonLegs.length;
                    /** For Departures, default transition name should be last leg icao - override in child method */
                    return ICAO.getIdent(procedure.commonLegs[legsLen - 1].fixIcao);
                }
                else {
                    const rwyTrans = procedure.runwayTransitions[this.selectedRwyIndex.get()];
                    const legsLen = rwyTrans.legs.length;
                    /** For Departures, default transition name should be last leg icao - override in child method */
                    return ICAO.getIdent(rwyTrans.legs[legsLen - 1].fixIcao);
                }
            }
            else {
                const enrTrans = procedure.enRouteTransitions[transitionIndex];
                if (enrTrans.name.length > 0) {
                    return enrTrans.name;
                }
                else {
                    /** For Departures, default transition name should be last leg icao - override in child method */
                    const legsLen = enrTrans.legs.length;
                    return ICAO.getIdent(enrTrans.legs[legsLen - 1].fixIcao);
                }
            }
        }
        return 'NONE';
    }
}

/**
 * A view for selecting departures/arrivals.
 */
class SelectProcedure extends UiView {
    /**
     * Creates an instance of select procedure.
     * @param props The props.
     */
    constructor(props) {
        super(props);
        /** Goto and activate next select control. */
        this.gotoNextSelect = () => {
            this.scrollController.gotoNext();
            setTimeout(() => {
                const focusedCtrl = this.scrollController.getFocusedUiControl();
                if (focusedCtrl instanceof SelectControl) {
                    if (focusedCtrl.MenuItems.length > 1) {
                        focusedCtrl.onUpperKnob();
                    }
                    else {
                        this.gotoNextSelect();
                    }
                }
            }, 50);
        };
        this.store = this.getStore();
        this.controller = this.getController();
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.CLR:
                this.close();
                return true;
        }
        return false;
    }
    /** @inheritdoc */
    onViewOpened() {
        this.controller.initialize();
    }
    /**
     * Renders the waypoint input component.
     * @returns The rendered waypoint input component, as a VNode.
     */
    renderWaypointInput() {
        return (FSComponent.buildComponent(WaypointInput, { bus: this.props.bus, onRegister: this.register, onInputEnterPressed: this.gotoNextSelect, selectedIcao: this.controller.inputIcao, onFacilityChanged: this.controller.facilityChangedHandler, filter: FacilitySearchType.Airport }));
    }
    /**
     * Renders the procedure select control component.
     * @param dialogPosition The position of the pop-up context menu dialog spawned by the select control.
     * @returns The rendered procedure select control component, as a VNode.
     */
    renderProcedureSelectControl(dialogPosition) {
        return (FSComponent.buildComponent(SelectControl, { onRegister: this.register, outerContainer: this.viewContainerRef, data: this.store.procedures, onItemSelected: this.controller.onProcSelected, buildMenuItem: this.controller.buildProcMenuItem, dialogPosition: dialogPosition, class: 'slctproc-proc-value' }));
    }
    /**
     * Renders the runway transition select control component.
     * @param dialogPosition The position of the pop-up context menu dialog spawned by the select control.
     * @returns The rendered runway transition select control component, as a VNode.
     */
    renderRunwaySelectControl(dialogPosition) {
        return (FSComponent.buildComponent(SelectControl, { onRegister: this.register, outerContainer: this.viewContainerRef, data: this.store.runways, onItemSelected: this.controller.onRwySelected, buildMenuItem: this.controller.buildRwyMenuItem, dialogPosition: dialogPosition, class: 'slctproc-rwy-value' }));
    }
    /**
     * Renders the enroute transition select control component.
     * @param dialogPosition The position of the pop-up context menu dialog spawned by the select control.
     * @returns The rendered enroute transition select control component, as a VNode.
     */
    renderEnrouteSelectControl(dialogPosition) {
        return (FSComponent.buildComponent(SelectControl, { onRegister: this.register, outerContainer: this.viewContainerRef, data: this.store.transitions, onItemSelected: this.controller.onTransSelected, buildMenuItem: this.controller.buildTransMenuItem, dialogPosition: dialogPosition, class: 'slctproc-trans-value' }));
    }
}

/**
 * An MFD view for selecting departures/arrivals.
 */
class MFDSelectProcedure extends SelectProcedure {
    constructor() {
        super(...arguments);
        this.sequenceListContainerRef = FSComponent.createRef();
        this.buildLegItem = (data, registerFn) => {
            return FSComponent.buildComponent(ProcSequenceItem, { onRegister: registerFn, data: data });
        };
    }
    /**
     * A callback which is called when the Load action is executed.
     */
    onLoadSelected() {
        this.controller.onLoadSelected();
        this.props.viewService.open('FPLPage');
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: 'mfd-dark-background', ref: this.viewContainerRef },
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Airport" }, this.renderWaypointInput()),
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Procedure" }, this.renderProcedureSelectControl()),
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Runway" }, this.renderRunwaySelectControl()),
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Transition" }, this.renderEnrouteSelectControl()),
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Sequence" },
                FSComponent.buildComponent("div", { style: 'height: 160px; overflow:hidden', ref: this.sequenceListContainerRef },
                    FSComponent.buildComponent(List, { onRegister: this.register, data: this.store.sequence, renderItem: this.buildLegItem, scrollContainer: this.sequenceListContainerRef })),
                FSComponent.buildComponent(ScrollBar, null)),
            FSComponent.buildComponent("div", { class: "mfd-selectproc-load-button" },
                FSComponent.buildComponent(ActionButton, { onRegister: this.register, onExecute: this.onLoadSelected.bind(this), isVisible: this.controller.canLoad, text: "Load?" }))));
    }
}
/**
 * An MFD view for selecting departures.
 */
class MFDSelectDeparture extends MFDSelectProcedure {
    /** @inheritdoc */
    getController() {
        return new SelectDepartureController(this.getStore(), this.gotoNextSelect, this.props.fms, ProcedureType.DEPARTURE);
    }
    /** @inheritdoc */
    getProcLabel() {
        return 'Departure';
    }
    /** @inheritdoc */
    getStore() {
        var _a;
        return (_a = this.store) !== null && _a !== void 0 ? _a : new SelectDepartureStore();
    }
}
/**
 * An MFD view for selecting arrivals.
 */
class MFDSelectArrival extends MFDSelectProcedure {
    /** @inheritdoc */
    getController() {
        return new SelectArrivalController(this.getStore(), this.gotoNextSelect, this.props.fms, ProcedureType.ARRIVAL);
    }
    /** @inheritdoc */
    getProcLabel() {
        return 'Arrival';
    }
    /** @inheritdoc */
    getStore() {
        var _a;
        return (_a = this.store) !== null && _a !== void 0 ? _a : new SelectArrivalStore();
    }
}

/** The controller for the DTO view */
class DirectToController {
    /**
     * Creates an instance of direct to controller.
     * @param store is the Direct To Store
     * @param fms is the Direct To Controller
     */
    constructor(store, fms) {
        this.store = store;
        this.fms = fms;
        this.inputIcao = Subject.create('');
        this.canActivate = Subject.create(false);
        this.directToExisting = undefined;
        /**
         * A function which handles changes in waypoint input's selected waypoint.
         * @param waypoint The selected waypoint.
         */
        this.waypointChangedHandler = async (waypoint) => {
            var _a;
            const facility = waypoint instanceof FacilityWaypoint ? waypoint.facility : null;
            if ((facility === null || facility === void 0 ? void 0 : facility.icao) !== ((_a = this.directToExisting) === null || _a === void 0 ? void 0 : _a.icao)) {
                this.directToExisting = undefined;
                const plan = this.fms.getFlightPlan();
                for (let i = 0; i < plan.length; i++) {
                    const leg = plan.getLeg(i);
                    if (leg.leg.fixIcao === (facility === null || facility === void 0 ? void 0 : facility.icao) && leg.leg.type !== LegType.FC && leg.leg.type !== LegType.FD && leg.leg.type !== LegType.PI) {
                        const segmentIndex = plan.getSegmentIndex(i);
                        const segment = plan.getSegment(segmentIndex);
                        const directToExisting = {
                            segmentIndex: segmentIndex,
                            legIndex: i - segment.offset,
                            icao: facility === null || facility === void 0 ? void 0 : facility.icao
                        };
                        this.directToExisting = directToExisting;
                    }
                }
            }
            this.store.waypoint.set(waypoint);
            this.canActivate.set(!!facility);
        };
        // ---- ACTION CALLBACKS
        this.onActivateSelected = () => {
            const selectedWaypoint = this.store.waypoint.get();
            const facility = selectedWaypoint instanceof FacilityWaypoint ? selectedWaypoint.facility : null;
            if (facility) {
                if (this.directToExisting !== undefined && this.directToExisting.segmentIndex !== undefined && this.directToExisting.legIndex !== undefined) {
                    this.fms.createDirectToExisting(this.directToExisting.segmentIndex, this.directToExisting.legIndex);
                }
                else {
                    this.fms.createDirectToRandom(facility);
                }
                this.directToExisting = undefined;
            }
        };
    }
    /**
     * Initializes the direct to target based on input data. If the input data is defined, the target will be set to that
     * defined by the input data. If the input data is undefined, an attempt will be made to set the target to the
     * following, in order:
     * * The current active direct to target.
     * * The current active flight plan leg.
     * * The next leg in the primary flight plan, following the active leg, that is a valid direct to target.
     * * The previous leg in the primary flight plan, before the active leg, that is a valid direct to target.
     * @param dtoData The input data.
     */
    initializeTarget(dtoData) {
        this.directToExisting = undefined;
        let targetIcao = '';
        if ((dtoData === null || dtoData === void 0 ? void 0 : dtoData.legIndex) !== undefined && (dtoData === null || dtoData === void 0 ? void 0 : dtoData.segmentIndex) !== undefined) {
            this.directToExisting = dtoData;
            targetIcao = dtoData.icao;
        }
        else {
            const dtoState = this.fms.getDirectToState();
            if (dtoState === DirectToState.TOEXISTING) {
                const plan = this.fms.getPrimaryFlightPlan();
                this.directToExisting = {
                    icao: plan.getLeg(plan.activeLateralLeg).leg.fixIcao,
                    segmentIndex: plan.directToData.segmentIndex,
                    legIndex: plan.directToData.segmentLegIndex
                };
                targetIcao = this.directToExisting.icao;
            }
            else if (dtoState === DirectToState.TORANDOM) {
                const plan = this.fms.getDirectToFlightPlan();
                targetIcao = plan.getLeg(plan.activeLateralLeg).leg.fixIcao;
            }
            else if (this.fms.hasPrimaryFlightPlan()) {
                const plan = this.fms.getPrimaryFlightPlan();
                const activeLegIndex = plan.activeLateralLeg;
                let dtoExisting;
                // search forwards in plan for valid DTO target
                const len = plan.length;
                for (let i = activeLegIndex; i < len; i++) {
                    const segmentIndex = plan.getSegmentIndex(i);
                    const segmentLegIndex = i - plan.getSegment(segmentIndex).offset;
                    if (this.fms.canDirectTo(segmentIndex, segmentLegIndex)) {
                        dtoExisting = DirectToController.createDtoExistingData(plan, segmentIndex, segmentLegIndex);
                        break;
                    }
                }
                if (!dtoExisting) {
                    // search backwards in plan for valid DTO target
                    for (let i = activeLegIndex - 1; i >= 0; i--) {
                        const segmentIndex = plan.getSegmentIndex(i);
                        const segmentLegIndex = i - plan.getSegment(segmentIndex).offset;
                        if (this.fms.canDirectTo(segmentIndex, segmentLegIndex)) {
                            dtoExisting = DirectToController.createDtoExistingData(plan, segmentIndex, segmentLegIndex);
                            break;
                        }
                    }
                }
                if (dtoExisting) {
                    this.directToExisting = dtoExisting;
                    targetIcao = dtoExisting.icao;
                }
            }
        }
        this.inputIcao.set(targetIcao);
    }
    /**
     * Creates a direct to existing data object for a flight plan leg.
     * @param plan A flight plan.
     * @param segmentIndex The index of the segment in which the leg resides.
     * @param segmentLegIndex The index of the leg in its segment.
     * @returns A direct to existing data object.
     */
    static createDtoExistingData(plan, segmentIndex, segmentLegIndex) {
        return {
            icao: plan.getSegment(segmentIndex).legs[segmentLegIndex].leg.fixIcao,
            segmentIndex,
            legIndex: segmentLegIndex
        };
    }
}

/**
 * Utility class for working with ICAO region codes in a Garmin context.
 */
class Regions {
    /**
     * Gets the Garmin display name of the region associated with a specified ICAO region code.
     * @param code - the 2 character ICAO region code.
     * @returns the Garmin display name of the region.
     */
    static getName(code) {
        const name = Regions.NAME_TABLE[code.toUpperCase()];
        return name !== null && name !== void 0 ? name : '';
    }
}
Regions.NAME_TABLE = {
    'AG': 'SOLOMON ISL',
    'AN': 'NAURU ISL',
    'AY': 'PAPUA N GN',
    'BG': 'GREENLAND',
    'BI': 'ICELAND',
    'BK': 'KOSOVO',
    'CY': 'CANADA',
    'DA': 'ALGERIA',
    'DB': 'BENIN',
    'DF': 'BURKINA FASO',
    'DG': 'GHANA',
    'DI': 'IVRY COAST',
    'DN': 'NIGERIA',
    'DR': 'NIGER',
    'DT': 'TUNISIA',
    'DX': 'TOGO',
    'EB': 'BELGIUM',
    'ED': 'GERMANY',
    'EE': 'ESTONIA',
    'EF': 'FINLAND',
    'EG': 'U KINGDOM',
    'EH': 'NETHERLNDS',
    'EI': 'IRELAND',
    'EK': 'DENMARK',
    'EL': 'LUXEMBOURG',
    'EN': 'NORWAY',
    'EP': 'POLAND',
    'ES': 'SWEDEN',
    'ET': 'GERMANY',
    'EV': 'LATVIA',
    'EY': 'LITHUANIA',
    'FA': 'S AFRICA',
    'FB': 'BOTSWANA',
    'FC': 'CONGO',
    'FD': 'ESWATINI',
    'FE': 'CENTRL AFR',
    'FG': 'EQU GUINEA',
    'FH': 'ASCENSION IS',
    'FI': 'MAURITIUS',
    'FJ': 'BRIT INDIAN OC TERR',
    'FK': 'CAMEROON',
    'FL': 'ZAMBIA',
    'FM': 'MADAGASCAR',
    'FN': 'ANGOLA',
    'FO': 'GABON',
    'FP': 'SAO TOME',
    'FQ': 'MOZAMBIQUE',
    'FS': 'SEYCHELLES',
    'FT': 'CHAD',
    'FV': 'ZIMBABWE',
    'FW': 'MALAWI',
    'FX': 'LESOTHO',
    'FY': 'NAMIBIA',
    'FZ': 'DEM CONGO',
    'GA': 'MALI',
    'GB': 'GAMBIA',
    'GC': 'CANARY ISL',
    'GE': 'MELILLA',
    'GF': 'SIERRA LEONE',
    'GG': 'GUINEA BISSAU',
    'GL': 'LIBERIA',
    'GM': 'MOROCCO',
    'GO': 'SENEGAL',
    'GQ': 'MAURITANIA',
    'GS': 'W SAHARA',
    'GU': 'GUINEA',
    'GV': 'CAPE VERDE',
    'HA': 'ETHIOPIA',
    'HB': 'BURUNDI',
    'HD': 'DJIBOUTI',
    'HE': 'EGYPT',
    'HH': 'ERITREA',
    'HK': 'KENYRA',
    'HL': 'LIBYA',
    'HR': 'RWANDA',
    'HS': 'SUDAN',
    'HT': 'TANZANIA',
    'HU': 'UGANDA',
    'K1': 'NW USA',
    'K2': 'SW USA',
    'K3': 'N CEN USA',
    'K4': 'S CEN USA',
    'K5': 'GR LKS USA',
    'K6': 'NE USA',
    'K7': 'SE USA',
    'LA': 'ALBANIA',
    'LB': 'BULGARIA',
    'LC': 'CYPRUS',
    'LD': 'CROATIA',
    'LE': 'SPAIN',
    'LF': 'FRANCE',
    'LG': 'GREECE',
    'LH': 'HUNGARY',
    'LI': 'ITALY',
    'LJ': 'SLOVENIA',
    'LK': 'CZECH',
    'LL': 'ISRAEL',
    'LM': 'MALTA',
    'LO': 'AUSTRIA',
    'LP': 'PORTUGAL',
    'LQ': 'BOSNIA-HRZ',
    'LR': 'ROMANIA',
    'LS': 'SWITZERLAND',
    'LT': 'TURKEY',
    'LU': 'MOLDOVA',
    'LV': 'PALESTINE',
    'LW': 'MACEDONIA',
    'LX': 'GIBRALTAR',
    'LY': 'SERB/MONTG',
    'LZ': 'SLOVAKIA',
    'MB': 'TURKS/CAIC',
    'MD': 'DOM REPBLC',
    'MG': 'GUATEMALA',
    'MH': 'HONDURAS',
    'MK': 'JAMAICA',
    'MM': 'MEXICO',
    'MN': 'NICARAGUA',
    'MP': 'PANAMA',
    'MR': 'COSTA RICA',
    'MS': 'EL SALVADOR',
    'MT': 'HAITI',
    'MU': 'CUBA',
    'MW': 'CAYMAN IS',
    'MY': 'BAHAMAS',
    'MZ': 'BELIZE',
    'NC': 'COOK IS',
    'NF': 'FIJI',
    'NG': 'KIRIBATI IS',
    'NI': 'NIUE IS',
    'NL': 'WALLIS IS',
    'NS': 'AM/W SAMOA',
    'NT': 'FRNCH POLY',
    'NV': 'VANUATU',
    'NW': 'NEW CALEDONIA',
    'NZ': 'NEW ZEALND',
    'OA': 'AFGHANISTAN',
    'OB': 'BAHRAIN',
    'OE': 'SAUDI ARAB',
    'OI': 'IRAN',
    'OJ': 'JORDAN',
    'OK': 'KUWAIT',
    'OL': 'LEBANON',
    'OM': 'ARAB EMIRA',
    'OO': 'OMAN',
    'OP': 'PAKISTAN',
    'OR': 'IRAQ',
    'OS': 'SYRIA',
    'OT': 'QATAR',
    'OY': 'YEMEN',
    'PA': 'ALASKA',
    'PG': 'GUAM',
    'PH': 'HAWAII',
    'PJ': 'JOHNSTON ATOLL',
    'PK': 'MARSHLL IS',
    'PL': 'KIRIBATI',
    'PM': 'MIDWAY IS',
    'PO': 'ALASKA',
    'PP': 'ALASKA',
    'PT': 'MICRONESIA',
    'PW': 'WAKE IS',
    'RC': 'TAIWAN',
    'RJ': 'JAPAN',
    'RK': 'S KOREA',
    'RO': 'OKINAWA',
    'RP': 'PHILIPPINES',
    'SA': 'ARGENTINA',
    'SB': 'BRAZIL',
    'SC': 'CHILE',
    'SD': 'BRAZIL',
    'SE': 'EQUADOR',
    'SG': 'PARAGUAY',
    'SI': 'BRAZIL',
    'SJ': 'BRAZIL',
    'SK': 'COLOMBIA',
    'SL': 'BOLIVIA',
    'SM': 'SURINAME',
    'SO': 'FRN GUIANA',
    'SP': 'PERU',
    'SS': 'BRAZIL',
    'SU': 'URUGUAY',
    'SV': 'VENEZUELA',
    'SW': 'BRAZIL',
    'SY': 'GUYANA',
    'TA': 'ANTIGUA',
    'TB': 'BARBADOS',
    'TD': 'ANTIGUA',
    'TF': 'GUAD/MRTNQ',
    'TG': 'GRENADA',
    'TI': 'US VRGN IS',
    'TJ': 'PUERTO RIC',
    'TK': 'ST KTS/NEV',
    'TL': 'ST LUCIA',
    'TN': 'ARUBA',
    'TQ': 'ANGUILLA',
    'TT': 'MONTSERRAT',
    'TU': 'TRIN/TOBAG',
    'TV': 'BR VRGN IS',
    'TX': 'BERMUDA',
    'UA': 'KZKHSTN',
    'UB': 'AZERBAIJAN',
    'UC': 'KYRGYZSTAN',
    'UD': 'ARMENIA',
    'UE': 'RUSSIA',
    'UG': 'GEORGIA',
    'UH': 'RUSSIA',
    'UI': 'RUSSIA',
    'UK': 'UKRAINE',
    'UL': 'NW RUSSIA',
    'UM': 'BELARUS',
    'UN': 'RUSSIA',
    'UO': 'RUSSIA',
    'UR': 'RUSS/KZKST',
    'US': 'RUSSIA',
    'UT': 'UZBEK/TADZ',
    'UU': 'RUSSIA',
    'UW': 'RUSSIA',
    'VA': 'INDIA',
    'VC': 'SRI LANKA',
    'VD': 'CAMBODIA',
    'VE': 'INDIA',
    'VG': 'BANGLADESH',
    'VH': 'HONG KONG',
    'VI': 'INDIA',
    'VL': 'LAOS',
    'VM': 'MACAU',
    'VN': 'NEPAL',
    'VO': 'INDIA',
    'VR': 'MALDIVES',
    'VT': 'THAILAND',
    'VV': 'VIETNAM',
    'VY': 'MYANMAR',
    'WA': 'INDONESIA',
    'WB': 'BRUNEI',
    'WI': 'INDONESIA',
    'WM': 'MALAYSIA',
    'WR': 'INDONESIA',
    'WS': 'SINGAPORE',
    'YB': 'AUSTRALIA',
    'YM': 'AUSTRALIA',
    'ZB': 'CHINA',
    'ZG': 'CHINA',
    'ZH': 'CHINA',
    'ZK': 'N KOREA',
    'ZL': 'CHINA',
    'ZM': 'MONGOLIA',
    'ZP': 'CHINA',
    'ZS': 'CHINA',
    'ZU': 'CHINA',
    'ZW': 'CHINA',
    'ZY': 'CHINA',
};

/**
 * A store for commonly used waypoint info.
 */
class WaypointInfoStore {
    /**
     * Constructor.
     * @param waypoint A subscribable which provides this store's waypoint. If not defined, this store's waypoint can
     * still be set via its .waypoint Subject.
     * @param planePos A subscribable which provides the current airplane position for this store. If not defined, then
     * this store will not provide distance- or bearing-to-waypoint information.
     */
    constructor(waypoint, planePos) {
        this.planePos = planePos;
        /** This store's current waypoint. */
        this.waypoint = Subject.create(null);
        this._location = GeoPointSubject.createFromGeoPoint(WaypointInfoStore.NULL_LOCATION.copy());
        this._name = ComputedSubject.create(null, (waypoint) => {
            if (waypoint) {
                if (waypoint instanceof FacilityWaypoint && waypoint.facility.name !== '') {
                    return Utils.Translate(waypoint.facility.name);
                }
            }
            return '__________';
        });
        this._region = ComputedSubject.create(null, (waypoint) => {
            if (waypoint instanceof FacilityWaypoint) {
                if (waypoint instanceof AirportWaypoint) {
                    // airports don't have region codes in their ICAO strings, we will try to grab the code from the first 2
                    // letters of the ident. However, some airports (e.g. in the US and those w/o 4-letter idents) don't use the
                    // region code for the ident, so we need a third fallback, which is to just display the city name instead.
                    const airport = waypoint.facility;
                    const ident = ICAO.getIdent(airport.icao).trim();
                    let text = ident.length === 4 ? Regions.getName(ident.substr(0, 2)) : '';
                    if (text === '' && airport.city !== '') {
                        text = airport.city.split(', ').map(name => Utils.Translate(name)).join(', ');
                    }
                    if (text) {
                        return text;
                    }
                }
                else {
                    return Regions.getName(waypoint.facility.icao.substr(1, 2));
                }
            }
            return '__________';
        });
        this._city = ComputedSubject.create(null, (waypoint) => {
            if (waypoint instanceof FacilityWaypoint && waypoint.facility.city !== '') {
                return waypoint.facility.city.split(', ').map(name => Utils.Translate(name)).join(', ');
            }
            return '__________';
        });
        this._distance = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(NaN));
        this._bearing = NumberUnitSubject.createFromNumberUnit(UnitType.DEGREE.createNumber(NaN));
        waypoint && waypoint.sub(wpt => { this.waypoint.set(wpt); }, true);
        this.waypoint.sub(this.onWaypointChanged.bind(this), true);
        planePos && planePos.sub(this.onPlanePosChanged.bind(this), true);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The location of this store's current waypoint. */
    get location() {
        return this._location;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The name of this store's current waypoint. */
    get name() {
        return this._name;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The region of this store's current waypoint. */
    get region() {
        return this._region;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The city associated with this store's current waypoint. */
    get city() {
        return this._city;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The distance from the airplane to this store's current waypoint. */
    get distance() {
        return this._distance;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The true bearing from the airplane to this store's current waypoint. */
    get bearing() {
        return this._bearing;
    }
    /**
     * A callback which is called when this store's waypoint changes.
     * @param waypoint The new waypoint.
     */
    onWaypointChanged(waypoint) {
        var _a, _b;
        const planePos = (_b = (_a = this.planePos) === null || _a === void 0 ? void 0 : _a.get()) !== null && _b !== void 0 ? _b : WaypointInfoStore.NULL_LOCATION;
        this.updateLocation(waypoint);
        this.updateName(waypoint);
        this.updateRegion(waypoint);
        this.updateCity(waypoint);
        this.updateDistance(waypoint, planePos);
        this.updateBearing(waypoint, planePos);
    }
    /**
     * A callback which is called when this store's plane position changes.
     * @param planePos The new plane position.
     */
    onPlanePosChanged(planePos) {
        const waypoint = this.waypoint.get();
        if (waypoint) {
            this.updateDistance(waypoint, planePos);
            this.updateBearing(waypoint, planePos);
        }
    }
    /**
     * Updates this store's location information.
     * @param waypoint The store's current waypoint.
     */
    updateLocation(waypoint) {
        var _a;
        this._location.set((_a = waypoint === null || waypoint === void 0 ? void 0 : waypoint.location) !== null && _a !== void 0 ? _a : WaypointInfoStore.NULL_LOCATION);
    }
    /**
     * Updates this store's name information.
     * @param waypoint The store's current waypoint.
     */
    updateName(waypoint) {
        this._name.set(waypoint);
    }
    /**
     * Updates this store's region information.
     * @param waypoint The store's current waypoint.
     */
    updateRegion(waypoint) {
        this._region.set(waypoint);
    }
    /**
     * Updates this store's city information.
     * @param waypoint The store's current waypoint.
     */
    updateCity(waypoint) {
        this._city.set(waypoint);
    }
    /**
     * Updates this store's distance-to-waypoint information.
     * @param waypoint The store's current waypoint.
     * @param planePos The current position of the airplane.
     */
    updateDistance(waypoint, planePos) {
        if (!waypoint || isNaN(planePos.lat) || isNaN(planePos.lon)) {
            this._distance.set(NaN);
            return;
        }
        this._distance.set(waypoint.location.distance(planePos), UnitType.GA_RADIAN);
    }
    /**
     * Updates this store's bearing-to-waypoint information.
     * @param waypoint The store's current waypoint.
     * @param planePos The current position of the airplane.
     */
    updateBearing(waypoint, planePos) {
        if (!waypoint || isNaN(planePos.lat) || isNaN(planePos.lon)) {
            this._bearing.set(NaN);
            return;
        }
        const brg = NavMath.normalizeHeading(Math.round(planePos.bearingTo(waypoint.location) - MagVar.get(planePos)));
        this._bearing.set(brg === 0 ? 360 : brg);
    }
}
WaypointInfoStore.NULL_LOCATION = new GeoPoint(NaN, NaN);

/** The store for the DTO view */
class DirectToStore {
    /**
     * Constructor.
     * @param planePos A subscribable which provides the current airplane position for this store.
     */
    constructor(planePos) {
        this.planePos = planePos;
        this.waypointInfoStore = new WaypointInfoStore(undefined, planePos);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** A subject which provides this store's selected waypoint. */
    get waypoint() {
        return this.waypointInfoStore.waypoint;
    }
}

/**
 * A view which provides control of the Direct-To function.
 */
class DirectTo extends UiView {
    constructor() {
        super(...arguments);
        this.planePosSub = GeoPointSubject.createFromGeoPoint(new GeoPoint(NaN, NaN));
        this.planeHeadingSub = Subject.create(NaN);
        this.planePosConsumer = this.props.bus.getSubscriber().on('gps-position').whenChanged();
        this.planeHeadingConsumer = this.props.bus.getSubscriber().on('hdg_deg_true').withPrecision(1);
        this.planePosHandler = this.onPlanePosChanged.bind(this);
        this.planeHeadingHandler = this.onPlaneHeadingChanged.bind(this);
        this.store = new DirectToStore(this.planePosSub);
        this.controller = new DirectToController(this.store, this.props.fms);
        this.isOpen = false;
        /** @inheritdoc */
        this.gotoActivateButton = () => {
            this.scrollController.gotoNext();
        };
        /**
         * Callback for when the Hold button is pressed.
         */
        this.onHoldButtonPressed = () => {
            //Do stuff
        };
        /**
         * A callback which is called when the Load action is executed.
         */
        this.onLoadExecuted = () => {
            this.controller.onActivateSelected();
            this.close();
        };
    }
    /** @inheritdoc */
    onInputDataSet(directToInputData) {
        if (this.isOpen) {
            this.controller.initializeTarget(directToInputData);
        }
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.DIRECTTO:
            case FmsHEvent.CLR:
                this.close();
                return true;
        }
        return false;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewOpened() {
        this.isOpen = true;
        this.planePosConsumer.handle(this.planePosHandler);
        this.planeHeadingConsumer.handle(this.planeHeadingHandler);
        this.controller.initializeTarget(this.inputData.get());
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewClosed() {
        this.isOpen = false;
        this.planePosConsumer.off(this.planePosHandler);
        this.planeHeadingConsumer.off(this.planeHeadingHandler);
    }
    /**
     * A callback which is called when the plane's current position changes.
     * @param pos The new position.
     */
    onPlanePosChanged(pos) {
        this.planePosSub.set(pos.lat, pos.long);
    }
    /**
     * A callback which is called when the plane's current true heading changes.
     * @param heading The new heading, in degrees.
     */
    onPlaneHeadingChanged(heading) {
        this.planeHeadingSub.set(heading);
    }
    /**
     * Renders a waypoint input component.
     * @returns a waypoint input component, as a VNode.
     */
    renderWaypointInput() {
        return (FSComponent.buildComponent(WaypointInput, { bus: this.props.bus, onRegister: this.register, onInputEnterPressed: this.gotoActivateButton, onWaypointChanged: this.controller.waypointChangedHandler, selectedIcao: this.controller.inputIcao, filter: FacilitySearchType.None }));
    }
    /**
     * Renders a component which displays the bearing to the store's selected waypoint.
     * @param cssClass CSS class(es) to apply to the root of the component.
     * @returns a component which displays the bearing to the store's selected waypoint, as a VNode.
     */
    renderBearing(cssClass) {
        return (FSComponent.buildComponent(NumberUnitDisplay, { value: this.store.waypointInfoStore.bearing, displayUnit: Subject.create(UnitType.DEGREE), formatter: NumberFormatter.create({ precision: 1, pad: 3, nanString: '___' }), class: cssClass }));
    }
    /**
     * Renders a component which displays the distance to the store's selected waypoint.
     * @param cssClass CSS class(es) to apply to the root of the component.
     * @returns a component which displays the distance to the store's selected waypoint, as a VNode.
     */
    renderDistance(cssClass) {
        return (FSComponent.buildComponent(NumberUnitDisplay, { value: this.store.waypointInfoStore.distance, displayUnit: Subject.create(UnitType.NMILE), formatter: NumberFormatter.create({ precision: 0.1, maxDigits: 3, forceDecimalZeroes: false, nanString: '__._' }), class: cssClass }));
    }
}

/**
 * The map layer showing highlighted waypoints.
 */
class MapWaypointHighlightLayer extends MapSyncedCanvasLayer {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.registeredWaypoint = null;
        this.iconFactory = new WaypointIconFactory({
            highlightRingRadiusBuffer: this.props.styles.highlightRingRadiusBuffer,
            highlightRingStrokeWidth: this.props.styles.highlightRingStrokeWidth,
            highlightRingStrokeColor: this.props.styles.highlightRingStrokeColor,
            highlightRingOutlineWidth: this.props.styles.highlightRingOutlineWidth,
            highlightRingOutlineColor: this.props.styles.highlightRingOutlineColor,
            highlightBgColor: this.props.styles.highlightBgColor,
            airportIconPriority: Object.assign({}, this.props.styles.airportIconPriority),
            vorIconPriority: this.props.styles.vorIconPriority,
            ndbIconPriority: this.props.styles.ndbIconPriority,
            intIconPriority: this.props.styles.intIconPriority,
            userIconPriority: this.props.styles.userIconPriority,
            airportIconSize: Object.assign({}, this.props.styles.airportIconSize),
            vorIconSize: this.props.styles.vorIconSize,
            ndbIconSize: this.props.styles.ndbIconSize,
            intIconSize: this.props.styles.intIconSize,
            userIconSize: this.props.styles.userIconSize
        });
        this.labelFactory = new WaypointLabelFactory({
            airportLabelPriority: Object.assign({}, this.props.styles.airportLabelPriority),
            vorLabelPriority: this.props.styles.vorLabelPriority,
            ndbLabelPriority: this.props.styles.ndbLabelPriority,
            intLabelPriority: this.props.styles.intLabelPriority,
            userLabelPriority: this.props.styles.userLabelPriority,
            airportLabelOptions: {
                [AirportSize.Large]: Object.assign({}, this.props.styles.airportLabelOptions[AirportSize.Large]),
                [AirportSize.Medium]: Object.assign({}, this.props.styles.airportLabelOptions[AirportSize.Medium]),
                [AirportSize.Small]: Object.assign({}, this.props.styles.airportLabelOptions[AirportSize.Small])
            },
            vorLabelOptions: Object.assign({}, this.props.styles.vorLabelOptions),
            ndbLabelOptions: Object.assign({}, this.props.styles.ndbLabelOptions),
            intLabelOptions: Object.assign({}, this.props.styles.intLabelOptions),
            userLabelOptions: Object.assign({}, this.props.styles.userLabelOptions),
        });
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAttached() {
        super.onAttached();
        this.isInit = false;
        this.initWaypointRenderer();
        this.initModuleListener();
        this.isInit = true;
    }
    /**
     * Initializes the waypoint renderer.
     */
    initWaypointRenderer() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.props.waypointRenderer.setCanvasContext(MapWaypointRenderRole.Highlight, this.display.context);
        this.props.waypointRenderer.setIconFactory(MapWaypointRenderRole.Highlight, this.iconFactory);
        this.props.waypointRenderer.setLabelFactory(MapWaypointRenderRole.Highlight, this.labelFactory);
    }
    /**
     * Initializes the waypoint highlight listener.
     */
    initModuleListener() {
        this.props.model.getModule('waypointHighlight').waypoint.sub(this.onWaypointChanged.bind(this), true);
    }
    /**
     * A callback which is called when the highlighted waypoint changes.
     * @param waypoint The new highlighted waypoint.
     */
    onWaypointChanged(waypoint) {
        this.registeredWaypoint && this.props.waypointRenderer.deregister(this.registeredWaypoint, MapWaypointRenderRole.Highlight, 'waypoint-highlight-layer');
        waypoint && this.props.waypointRenderer.register(waypoint, MapWaypointRenderRole.Highlight, 'waypoint-highlight-layer');
        this.registeredWaypoint = waypoint;
    }
}
/**
 * A waypoint icon factory.
 */
class WaypointIconFactory {
    /**
     * Constructor.
     * @param styles Icon styling options used by this factory.
     */
    constructor(styles) {
        this.styles = styles;
        this.cache = new Map();
        this.highlightStyles = {
            ringRadiusBuffer: styles.highlightRingRadiusBuffer,
            strokeWidth: styles.highlightRingStrokeWidth,
            strokeColor: styles.highlightRingStrokeColor,
            outlineWidth: styles.highlightRingOutlineWidth,
            outlineColor: styles.highlightRingOutlineColor,
            bgColor: styles.highlightBgColor
        };
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getIcon(waypoint) {
        let existing = this.cache.get(waypoint.uid);
        if (!existing) {
            existing = this.createIcon(waypoint);
            this.cache.set(waypoint.uid, existing);
        }
        return existing;
    }
    /**
     * Creates a new icon for a waypoint.
     * @param waypoint The waypoint for which to create an icon.
     * @returns a waypoint icon.
     */
    createIcon(waypoint) {
        const baseIcon = this.createBaseIcon(waypoint);
        return baseIcon
            ? new MapWaypointHighlightIcon(baseIcon, baseIcon.priority, this.highlightStyles)
            : new MapBlankWaypointIcon(waypoint, 0);
    }
    /**
     * Creates a new base icon for a waypoint.
     * @param waypoint The waypoint for which to create a base icon.
     * @returns a waypoint base icon.
     */
    createBaseIcon(waypoint) {
        if (waypoint instanceof AirportWaypoint) {
            return new MapAirportIcon(waypoint, this.styles.airportIconPriority[waypoint.size], this.styles.airportIconSize[waypoint.size], this.styles.airportIconSize[waypoint.size]);
        }
        else if (waypoint instanceof FacilityWaypoint) {
            switch (ICAO.getFacilityType(waypoint.facility.icao)) {
                case FacilityType.VOR:
                    return new MapVorIcon(waypoint, this.styles.vorIconPriority, this.styles.vorIconSize, this.styles.vorIconSize);
                case FacilityType.NDB:
                    return new MapNdbIcon(waypoint, this.styles.ndbIconPriority, this.styles.ndbIconSize, this.styles.ndbIconSize);
                case FacilityType.Intersection:
                    return new MapIntersectionIcon(waypoint, this.styles.intIconPriority, this.styles.intIconSize, this.styles.intIconSize);
                case FacilityType.USR:
                    return new MapUserWaypointIcon(waypoint, this.styles.userIconPriority, this.styles.userIconSize, this.styles.userIconSize);
            }
        }
        return null;
    }
}
/**
 * A waypoint label factory.
 */
class WaypointLabelFactory {
    /**
     * Constructor.
     * @param styles Icon styling options used by this factory.
     */
    constructor(styles) {
        this.styles = styles;
        this.cache = new Map();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getLabel(waypoint) {
        let existing = this.cache.get(waypoint.uid);
        if (!existing) {
            existing = this.createLabel(waypoint);
            this.cache.set(waypoint.uid, existing);
        }
        return existing;
    }
    /**
     * Creates a new icon for a waypoint.
     * @param waypoint The waypoint for which to create an icon.
     * @returns a waypoint icon.
     */
    createLabel(waypoint) {
        let text = '';
        let priority = 0;
        let options;
        if (waypoint instanceof FacilityWaypoint) {
            text = ICAO.getIdent(waypoint.facility.icao);
            switch (ICAO.getFacilityType(waypoint.facility.icao)) {
                case FacilityType.Airport:
                    priority = this.styles.airportLabelPriority[waypoint.size];
                    options = this.styles.airportLabelOptions[waypoint.size];
                    break;
                case FacilityType.VOR:
                    priority = this.styles.vorLabelPriority;
                    options = this.styles.vorLabelOptions;
                    break;
                case FacilityType.NDB:
                    priority = this.styles.ndbLabelPriority;
                    options = this.styles.ndbLabelOptions;
                    break;
                case FacilityType.Intersection:
                    priority = this.styles.intLabelPriority;
                    options = this.styles.intLabelOptions;
                    break;
                case FacilityType.USR:
                    priority = this.styles.userLabelPriority;
                    options = this.styles.userLabelOptions;
                    break;
            }
        }
        return new MapCullableLocationTextLabel(text, priority, waypoint.location, false, options);
    }
}

/**
 * A G1000 waypoint info map component.
 */
class WaypointMapComponent extends MapComponent {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.rootRef = FSComponent.createRef();
        this.bingLayerRef = FSComponent.createRef();
        this.waypointsLayerRef = FSComponent.createRef();
        this.waypointHighlightLayerRef = FSComponent.createRef();
        this.textLayerRef = FSComponent.createRef();
        this.rangeRingLayerRef = FSComponent.createRef();
        this.crosshairLayerRef = FSComponent.createRef();
        this.ownAirplaneLayerRef = FSComponent.createRef();
        this.miniCompassLayerRef = FSComponent.createRef();
        this.pointerLayerRef = FSComponent.createRef();
        this.pointerInfoLayerRef = FSComponent.createRef();
        this.pointerBoundsSub = VecNSubject.createFromVector(new Float64Array([0, 0, this.props.projectedWidth, this.props.projectedHeight]));
        this.textManager = new MapCullableTextLabelManager();
        this.waypointRenderer = new MapWaypointRenderer(this.textManager);
        this.settingManager = MapUserSettings.getMfdManager(this.props.bus);
        this.terrainColorController = new MapTerrainController(this.props.model, this.settingManager, false);
        this.waypointsVisController = new MapWaypointsVisController(this.props.model, this.settingManager);
        this.crosshairController = new MapCrosshairController(this.props.model);
        this.updatePointerBounds();
        this.rangeTargetRotationController = new WaypointMapRangeTargetRotationController(this.props.model, this.mapProjection, WaypointMapRangeTargetRotationController.DEFAULT_MAP_RANGES, this.props.rangeIndex, this.props.waypoint, this.pointerBoundsSub);
    }
    /** @inheritdoc */
    onAfterRender() {
        super.onAfterRender();
        this.setRootSize(this.mapProjection.getProjectedSize());
        this.initEventBusHandlers();
        this.initWaypointHandler();
        this.rangeTargetRotationController.init();
        this.initControllers();
        this.initLayers();
    }
    /**
     * Sets the size of this map's root HTML element.
     * @param size The new size, in pixels.
     */
    setRootSize(size) {
        this.rootRef.instance.style.width = `${size[0]}px`;
        this.rootRef.instance.style.height = `${size[1]}px`;
    }
    /**
     * Initializes event bus handlers.
     */
    initEventBusHandlers() {
        this.props.model.getModule('ownAirplaneProps').beginSync(this.props.bus, this.props.updateFreq);
    }
    /**
     * Initializes the focused waypoint handler.
     */
    initWaypointHandler() {
        this.props.waypoint.sub(this.onWaypointChanged.bind(this), true);
    }
    /**
     * Initializes model controllers.
     */
    initControllers() {
        this.terrainColorController.init();
        this.waypointsVisController.init();
        this.crosshairController.init();
    }
    /**
     * Initializes this map's layers.
     */
    initLayers() {
        this.attachLayer(this.bingLayerRef.instance);
        this.attachLayer(this.waypointsLayerRef.instance);
        this.attachLayer(this.waypointHighlightLayerRef.instance);
        this.attachLayer(this.textLayerRef.instance);
        this.attachLayer(this.rangeRingLayerRef.instance);
        this.attachLayer(this.crosshairLayerRef.instance);
        this.attachLayer(this.ownAirplaneLayerRef.instance);
        this.attachLayer(this.miniCompassLayerRef.instance);
        this.attachLayer(this.pointerLayerRef.instance);
        this.attachLayer(this.pointerInfoLayerRef.instance);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onProjectedSizeChanged() {
        this.setRootSize(this.mapProjection.getProjectedSize());
        this.updatePointerBounds();
    }
    /**
     * Updates this map's pointer bounds.
     */
    updatePointerBounds() {
        const size = this.mapProjection.getProjectedSize();
        const width = size[0];
        const height = size[1];
        this.pointerBoundsSub.set(width * 0.1, height * 0.1, width * 0.6, height * 0.9);
    }
    /**
     * A callback which is called when the focused waypoint changes.
     * @param waypoint The new focused waypoint.
     */
    onWaypointChanged(waypoint) {
        this.props.model.getModule('waypointHighlight').waypoint.set(waypoint);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        this.updateRangeTargetRotationController();
        this.waypointRenderer.update(this.mapProjection);
        super.onUpdated(time, elapsed);
    }
    /**
     * Updates this map's range/target/rotation controller.
     */
    updateRangeTargetRotationController() {
        this.rangeTargetRotationController.update();
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { ref: this.rootRef, class: `waypoint-map ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}` },
            FSComponent.buildComponent(MapBingLayer, { ref: this.bingLayerRef, model: this.props.model, mapProjection: this.mapProjection, bingId: this.props.id }),
            FSComponent.buildComponent(MapWaypointsLayer, { ref: this.waypointsLayerRef, model: this.props.model, mapProjection: this.mapProjection, bus: this.props.bus, waypointRenderer: this.waypointRenderer, textManager: this.textManager, styles: this.getWaypointsLayerStyles() }),
            FSComponent.buildComponent(MapWaypointHighlightLayer, { ref: this.waypointHighlightLayerRef, model: this.props.model, mapProjection: this.mapProjection, waypointRenderer: this.waypointRenderer, textManager: this.textManager, styles: this.getWaypointHighlightLayerStyles() }),
            FSComponent.buildComponent(MapCullableTextLayer, { ref: this.textLayerRef, model: this.props.model, mapProjection: this.mapProjection, manager: this.textManager }),
            FSComponent.buildComponent(MapRangeRingLayer, { ref: this.rangeRingLayerRef, model: this.props.model, mapProjection: this.mapProjection, showLabel: true, strokeWidth: 2, strokeStyle: 'white' }),
            FSComponent.buildComponent(MapCrosshairLayer, { ref: this.crosshairLayerRef, model: this.props.model, mapProjection: this.mapProjection }),
            FSComponent.buildComponent(MapOwnAirplaneLayer, { ref: this.ownAirplaneLayerRef, model: this.props.model, mapProjection: this.mapProjection, imageFilePath: this.props.ownAirplaneLayerProps.imageFilePath, iconSize: this.props.ownAirplaneLayerProps.iconSize, iconAnchor: this.props.ownAirplaneLayerProps.iconAnchor }),
            FSComponent.buildComponent(MapMiniCompassLayer, { ref: this.miniCompassLayerRef, class: 'minicompass-layer', model: this.props.model, mapProjection: this.mapProjection, imgSrc: 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/map_mini_compass.png' }),
            FSComponent.buildComponent(MapPointerInfoLayer, { ref: this.pointerInfoLayerRef, model: this.props.model, mapProjection: this.mapProjection, size: MapPointerInfoLayerSize.Medium }),
            FSComponent.buildComponent(MapOrientationIndicator, { orientation: this.props.model.getModule('orientation').orientation, text: {
                    [MapOrientation.NorthUp]: 'NORTH UP',
                    [MapOrientation.TrackUp]: 'TRK UP',
                    [MapOrientation.HeadingUp]: 'HDG UP'
                }, isVisible: this.props.model.getModule('pointer').isActive.map(isActive => !isActive) }),
            FSComponent.buildComponent(MapPointerLayer, { ref: this.pointerLayerRef, model: this.props.model, mapProjection: this.mapProjection })));
    }
    /**
     * Gets styles for the waypoints layer.
     * @returns styles for the waypoints layer.
     */
    getWaypointsLayerStyles() {
        return MapWaypointStyles.getNormalStyles(1, 10);
    }
    /**
     * Gets styles for the waypoint highlight layer.
     * @returns styles for the waypoint highlight layer.
     */
    getWaypointHighlightLayerStyles() {
        return MapWaypointStyles.getHighlightStyles(1, 20);
    }
}
/**
 * A controller for handling map range, target, and rotation changes.
 */
class WaypointMapRangeTargetRotationController {
    /**
     * Creates an instance of a MapRangeController.
     * @param mapModel The map model.
     * @param mapProjection The map projection.
     * @param mapRanges An array of valid map ranges.
     * @param rangeIndex A subscribable which provides a range index for this controller to bind.
     * @param waypoint A subscribable which provides a waypoint for this controller to bind as the focused waypoint.
     * @param pointerBounds A subscribable which provides the bounds of the area accessible to the map pointer. The
     * bounds should be expressed as `[left, top, right, bottom]` in pixels.
     */
    constructor(mapModel, mapProjection, mapRanges, rangeIndex, waypoint, pointerBounds) {
        this.mapModel = mapModel;
        this.mapProjection = mapProjection;
        this.mapRanges = mapRanges;
        this.rangeIndex = rangeIndex;
        this.waypoint = waypoint;
        this.pointerBounds = pointerBounds;
        this.needUpdateProjection = false;
        this.needUpdatePointerScroll = false;
        this.currentMapParameters = {
            range: 0,
            target: new GeoPoint(0, 0),
            targetProjectedOffset: new Float64Array(2),
            rotation: 0
        };
        this.airplanePropsModule = this.mapModel.getModule('ownAirplaneProps');
        this.pointerModule = this.mapModel.getModule('pointer');
        this.airplanePositionChangedHandler = this.onAirplanePositionChanged.bind(this);
        this.pointerPositionChangedHandler = this.onPointerPositionChanged.bind(this);
        this.pointerTargetChangedHandler = this.onPointerTargetChanged.bind(this);
        this.pointerBoundsChangedHandler = this.onPointerBoundsChanged.bind(this);
        this.areAirplanePositionListenersActive = false;
    }
    /**
     * Executes this controller's first-run initialization code.
     */
    init() {
        this.mapModel.getModule('range').nominalRanges.set(this.mapRanges);
        this.rangeIndex.sub(this.onRangeIndexChanged.bind(this));
        this.mapProjection.addChangeListener(this.onMapProjectionChanged.bind(this));
        this.initModuleListeners();
        this.initState();
        this.scheduleProjectionUpdate();
    }
    /**
     * Initializes module listeners.
     */
    initModuleListeners() {
        this.waypoint.sub(this.onWaypointChanged.bind(this), true);
        this.mapModel.getModule('ownAirplaneProps').position.sub(this.onAirplanePositionChanged.bind(this));
        this.pointerModule.isActive.sub(this.onPointerActiveChanged.bind(this), true);
    }
    /**
     * Initializes this controller's state.
     */
    initState() {
        this.updateRangeFromIndex();
        this.updateTargetFromPPos();
    }
    /**
     * Updates the current range from the current range index.
     */
    updateRangeFromIndex() {
        const nominalRange = this.mapRanges[Utils.Clamp(this.rangeIndex.get(), 0, this.mapRanges.length - 1)];
        this.currentMapParameters.range = this.convertToTrueRange(nominalRange);
    }
    /**
     * Converts a nominal range to a true map range.
     * @param nominalRange The nominal range to convert.
     * @returns the true map range for the given nominal range, in great-arc radians.
     */
    convertToTrueRange(nominalRange) {
        return nominalRange.asUnit(UnitType.GA_RADIAN) * 4;
    }
    /**
     * Updates the map target based on the airplane's present position.
     */
    updateTargetFromPPos() {
        this.currentMapParameters.target.set(this.airplanePropsModule.position.get());
    }
    /**
     * Updates the map target based on the airplane's present position.
     */
    updateTargetFromWaypoint() {
        const waypoint = this.waypoint.get();
        if (waypoint) {
            this.currentMapParameters.target.set(waypoint.location);
            this.pointerModule.position.set(this.mapProjection.getTargetProjected());
        }
    }
    /**
     * Responds to map projection changes.
     * @param mapProjection The map projection that changed.
     * @param changeFlags The types of changes made to the projection.
     */
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.onProjectedSizeChanged();
        }
    }
    /**
     * Responds to projected map window size changes.
     */
    onProjectedSizeChanged() {
        this.updateRangeFromIndex();
        this.scheduleProjectionUpdate();
    }
    /**
     * Responds to range index changes.
     */
    onRangeIndexChanged() {
        this.updateRangeFromIndex();
        this.scheduleProjectionUpdate();
    }
    /**
     * Responds to focused waypoint changes.
     */
    onWaypointChanged() {
        this.updateAirplanePositionListeners();
        this.updateTargetFromWaypoint();
        this.scheduleProjectionUpdate();
    }
    /**
     * Responds to airplane position changes.
     */
    onAirplanePositionChanged() {
        this.updateTargetFromPPos();
        this.scheduleProjectionUpdate();
    }
    /**
     * Responds to map pointer activation changes.
     * @param isActive Whether the map pointer is active.
     */
    onPointerActiveChanged(isActive) {
        this.updateAirplanePositionListeners();
        this.updatePointerListeners();
        if (!isActive) {
            this.updateTargetFromWaypoint();
        }
        this.scheduleProjectionUpdate();
    }
    /**
     * Responds to map pointer position changes.
     */
    onPointerPositionChanged() {
        this.schedulePointerScrollUpdate();
    }
    /**
     * Responds to map pointer desired target changes.
     * @param target The desired target.
     */
    onPointerTargetChanged(target) {
        this.currentMapParameters.target.set(target);
        this.scheduleProjectionUpdate();
    }
    /**
     * Responds to map pointer bounds changes.
     */
    onPointerBoundsChanged() {
        const position = this.pointerModule.position.get();
        const bounds = this.pointerBounds.get();
        const clampedPositionX = Utils.Clamp(position[0], bounds[0], bounds[2]);
        const clampedPositionY = Utils.Clamp(position[1], bounds[1], bounds[3]);
        this.pointerModule.position.set(clampedPositionX, clampedPositionY);
    }
    /**
     * Updates listeners for airplane position and on ground status.
     */
    updateAirplanePositionListeners() {
        this.setAirplanePositionListenersActive(!this.waypoint.get() && !this.pointerModule.isActive.get());
    }
    /**
     * Activates or deactivates airplane position listeners.
     * @param value Whether to activate airplane position listeners.
     */
    setAirplanePositionListenersActive(value) {
        if (value === this.areAirplanePositionListenersActive) {
            return;
        }
        if (value) {
            this.airplanePropsModule.position.sub(this.airplanePositionChangedHandler, true);
        }
        else {
            this.airplanePropsModule.position.unsub(this.airplanePositionChangedHandler);
        }
        this.areAirplanePositionListenersActive = value;
    }
    /**
     * Updates the pointer position listener.
     */
    updatePointerListeners() {
        if (this.pointerModule.isActive.get()) {
            this.pointerBounds.sub(this.pointerBoundsChangedHandler);
            this.pointerModule.position.sub(this.pointerPositionChangedHandler);
            this.pointerModule.target.sub(this.pointerTargetChangedHandler, true);
        }
        else {
            this.pointerBounds.unsub(this.pointerBoundsChangedHandler);
            this.pointerModule.position.unsub(this.pointerPositionChangedHandler);
            this.pointerModule.target.unsub(this.pointerTargetChangedHandler);
        }
    }
    /**
     * Schedules an update.
     */
    scheduleProjectionUpdate() {
        this.needUpdateProjection = true;
    }
    /**
     * Schedules an update to scrolling due to the pointer.
     */
    schedulePointerScrollUpdate() {
        this.needUpdatePointerScroll = true;
    }
    /**
     * Updates this controller.
     */
    update() {
        this.updateModules();
        this.updatePointerScroll();
        this.updateMapProjection();
    }
    /**
     * Updates map model modules.
     */
    updateModules() {
        this.mapModel.getModule('range').setNominalRangeIndex(this.rangeIndex.get());
    }
    /**
     * Updates the map projection with the latest range, target, and rotation values.
     */
    updateMapProjection() {
        if (!this.needUpdateProjection) {
            return;
        }
        this.mapProjection.set(this.currentMapParameters);
        this.needUpdateProjection = false;
    }
    /**
     * Updates scrolling due to the pointer.
     */
    updatePointerScroll() {
        if (!this.needUpdatePointerScroll) {
            return;
        }
        const position = this.pointerModule.position.get();
        const bounds = this.pointerBounds.get();
        const clampedPositionX = Utils.Clamp(position[0], bounds[0], bounds[2]);
        const clampedPositionY = Utils.Clamp(position[1], bounds[1], bounds[3]);
        const scrollDeltaX = position[0] - clampedPositionX;
        const scrollDeltaY = position[1] - clampedPositionY;
        if (scrollDeltaX === 0 && scrollDeltaY === 0) {
            return;
        }
        this.pointerModule.position.set(clampedPositionX, clampedPositionY);
        const newTargetProjected = Vec2Math.add(this.mapProjection.getTargetProjected(), Vec2Math.set(scrollDeltaX, scrollDeltaY, WaypointMapRangeTargetRotationController.vec2Cache[0]), WaypointMapRangeTargetRotationController.vec2Cache[0]);
        this.mapProjection.invert(newTargetProjected, this.currentMapParameters.target);
        this.scheduleProjectionUpdate();
        this.needUpdatePointerScroll = false;
    }
}
WaypointMapRangeTargetRotationController.DEFAULT_MAP_RANGES = [
    ...[
        250,
        400,
        500,
        750,
        1000,
        1500,
        2500
    ].map(value => UnitType.FOOT.createNumber(value)),
    ...[
        0.5,
        0.75,
        1,
        1.5,
        2.5,
        4,
        5,
        7.5,
        10,
        15,
        25,
        40,
        50,
        75,
        100,
        150,
        250,
        400,
        500,
        750,
        1000
    ].map(value => UnitType.NMILE.createNumber(value))
];
WaypointMapRangeTargetRotationController.DEFAULT_MAP_RANGE_INDEX = 14;
WaypointMapRangeTargetRotationController.vec2Cache = [new Float64Array(2)];

/**
 * A module which defines a highlighted waypoint.
 */
class MapWaypointHighlightModule {
    constructor() {
        /** The highlighted waypoint. */
        this.waypoint = Subject.create(null);
    }
}

/**
 * Class for creating navmap models.
 */
class WaypointMapModel {
    /**
     * Creates an instance of a navmap model.
     * @returns a navmap model instance.
     */
    static createModel() {
        const model = new MapModel();
        model.addModule('range', new MapIndexedRangeModule());
        model.addModule('orientation', new MapOrientationModule());
        model.addModule('declutter', new MapDeclutterModule());
        model.addModule('terrain', new MapTerrainModule());
        model.addModule('ownAirplaneProps', new MapOwnAirplanePropsModule());
        model.addModule('ownAirplaneIcon', new MapOwnAirplaneIconModule());
        model.addModule('rangeRing', new MapRangeRingModule());
        model.addModule('waypoints', new MapWaypointsModule());
        model.addModule('airspace', new MapAirspaceModule());
        model.addModule('waypointHighlight', new MapWaypointHighlightModule());
        model.addModule('nexrad', new MapNexradModule());
        model.addModule('pointer', new MapPointerModule());
        model.addModule('crosshair', new MapCrosshairModule());
        model.getModule('orientation').orientation.set(MapOrientation.NorthUp);
        return model;
    }
}

/**
 * The MFD direct-to popout.
 */
class MFDDirectTo extends DirectTo {
    constructor() {
        super(...arguments);
        this.mapRef = FSComponent.createRef();
        this.mapModel = this.createMapModel();
        this.mapRangeIndexSub = Subject.create(WaypointMapRangeTargetRotationController.DEFAULT_MAP_RANGE_INDEX);
    }
    /**
     * Creates the model for this component's map.
     * @returns a map model.
     */
    createMapModel() {
        return WaypointMapModel.createModel();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.RANGE_DEC:
                this.changeMapRangeIndex(-1);
                return true;
            case FmsHEvent.RANGE_INC:
                this.changeMapRangeIndex(1);
                return true;
        }
        return super.onInteractionEvent(evt);
    }
    /**
     * Changes the MFD map range index setting.
     * @param delta The change in index to apply.
     */
    changeMapRangeIndex(delta) {
        const newIndex = Utils.Clamp(this.mapRangeIndexSub.get() + delta, 0, WaypointMapRangeTargetRotationController.DEFAULT_MAP_RANGES.length - 1);
        this.mapRangeIndexSub.set(newIndex);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewOpened() {
        super.onViewOpened();
        this.mapRef.instance.wake();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewClosed() {
        super.onViewClosed();
        this.mapRef.instance.sleep();
        this.mapRangeIndexSub.set(WaypointMapRangeTargetRotationController.DEFAULT_MAP_RANGE_INDEX);
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: 'popout-dialog mfd-dto', ref: this.viewContainerRef },
            FSComponent.buildComponent("h1", null, this.props.title),
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Ident, Facility, City" }, this.renderWaypointInput()),
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "VNV" },
                FSComponent.buildComponent("div", { class: "mfd-dto-vnv-box" },
                    FSComponent.buildComponent("div", null,
                        "- - - - -",
                        FSComponent.buildComponent("span", { class: "size12" }, "FT")),
                    FSComponent.buildComponent("div", null,
                        "+0",
                        FSComponent.buildComponent("span", { class: "size12" }, "NM")))),
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Map", class: 'mfd-dto-map-box' },
                FSComponent.buildComponent(WaypointMapComponent, { ref: this.mapRef, model: this.mapModel, bus: this.props.bus, updateFreq: 4, projectedWidth: 285, projectedHeight: 250, id: 'mfd_dto_map', rangeIndex: this.mapRangeIndexSub, waypoint: this.store.waypoint, ownAirplaneLayerProps: {
                        imageFilePath: 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/own_airplane_icon.svg',
                        iconSize: 40,
                        iconAnchor: new Float64Array([0.5, 0])
                    } })),
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Location" },
                FSComponent.buildComponent("div", { class: "mfd-dto-location" },
                    FSComponent.buildComponent("div", { class: 'mfd-dto-location-field mfd-dto-bearing' },
                        FSComponent.buildComponent("div", { class: 'mfd-dto-location-field-title' }, "BRG"),
                        this.renderBearing()),
                    FSComponent.buildComponent("div", { class: 'mfd-dto-location-field mfd-dto-distance' },
                        FSComponent.buildComponent("div", { class: 'mfd-dto-location-field-title' }, "DIS"),
                        this.renderDistance()))),
            FSComponent.buildComponent("div", { class: "mfd-dto-course-box" },
                FSComponent.buildComponent("div", { class: "mfd-dto-course-box-title" }, "Course"),
                FSComponent.buildComponent("div", null, "- - -\u00B0")),
            FSComponent.buildComponent("div", { class: "mfd-action-buttons mfd-dto-action-buttons" },
                FSComponent.buildComponent(ActionButton, { onRegister: this.register, isVisible: this.controller.canActivate, onExecute: this.onLoadExecuted, text: "Activate?" }))));
    }
}

/**
 * A controller which binds a user setting to a control component.
 */
class UserSettingController {
    /**
     * Constructor.
     * @param settingManager This controller's settings manager.
     * @param settingName The name of the setting associated with this controller.
     */
    constructor(settingManager, settingName) {
        this.settingManager = settingManager;
        this.settingName = settingName;
        /** The setting associated with this controller. */
        this.setting = this.settingManager.getSetting(this.settingName);
    }
    /**
     * Initializes this controller. This will immediately change the state of this controller's control component to
     * reflect the current value of this controller's setting. Furthermore, any future changes to the setting's value
     * will be synced to the control component.
     */
    init() {
        this.settingManager.whenSettingChanged(this.settingName).handle(this.onSettingChanged.bind(this));
    }
}

/**
 * A controller which binds a user setting that can take one of several enumerated values to a SelectControl
 * component.
 */
class UserSettingSelectController extends UserSettingController {
    /**
     * Constructor.
     * @param settingManager This controller's settings manager.
     * @param settingName The name of the setting associated with this controller.
     * @param values A subscribable array which provides the values this controller can assign to its setting.
     * @param selectControlRef A node reference to the SelectControl which this controller controls.
     */
    constructor(settingManager, settingName, values, selectControlRef) {
        super(settingManager, settingName);
        this.settingManager = settingManager;
        this.settingName = settingName;
        this.values = values;
        this.selectControlRef = selectControlRef;
        /**
         * A function which handles item selected events from the SelectControl component which this controller controls.
         * This handler should be passed to the SelectControl component via its `onItemSelected` prop.
         */
        this.itemSelectedHandler = this.onItemSelected.bind(this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onSettingChanged(value) {
        var _a;
        (_a = this.selectControlRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.SelectedValue.set(this.values.getArray().indexOf(value));
    }
    /**
     * A callback which is called when an item is selected using the SelectControl component.
     * @param index The index of the selected item.
     * @param item The selected item.
     * @param isRefresh Whether the selection was made due to a refresh.
     */
    onItemSelected(index, item, isRefresh) {
        if (item === undefined || isRefresh) {
            return;
        }
        this.setting.value = item;
    }
}
/**
 * A controller which binds a user setting that can take one of several enumerated values to a SelectControl
 * component which displays transformed versions of the setting values.
 */
class UserSettingTransformedSelectController extends UserSettingController {
    /**
     * Constructor.
     * @param settingManager This controller's settings manager.
     * @param settingName The name of the setting associated with this controller.
     * @param values A subscribable array which provides the values this controller can assign to its setting.
     * @param transformedValues A subscribable array which provides the transformed values displayed by the SelectControl
     * component controlled by this controller.
     * @param selectControlRef A node reference to the SelectControl which this controller controls.
     */
    constructor(settingManager, settingName, values, transformedValues, selectControlRef) {
        super(settingManager, settingName);
        this.settingManager = settingManager;
        this.settingName = settingName;
        this.values = values;
        this.transformedValues = transformedValues;
        this.selectControlRef = selectControlRef;
        /**
         * A function which handles item selected events from the SelectControl component which this controller controls.
         * This handler should be passed to the SelectControl component via its `onItemSelected` prop.
         */
        this.itemSelectedHandler = this.onItemSelected.bind(this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onSettingChanged(value) {
        var _a;
        (_a = this.selectControlRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.SelectedValue.set(this.values.getArray().indexOf(value));
    }
    /**
     * A callback which is called when an item is selected using the SelectControl component.
     * @param index The index of the selected item.
     * @param item The selected item.
     * @param isRefresh Whether the selection was made due to a refresh.
     */
    onItemSelected(index, item, isRefresh) {
        if (item === undefined || isRefresh) {
            return;
        }
        this.setting.value = this.values.get(index);
    }
}

/**
 * A controller which binds a setting that can take one of several enumerated values to an ArrowToggle component.
 */
class UserSettingToggleController extends UserSettingController {
    /**
     * Constructor.
     * @param settingManager This controller's settings manager.
     * @param settingName The name of the setting associated with this controller.
     * @param values An array of values this controller can assign to its setting.
     */
    constructor(settingManager, settingName, values) {
        super(settingManager, settingName);
        this.settingManager = settingManager;
        this.settingName = settingName;
        this.values = values;
        /**
         * A subject which provides a selected index for the ArrowToggle component which this controller controls. This
         * subject should be passed to the ArrowToggle component via its `dataref` prop.
         */
        this.selectedIndexSub = Subject.create(0);
        /**
         * A function which handles value selected events from the ArrowToggle component which this controller controls.
         * This handler should be passed to the ArrowToggle component via its `onOptionSelected` prop.
         */
        this.optionSelectedHandler = this.onOptionSelected.bind(this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onSettingChanged(value) {
        this.selectedIndexSub.set(this.values.indexOf(value));
    }
    /**
     * A callback which is called when an option is selected using the ArrowToggle component.
     * @param index The index of the selected option.
     */
    onOptionSelected(index) {
        this.setting.value = this.values[index];
    }
}

/**
 * A component which controls a map setting.
 */
class MapSettingControl extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.setting = this.props.settingManager.getSetting(this.props.settingName);
    }
}
/**
 * A component which controls an on/off map setting.
 */
class MapToggleSettingControl extends MapSettingControl {
    constructor() {
        super(...arguments);
        this.controller = new UserSettingToggleController(this.props.settingManager, this.props.settingName, [false, true]);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        this.controller.init();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        var _a;
        return (FSComponent.buildComponent(ArrowToggle, { onRegister: this.props.registerFunc, options: ['Off', 'On'], onOptionSelected: this.controller.optionSelectedHandler, dataref: this.controller.selectedIndexSub, class: `mapsettings-control ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}` }));
    }
}
/**
 * A component which controls a map setting which can take on one of several enumerated values.
 */
class MapEnumSettingControl extends MapSettingControl {
    constructor() {
        super(...arguments);
        this.selectControlRef = FSComponent.createRef();
        this.controller = new UserSettingSelectController(this.props.settingManager, this.props.settingName, ArraySubject.create(this.props.values), this.selectControlRef);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        this.controller.init();
    }
    /**
     * Builds a menu item definition for a setting value.
     * @param value A setting value.
     * @param index The index of the value in the menu.
     * @returns a menu item definition for the setting value.
     */
    buildMenuItem(value, index) {
        const text = this.props.valueText[index];
        return {
            id: text,
            renderContent: () => FSComponent.buildComponent("span", null, text),
            estimatedWidth: text.length * ContextMenuDialog.CHAR_WIDTH
        };
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        var _a;
        return (FSComponent.buildComponent(SelectControl, { ref: this.selectControlRef, onRegister: this.props.registerFunc, outerContainer: this.props.outerContainer, data: this.controller.values, buildMenuItem: this.buildMenuItem.bind(this), onItemSelected: this.controller.itemSelectedHandler, class: `mapsettings-control ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}` }));
    }
}
/**
 * A component which controls a map setting with values which represent NumberUnit values.
 */
class MapNumberUnitSettingControl extends MapSettingControl {
    constructor() {
        super(...arguments);
        this.selectControlRef = FSComponent.createRef();
        this.controller = new UserSettingTransformedSelectController(this.props.settingManager, this.props.settingName, ArraySubject.create(this.props.values), this.props.numberUnits, this.selectControlRef);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        this.controller.init();
    }
    /**
     * Builds a menu item definition for a setting value.
     * @param value The NumberUnit representation of the value.
     * @param index The index of the value in the menu.
     * @returns a menu item definition for the setting value.
     */
    buildMenuItem(value, index) {
        return {
            id: `${index}`,
            renderContent: () => {
                return (FSComponent.buildComponent(NumberUnitDisplay, { value: NumberUnitSubject.createFromNumberUnit(value.copy()), displayUnit: this.props.displayUnit, formatter: this.props.formatter }));
            },
            estimatedWidth: this.props.estimatedMaxWidth
        };
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        var _a;
        return (FSComponent.buildComponent(SelectControl, { ref: this.selectControlRef, onRegister: this.props.registerFunc, outerContainer: this.props.outerContainer, data: this.controller.transformedValues, buildMenuItem: this.buildMenuItem.bind(this), onItemSelected: this.controller.itemSelectedHandler, class: `mapsettings-control ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}` }));
    }
}
/**
 * A component which controls a map setting with values which represent NumberUnit values.
 */
class MapRangeSettingControl extends MapSettingControl {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.numberUnitsSub = ArraySubject.create([]);
        this.props.mapRanges.sub(this.onMapRangesChanged.bind(this), true);
    }
    /**
     * A callback which is called when the map range values change.
     */
    onMapRangesChanged() {
        this.numberUnitsSub.set(this.props.values.map(value => this.props.mapRanges.get(value)));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        var _a;
        return (FSComponent.buildComponent(MapNumberUnitSettingControl, { registerFunc: this.props.registerFunc, settingManager: this.props.settingManager, settingName: this.props.settingName, values: this.props.values, numberUnits: this.numberUnitsSub, displayUnit: Subject.create(null), formatter: NumberFormatter.create({ precision: 0.1, forceDecimalZeroes: false, maxDigits: 3 }), estimatedMaxWidth: ContextMenuDialog.CHAR_WIDTH * 6, outerContainer: this.props.outerContainer, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' }));
    }
}

/**
 * A component which displays a group of controls to adjust map settings.
 */
class MFDMapSettingsGroup extends UiControlGroup {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
    }
    /**
     * Shows this group.
     */
    show() {
        this.containerRef.instance.style.display = '';
    }
    /**
     * Hides this group.
     */
    hide() {
        this.containerRef.instance.style.display = 'none';
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent("div", { ref: this.containerRef, class: 'mfd-mapsettings-group', style: 'display: none;' },
            FSComponent.buildComponent("div", { class: 'mfd-mapsettings-group-rightbg' }),
            this.getSettingRows(this.containerRef)));
    }
}

/**
 * A settings row for a MFDMapSettingsMapGroup. Each row has a title and up to two setting controls.
 */
class MFDMapSettingsRow extends DisplayComponent {
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent("div", { class: 'mfd-mapsettings-row' },
            FSComponent.buildComponent("div", { class: 'mfd-mapsettings-row-title' }, this.props.title),
            this.renderLeftControl(),
            this.renderRightControl()));
    }
}
/**
 * A row which contains a single enum setting control.
 */
class MFDMapSingleEnumSettingRow extends MFDMapSettingsRow {
    // eslint-disable-next-line jsdoc/require-jsdoc
    renderLeftControl() {
        return (FSComponent.buildComponent(MapEnumSettingControl, { registerFunc: this.props.controlProps.registerFunc, settingManager: this.props.controlProps.settingManager, settingName: this.props.controlProps.settingName, values: this.props.controlProps.values, valueText: this.props.controlProps.valueText, outerContainer: this.props.controlProps.outerContainer, class: 'mfd-mapsettings-row-leftcontrol' }));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    renderRightControl() {
        return null;
    }
}
/**
 * A map settings row which contains a toggle setting control.
 */
class MFDMapToggleSettingRow extends MFDMapSettingsRow {
    // eslint-disable-next-line jsdoc/require-jsdoc
    renderLeftControl() {
        return (FSComponent.buildComponent(MapToggleSettingControl, { registerFunc: this.props.toggleProps.registerFunc, settingManager: this.props.toggleProps.settingManager, settingName: this.props.toggleProps.settingName, class: 'mfd-mapsettings-row-leftcontrol' }));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    renderRightControl() {
        return null;
    }
}
/**
 * A map settings row which contains a map range setting control.
 */
class MFDMapRangeSettingRow extends MFDMapSettingsRow {
    // eslint-disable-next-line jsdoc/require-jsdoc
    renderLeftControl() {
        return FSComponent.buildComponent("div", { style: 'visibility: hidden;' });
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    renderRightControl() {
        return (FSComponent.buildComponent(MapRangeSettingControl, { registerFunc: this.props.rangeProps.registerFunc, settingManager: this.props.rangeProps.settingManager, settingName: this.props.rangeProps.settingName, values: this.props.rangeProps.values, mapRanges: this.props.rangeProps.mapRanges, outerContainer: this.props.rangeProps.outerContainer, class: 'mfd-mapsettings-row-rightcontrol' }));
    }
}
/**
 * A map settings row which contains a toggle setting control and a map range setting control.
 */
class MFDMapToggleRangeSettingsRow extends MFDMapToggleSettingRow {
    // eslint-disable-next-line jsdoc/require-jsdoc
    renderRightControl() {
        return (FSComponent.buildComponent(MapRangeSettingControl, { registerFunc: this.props.rangeProps.registerFunc, settingManager: this.props.rangeProps.settingManager, settingName: this.props.rangeProps.settingName, values: this.props.rangeProps.values, mapRanges: this.props.rangeProps.mapRanges, outerContainer: this.props.rangeProps.outerContainer, class: 'mfd-mapsettings-row-rightcontrol' }));
    }
}

/**
 * The 'Map' map settings group.
 */
class MFDMapSettingsMapGroup extends MFDMapSettingsGroup {
    // eslint-disable-next-line jsdoc/require-jsdoc
    getSettingRows(containerRef) {
        return [
            FSComponent.buildComponent(MFDMapSingleEnumSettingRow, { title: 'Orientation', controlProps: {
                    registerFunc: this.register,
                    settingManager: this.props.settingManager,
                    settingName: 'mapOrientation',
                    values: [MapOrientationSettingMode.NorthUp, MapOrientationSettingMode.TrackUp, MapOrientationSettingMode.HeadingUp],
                    valueText: ['North up', 'Track up', 'HDG up'],
                    outerContainer: containerRef
                } }),
            FSComponent.buildComponent(MFDMapToggleRangeSettingsRow, { title: 'North Up Above', toggleProps: {
                    registerFunc: this.register,
                    settingManager: this.props.settingManager,
                    settingName: 'mapAutoNorthUpActive',
                }, rangeProps: {
                    registerFunc: this.register,
                    settingManager: this.props.settingManager,
                    settingName: 'mapAutoNorthUpRangeIndex',
                    values: Array.from({ length: 7 }, (value, index) => index + 21),
                    mapRanges: this.props.mapRanges,
                    outerContainer: containerRef
                } }),
            FSComponent.buildComponent(MFDMapSettingsTerrainRow, { title: 'Terrain Display', registerFunc: this.register, settingManager: this.props.settingManager, mapRanges: this.props.mapRanges, outerContainer: containerRef }),
            FSComponent.buildComponent(MFDMapToggleSettingRow, { title: 'Topo Scale', toggleProps: {
                    registerFunc: this.register,
                    settingManager: this.props.settingManager,
                    settingName: 'mapTerrainScaleShow',
                } })
        ];
    }
}
/**
 * A map settings row which controls terrain settings.
 */
class MFDMapSettingsTerrainRow extends MFDMapSettingsRow {
    // eslint-disable-next-line jsdoc/require-jsdoc
    renderLeftControl() {
        return (FSComponent.buildComponent(MapEnumSettingControl, { registerFunc: this.props.registerFunc, settingManager: this.props.settingManager, settingName: 'mapTerrainMode', values: [MapTerrainSettingMode.None, MapTerrainSettingMode.Absolute, MapTerrainSettingMode.Relative], valueText: ['Off', 'Topo', 'REL'], outerContainer: this.props.outerContainer, class: 'mfd-mapsettings-row-leftcontrol' }));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    renderRightControl() {
        return (FSComponent.buildComponent(MapRangeSettingControl, { registerFunc: this.props.registerFunc, settingManager: this.props.settingManager, settingName: 'mapTerrainRangeIndex', values: Array.from({ length: 19 }, (value, index) => index + 9), mapRanges: this.props.mapRanges, outerContainer: this.props.outerContainer, class: 'mfd-mapsettings-row-rightcontrol' }));
    }
}

/**
 * The 'Weather' map settings group.
 */
class MFDMapSettingsWeatherGroup extends MFDMapSettingsGroup {
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    getSettingRows(containerRef) {
        return [
            FSComponent.buildComponent(MFDMapToggleRangeSettingsRow, { title: 'NEXRAD Data', toggleProps: {
                    registerFunc: this.register,
                    settingManager: this.props.settingManager,
                    settingName: 'mapNexradShow',
                }, rangeProps: {
                    registerFunc: this.register,
                    settingManager: this.props.settingManager,
                    settingName: 'mapNexradRangeIndex',
                    values: Array.from({ length: 19 }, (value, index) => index + 9),
                    mapRanges: this.props.mapRanges,
                    outerContainer: containerRef
                } })
        ];
    }
}

/**
 * The 'Aviation' map settings group.
 */
class MFDMapSettingsAviationGroup extends MFDMapSettingsGroup {
    // eslint-disable-next-line jsdoc/require-jsdoc
    getSettingRows(containerRef) {
        return [
            FSComponent.buildComponent(MFDMapToggleRangeSettingsRow, { title: 'Large Airport', toggleProps: {
                    registerFunc: this.register,
                    settingManager: this.props.settingManager,
                    settingName: 'mapAirportLargeShow',
                }, rangeProps: {
                    registerFunc: this.register,
                    settingManager: this.props.settingManager,
                    settingName: 'mapAirportLargeRangeIndex',
                    values: Array.from({ length: 28 }, (value, index) => index),
                    mapRanges: this.props.mapRanges,
                    outerContainer: containerRef
                } }),
            FSComponent.buildComponent(MFDMapToggleRangeSettingsRow, { title: 'Medium Airport', toggleProps: {
                    registerFunc: this.register,
                    settingManager: this.props.settingManager,
                    settingName: 'mapAirportMediumShow',
                }, rangeProps: {
                    registerFunc: this.register,
                    settingManager: this.props.settingManager,
                    settingName: 'mapAirportMediumRangeIndex',
                    values: Array.from({ length: 25 }, (value, index) => index),
                    mapRanges: this.props.mapRanges,
                    outerContainer: containerRef
                } }),
            FSComponent.buildComponent(MFDMapToggleRangeSettingsRow, { title: 'Small Airport', toggleProps: {
                    registerFunc: this.register,
                    settingManager: this.props.settingManager,
                    settingName: 'mapAirportSmallShow',
                }, rangeProps: {
                    registerFunc: this.register,
                    settingManager: this.props.settingManager,
                    settingName: 'mapAirportSmallRangeIndex',
                    values: Array.from({ length: 23 }, (value, index) => index),
                    mapRanges: this.props.mapRanges,
                    outerContainer: containerRef
                } }),
            FSComponent.buildComponent(MFDMapToggleRangeSettingsRow, { title: 'INT', toggleProps: {
                    registerFunc: this.register,
                    settingManager: this.props.settingManager,
                    settingName: 'mapIntersectionShow',
                }, rangeProps: {
                    registerFunc: this.register,
                    settingManager: this.props.settingManager,
                    settingName: 'mapIntersectionRangeIndex',
                    values: Array.from({ length: 10 }, (value, index) => index + 9),
                    mapRanges: this.props.mapRanges,
                    outerContainer: containerRef
                } }),
            FSComponent.buildComponent(MFDMapToggleRangeSettingsRow, { title: 'NDB', toggleProps: {
                    registerFunc: this.register,
                    settingManager: this.props.settingManager,
                    settingName: 'mapNdbShow',
                }, rangeProps: {
                    registerFunc: this.register,
                    settingManager: this.props.settingManager,
                    settingName: 'mapNdbRangeIndex',
                    values: Array.from({ length: 11 }, (value, index) => index + 9),
                    mapRanges: this.props.mapRanges,
                    outerContainer: containerRef
                } }),
            FSComponent.buildComponent(MFDMapToggleRangeSettingsRow, { title: 'VOR', toggleProps: {
                    registerFunc: this.register,
                    settingManager: this.props.settingManager,
                    settingName: 'mapVorShow',
                }, rangeProps: {
                    registerFunc: this.register,
                    settingManager: this.props.settingManager,
                    settingName: 'mapVorRangeIndex',
                    values: Array.from({ length: 15 }, (value, index) => index + 9),
                    mapRanges: this.props.mapRanges,
                    outerContainer: containerRef
                } })
        ];
    }
}

/**
 * The 'Aviation' map settings group.
 */
class MFDMapSettingsTrafficGroup extends MFDMapSettingsGroup {
    // eslint-disable-next-line jsdoc/require-jsdoc
    getSettingRows(containerRef) {
        return [
            FSComponent.buildComponent(MFDMapToggleSettingRow, { title: 'Traffic', toggleProps: {
                    registerFunc: this.register,
                    settingManager: this.props.settingManager,
                    settingName: 'mapTrafficShow',
                } }),
            FSComponent.buildComponent(MFDMapSingleEnumSettingRow, { title: 'Traffic Mode', controlProps: {
                    registerFunc: this.register,
                    settingManager: this.props.settingManager,
                    settingName: 'mapTrafficAlertLevelMode',
                    values: [MapTrafficAlertLevelMode.All, MapTrafficAlertLevelMode.Advisories, MapTrafficAlertLevelMode.TA_RA],
                    valueText: ['All Traffic', 'TA/PA', 'TA Only'],
                    outerContainer: containerRef
                } }),
            FSComponent.buildComponent(MFDMapRangeSettingRow, { title: 'Traffic Symbols', rangeProps: {
                    registerFunc: this.register,
                    settingManager: this.props.settingManager,
                    settingName: 'mapTrafficRangeIndex',
                    values: Array.from({ length: 19 }, (value, index) => index + 9),
                    mapRanges: this.props.mapRanges,
                    outerContainer: containerRef
                } }),
            FSComponent.buildComponent(MFDMapToggleRangeSettingsRow, { title: 'Traffic Labels', toggleProps: {
                    registerFunc: this.register,
                    settingManager: this.props.settingManager,
                    settingName: 'mapTrafficLabelShow',
                }, rangeProps: {
                    registerFunc: this.register,
                    settingManager: this.props.settingManager,
                    settingName: 'mapTrafficLabelRangeIndex',
                    values: Array.from({ length: 19 }, (value, index) => index + 9),
                    mapRanges: this.props.mapRanges,
                    outerContainer: containerRef
                } })
        ];
    }
}

/**
 * The MFD map settings menu.
 */
class MFDMapSettings extends UiView {
    constructor() {
        super(...arguments);
        this.groupRefs = {
            ['Map']: FSComponent.createRef(),
            ['Weather']: FSComponent.createRef(),
            ['Traffic']: FSComponent.createRef(),
            ['Aviation']: FSComponent.createRef(),
            ['Airspace']: FSComponent.createRef(),
            ['Airways']: FSComponent.createRef(),
            ['Land']: FSComponent.createRef(),
            ['VSD']: FSComponent.createRef()
        };
        this.settingManager = MapUserSettings.getMfdManager(this.props.bus);
        this.mapRangesSub = ArraySubject.create(NavMapRangeTargetRotationController.DEFAULT_MAP_RANGES.slice());
        this.activeGroup = null;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.UPPER_PUSH:
            case FmsHEvent.CLR:
                this.close();
                return true;
        }
        return false;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewOpened() {
        this.props.menuSystem.pushMenu('empty');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewClosed() {
        this.props.menuSystem.back();
    }
    /**
     * Builds a menu item definition for a group item.
     * @param item A group item.
     * @returns a menu item definition for the group item.
     */
    buildGroupMenuItem(item) {
        return {
            id: item,
            renderContent: () => FSComponent.buildComponent("span", null, item),
            estimatedWidth: item.length * ContextMenuDialog.CHAR_WIDTH,
            isEnabled: item === 'Map' || item === 'Weather' || item === 'Aviation' || item === 'Traffic'
        };
    }
    /**
     * A callback which is called when a group item is selected.
     * @param index The index of the selected item.
     * @param item The selected item.
     */
    onGroupItemSelected(index, item) {
        const selectedGroup = item === undefined ? null : this.groupRefs[item].instance;
        if (selectedGroup !== this.activeGroup) {
            if (this.activeGroup) {
                this.activeGroup.hide();
                this.scrollController.unregisterCtrl(this.activeGroup);
            }
            if (selectedGroup) {
                this.scrollController.registerCtrl(selectedGroup);
                selectedGroup.show();
            }
            this.activeGroup = selectedGroup;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent("div", { ref: this.viewContainerRef, class: 'popout-dialog mfd-mapsettings' },
            FSComponent.buildComponent("h1", null, this.props.title),
            FSComponent.buildComponent(GroupBox, { title: 'Group' },
                FSComponent.buildComponent(SelectControl, { onRegister: this.register, outerContainer: this.viewContainerRef, data: ArraySubject.create(MFDMapSettings.GROUP_ITEMS), buildMenuItem: this.buildGroupMenuItem.bind(this), onItemSelected: this.onGroupItemSelected.bind(this) })),
            FSComponent.buildComponent("div", { class: 'mfd-mapsettings-groupcontainer' },
                FSComponent.buildComponent(MFDMapSettingsMapGroup, { ref: this.groupRefs['Map'], settingManager: this.settingManager, mapRanges: this.mapRangesSub }),
                FSComponent.buildComponent(MFDMapSettingsWeatherGroup, { ref: this.groupRefs['Weather'], settingManager: this.settingManager, mapRanges: this.mapRangesSub }),
                FSComponent.buildComponent(MFDMapSettingsAviationGroup, { ref: this.groupRefs['Aviation'], settingManager: this.settingManager, mapRanges: this.mapRangesSub }),
                FSComponent.buildComponent(MFDMapSettingsTrafficGroup, { ref: this.groupRefs['Traffic'], settingManager: this.settingManager, mapRanges: this.mapRangesSub }))));
    }
}
MFDMapSettings.GROUP_ITEMS = ['Map', 'Weather', 'Traffic', 'Aviation', 'Airspace', 'Airways', 'Land', 'VSD'];

/**
 * Wpt info store
 */
class WptInfoStore extends WaypointInfoStore {
    constructor() {
        super(...arguments);
        this.prompt = Subject.create('');
        this._matchedWaypoints = [];
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** An array of waypoints which have matched the input. */
    get matchedWaypoints() {
        return this._matchedWaypoints;
    }
    /**
     * Set the list of matched waypoints.
     * @param waypoints An array of matched waypoints.
     */
    setMatchedWaypoints(waypoints) {
        this._matchedWaypoints = [...waypoints];
    }
}

/**
 * Wpt info controller
 */
class WptInfoController {
    /**
     * Creates an instance of wpt info controller.
     * @param store The store.
     * @param selectedWaypoint The subject which provides the waypoint info component's selected waypoint.
     */
    constructor(store, selectedWaypoint) {
        this.store = store;
        this.selectedWaypoint = selectedWaypoint;
        /**
         * A function which handles changes in waypoint input's matched waypoints.
         * @param waypoints The matched waypoints.
         */
        this.matchedWaypointsChangedHandler = this.onMatchedWaypointsChanged.bind(this);
        /**
         * A function which handles changes in waypoint input's selected waypoint.
         * @param waypoint The selected waypoint.
         */
        this.selectedWaypointChangedHandler = this.onSelectedWaypointChanged.bind(this);
        this.onMatchedWaypointsChanged([]);
    }
    /**
     * A callback which is called when the waypoint input's matched waypoints change.
     * @param waypoints The matched waypoints.
     */
    onMatchedWaypointsChanged(waypoints) {
        this.store.setMatchedWaypoints(waypoints);
        if (waypoints.length > 1) {
            this.store.prompt.set('Press "ENT" for dups');
        }
        else {
            this.store.prompt.set('Press "ENT" to accept');
        }
    }
    /**
     * A callback which is called when the waypoint input's selected waypoint changes.
     * @param waypoint The selected waypoint.
     */
    onSelectedWaypointChanged(waypoint) {
        this.selectedWaypoint.set(waypoint);
    }
}

/**
 * The PFD waypoint info popout.
 */
class WptInfo extends UiView {
    constructor() {
        super(...arguments);
        this.inputSelectedIcao = Subject.create('');
        this.selectedWaypointSub = Subject.create(null);
        this.planePosSub = GeoPointSubject.createFromGeoPoint(new GeoPoint(NaN, NaN));
        this.planeHeadingSub = Subject.create(NaN);
        this.planePosConsumer = this.props.bus.getSubscriber().on('gps-position').whenChanged();
        this.planeHeadingConsumer = this.props.bus.getSubscriber().on('hdg_deg_true').withPrecision(1);
        this.planePosHandler = this.onPlanePosChanged.bind(this);
        this.planeHeadingHandler = this.onPlaneHeadingChanged.bind(this);
        this.store = new WptInfoStore(this.selectedWaypointSub, this.planePosSub);
        this.controller = new WptInfoController(this.store, this.selectedWaypointSub);
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.CLR:
                this.close();
                return true;
            case FmsHEvent.ENT:
                this.onEnterPressed();
                return true;
        }
        return false;
    }
    /**
     * Executes actions when Enter is pressed.
     */
    onEnterPressed() {
        const matchedWaypoints = this.store.matchedWaypoints;
        const selectedWaypoint = this.store.waypoint.get();
        if (matchedWaypoints.length > 1) {
            const dialog = Fms.viewService.open(this.getWptDupDialogName(), true).setInput(matchedWaypoints);
            dialog.onAccept.on((sender, facility) => {
                this.onWptDupDialogAccept(facility);
            });
            dialog.onClose.on(() => { this.onWptDupDialogClose(); });
        }
        else if (selectedWaypoint) {
            this.accept(selectedWaypoint.facility);
        }
    }
    /**
     * A callback which is called when a waypoint duplicate dialog invoked by this view accepts.
     * @param facility The facility returned by the waypoint duplicate dialog.
     */
    onWptDupDialogAccept(facility) {
        facility && this.accept(facility);
    }
    /**
     * A callback which is called when a waypoint duplicate dialog invoked by this view closes.
     */
    onWptDupDialogClose() {
        // noop
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewOpened() {
        this.inputSelectedIcao.set('');
        this.planePosConsumer.handle(this.planePosHandler);
        this.planeHeadingConsumer.handle(this.planeHeadingHandler);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewClosed() {
        this.planePosConsumer.off(this.planePosHandler);
        this.planeHeadingConsumer.off(this.planeHeadingHandler);
    }
    /**
     * A callback which is called when the plane's current position changes.
     * @param pos The new position.
     */
    onPlanePosChanged(pos) {
        this.planePosSub.set(pos.lat, pos.long);
    }
    /**
     * A callback which is called when the plane's current true heading changes.
     * @param heading The new heading, in degrees.
     */
    onPlaneHeadingChanged(heading) {
        this.planeHeadingSub.set(heading);
    }
    /**
     * Renders a waypoint input component.
     * @returns a waypoint input component, as a VNode.
     */
    renderWaypointInput() {
        return (FSComponent.buildComponent(WaypointInput, { bus: this.props.bus, onRegister: this.register, selectedIcao: this.inputSelectedIcao, onMatchedWaypointsChanged: this.controller.matchedWaypointsChangedHandler, onWaypointChanged: this.controller.selectedWaypointChangedHandler, onInputEnterPressed: this.onEnterPressed.bind(this), planeHeading: this.planeHeadingSub, filter: FacilitySearchType.None }));
    }
    /**
     * Renders a component which displays the bearing to the store's selected waypoint.
     * @param cssClass CSS class(es) to apply to the root of the component.
     * @returns a component which displays the bearing to the store's selected waypoint, as a VNode.
     */
    renderBearing(cssClass) {
        return (FSComponent.buildComponent(NumberUnitDisplay, { value: this.store.bearing, displayUnit: Subject.create(UnitType.DEGREE), formatter: NumberFormatter.create({ precision: 1, pad: 3, nanString: '___' }), class: cssClass }));
    }
    /**
     * Renders a component which displays the distance to the store's selected waypoint.
     * @param cssClass CSS class(es) to apply to the root of the component.
     * @returns a component which displays the distance to the store's selected waypoint, as a VNode.
     */
    renderDistance(cssClass) {
        return (FSComponent.buildComponent(NumberUnitDisplay, { value: this.store.distance, displayUnit: Subject.create(UnitType.NMILE), formatter: NumberFormatter.create({ precision: 0.1, maxDigits: 3, forceDecimalZeroes: false, nanString: '__._' }), class: cssClass }));
    }
}

/**
 * A text display for waypoint region.
 */
class WaypointRegion extends WaypointComponent {
    constructor() {
        super(...arguments);
        this.textSub = ComputedSubject.create(null, (waypoint) => {
            if (waypoint instanceof FacilityWaypoint) {
                if (waypoint instanceof AirportWaypoint) {
                    // airports don't have region codes in their ICAO strings, we will try to grab the code from the first 2
                    // letters of the ident. However, some airports (e.g. in the US and those w/o 4-letter idents) don't use the
                    // region code for the ident, so we need a third fallback, which is to just display the city name instead.
                    const airport = waypoint.facility;
                    const ident = ICAO.getIdent(airport.icao).trim();
                    let text = ident.length === 4 ? Regions.getName(ident.substr(0, 2)) : '';
                    if (text === '' && airport.city !== '') {
                        text = airport.city.split(', ').map(name => Utils.Translate(name)).join(', ');
                    }
                    if (text) {
                        return text;
                    }
                }
                else {
                    return Regions.getName(waypoint.facility.icao.substr(1, 2));
                }
            }
            return '__________';
        });
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onWaypointChanged(waypoint) {
        this.textSub.set(waypoint);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' }, this.textSub));
    }
}

/**
 * An item in a list of duplicate facility waypoints. Displays the type of the waypoint, an icon, and the region in
 * which the waypoint is located.
 */
class WptDupListItem extends UiControl {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.iconRef = FSComponent.createRef();
        this.regionContainerRef = FSComponent.createRef();
        this.regionRef = FSComponent.createRef();
        this.waypointChangedHandler = this.onWaypointChanged.bind(this);
        this.facilityTypeSub = ComputedSubject.create(null, (waypoint) => {
            return waypoint ? WptDupListItem.FACILITY_TYPE_TEXT[ICAO.getFacilityType(waypoint.facility.icao)] : '';
        });
        this.props.waypoint.sub(this.waypointChangedHandler, true);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getHighlightElement() {
        return this.regionContainerRef.instance;
    }
    /**
     * A callback which is called when this item's waypoint changes.
     * @param waypoint The new waypoint.
     */
    onWaypointChanged(waypoint) {
        this.facilityTypeSub.set(waypoint);
    }
    /**
     * Renders this control.
     * @returns this control's VNode.
     */
    renderControl() {
        var _a;
        return (FSComponent.buildComponent("div", { class: `wpt-dup-listitem ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}` },
            FSComponent.buildComponent("div", { class: 'wpt-dup-listitem-type' }, this.facilityTypeSub),
            FSComponent.buildComponent(WaypointIcon, { ref: this.iconRef, waypoint: this.props.waypoint, class: 'wpt-dup-listitem-icon' }),
            FSComponent.buildComponent("div", { ref: this.regionContainerRef, class: 'wpt-dup-listitem-region-container' },
                FSComponent.buildComponent(WaypointRegion, { ref: this.regionRef, waypoint: this.props.waypoint, class: 'wpt-dup-listitem-region' }))));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    destroy() {
        this.iconRef.instance.destroy();
        this.regionRef.instance.destroy();
        this.props.waypoint.unsub(this.waypointChangedHandler);
    }
}
WptDupListItem.FACILITY_TYPE_TEXT = {
    [FacilityType.Airport]: 'APT',
    [FacilityType.VOR]: 'VOR',
    [FacilityType.NDB]: 'NDB',
    [FacilityType.Intersection]: 'INT',
    [FacilityType.USR]: 'USR',
    [FacilityType.RWY]: 'RWY',
    [FacilityType.VIS]: 'VIS'
};

/**
 * A dialog for selecting from a list of duplicate waypoints.
 */
class WptDupDialog extends UiView {
    constructor() {
        super(...arguments);
        this.listRef = FSComponent.createRef();
        this.waypoints = ArraySubject.create();
        this.ident = Subject.create('');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onInputDataSet(input) {
        this.ident.set((input === null || input === void 0 ? void 0 : input.length) ? ICAO.getIdent(input[0].facility.icao) : '');
        input ? this.waypoints.set(input) : this.waypoints.clear();
        this.scrollController.gotoFirst();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.ENT:
                return this.onEnterPressed();
            case FmsHEvent.CLR:
                return this.onClearPressed();
        }
        return false;
    }
    /**
     * This method is called when Enter is pressed.
     * @returns whether the event was handled.
     */
    onEnterPressed() {
        const selectedWaypoint = this.listRef.instance.getSelectedItem();
        if (selectedWaypoint) {
            this.accept(selectedWaypoint.facility, true);
            return true;
        }
        return false;
    }
    /**
     * This method is called when CLR is pressed.
     * @returns whether the event was handled.
     */
    onClearPressed() {
        this.close();
        return true;
    }
    /**
     * Renders a duplicate waypoint list item.
     * @param cssClass CSS class(es) to add to the list item.
     * @param waypoint A waypoint.
     * @param registerFn The register callback to use.
     * @returns a list item VNode.
     */
    renderListItem(cssClass, waypoint, registerFn) {
        return (FSComponent.buildComponent(WptDupListItem, { onRegister: registerFn, waypoint: Subject.create(waypoint), class: cssClass }));
    }
}

/**
 * A dialog for selecting from a list of duplicate waypoints.
 */
class MFDWptDupDialog extends WptDupDialog {
    constructor() {
        super(...arguments);
        this.selectedWaypointSub = Subject.create(null);
        this.planePosSub = GeoPointSubject.createFromGeoPoint(new GeoPoint(NaN, NaN));
        this.planePosConsumer = this.props.bus.getSubscriber().on('gps-position').whenChanged();
        this.planePosHandler = this.onPlanePosChanged.bind(this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewOpened() {
        this.planePosConsumer.handle(this.planePosHandler);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewClosed() {
        this.planePosConsumer.off(this.planePosHandler);
    }
    /**
     * A callback which is called when the plane's current position changes.
     * @param pos The new position.
     */
    onPlanePosChanged(pos) {
        this.planePosSub.set(MFDWptDupDialog.tempGeoPoint.set(pos.lat, pos.long));
    }
    /**
     * A callback which is called when the selected waypoint changes.
     * @param waypoint The new selected waypoint.
     */
    onWaypointSelected(waypoint) {
        this.selectedWaypointSub.set(waypoint);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        const listContainerRef = FSComponent.createRef();
        return (FSComponent.buildComponent("div", { class: 'popout-dialog mfd-wpt-dup', ref: this.viewContainerRef },
            FSComponent.buildComponent("h1", null, this.props.title),
            FSComponent.buildComponent(GroupBox, { title: 'Waypoint' },
                FSComponent.buildComponent("div", { class: 'mfd-wpt-dup-ident' }, this.ident)),
            FSComponent.buildComponent(GroupBox, { title: 'Duplicates', class: 'mfd-wpt-dup-list-box' },
                FSComponent.buildComponent("div", { class: 'mfd-wpt-dup-list-wrapper' },
                    FSComponent.buildComponent("div", { class: 'mfd-wpt-dup-list-container', ref: listContainerRef },
                        FSComponent.buildComponent(List, { ref: this.listRef, onRegister: this.register, data: this.waypoints, renderItem: this.renderListItem.bind(this, 'mfd-wpt-dup-listitem'), onItemSelected: this.onWaypointSelected.bind(this), scrollContainer: listContainerRef, class: 'mfd-wpt-dup-list' })),
                    FSComponent.buildComponent(ScrollBar, null))),
            FSComponent.buildComponent(GroupBox, { title: 'Information', class: 'mfd-wpt-dup-info-box' },
                FSComponent.buildComponent(MFDWptDupInfo, { waypoint: this.selectedWaypointSub, planePos: this.planePosSub })),
            FSComponent.buildComponent("div", { class: 'mfd-wpt-dup-prompt' }, "Press \"ENT\" to select duplicate or \"CLR\" to cancel")));
    }
}
MFDWptDupDialog.tempGeoPoint = new GeoPoint(0, 0);
/**
 * Displays waypoint information in the MFD duplicate waypoints dialog.
 */
class MFDWptDupInfo extends WaypointComponent {
    constructor() {
        super(...arguments);
        this.store = new WaypointInfoStore(this.props.waypoint, this.props.planePos);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent("div", { class: 'mfd-wpt-dup-info' },
            FSComponent.buildComponent("div", { class: 'mfd-wpt-dup-info-city' }, this.store.city),
            FSComponent.buildComponent("div", { class: 'mfd-wpt-dup-info-name' }, this.store.name),
            FSComponent.buildComponent(LatLonDisplay, { location: this.store.location, class: 'mfd-wpt-dup-info-latlon' }),
            FSComponent.buildComponent(NumberUnitDisplay, { value: this.store.bearing, displayUnit: Subject.create(UnitType.DEGREE), formatter: NumberFormatter.create({ precision: 1, pad: 3, nanString: '___' }), class: 'mfd-wpt-dup-info-bearing' }),
            FSComponent.buildComponent(NumberUnitDisplay, { value: this.store.distance, displayUnit: Subject.create(UnitType.NMILE), formatter: NumberFormatter.create({ precision: 0.1, maxDigits: 3, forceDecimalZeroes: false, nanString: '___' }), class: 'mfd-wpt-dup-info-distance' })));
    }
}

/**
 * The MFD waypoint info popout.
 */
class MFDWptInfo extends WptInfo {
    constructor() {
        super(...arguments);
        this.mapRef = FSComponent.createRef();
        this.mapModel = this.createMapModel();
        this.pointerModule = this.mapModel.getModule('pointer');
        this.mapRangeIndexSub = Subject.create(WaypointMapRangeTargetRotationController.DEFAULT_MAP_RANGE_INDEX);
    }
    /**
     * Creates the model for this component's map.
     * @returns a map model.
     */
    createMapModel() {
        return WaypointMapModel.createModel();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        super.onAfterRender();
        this.mapPointerController = new MapPointerController(this.mapModel, this.mapRef.instance.mapProjection);
        this.mapRef.instance.sleep();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onInteractionEvent(evt) {
        var _a;
        switch (evt) {
            case FmsHEvent.RANGE_DEC:
                this.changeMapRangeIndex(-1);
                return true;
            case FmsHEvent.RANGE_INC:
                this.changeMapRangeIndex(1);
                return true;
            case FmsHEvent.JOYSTICK_PUSH:
                (_a = this.mapPointerController) === null || _a === void 0 ? void 0 : _a.togglePointerActive();
                return true;
        }
        return this.handleMapPointerMoveEvent(evt) || super.onInteractionEvent(evt);
    }
    /**
     * Changes the MFD map range index setting.
     * @param delta The change in index to apply.
     */
    changeMapRangeIndex(delta) {
        var _a;
        const currentIndex = this.mapRangeIndexSub.get();
        const newIndex = Utils.Clamp(currentIndex + delta, 0, WaypointMapRangeTargetRotationController.DEFAULT_MAP_RANGES.length - 1);
        if (currentIndex !== newIndex) {
            (_a = this.mapPointerController) === null || _a === void 0 ? void 0 : _a.targetPointer();
            this.mapRangeIndexSub.set(newIndex);
        }
    }
    /**
     * Handles events that move the map pointer.
     * @param evt The event.
     * @returns Whether the event was handled.
     */
    handleMapPointerMoveEvent(evt) {
        var _a, _b, _c, _d;
        if (!this.pointerModule.isActive.get()) {
            return false;
        }
        switch (evt) {
            case FmsHEvent.JOYSTICK_LEFT:
                (_a = this.mapPointerController) === null || _a === void 0 ? void 0 : _a.movePointer(-MFDWptInfo.POINTER_MOVE_INCREMENT, 0);
                return true;
            case FmsHEvent.JOYSTICK_UP:
                (_b = this.mapPointerController) === null || _b === void 0 ? void 0 : _b.movePointer(0, -MFDWptInfo.POINTER_MOVE_INCREMENT);
                return true;
            case FmsHEvent.JOYSTICK_RIGHT:
                (_c = this.mapPointerController) === null || _c === void 0 ? void 0 : _c.movePointer(MFDWptInfo.POINTER_MOVE_INCREMENT, 0);
                return true;
            case FmsHEvent.JOYSTICK_DOWN:
                (_d = this.mapPointerController) === null || _d === void 0 ? void 0 : _d.movePointer(0, MFDWptInfo.POINTER_MOVE_INCREMENT);
                return true;
        }
        return false;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getWptDupDialogName() {
        return MFDWptDupDialog.name;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onWptDupDialogClose() {
        this.close();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewOpened() {
        super.onViewOpened();
        this.mapRef.instance.wake();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewClosed() {
        var _a;
        super.onViewClosed();
        (_a = this.mapPointerController) === null || _a === void 0 ? void 0 : _a.setPointerActive(false);
        this.mapRef.instance.sleep();
        this.mapRangeIndexSub.set(WaypointMapRangeTargetRotationController.DEFAULT_MAP_RANGE_INDEX);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent("div", { class: 'popout-dialog mfd-wptinfo', ref: this.viewContainerRef },
            FSComponent.buildComponent("h1", null, this.props.title),
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Ident, Facility, City" }, this.renderWaypointInput()),
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Map", class: 'mfd-wptinfo-map-box' },
                FSComponent.buildComponent(WaypointMapComponent, { ref: this.mapRef, model: this.mapModel, bus: this.props.bus, updateFreq: 15, projectedWidth: 285, projectedHeight: 300, id: 'mfd_wptinfo_map', rangeIndex: this.mapRangeIndexSub, waypoint: this.store.waypoint, ownAirplaneLayerProps: {
                        imageFilePath: 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/own_airplane_icon.svg',
                        iconSize: 40,
                        iconAnchor: new Float64Array([0.5, 0])
                    } })),
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Location" },
                FSComponent.buildComponent("div", { class: 'mfd-wptinfo-loc' },
                    FSComponent.buildComponent("div", { class: 'mfd-wptinfo-loc-field mfd-wptinfo-loc-bearing' },
                        FSComponent.buildComponent("div", { class: 'mfd-wptinfo-loc-title' }, "BRG"),
                        this.renderBearing('mfd-wptinfo-loc-value')),
                    FSComponent.buildComponent("div", { class: 'mfd-wptinfo-loc-field mfd-wptinfo-loc-distance' },
                        FSComponent.buildComponent("div", { class: 'mfd-wptinfo-loc-title' }, "DIS"),
                        this.renderDistance('mfd-wptinfo-loc-value')),
                    FSComponent.buildComponent("div", { class: 'mfd-wptinfo-loc-region' }, this.store.region),
                    FSComponent.buildComponent(LatLonDisplay, { location: this.store.location, class: 'mfd-wptinfo-loc-latlon' }))),
            FSComponent.buildComponent("div", { class: "mfd-wptinfo-bottom-prompt" }, this.store.prompt)));
    }
}
MFDWptInfo.POINTER_MOVE_INCREMENT = 2; // pixels

/**
 *
 */
class SetRunwayStore {
    /**
     * Constructor.
     */
    constructor() {
        /** A subject which provides this store's airport. */
        this.airport = Subject.create(null);
        this._airportIdent = Subject.create('');
        /** An array of runways at this store's airport. */
        this.oneWayRunways = ArraySubject.create([]);
        this.airport.sub(this.onAirportChanged.bind(this));
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The ident of this store's airport. */
    get airportIdent() {
        return this._airportIdent;
    }
    /**
     * A callback which is called when this store's airport changes.
     * @param airport The new airport.
     */
    onAirportChanged(airport) {
        var _a;
        this._airportIdent.set(airport ? ICAO.getIdent(airport.icao) : '');
        const runways = (_a = airport === null || airport === void 0 ? void 0 : airport.runways.reduce((acc, runway, index) => {
            acc.push(...RunwayUtils.getOneWayRunways(runway, index));
            return acc;
        }, []).sort(RunwayUtils.sortRunways)) !== null && _a !== void 0 ? _a : [];
        runways.unshift(RunwayUtils.createEmptyOneWayRunway());
        this.oneWayRunways.set(runways);
    }
}

/**
 * A dialog for setting runways.
 */
class SetRunway extends UiView {
    constructor() {
        super(...arguments);
        this.store = new SetRunwayStore();
        this.selectedRunway = undefined;
    }
    /** @inheritdoc */
    onInputDataSet(input) {
        this.store.airport.set(input !== null && input !== void 0 ? input : null);
        this.scrollController.gotoFirst();
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.ENT:
                return this.onEnterPressed();
            case FmsHEvent.CLR:
                return this.onCLRPressed();
        }
        return false;
    }
    /**
     * This method is called when an Enter button event occurs.
     * @returns whether the event was handled.
     */
    onEnterPressed() {
        this.accept(this.selectedRunway, true);
        return true;
    }
    /**
     * This method is called when a CLR button event occurs.
     * @returns whether the event was handled.
     */
    onCLRPressed() {
        this.selectedRunway = undefined;
        this.close();
        return true;
    }
    /**
     * A callback which is called when a runway is selected.
     * @param index The index of the selection.
     * @param runway The runway which was selected.
     */
    onRunwaySelected(index, runway) {
        this.selectedRunway = (runway !== undefined && runway.designation !== '') ? runway : undefined;
    }
    /**
     * Builds a runway menu item definition for a runway.
     * @param runway A runway.
     * @param index The index of the item in the menu.
     * @returns a menu item definition for the runway.
     */
    buildRunwayMenuItem(runway, index) {
        const text = (runway.designation !== '') ? runway.designation : 'NONE';
        return { id: index.toString(), renderContent: () => FSComponent.buildComponent("span", null, text), estimatedWidth: text.length * ContextMenuDialog.CHAR_WIDTH };
    }
}

/**
 * A dialog for setting runways.
 */
class MFDSetRunway extends SetRunway {
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: 'popout-dialog mfd-setrunway', ref: this.viewContainerRef },
            FSComponent.buildComponent("h1", null, this.props.title),
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Runway" },
                FSComponent.buildComponent("div", { class: "mfd-setrunway-container" },
                    FSComponent.buildComponent("div", { class: "mfd-setrunway-left mfd-setrunway-airport" }, "Airport"),
                    FSComponent.buildComponent("div", { class: "mfd-setrunway-right mfd-setrunway-airport-value" }, this.store.airportIdent),
                    FSComponent.buildComponent("div", { class: "mfd-setrunway-left mfd-setrunway-runway" }, "Runway"),
                    FSComponent.buildComponent(SelectControl, { onRegister: this.register, outerContainer: this.viewContainerRef, dialogPosition: ContextMenuPosition.CENTER, data: this.store.oneWayRunways, buildMenuItem: this.buildRunwayMenuItem.bind(this), onItemSelected: this.onRunwaySelected.bind(this), class: "mfd-setrunway-right mfd-setrunway-runway-value" }))),
            FSComponent.buildComponent("div", { class: "mfd-setrunway-press-ent" }, "Press \"ENT\" to accept")));
    }
}

/// <reference types="msfstypes/JS/common" />
/**
 * An instrument that gathers localizer and glideslope information for use by
 * the AP systems.
 */
class APRadioNavInstrument {
    /**
     * Creates an instance of the APRadioNavInstrument.
     * @param bus The event bus to use with this instance.
     */
    constructor(bus) {
        this.bus = bus;
        this.navRadioData = {
            1: {
                glideslope: this.createEmptyGlideslope({ index: 1, type: NavSourceType.Nav }),
                localizer: this.createEmptyLocalizer({ index: 1, type: NavSourceType.Nav }),
                cdi: this.createEmptyCdi({ index: 1, type: NavSourceType.Nav }),
                obs: this.createEmptyObs({ index: 1, type: NavSourceType.Nav })
            },
            2: {
                glideslope: this.createEmptyGlideslope({ index: 2, type: NavSourceType.Nav }),
                localizer: this.createEmptyLocalizer({ index: 2, type: NavSourceType.Nav }),
                cdi: this.createEmptyCdi({ index: 2, type: NavSourceType.Nav }),
                obs: this.createEmptyObs({ index: 2, type: NavSourceType.Nav })
            }
        };
        this.currentCdiIndex = 1;
        this.navProc = new NavProcSimVarPublisher(bus);
        this.publisher = bus.getPublisher();
    }
    /** @inheritdoc */
    init() {
        this.navProc.subscribe('nav1_glideslope');
        this.navProc.subscribe('nav1_gs_lla');
        this.navProc.subscribe('nav1_gs_error');
        this.navProc.subscribe('nav1_raw_gs');
        this.navProc.subscribe('nav1_localizer');
        this.navProc.subscribe('nav1_localizer_crs');
        this.navProc.subscribe('nav1_cdi');
        this.navProc.subscribe('nav1_obs');
        this.navProc.subscribe('nav2_glideslope');
        this.navProc.subscribe('nav2_gs_lla');
        this.navProc.subscribe('nav2_gs_error');
        this.navProc.subscribe('nav2_raw_gs');
        this.navProc.subscribe('nav2_localizer');
        this.navProc.subscribe('nav2_localizer_crs');
        this.navProc.subscribe('nav2_cdi');
        this.navProc.subscribe('nav2_obs');
        this.navProc.subscribe('nav1_lla');
        this.navProc.subscribe('nav2_lla');
        this.navProc.startPublish();
        const navProcSubscriber = this.bus.getSubscriber();
        navProcSubscriber.on('nav1_glideslope').handle(hasGs => this.setGlideslopeValue(1, 'isValid', hasGs));
        navProcSubscriber.on('nav1_gs_lla').handle(lla => this.sendGlideslopePosition(1, lla));
        navProcSubscriber.on('nav1_gs_error').handle(gsError => this.setGlideslopeValue(1, 'deviation', gsError));
        navProcSubscriber.on('nav1_raw_gs').handle(rawGs => this.setGlideslopeValue(1, 'gsAngle', rawGs));
        navProcSubscriber.on('nav1_localizer').handle(hasLoc => this.setLocalizerValue(1, 'isValid', hasLoc));
        navProcSubscriber.on('nav1_localizer_crs').handle(locCourse => this.setLocalizerValue(1, 'course', locCourse));
        navProcSubscriber.on('nav1_cdi').handle(deviation => this.setCDIValue(1, 'deviation', deviation));
        navProcSubscriber.on('nav1_obs').handle(obs => this.setOBSValue(1, 'heading', obs));
        navProcSubscriber.on('nav2_glideslope').handle(hasGs => this.setGlideslopeValue(2, 'isValid', hasGs));
        navProcSubscriber.on('nav2_gs_lla').handle(lla => this.sendGlideslopePosition(2, lla));
        navProcSubscriber.on('nav2_gs_error').handle(gsError => this.setGlideslopeValue(2, 'deviation', gsError));
        navProcSubscriber.on('nav2_raw_gs').handle(rawGs => this.setGlideslopeValue(2, 'gsAngle', rawGs));
        navProcSubscriber.on('nav2_localizer').handle(hasLoc => this.setLocalizerValue(2, 'isValid', hasLoc));
        navProcSubscriber.on('nav2_localizer_crs').handle(locCourse => this.setLocalizerValue(2, 'course', locCourse));
        navProcSubscriber.on('nav2_cdi').handle(deviation => this.setCDIValue(2, 'deviation', deviation));
        navProcSubscriber.on('nav2_obs').handle(obs => this.setOBSValue(2, 'heading', obs));
        navProcSubscriber.on('nav1_lla').handle(lla => this.sendNavPosition(1, lla));
        navProcSubscriber.on('nav2_lla').handle(lla => this.sendNavPosition(2, lla));
        const navEvents = this.bus.getSubscriber();
        navEvents.on('cdi_select').handle(source => this.currentCdiIndex = source.type === NavSourceType.Nav ? source.index : 0);
    }
    /** @inheritdoc */
    onUpdate() {
        this.navProc.onUpdate();
    }
    /**
     * Sets a value in a nav radio glideslope.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setGlideslopeValue(index, field, value) {
        this.navRadioData[index].glideslope[field] = value;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('glideslope', this.navRadioData[index].glideslope);
        }
    }
    /**
     * Sends the current glideslope's LLA position.
     * @param index The index of the nav radio.
     * @param lla The LLA to send.
     */
    sendGlideslopePosition(index, lla) {
        if (this.currentCdiIndex === index) {
            this.publisher.pub('gsLocation', lla);
        }
    }
    /**
     * Sends the current nav's LLA position.
     * @param index The index of the nav radio.
     * @param lla The LLA to send.
     */
    sendNavPosition(index, lla) {
        if (this.currentCdiIndex === index) {
            this.publisher.pub('navLocation', lla);
        }
    }
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setLocalizerValue(index, field, value) {
        this.navRadioData[index].localizer[field] = value;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('localizer', this.navRadioData[index].localizer);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_1_localizer', this.navRadioData[index].localizer);
                break;
            case 2:
                this.publisher.pub('nav_2_localizer', this.navRadioData[index].localizer);
                break;
        }
    }
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setCDIValue(index, field, value) {
        this.navRadioData[index].cdi[field] = value;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('cdi_deviation', this.navRadioData[index].cdi);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_1_cdi', this.navRadioData[index].cdi);
                break;
            case 2:
                this.publisher.pub('nav_2_cdi', this.navRadioData[index].cdi);
                break;
        }
    }
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setOBSValue(index, field, value) {
        this.navRadioData[index].obs[field] = value;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('obs_setting', this.navRadioData[index].obs);
        }
    }
    /**
     * Creates an empty localizer data.
     * @param id The nav source ID.
     * @returns New empty localizer data.
     */
    createEmptyLocalizer(id) {
        return {
            isValid: false,
            course: 0,
            source: id
        };
    }
    /**
     * Creates an empty glideslope data.
     * @param id The nav source ID.
     * @returns New empty glideslope data.
     */
    createEmptyGlideslope(id) {
        return {
            isValid: false,
            gsAngle: 0,
            deviation: 0,
            source: id
        };
    }
    /**
     * Creates an empty CDI data.
     * @param id The nav source ID.
     * @returns New empty CDI data.
     */
    createEmptyCdi(id) {
        return {
            deviation: 0,
            source: id
        };
    }
    /**
     * Creates an empty OBS data.
     * @param id The nav source ID.
     * @returns New empty OBS data.
     */
    createEmptyObs(id) {
        return {
            heading: 0,
            source: id
        };
    }
}

/** The data store for SelectProcedure pages */
class SelectAirwayStore {
    constructor() {
        this.inputSegment = -1;
        this.inputLeg = -1;
        this.airways = ArraySubject.create();
        this.exits = ArraySubject.create();
        this.sequence = ArraySubject.create();
    }
    /**
     * Gets the airways array for this facility.
     * @returns The an array of unique airway names.
     */
    getFacilityAirways() {
        const airways = [];
        airways.push('NONE');
        if (this.selectedFacility !== undefined && this.selectedFacility.routes.length > 0) {
            this.selectedFacility.routes.forEach((route) => {
                airways.push(route.name);
            });
            const uniqueAirways = airways.filter((v, i, a) => a.indexOf(v) === i);
            return uniqueAirways;
        }
        return [];
    }
    /**
     * Gets the airway.
     * @param airwayName is the name of the airway as a string.
     * @param facLoader is an instance of the facility loader.
     */
    async loadAirway(airwayName, facLoader) {
        var _a, _b;
        const route = (_a = this.selectedFacility) === null || _a === void 0 ? void 0 : _a.routes.find((r) => r.name === airwayName);
        if (route !== undefined && this.selectedFacility !== undefined) {
            this.selectedAirway = await facLoader.getAirway(airwayName, route.type, (_b = this.selectedFacility) === null || _b === void 0 ? void 0 : _b.icao);
        }
    }
    /**
     * Builds the sequence list for the approach preview
     * @param fms is an instance of the FMS
     */
    buildSequence(fms) {
        if (this.selectedFacility !== undefined && this.selectedAirway !== undefined && this.selectedExit !== undefined) {
            const legs = [];
            const previewPlanIndex = fms.buildAirwayPreviewSegment(this.selectedAirway, this.selectedFacility, this.selectedExit);
            const previewPlan = fms.getFlightPlan(previewPlanIndex);
            previewPlan.getSegment(0).legs.forEach((l) => {
                legs.push(Subject.create(l));
            });
            this.sequence.set(legs);
        }
    }
    /**
     * Sets the data to display the facility.
     * @param facility The airport facility to be shown.
     */
    loadFacility(facility) {
        this.selectedFacility = facility;
        this.airways.clear();
        this.exits.clear();
        this.sequence.clear();
        this.airways.set(this.getFacilityAirways());
    }
    /**
     * Empties the display content when no facility is selected
     */
    clearFacility() {
        this.selectedFacility = undefined;
        this.airways.clear();
        this.exits.clear();
        this.sequence.clear();
    }
    /**
     * Gets the exits of the selected airway.
     * @returns The airway exits.
     */
    getExits() {
        var _a;
        const exits = [];
        if (this.selectedAirway !== undefined && this.selectedAirway.waypoints.length > 1) {
            (_a = this.selectedAirway) === null || _a === void 0 ? void 0 : _a.waypoints.forEach((waypoint) => {
                exits.push(waypoint);
            });
        }
        return exits;
    }
}

/** The controller for SelectProcedure views. */
class SelectAirwayController {
    /**
     * Creates a Select Airway Controller
     * @param store The store.
     * @param selectNextCb Callback when the next control should be focused.
     * @param fms The FMS instance.
     * @param exitSelectControlRef is the ref for the exit select control.
     */
    constructor(store, selectNextCb, fms, exitSelectControlRef) {
        this.store = store;
        this.selectNextCb = selectNextCb;
        this.fms = fms;
        this.exitSelectControlRef = exitSelectControlRef;
        this.inputIcao = Subject.create('');
        this.entrySubject = Subject.create('');
        this.canLoad = Subject.create(false);
        this.emptyListText = Subject.create('NONE');
        this.entryIndex = -1;
        this.entryIndexSubject = Subject.create(-1);
        /**
         * Evaluates if the next select should be focused.
         * @param isRefresh If select event happened based on a data refresh.
         */
        this.gotoNextSelect = (isRefresh) => {
            if (!isRefresh) {
                this.selectNextCb();
            }
        };
        /**
         * Callback handler for when an airway is selected.
         * @param index is the index of the item selected
         * @param airway The airway name selected.
         * @param isRefresh If select event happened based on a data refresh.
         */
        this.onAirwaySelected = (index, airway, isRefresh) => {
            this.emptyListText.set(index <= 0 ? 'NONE' : 'LOADING...');
            this.canLoad.set(false);
            this.store.exits.clear();
            this.store.sequence.clear();
            if (!isRefresh && index > 0) {
                this.store.loadAirway(airway, this.fms.facLoader).then(() => {
                    this.store.exits.set(this.store.getExits());
                    this.exitSelectControlRef.instance.SelectedValue.set(this.entryIndex);
                    this.entryIndexSubject.set(this.entryIndex);
                    this.gotoNextSelect(isRefresh);
                });
            }
        };
        /**
         * Builds an airway menu item.
         * @param airway The airway to build the menu item for.
         * @returns A menu item definition.
         */
        this.buildAirwayMenuItem = (airway) => {
            return { id: airway, renderContent: () => FSComponent.buildComponent("span", null, airway), estimatedWidth: airway.length * ContextMenuDialog.CHAR_WIDTH };
        };
        /**
         * Callback handler for when an enroute transition is selected.
         * @param index The index of the selected transition.
         * @param item The transition selected.
         * @param isRefresh If select event happened based on a data refresh.
         */
        this.onExitSelected = (index, item, isRefresh) => {
            this.store.selectedExit = item;
            if (!isRefresh) {
                this.store.buildSequence(this.fms);
                this.gotoNextSelect(isRefresh);
                this.canLoad.set(true);
            }
        };
        /**
         * Builds an airway exit menu item.
         * @param waypoint The intersection facility of the exit.
         * @param index The index of the airway.
         * @returns A menu item definition.
         */
        this.buildExitMenuItem = (waypoint, index) => {
            const isEnabled = waypoint.icao !== this.inputIcao.get();
            if (!isEnabled) {
                console.log('entry index: ' + index);
                this.entryIndex = index;
            }
            const ident = ICAO.getIdent(waypoint.icao);
            return {
                id: index.toString(),
                renderContent: () => FSComponent.buildComponent("span", null, ident),
                isEnabled: isEnabled,
                estimatedWidth: ident.length * ContextMenuDialog.CHAR_WIDTH
            };
        };
        /** Callback handler for when load is pressed. */
        this.onLoadSelected = () => {
            this.onLoadExecuted();
        };
        /** Callback handler for when load is pressed. */
        this.onLoadExecuted = () => {
            if (this.store.selectedFacility !== undefined && this.store.selectedAirway !== undefined && this.store.selectedExit !== undefined) {
                this.fms.insertAirwaySegment(this.store.selectedAirway, this.store.selectedFacility, this.store.selectedExit, this.store.inputSegment, this.store.inputLeg);
            }
        };
        const fpl = this.fms.bus.getSubscriber();
        fpl.on('fplCalculated').handle((e) => {
            if (e.planIndex == 2) {
                const plan = this.fms.flightPlanner.getFlightPlan(2);
                if (plan.segmentCount > 0) {
                    const segment = plan.getSegment(0);
                    for (let i = 0; i < segment.legs.length; i++) {
                        const leg = this.store.sequence.tryGet(i);
                        if (leg !== undefined) {
                            leg.get().calculated = segment.legs[i].calculated;
                            leg.notify();
                        }
                    }
                }
            }
        });
    }
    /**
     * Sets existing fix for Direct To Existing
     * @param inputData is the DirectToInputData
     */
    async setExistingFix(inputData) {
        if ((inputData === null || inputData === void 0 ? void 0 : inputData.legIndex) !== undefined && (inputData === null || inputData === void 0 ? void 0 : inputData.segmentIndex) !== undefined) {
            const plan = this.fms.getFlightPlan();
            const segment = plan.getSegment(inputData.segmentIndex);
            const fixIcao = segment.legs[inputData.legIndex].leg.fixIcao;
            this.inputIcao.set(fixIcao);
            this.entrySubject.set(ICAO.getIdent(this.inputIcao.get()));
            const fac = await this.getFacility(this.inputIcao.get());
            this.store.loadFacility(fac);
            this.gotoNextSelect(false);
        }
        else {
            this.inputIcao.set('');
        }
    }
    /** Initialize the controller. */
    initialize() {
        this.emptyListText.set('NONE');
        this.canLoad.set(false);
        this.store.clearFacility();
    }
    /** Get the facility.
     * @param icao is the intersection icao
     * @returns an Intersection Facility
     */
    async getFacility(icao) {
        const facility = await this.fms.facLoader.getFacility(FacilityType.Intersection, icao);
        return facility;
    }
}

/**
 * A view which allows the user to select an airway.
 */
class SelectAirway extends UiView {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.exitSelectControlRef = FSComponent.createRef();
        /** Goto and activate next select control. */
        this.gotoNextSelect = () => {
            this.scrollController.gotoNext();
        };
        this.store = new SelectAirwayStore();
        this.controller = new SelectAirwayController(this.store, this.gotoNextSelect, this.props.fms, this.exitSelectControlRef);
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.CLR:
                this.close();
                return true;
        }
        return false;
    }
    /** @inheritdoc */
    onInputDataSet(inputData) {
        this.store.inputSegment = (inputData === null || inputData === void 0 ? void 0 : inputData.segmentIndex) !== undefined ? inputData === null || inputData === void 0 ? void 0 : inputData.segmentIndex : -1;
        this.store.inputLeg = (inputData === null || inputData === void 0 ? void 0 : inputData.legIndex) !== undefined ? inputData === null || inputData === void 0 ? void 0 : inputData.legIndex : -1;
        this.controller.setExistingFix(inputData);
    }
    /** @inheritdoc */
    onViewOpened() {
        this.controller.initialize();
    }
    /**
     * A callback which is called when the Load action is executed.
     */
    onLoadExecuted() {
        this.controller.onLoadExecuted();
        this.close();
    }
    /**
     * Renders the airway select control component.
     * @param dialogPosition The position of the pop-up context menu dialog spawned by the select control.
     * @returns The rendered airway select control component, as a VNode.
     */
    renderAirwaySelectControl(dialogPosition) {
        return (FSComponent.buildComponent(SelectControl, { onRegister: this.register, class: "set-airway-airway-value", dialogPosition: dialogPosition, outerContainer: this.viewContainerRef, data: this.store.airways, buildMenuItem: this.controller.buildAirwayMenuItem, onItemSelected: this.controller.onAirwaySelected }));
    }
    /**
     * Renders the exit waypoint select control component.
     * @param dialogPosition The position of the pop-up context menu dialog spawned by the select control.
     * @returns The rendered exit waypoint select control component, as a VNode.
     */
    renderExitSelectControl(dialogPosition) {
        return (FSComponent.buildComponent(SelectControl, { onRegister: this.register, class: "set-airway-exit-value", ref: this.exitSelectControlRef, dialogPosition: dialogPosition, outerContainer: this.viewContainerRef, nullSelectionText: this.controller.emptyListText, data: this.store.exits, onItemSelected: this.controller.onExitSelected, buildMenuItem: this.controller.buildExitMenuItem, dialogScrollStartIndex: this.controller.entryIndexSubject }));
    }
    /**
     * Renders the load button.
     * @returns the rendered load button, as a VNode.
     */
    renderLoadButton() {
        return (FSComponent.buildComponent(ActionButton, { onRegister: this.register, onExecute: this.onLoadExecuted.bind(this), isVisible: this.controller.canLoad, text: "Load?" }));
    }
}

/**
 * A view which allows the user to select an airway on the MFD.
 */
class MFDSelectAirway extends SelectAirway {
    constructor() {
        super(...arguments);
        this.sequenceListContainerRef = FSComponent.createRef();
        this.buildLegItem = (data, registerFn) => {
            return FSComponent.buildComponent(ProcSequenceItem, { onRegister: registerFn, data: data });
        };
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: 'mfd-dark-background', ref: this.viewContainerRef },
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Entry" }, this.controller.entrySubject),
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Airway" }, this.renderAirwaySelectControl()),
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Exit" }, this.renderExitSelectControl()),
            FSComponent.buildComponent(GroupBox, { onRegister: this.register, title: "Sequence" },
                FSComponent.buildComponent("div", { style: 'height: 160px; overflow:hidden', ref: this.sequenceListContainerRef },
                    FSComponent.buildComponent(List, { onRegister: this.register, data: this.store.sequence, renderItem: this.buildLegItem, scrollContainer: this.sequenceListContainerRef })),
                FSComponent.buildComponent(ScrollBar, null)),
            FSComponent.buildComponent("div", { class: "mfd-slctawy-button" }, this.renderLoadButton())));
    }
}

/**
 * Traffic Advisory System for the G1000.
 */
class TrafficAdvisorySystem extends TCAS {
    constructor() {
        super(...arguments);
        this.operatingModeSetting = TrafficUserSettings.getManager(this.bus).getSetting('trafficOperatingMode');
        this.cdiScalingLabel = CDIScaleLabel.Enroute;
        this.operatingModeChangeTimer = null;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    createSensitivity() {
        return new TASSensitivity();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    init() {
        super.init();
        this.bus.getSubscriber().on('lnavCdiScalingLabel').whenChanged().handle(label => { this.cdiScalingLabel = label; });
        this.bus.getSubscriber().on('trafficOperatingMode').whenChanged().handle((value) => {
            this.operatingModeSub.set(value === TrafficOperatingModeSetting.Operating ? TCASOperatingMode.TAOnly : TCASOperatingMode.Standby);
        });
        this.operatingModeSub.sub(() => this.cancelOperatingModeChange());
        this.bus.getSubscriber().on('on_ground').whenChanged().handle(this.onGroundChanged.bind(this));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    createIntruderEntry(contact) {
        return new TASIntruder(contact);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    updateIntruderAlertLevel(simTime, intruder) {
        intruder.updateAlertLevel(simTime, this.isOwnAirplaneOnGround);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    updateSensitivity() {
        // TODO: Add radar alt data for planes that have it
        this.sensitivity.update(this.ownAirplaneSubs.altitude.get(), this.cdiScalingLabel);
    }
    /**
     * A callback which is called when whether own airplane is on the ground changes.
     * @param isOnGround Whether own airplane is on the ground.
     */
    onGroundChanged(isOnGround) {
        this.cancelOperatingModeChange();
        if (isOnGround) {
            if (this.operatingModeSetting.value === TrafficOperatingModeSetting.Operating) {
                this.scheduleOperatingModeChange(TrafficOperatingModeSetting.Standby, TrafficAdvisorySystem.LANDING_STANDBY_DELAY);
            }
        }
        else {
            if (this.operatingModeSetting.value === TrafficOperatingModeSetting.Standby) {
                this.scheduleOperatingModeChange(TrafficOperatingModeSetting.Operating, TrafficAdvisorySystem.TAKEOFF_OPER_DELAY);
            }
        }
    }
    /**
     * Schedules a delayed operating mode change.
     * @param toMode The target operating mode.
     * @param delay The delay, in milliseconds.
     */
    scheduleOperatingModeChange(toMode, delay) {
        this.cancelOperatingModeChange();
        this.operatingModeChangeTimer = setTimeout(() => {
            this.operatingModeSetting.value = toMode;
            this.operatingModeChangeTimer = null;
        }, delay);
    }
    /**
     * Cancels the currently scheduled operating mode change, if one exists.
     */
    cancelOperatingModeChange() {
        if (this.operatingModeChangeTimer === null) {
            return;
        }
        clearTimeout(this.operatingModeChangeTimer);
        this.operatingModeChangeTimer = null;
    }
}
TrafficAdvisorySystem.TAKEOFF_OPER_DELAY = 8000; // milliseconds
TrafficAdvisorySystem.LANDING_STANDBY_DELAY = 24000; // milliseconds
/**
 * An intruder tracked by the the G1000 TAS.
 */
class TASIntruder extends AbstractTCASIntruder {
    constructor() {
        super(...arguments);
        this.lastHorizontalSep = UnitType.NMILE.createNumber(0);
        this.lastVerticalSep = UnitType.FOOT.createNumber(0);
        this.taOnTime = 0;
        this.taOffTime = 0;
    }
    /**
     * Updates this intruder's assigned alert level.
     * @param simTime The current sim time.
     * @param isOnGround Whether the own airplane is on the ground.
     */
    updateAlertLevel(simTime, isOnGround) {
        if (!this.isPredictionValid) {
            this.alertLevel.set(TCASAlertLevel.None);
        }
        let isTA = false;
        const currentTime = simTime;
        const currentAlertLevel = this.alertLevel.get();
        if (isOnGround) {
            // suppress traffic advisories while own aircraft is on the ground
            if (currentAlertLevel === TCASAlertLevel.TrafficAdvisory) {
                this.taOffTime = currentTime;
            }
        }
        else if (this.tcaNorm <= 1) {
            if (currentAlertLevel !== TCASAlertLevel.TrafficAdvisory) {
                const dt = currentTime - this.taOffTime;
                if (dt >= TASIntruder.TA_ON_HYSTERESIS) {
                    isTA = true;
                    this.taOnTime = currentTime;
                }
            }
            else {
                isTA = true;
            }
        }
        else if (currentAlertLevel === TCASAlertLevel.TrafficAdvisory) {
            const dt = currentTime - this.taOnTime;
            if (dt >= TASIntruder.TA_OFF_HYSTERESIS) {
                this.taOffTime = currentTime;
            }
            else {
                isTA = true;
            }
        }
        if (isTA) {
            this.alertLevel.set(TCASAlertLevel.TrafficAdvisory);
        }
        else {
            this.updateNonTAAlertLevel(simTime);
        }
    }
    /**
     * Updates this intruder's assigned alert level, assuming it does not quality for a traffic advisory.
     * @param simTime The current sim time.
     */
    updateNonTAAlertLevel(simTime) {
        this.predictSeparation(simTime, this.lastHorizontalSep, this.lastVerticalSep);
        if (this.lastHorizontalSep.number <= 6 // 6 nm
            && this.lastVerticalSep.number <= 1200 // 1200 ft
        ) {
            this.alertLevel.set(TCASAlertLevel.ProximityAdvisory);
        }
        else {
            this.alertLevel.set(TCASAlertLevel.None);
        }
    }
}
TASIntruder.TA_ON_HYSTERESIS = 2000; // ms
TASIntruder.TA_OFF_HYSTERESIS = 8000; // ms
/**
 * Sensitivity settings for the the G1000 TAS.
 */
class TASSensitivity extends AbstractTCASSensitivity {
    /**
     * Updates the sensitivity level.
     * @param altitude The indicated altitude of the own airplane.
     * @param cdiScalingLabel The CDI scaling sensitivity of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     */
    update(altitude, cdiScalingLabel, radarAltitude) {
        const altFeet = altitude.asUnit(UnitType.FOOT);
        const radarAltFeet = radarAltitude === null || radarAltitude === void 0 ? void 0 : radarAltitude.asUnit(UnitType.FOOT);
        let isApproach = false;
        switch (cdiScalingLabel) {
            case CDIScaleLabel.LNav:
            case CDIScaleLabel.LNavPlusV:
            case CDIScaleLabel.LNavVNav:
            case CDIScaleLabel.LP:
            case CDIScaleLabel.LPPlusV:
            case CDIScaleLabel.LPV:
            case CDIScaleLabel.MissedApproach:
                isApproach = true;
        }
        let level;
        if ((radarAltFeet === undefined || radarAltFeet > 2350)
            && (!isApproach && cdiScalingLabel !== CDIScaleLabel.Terminal)) {
            if (altFeet > 42000) {
                level = 6;
            }
            else if (altFeet > 20000) {
                level = 5;
            }
            else if (altFeet > 10000) {
                level = 4;
            }
            else if (altFeet > 5000) {
                level = 3;
            }
            else {
                level = 2;
            }
        }
        else if (cdiScalingLabel === CDIScaleLabel.Terminal
            || (radarAltFeet !== undefined && radarAltFeet > 1000)) {
            level = 1;
        }
        else {
            level = 0;
        }
        const parameters = TASSensitivity.LEVELS[level];
        this.lookaheadTime.set(parameters.lookaheadTime);
        this.protectedRadius.set(parameters.protectedRadius);
        this.protectedHeight.set(parameters.protectedHeight);
    }
}
TASSensitivity.LEVELS = [
    {
        lookaheadTime: 20,
        protectedRadius: 0.2,
        protectedHeight: 850
    },
    {
        lookaheadTime: 25,
        protectedRadius: 0.2,
        protectedHeight: 850
    },
    {
        lookaheadTime: 30,
        protectedRadius: 0.35,
        protectedHeight: 850
    },
    {
        lookaheadTime: 40,
        protectedRadius: 0.55,
        protectedHeight: 850
    },
    {
        lookaheadTime: 45,
        protectedRadius: 0.8,
        protectedHeight: 850
    },
    {
        lookaheadTime: 48,
        protectedRadius: 1.1,
        protectedHeight: 850
    },
    {
        lookaheadTime: 48,
        protectedRadius: 1.1,
        protectedHeight: 1200
    }
];

/**
 * Setting modes for backlighting.
 */
var BacklightMode;
(function (BacklightMode) {
    BacklightMode[BacklightMode["Auto"] = 0] = "Auto";
    BacklightMode[BacklightMode["Manual"] = 1] = "Manual";
})(BacklightMode || (BacklightMode = {}));
/**
 * Utility class for retrieving backlight user setting managers.
 */
class BacklightUserSettings {
    /**
     * Retrieves a manager for backlight user settings.
     * @param bus The event bus.
     * @returns a manager for backlight user settings.
     */
    static getManager(bus) {
        var _a;
        return (_a = BacklightUserSettings.INSTANCE) !== null && _a !== void 0 ? _a : (BacklightUserSettings.INSTANCE = new DefaultUserSettingManager(bus, [
            {
                name: 'pfdScreenBacklightMode',
                defaultValue: BacklightMode.Auto
            },
            {
                name: 'pfdScreenBacklightIntensity',
                defaultValue: 100
            },
            {
                name: 'pfdKeyBacklightMode',
                defaultValue: BacklightMode.Auto
            },
            {
                name: 'pfdKeyBacklightIntensity',
                defaultValue: 100
            },
            {
                name: 'mfdScreenBacklightMode',
                defaultValue: BacklightMode.Auto
            },
            {
                name: 'mfdScreenBacklightIntensity',
                defaultValue: 100
            },
            {
                name: 'mfdKeyBacklightMode',
                defaultValue: BacklightMode.Auto
            },
            {
                name: 'mfdKeyBacklightIntensity',
                defaultValue: 100
            },
        ]));
    }
}

/**
 * Manages backlight levels for the PFD and MFD screens and softkeys.
 */
class BacklightManager {
    /**
     * Constructor.
     * @param display The display to manage. Either the PFD or the MFD.
     * @param bus The event bus.
     */
    constructor(display, bus) {
        this.display = display;
        this.simTimeChangeConsumer = null;
        this.simTime = 0;
        this.pposChangeConsumer = null;
        this.ppos = new Float64Array(3);
        this.simTimeHandler = this.onSimTimeChanged.bind(this);
        this.pposHandler = this.onPPosChanged.bind(this);
        this.needRecalcAuto = true;
        this.MODE_SETTING_NAME = `${this.display}ScreenBacklightMode`;
        this.INTENSITY_SETTING_NAME = `${this.display}ScreenBacklightIntensity`;
        this.LVAR_NAME = `L:AS1000_${this.display}_Brightness`;
        this.settingManager = BacklightUserSettings.getManager(bus);
        this.screenIntensitySetting = this.settingManager.getSetting(this.INTENSITY_SETTING_NAME);
        const clockSubscriber = bus.getSubscriber();
        this.simTimeConsumer = clockSubscriber.on('simTime');
        this.pposConsumer = bus.getSubscriber().on('gps-position');
        clockSubscriber.on('realTime').atFrequency(BacklightManager.AUTO_UPDATE_REALTIME_FREQ).handle(this.onUpdate.bind(this));
    }
    /**
     * Initializes this manager. Once this manager is initialized, it will automatically set backlight levels in response
     * to changes in their settings.
     */
    init() {
        // TODO: Support key levels.
        this.settingManager.whenSettingChanged(this.MODE_SETTING_NAME).handle(this.onBacklightModeChanged.bind(this));
        this.settingManager.whenSettingChanged(this.INTENSITY_SETTING_NAME).handle(this.onScreenIntensityChanged.bind(this, this.LVAR_NAME));
    }
    /**
     * A callback which is called when the backlight mode changes.
     * @param mode The new backlight mode.
     */
    onBacklightModeChanged(mode) {
        if (this.simTimeChangeConsumer) {
            this.simTimeChangeConsumer.off(this.simTimeHandler);
            this.simTimeChangeConsumer = null;
        }
        if (this.pposChangeConsumer) {
            this.pposChangeConsumer.off(this.pposHandler);
            this.pposChangeConsumer = null;
        }
        if (mode === BacklightMode.Auto) {
            this.simTimeChangeConsumer = this.simTimeConsumer.whenChangedBy(BacklightManager.AUTO_UPDATE_SIMTIME_THRESHOLD);
            this.simTimeChangeConsumer.handle(this.simTimeHandler);
            this.pposChangeConsumer = this.pposConsumer.atFrequency(BacklightManager.AUTO_UPDATE_REALTIME_FREQ);
            this.pposChangeConsumer.handle(this.pposHandler);
        }
        else {
            this.needRecalcAuto = false;
        }
    }
    /**
     * A callback which is called when the screen intensity value changes.
     * @param simvar The simvar to adjust.
     * @param intensity The new intensity value.
     */
    onScreenIntensityChanged(simvar, intensity) {
        const level = BacklightManager.RESPONSE_MIN + (Math.exp(BacklightManager.RESPONSE_FACTOR * intensity / 100) - 1) * BacklightManager.RESPONSE_SCALE;
        SimVar.SetSimVarValue(simvar, 'number', level);
    }
    /**
     * A callback which is called when the sim time changes.
     * @param time The new sim time.
     */
    onSimTimeChanged(time) {
        this.simTime = time;
        this.needRecalcAuto = true;
    }
    /**
     * A callback which is called when the sim time changes.
     * @param ppos The new plane position.
     */
    onPPosChanged(ppos) {
        const pposVec = GeoPoint.sphericalToCartesian(ppos.lat, ppos.long, BacklightManager.tempVec3);
        if (Vec3Math.dot(pposVec, this.ppos) >= 1 - 1e-4) { // ~600 m
            return;
        }
        Vec3Math.copy(pposVec, this.ppos);
        this.needRecalcAuto = true;
    }
    /**
     * This method runs once per update cycle.
     */
    onUpdate() {
        if (this.needRecalcAuto) {
            this.updateAutoBacklightIntensity();
            this.needRecalcAuto = false;
        }
    }
    /**
     * Updates backlight intensity according to the auto setting algorithm.
     */
    updateAutoBacklightIntensity() {
        const subSolarPoint = BacklightManager.calculateSubSolarPoint(this.simTime, BacklightManager.tempVec3);
        const sinSolarAngle = Vec3Math.dot(this.ppos, subSolarPoint);
        const sinSolarAngleClamped = Utils.Clamp(sinSolarAngle, BacklightManager.AUTO_MIN_SOLAR_ANGLE_SIN, BacklightManager.AUTO_MAX_SOLAR_ANGLE_SIN);
        const intensityFrac = (sinSolarAngleClamped - BacklightManager.AUTO_MIN_SOLAR_ANGLE_SIN) / BacklightManager.AUTO_SOLAR_ANGLE_RANGE_SIN;
        this.screenIntensitySetting.value = Math.round(BacklightManager.AUTO_MIN_INTENSITY + intensityFrac * BacklightManager.AUTO_INTENSITY_RANGE);
    }
    /**
     * Calculates the subsolar point (the point on Earth's surface directly below the Sun, where solar zenith angle = 0)
     * given a specific time.
     * @param time A UNIX timestamp in milliseconds.
     * @param out A Float64Array object to which to write the result.
     * @returns the subsolar point at the specified time.
     */
    static calculateSubSolarPoint(time, out) {
        // Source: Zhang, T et al. https://doi.org/10.1016/j.renene.2021.03.047
        const PI2 = 2 * Math.PI;
        const days = (time - BacklightManager.EPOCH) / BacklightManager.DAY;
        const daysFrac = days - Math.floor(days);
        const L = (4.895055 + 0.01720279 * days);
        const g = (6.240041 + 0.01720197 * days);
        const lambda = L + 0.033423 * Math.sin(g) + 0.000349 * Math.sin(2 * g);
        const epsilon = 0.40910518 - 6.98e-9 * days;
        const rAscension = Math.atan2(Math.cos(epsilon) * Math.sin(lambda), Math.cos(lambda));
        const declination = Math.asin(Math.sin(epsilon) * Math.sin(lambda));
        // equation of time in days.
        const E = (((L - rAscension) % PI2 + 3 * Math.PI) % PI2 - Math.PI) * 0.159155;
        const lat = declination * Avionics.Utils.RAD2DEG;
        const lon = -15 * (daysFrac - 0.5 + E) * 24;
        return GeoPoint.sphericalToCartesian(lat, lon, out);
    }
}
// The following constants control the response of the backlight simvar to the set intensity level.
BacklightManager.RESPONSE_MIN = 0.01; // minimum backlight response
BacklightManager.RESPONSE_MAX = 2; // maximum backlight response
BacklightManager.RESPONSE_FACTOR = 3; // the greater the factor, the steeper the response curve
BacklightManager.RESPONSE_SCALE = (BacklightManager.RESPONSE_MAX - BacklightManager.RESPONSE_MIN) / (Math.exp(BacklightManager.RESPONSE_FACTOR) - 1);
BacklightManager.AUTO_UPDATE_REALTIME_FREQ = 10; // max frequency (Hz) of auto backlight level updates in real time
BacklightManager.AUTO_UPDATE_SIMTIME_THRESHOLD = 60000; // minimum interval (ms) between auto backlight level updates in sim time
BacklightManager.AUTO_MAX_INTENSITY = 100; // The maximum intensity applied by auto backlight.
BacklightManager.AUTO_MIN_INTENSITY = 30; // The minimum intensity applied by auto backlight.
BacklightManager.AUTO_INTENSITY_RANGE = BacklightManager.AUTO_MAX_INTENSITY - BacklightManager.AUTO_MIN_INTENSITY;
BacklightManager.AUTO_MAX_SOLAR_ANGLE = 3; // The solar altitude angle at which auto backlight reaches maximum intensity.
BacklightManager.AUTO_MIN_SOLAR_ANGLE = -8; // The solar altitude angle at which auto backlight reaches minimum intensity.
BacklightManager.AUTO_MAX_SOLAR_ANGLE_SIN = Math.sin(BacklightManager.AUTO_MAX_SOLAR_ANGLE * Avionics.Utils.DEG2RAD);
BacklightManager.AUTO_MIN_SOLAR_ANGLE_SIN = Math.sin(BacklightManager.AUTO_MIN_SOLAR_ANGLE * Avionics.Utils.DEG2RAD);
BacklightManager.AUTO_SOLAR_ANGLE_RANGE_SIN = BacklightManager.AUTO_MAX_SOLAR_ANGLE_SIN - BacklightManager.AUTO_MIN_SOLAR_ANGLE_SIN;
BacklightManager.EPOCH = 946684800000; // Jan 1, 2000 00:00:00 UTC
BacklightManager.DAY = 86400000; // milliseconds in one day
BacklightManager.tempVec3 = new Float64Array(3);

/**
 * The wind overlay options.
 */
var WindOverlaySettingMode;
(function (WindOverlaySettingMode) {
    WindOverlaySettingMode[WindOverlaySettingMode["Off"] = 0] = "Off";
    WindOverlaySettingMode[WindOverlaySettingMode["Opt1"] = 1] = "Opt1";
    WindOverlaySettingMode[WindOverlaySettingMode["Opt2"] = 2] = "Opt2";
    WindOverlaySettingMode[WindOverlaySettingMode["Opt3"] = 3] = "Opt3";
})(WindOverlaySettingMode || (WindOverlaySettingMode = {}));
/**
 * Setting modes for the pfd map layout option.
 */
var PfdMapLayoutSettingMode;
(function (PfdMapLayoutSettingMode) {
    PfdMapLayoutSettingMode[PfdMapLayoutSettingMode["Off"] = 0] = "Off";
    PfdMapLayoutSettingMode[PfdMapLayoutSettingMode["Inset"] = 1] = "Inset";
    PfdMapLayoutSettingMode[PfdMapLayoutSettingMode["HSI"] = 2] = "HSI";
    PfdMapLayoutSettingMode[PfdMapLayoutSettingMode["TFC"] = 3] = "TFC";
})(PfdMapLayoutSettingMode || (PfdMapLayoutSettingMode = {}));
/**
 * Utility class for retrieving PFD user setting managers.
 */
class PFDUserSettings {
    /**
     * Retrieves a manager for map user settings.
     * @param bus The event bus.
     * @returns a manager for map user settings.
     */
    static getManager(bus) {
        var _a;
        return (_a = PFDUserSettings.INSTANCE) !== null && _a !== void 0 ? _a : (PFDUserSettings.INSTANCE = new DefaultUserSettingManager(bus, [
            {
                name: 'windOption',
                defaultValue: WindOverlaySettingMode.Off
            },
            {
                name: 'mapLayout',
                defaultValue: PfdMapLayoutSettingMode.Off
            },
            {
                name: 'svtToggle',
                defaultValue: true
            },
            {
                name: 'baroHpa',
                defaultValue: false
            },
            {
                name: 'svtHdgLabelToggle',
                defaultValue: true
            },
        ]));
    }
}

/**
 * A manager for G1000 settings which are saved to pilot profiles.
 */
class G1000SettingSaveManager extends UserSettingSaveManager {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
        const backlightSettingManager = BacklightUserSettings.getManager(bus);
        const mapSettingManager = MapUserSettings.getManager(bus);
        const pfdSettingManager = PFDUserSettings.getManager(bus);
        const trafficSettingManager = TrafficUserSettings.getManager(bus);
        const settings = [
            ...backlightSettingManager.getAllSettings(),
            ...pfdSettingManager.getAllSettings(),
            ...mapSettingManager.getAllSettings(),
            ...trafficSettingManager.getAllSettings().filter(setting => setting.definition.name !== 'trafficOperatingMode')
        ];
        super(settings, bus);
    }
}

/// <reference types="msfstypes/JS/simvar" />
/** Simvars to publish. */
var FuelComputerSimVars;
(function (FuelComputerSimVars) {
    FuelComputerSimVars["Remaining"] = "L:WT1000_Fuel_GalRemaining";
    FuelComputerSimVars["Burned"] = "L:WT1000_Fuel_GalBurned";
    FuelComputerSimVars["Endurance"] = "L:WT1000_Fuel_Endurance";
    FuelComputerSimVars["Range"] = "L:WT1000_Fuel_Range";
})(FuelComputerSimVars || (FuelComputerSimVars = {}));
/** A publisher to poll fuel-related simvars. */
class FuelSimVarPublisher extends SimVarPublisher {
    /**
     * Create a FuelSimVarPublisher
     * @param bus The EventBus to publish to
     */
    constructor(bus) {
        super(FuelSimVarPublisher.simvars, bus);
    }
}
FuelSimVarPublisher.simvars = new Map([
    ['fuelQty', { name: 'FUEL TOTAL QUANTITY', type: SimVarValueType.GAL }],
    ['fuelFlow1', { name: 'ENG FUEL FLOW GPH:1', type: SimVarValueType.GPH }],
    ['fuelFlow2', { name: 'ENG FUEL FLOW GPH:2', type: SimVarValueType.GPH }],
]);
/** A simple fuel totalizer and related logic. */
class Totalizer {
    constructor() {
        this._fuelCapacity = 0;
        this._fuelRemaining = 0;
        this._fuelBurned = 0;
        this._rawQty = 0;
        this._priorRawQty = 0;
    }
    /**
     * Set the total fuel capacity, but only once.
     * @param capacity The total capacity.
     */
    setCapacity(capacity) {
        if (this._fuelCapacity == 0) {
            this._fuelCapacity = capacity;
        }
    }
    /**
     * Set the amount of fuel remaining.
     * @param value The amount of fuel remaining.
     */
    set fuelRemaining(value) {
        this._fuelRemaining = value;
        SimVar.SetSimVarValue(FuelComputerSimVars.Remaining, 'gallons', value);
    }
    /**
     * Get the amount of fuel remaining.
     * @returns The amount of fuel remaining.
     */
    get fuelRemaining() {
        return this._fuelRemaining;
    }
    /**
     * Set the amount of fuel burned.
     * @param value The amount of fuel burned.
     */
    set fuelBurned(value) {
        this._fuelBurned = value;
        SimVar.SetSimVarValue(FuelComputerSimVars.Burned, 'gallons', value);
    }
    /**
     * Get the amount of fuel burned.
     * @returns The amount of fuel burned.
     */
    get fuelBurned() {
        return this._fuelBurned;
    }
    /**
     * Set the raw quantity present.
     * @param value The quantity present.
     */
    set rawQty(value) {
        if (value < this._priorRawQty) {
            // We would normally expect the raw quantity to decrease.   If it does,
            // assume we're seeing standard fuel burn and update our totals.  If it
            // goes _up_, we'll treat it as a refuel and not add any burn total and
            // it's up to the user to increase the fuel remaining, just like in
            // real life!
            const burned = this._priorRawQty - value;
            this.fuelBurned += burned;
            this.fuelRemaining -= burned;
        }
        this._priorRawQty = value;
    }
    /**
     * Get the current raw quantity.
     * @returns The current raw quantity.
     */
    get rawQty() {
        return this._rawQty;
    }
    /**
     * Handle an adjustment to the fuel remaining value.
     * @param adjustment The adjustment to make.
     */
    adjust(adjustment) {
        switch (adjustment.direction) {
            case 'add':
                this.fuelRemaining += adjustment.amount;
                break;
            case 'remove':
                this.fuelRemaining -= adjustment.amount;
                break;
            case 'set':
                this.fuelRemaining = adjustment.amount;
                break;
        }
        // Always reset the burn total when there's an adjustment.
        this.fuelBurned = 0;
    }
    /**
     * Reset the fuel totalizer.
     * @param flag If true, reset.   (We need to have real noop events.)
     */
    reset(flag) {
        if (flag) {
            this.fuelRemaining = this._fuelCapacity;
            this.fuelBurned = 0;
        }
    }
}
/**
 * An instrument that tracks fuel state for use by the G1000 systems page.
 */
class FuelComputer {
    /**
     * Create a fuel computer.
     * @param bus An event bus
     */
    constructor(bus) {
        this.simVarPublisher = new FuelSimVarPublisher(bus);
        this.simVarPublisher.subscribe('fuelQty');
        this.simVarPublisher.subscribe('fuelFlow1');
        this.simVarPublisher.subscribe('fuelFlow2');
        this.simVarSubscriber = bus.getSubscriber();
        this.controlSubscriber = bus.getSubscriber();
        this.totalizer = new Totalizer();
    }
    /** Intialize the instrument. */
    init() {
        this.simVarPublisher.startPublish();
        this.totalizer.setCapacity(SimVar.GetSimVarValue('FUEL TOTAL CAPACITY', 'gallons') - SimVar.GetSimVarValue('UNUSABLE FUEL TOTAL QUANTITY', 'gallons'));
        this.totalizer.fuelRemaining = SimVar.GetSimVarValue('FUEL TOTAL QUANTITY', 'gallons');
        this.simVarSubscriber.on('fuelQty').whenChangedBy(0.1).handle((qty) => { this.totalizer.rawQty = qty; });
        this.controlSubscriber.on('fuel_adjustment').handle((adjustment) => { this.totalizer.adjust(adjustment); });
        this.controlSubscriber.on('fuel_comp_reset').handle((flag) => { this.totalizer.reset(flag); });
    }
    /**
     * Perform events for the update loop.
     */
    onUpdate() {
        this.simVarPublisher.onUpdate();
    }
}

/**
 * An input that can switch between time and distance.
 */
class TimeDistanceInput extends UiControlGroup {
    constructor() {
        super(...arguments);
        this.distanceSubject = Subject.create(0);
        this.minutesSubject = Subject.create(0);
        this.secondsTensSubject = Subject.create(0);
        this.secondsOnesSubject = Subject.create(0);
        this.distanceInput = FSComponent.createRef();
        this.minutesInput = FSComponent.createRef();
        this.tensInput = FSComponent.createRef();
        this.onesInput = FSComponent.createRef();
        this.minutesGroup = FSComponent.createRef();
        this.distanceGroup = FSComponent.createRef();
        this.isTimeMode = true;
        this.ignoreUpdate = false;
    }
    /** @inheritdoc */
    onAfterRender() {
        this.minutesSubject.sub(() => this.update());
        this.secondsTensSubject.sub(() => this.update());
        this.secondsOnesSubject.sub(() => this.update());
        this.distanceSubject.sub(() => this.update());
        this.props.distanceSubject.sub(v => {
            this.ignoreUpdate = true;
            this.distanceSubject.set(v.asUnit(UnitType.NMILE));
            this.ignoreUpdate = false;
        }, true);
        this.props.timeSubject.sub(v => {
            const minutes = Math.floor(v.asUnit(UnitType.MINUTE));
            const seconds = v.asUnit(UnitType.SECOND) % 60;
            this.ignoreUpdate = true;
            this.minutesSubject.set(minutes);
            this.secondsTensSubject.set(Math.floor(seconds / 10));
            this.secondsOnesSubject.set(seconds % 10);
            this.ignoreUpdate = false;
        }, true);
        this.setMode(true);
    }
    /**
     * Sets the input mode to time or distance.
     * @param isTime True if the input mode should be time, false otherwise.
     */
    setMode(isTime) {
        this.isTimeMode = isTime;
        this.minutesInput.instance.setIsEnabled(isTime);
        this.tensInput.instance.setIsEnabled(isTime);
        this.onesInput.instance.setIsEnabled(isTime);
        this.distanceInput.instance.setIsEnabled(!isTime);
        this.minutesGroup.instance.style.display = isTime ? '' : 'none';
        this.distanceGroup.instance.style.display = isTime ? 'none' : '';
    }
    /**
     * Updates the props subjects.
     */
    update() {
        if (this.ignoreUpdate) {
            return;
        }
        if (this.isTimeMode) {
            const seconds = (this.minutesSubject.get() * 60)
                + (this.secondsTensSubject.get() * 10)
                + this.secondsOnesSubject.get();
            this.props.timeSubject.set(seconds, UnitType.SECOND);
        }
        else {
            this.props.distanceSubject.set(this.distanceSubject.get(), UnitType.NMILE);
        }
    }
    /**
     * Renders the control.
     * @returns The rendered VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: this.props.class },
            FSComponent.buildComponent("div", { ref: this.distanceGroup },
                FSComponent.buildComponent(NumberInput, { ref: this.distanceInput, class: 'time-distance-input-number', minValue: 0, maxValue: 40, increment: 0.1, onRegister: this.register, wrap: true, dataSubject: this.distanceSubject, formatter: (v) => `${v.toFixed(1)}` }),
                FSComponent.buildComponent("span", { class: 'time-distance-input-nm' }, "NM")),
            FSComponent.buildComponent("div", { ref: this.minutesGroup },
                FSComponent.buildComponent(NumberInput, { class: 'time-distance-input-number', ref: this.minutesInput, minValue: 0, maxValue: 9, increment: 1, onRegister: this.register, wrap: true, dataSubject: this.minutesSubject }),
                FSComponent.buildComponent("div", { class: 'time-distance-input-number' }, ":"),
                FSComponent.buildComponent(NumberInput, { class: 'time-distance-input-number', ref: this.tensInput, minValue: 0, maxValue: 5, increment: 1, onRegister: this.register, wrap: true, dataSubject: this.secondsTensSubject }),
                FSComponent.buildComponent(NumberInput, { class: 'time-distance-input-number', ref: this.onesInput, minValue: 0, maxValue: 9, increment: 1, onRegister: this.register, wrap: true, dataSubject: this.secondsOnesSubject }))));
    }
}

/**
 * A controller for the Hold dialog.
 */
class HoldController {
    /**
     * Creates an instance of a HoldController.
     * @param store The hold store to use with this instance.
     * @param fms The FMS to use with this instance.
     */
    constructor(store, fms) {
        this.store = store;
        this.fms = fms;
        store.indexes.sub(i => {
            const plan = this.fms.getFlightPlan();
            const def = plan.getSegment(i.segmentIndex).legs[i.legIndex];
            this.store.fixIcao.set(def.leg.fixIcao);
            try {
                this.fms.facLoader.getFacility(ICAO.getFacilityType(def.leg.fixIcao), def.leg.fixIcao)
                    .then(fac => this.store.waypoint.set(new FacilityWaypoint(fac)));
            }
            catch ( /** Continue */_a) { /** Continue */ }
        }, true);
    }
    /**
     * Resets the hold dialog data.
     */
    reset() {
        this.store.distance.set(4);
        this.store.time.set(60);
        this.store.isInbound.set(0);
        this.store.isTime.set(0);
        this.store.turnDirection.set(1);
        this.store.waypoint.set(null);
        this.store.fixIcao.set('');
    }
    /**
     * Accepts the currently defined hold and adds it to the flight plan.
     */
    accept() {
        const indexes = this.store.indexes.get();
        const isTime = this.store.isTime.get() === 0 ? true : false;
        const leg = FlightPlan.createLeg({
            type: LegType.HM,
            turnDirection: this.store.turnDirection.get() + 1,
            course: this.store.isInbound.get() === 1 ? NavMath.normalizeHeading(this.store.course.get() + 180) : this.store.course.get(),
            distance: isTime ? this.store.time.get().asUnit(UnitType.MINUTE) : this.store.distance.get().asUnit(UnitType.METER),
            distanceMinutes: isTime,
            fixIcao: this.store.fixIcao.get()
        });
        this.fms.addHold(indexes.segmentIndex, indexes.legIndex, leg);
        this.reset();
    }
    /**
     * Gets a hold direction UI string for a given inbound course.
     * @param course The inbound course to get the string for.
     * @returns A UI human readable course string.
     */
    getDirectionString(course) {
        if (course >= 0 && course < 22.5) {
            return 'South';
        }
        else if (course >= 22.5 && course < 67.5) {
            return 'Southwest';
        }
        else if (course >= 67.5 && course < 112.5) {
            return 'West';
        }
        else if (course >= 112.5 && course < 157.5) {
            return 'Northwest';
        }
        else if (course >= 157.5 && course < 202.5) {
            return 'North';
        }
        else if (course >= 202.5 && course < 247.5) {
            return 'Northeast';
        }
        else if (course >= 247.5 && course < 292.5) {
            return 'East';
        }
        else if (course >= 292.5 && course < 337.5) {
            return 'Southeast';
        }
        else {
            return 'South';
        }
    }
}

/**
 * A store for the Hold page data.
 */
class HoldStore {
    constructor() {
        /** The indexes for the hold. */
        this.indexes = Subject.create({ segmentIndex: 0, legIndex: 0 });
        /** The course for the hold. */
        this.course = Subject.create(0);
        /** Whether or not the course is inbound or outbound. */
        this.isInbound = Subject.create(0);
        /** Whether or not the hold is based on time or distance. */
        this.isTime = Subject.create(0);
        /** The time that the hold legs should be. */
        this.time = NumberUnitSubject.createFromNumberUnit(UnitType.SECOND.createNumber(60));
        /** The distance of the hold legs. */
        this.distance = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(4));
        /** The direction of the hold. */
        this.turnDirection = Subject.create(0);
        /** The current leg waypoint. */
        this.waypoint = Subject.create(null);
        this.fixIcao = Subject.create('');
    }
}

/**
 * A class that displays a hold dialog.
 */
class Hold extends UiView {
    /**
     * Creates an instance of PFDHold.
     * @param props The props for this instance.
     */
    constructor(props) {
        super(props);
        this.distanceInput = FSComponent.createRef();
        this.store = new HoldStore();
        this.controller = new HoldController(this.store, props.fms);
        this.controller.reset();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.store.isTime.sub(v => this.distanceInput.instance.setMode(v === 0 ? true : false));
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.CLR:
                this.close();
                return true;
        }
        return super.onInteractionEvent(evt);
    }
    /** @inheritdoc */
    onInputDataSet(input) {
        var _a, _b;
        if (input !== undefined) {
            const def = this.props.fms.getFlightPlan().getSegment(input.segmentIndex).legs[input.legIndex];
            this.store.course.set((_b = (_a = def.calculated) === null || _a === void 0 ? void 0 : _a.initialDtk) !== null && _b !== void 0 ? _b : 0);
            this.store.indexes.set(input);
        }
        else {
            this.controller.reset();
        }
    }
    /**
     * Creates a subscribable which provides a direction string based on the set hold inbound course.
     * @returns A subscribable which provides a direction string based on the set hold inbound course.
     */
    createDirectionStringSubscribable() {
        const courseString = Subject.create('');
        const courseStringHandler = () => {
            const course = this.store.course.get();
            courseString.set(this.controller.getDirectionString(this.store.isInbound.get() === 0 ? course : NavMath.normalizeHeading(course + 180)));
        };
        this.store.course.sub(courseStringHandler);
        this.store.isInbound.sub(courseStringHandler, true);
        return courseString;
    }
}

/**
 * A class that displays the MFD hold dialog.
 */
class MFDHold extends Hold {
    constructor() {
        super(...arguments);
        this.mapRef = FSComponent.createRef();
        this.mapModel = this.createMapModel();
        this.mapRangeIndexSub = Subject.create(WaypointMapRangeTargetRotationController.DEFAULT_MAP_RANGE_INDEX);
    }
    /** @inheritdoc */
    onAfterRender() {
        super.onAfterRender();
        this.mapRef.instance.sleep();
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.RANGE_DEC:
                this.changeMapRangeIndex(-1);
                return true;
            case FmsHEvent.RANGE_INC:
                this.changeMapRangeIndex(1);
                return true;
        }
        return super.onInteractionEvent(evt);
    }
    /** @inheritdoc */
    onViewOpened() {
        super.onViewOpened();
        this.controller.reset();
        this.mapRef.instance.wake();
    }
    /** @inheritdoc */
    onViewClosed() {
        super.onViewClosed();
        this.mapRef.instance.sleep();
        this.mapRangeIndexSub.set(WaypointMapRangeTargetRotationController.DEFAULT_MAP_RANGE_INDEX);
    }
    /**
     * Changes the MFD map range index setting.
     * @param delta The change in index to apply.
     */
    changeMapRangeIndex(delta) {
        const newIndex = Utils.Clamp(this.mapRangeIndexSub.get() + delta, 0, WaypointMapRangeTargetRotationController.DEFAULT_MAP_RANGES.length - 1);
        this.mapRangeIndexSub.set(newIndex);
    }
    /**
     * Creates the model for this component's map.
     * @returns a map model.
     */
    createMapModel() {
        return WaypointMapModel.createModel();
    }
    /**
     * Renders the MFD hold dialog.
     * @returns The rendered VNode.
     */
    render() {
        const icao = this.store.indexes.map(indexes => { var _a; return (_a = this.props.fms.getFlightPlan().getSegment(indexes.segmentIndex).legs[indexes.legIndex].name) !== null && _a !== void 0 ? _a : ''; });
        const directionString = this.createDirectionStringSubscribable();
        return (FSComponent.buildComponent("div", { class: 'popout-dialog mfd-hold', ref: this.viewContainerRef },
            FSComponent.buildComponent("h1", null, this.props.title),
            FSComponent.buildComponent(GroupBox, { title: 'Direction, Course', onRegister: this.register },
                FSComponent.buildComponent("div", { class: 'mfd-hold-gridcontainer' },
                    FSComponent.buildComponent("div", null,
                        "Hold ",
                        FSComponent.buildComponent("span", null, directionString),
                        " of"),
                    FSComponent.buildComponent("div", null, icao),
                    FSComponent.buildComponent("div", null,
                        "Course ",
                        FSComponent.buildComponent(NumberInput, { class: 'mfd-hold-course', minValue: 1, maxValue: 360, wrap: true, dataSubject: this.store.course, increment: 1, onRegister: this.register, formatter: (v) => `${NavMath.normalizeHeading(v).toFixed(0).padStart(3, '0')}°` })),
                    FSComponent.buildComponent("div", null,
                        FSComponent.buildComponent(ArrowToggle, { class: 'mfd-hold-inbound', options: ['Inbound', 'Outbound'], dataref: this.store.isInbound, onRegister: this.register })))),
            FSComponent.buildComponent(GroupBox, { title: 'Leg Time, Distance', onRegister: this.register },
                FSComponent.buildComponent("div", { class: 'mfd-hold-gridcontainer' },
                    FSComponent.buildComponent("div", null,
                        "Leg ",
                        FSComponent.buildComponent(ArrowToggle, { class: 'mfd-hold-time', options: ['Time', 'Distance'], dataref: this.store.isTime, onRegister: this.register })),
                    FSComponent.buildComponent("div", null,
                        FSComponent.buildComponent(TimeDistanceInput, { ref: this.distanceInput, class: 'mfd-hold-distance', timeSubject: this.store.time, distanceSubject: this.store.distance, onRegister: this.register })))),
            FSComponent.buildComponent(GroupBox, { title: 'Turns', onRegister: this.register },
                FSComponent.buildComponent("div", { class: 'mfd-hold-gridcontainer' },
                    FSComponent.buildComponent("div", null, "Turn Direction"),
                    FSComponent.buildComponent("div", null,
                        FSComponent.buildComponent(ArrowToggle, { class: 'mfd-hold-direction', options: ['Left', 'Right'], dataref: this.store.turnDirection, onRegister: this.register })))),
            FSComponent.buildComponent(GroupBox, { title: 'Map', onRegister: this.register, class: 'mfd-hold-map-box' },
                FSComponent.buildComponent(WaypointMapComponent, { ref: this.mapRef, model: this.mapModel, bus: this.props.bus, updateFreq: 4, projectedWidth: 285, projectedHeight: 300, id: 'mfd_wptinfo_map', rangeIndex: this.mapRangeIndexSub, waypoint: this.store.waypoint, ownAirplaneLayerProps: {
                        imageFilePath: 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/own_airplane_icon.svg',
                        iconSize: 40,
                        iconAnchor: new Float64Array([0.5, 0])
                    } })),
            FSComponent.buildComponent(ActionButton, { class: 'mfd-hold-load', text: 'Load?', onExecute: () => { this.controller.accept(); this.close(); }, onRegister: this.register })));
    }
}

/**
 * Dialog used for displaying MFD FPL page menus.
 */
class MFDPageMenuDialog extends ListMenuDialog {
    /** @inheritdoc */
    onInteractionEvent(event) {
        if (event === FmsHEvent.UPPER_PUSH || event === FmsHEvent.MENU || event === FmsHEvent.CLR) {
            this.close();
            return true;
        }
        return false;
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        let className = 'popout-dialog mfd-pagemenu';
        if (this.props.class !== undefined) {
            className += ` ${this.props.class}`;
        }
        return (FSComponent.buildComponent("div", { class: className, ref: this.viewContainerRef },
            FSComponent.buildComponent("h1", null, this.props.title),
            FSComponent.buildComponent(GroupBox, { title: "Options", class: 'mfd-pagemenu-options', containerStyle: 'margin-top: 20px;' },
                FSComponent.buildComponent("div", { class: "mfd-pagemenu-listcontainer", ref: this.listContainerRef },
                    FSComponent.buildComponent(List, { class: 'mfd-pagemenu-list', ref: this.listRef, onRegister: this.register, data: this.menuItemsSubject, renderItem: this.renderItem, scrollContainer: this.listContainerRef }))),
            FSComponent.buildComponent("div", { class: 'mfd-pagemenu-backmessage' }, "Press the FMS CRSR knob to return to base page")));
    }
}

/**
 * A pop-up which allows the user to select the open MFD page.
 */
class MFDPageSelect extends UiView {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.listRef = FSComponent.createRef();
        this.tabRefs = [
            FSComponent.createRef(),
            FSComponent.createRef(),
            FSComponent.createRef(),
            FSComponent.createRef(),
            FSComponent.createRef()
        ];
        this.listItemDefs = MFDPageSelect.PAGE_GROUPS.map(defs => defs.map(this.buildListItemDefinition.bind(this)));
        this.listDataSub = ArraySubject.create();
        this.activeGroupIndex = -1;
        this.lastSelectedIndex = [0, 0, 0, 0, 0];
        this.ignoreSelection = false;
        this.openTimer = null;
        props.upperKnobCanScroll = true;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        this.props.viewService.openPageKey.sub(key => {
            let itemIndex = -1;
            const groupIndex = this.listItemDefs.findIndex(defs => (itemIndex = defs.findIndex(def => def.isEnabled && def.id === key)) >= 0);
            if (groupIndex >= 0) {
                this.setActiveGroup(groupIndex, itemIndex);
            }
        }, true);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.UPPER_PUSH:
            case FmsHEvent.CLR:
                this.close();
                return true;
        }
        return false;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    processScrollEvent(evt) {
        switch (evt) {
            case FmsHEvent.UPPER_INC:
                this.listRef.instance.processHEvent(FmsHEvent.LOWER_INC);
                break;
            case FmsHEvent.UPPER_DEC:
                this.listRef.instance.processHEvent(FmsHEvent.LOWER_DEC);
                break;
            case FmsHEvent.LOWER_INC:
                this.cycleActiveGroup(1);
                break;
            case FmsHEvent.LOWER_DEC:
                this.cycleActiveGroup(-1);
                break;
        }
        this.resetOpenTimer();
        return true;
    }
    /**
     * Cycles through the list of page groups to set the active page group.
     * @param delta The direction in which to cycle through the groups.
     */
    cycleActiveGroup(delta) {
        this.setActiveGroup(Utils.Clamp(this.activeGroupIndex + delta, 0, 4));
    }
    /**
     * Sets the active page group.
     * @param groupIndex The index of the new active group.
     * @param itemIndex The index of the group list item to which to initially scroll. Defaults to 0.
     */
    setActiveGroup(groupIndex, itemIndex) {
        var _a, _b, _c;
        if (groupIndex === this.activeGroupIndex) {
            return;
        }
        this.ignoreSelection = true;
        this.listDataSub.set(this.listItemDefs[groupIndex]);
        this.listRef.instance.scrollToIndex(itemIndex !== null && itemIndex !== void 0 ? itemIndex : this.lastSelectedIndex[groupIndex]);
        this.ignoreSelection = false;
        const index = this.listRef.instance.getSelectedIndex();
        this.onListItemSelected((_a = this.listDataSub.tryGet(index)) !== null && _a !== void 0 ? _a : null, this.listRef.instance.getListItemInstance(index), index);
        (_b = this.tabRefs[this.activeGroupIndex]) === null || _b === void 0 ? void 0 : _b.instance.classList.remove('active-tab');
        (_c = this.tabRefs[groupIndex]) === null || _c === void 0 ? void 0 : _c.instance.classList.add('active-tab');
        this.activeGroupIndex = groupIndex;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewOpened() {
        this.resetOpenTimer();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewClosed() {
        this.clearOpenTimer();
    }
    /**
     * Resets the open timer.
     */
    resetOpenTimer() {
        this.clearOpenTimer();
        this.openTimer = setTimeout(() => {
            this.openTimer = null;
            this.close();
        }, MFDPageSelect.OPEN_TIME);
    }
    /**
     * Clears the open timer.
     */
    clearOpenTimer() {
        if (this.openTimer !== null) {
            clearTimeout(this.openTimer);
            this.openTimer = null;
        }
    }
    /**
     * Builds a MenuItemDefinition from a page list item definition.
     * @param def A page list item definition.
     * @returns A MenuItemDefinition.
     */
    buildListItemDefinition(def) {
        return {
            id: def.key,
            renderContent: () => FSComponent.buildComponent("span", null, def.name),
            isEnabled: def.key !== '',
            action: () => {
                this.props.viewService.open(def.key);
            }
        };
    }
    /**
     * Renders a list item.
     * @param d The item definition.
     * @param registerFn The register function.
     * @returns The rendered list item.
     */
    renderListItem(d, registerFn) {
        return FSComponent.buildComponent(PopoutMenuItem, { onRegister: registerFn, parent: this, def: d });
    }
    /**
     * A callback which is called when a list item is selected.
     * @param d The selected item.
     * @param element The control associated with the selected item.
     * @param index The index of the selected item.
     */
    onListItemSelected(d, element, index) {
        if (this.ignoreSelection || !d) {
            return;
        }
        this.lastSelectedIndex[this.activeGroupIndex] = index;
        if (this.props.viewService.openPageKey.get() === d.id) {
            return;
        }
        this.props.viewService.open(d.id);
        this.props.viewService.open('PageSelect');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent("div", { ref: this.viewContainerRef, class: 'popout-dialog mfd-pageselect' },
            FSComponent.buildComponent(List, { ref: this.listRef, data: this.listDataSub, renderItem: this.renderListItem.bind(this), onItemSelected: this.onListItemSelected.bind(this), class: 'mfd-pageselect-group' }),
            FSComponent.buildComponent("div", { class: 'mfd-pageselect-tabs' },
                FSComponent.buildComponent("div", { ref: this.tabRefs[0] }, "Map"),
                FSComponent.buildComponent("div", { ref: this.tabRefs[1] }, "WPT"),
                FSComponent.buildComponent("div", { ref: this.tabRefs[2] }, "Aux"),
                FSComponent.buildComponent("div", { ref: this.tabRefs[3] }, "FPL"),
                FSComponent.buildComponent("div", { ref: this.tabRefs[4] }, "NRST"))));
    }
}
MFDPageSelect.OPEN_TIME = 3000; // ms
MFDPageSelect.PAGE_GROUPS = [
    [
        { name: 'Navigation Map', key: 'NavMapPage' },
        { name: 'IFR/VFR Charts', key: '' },
        { name: 'Traffic Map', key: 'TrafficPage' },
        { name: 'Weather Data Link', key: '' },
        { name: 'TAWS-B', key: '' }
    ],
    [
        { name: 'Airport Information', key: '' },
        { name: 'Intersection Information', key: '' },
        { name: 'NDB Information', key: '' },
        { name: 'VOR Information', key: '' },
        { name: 'VRP Information', key: '' },
        { name: 'User WPT Information', key: '' }
    ],
    [
        { name: 'Trip Planning', key: '' },
        { name: 'Utility', key: '' },
        { name: 'GPS Status', key: '' },
        { name: 'System Setup', key: '' },
        { name: 'XM Radio', key: '' },
        { name: 'System Status', key: '' },
        { name: 'Connext Setup', key: '' },
        { name: 'Databases', key: '' }
    ],
    [
        { name: 'Active Flight Plan', key: 'FPLPage' },
        { name: 'Flight Plan Catalog', key: '' }
    ],
    [
        { name: 'Nearest Airports', key: '' },
        { name: 'Nearest Intersections', key: '' },
        { name: 'Nearest NDB', key: '' },
        { name: 'Nearest VOR', key: '' },
        { name: 'Nearest VRP', key: '' },
        { name: 'Nearest User WPTs', key: '' },
        { name: 'Nearest Frequencies', key: '' },
        { name: 'Nearest Airspaces', key: '' }
    ]
];

/**
 * Class for creating traffic map models.
 */
class TrafficMapModel {
    /**
     * Creates an instance of a traffic map model.
     * @param tcas A TCAS.
     * @returns a traffic map model instance.
     */
    static createModel(tcas) {
        const model = new MapModel();
        model.addModule('range', new MapIndexedRangeModule());
        model.addModule('orientation', new MapOrientationModule());
        model.addModule('ownAirplaneProps', new MapOwnAirplanePropsModule());
        model.addModule('ownAirplaneIcon', new MapOwnAirplaneIconModule());
        model.addModule('traffic', new MapTrafficModule(tcas));
        return model;
    }
}

/**
 * A map layer which displays inner and outer range rings for traffic maps.
 */
class TrafficMapRangeLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.tickLayerRef = FSComponent.createRef();
        this.innerRangeLayerRef = FSComponent.createRef();
        this.outerRangeLayerRef = FSComponent.createRef();
        this.rangeModule = this.props.model.getModule('range');
        this.trafficModule = this.props.model.getModule('traffic');
        this.innerRangeSub = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(0));
        this.outerRangeSub = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(0));
        this.innerLabel = null;
        this.outerLabel = null;
        this.needUpdateRings = false;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAttached() {
        this.tickLayerRef.instance.onAttached();
        this.innerRangeLayerRef.instance.onAttached();
        this.outerRangeLayerRef.instance.onAttached();
        this.initLabels();
        this.initStyles();
        this.initModuleListeners();
        this.innerRangeSub.sub(() => { this.needUpdateRings = true; });
        this.outerRangeSub.sub(() => { this.needUpdateRings = true; });
        this.needUpdateRings = true;
    }
    /**
     * Initializes the range display labels.
     */
    initLabels() {
        // TODO: Add customizable display unit support.
        this.innerLabel = this.innerRangeLayerRef.instance.createLabel(FSComponent.buildComponent(MapRangeDisplay, { range: this.innerRangeSub, displayUnit: Subject.create(UnitType.NMILE) }));
        this.innerLabel.setAnchor(new Float64Array([0.5, 0.5]));
        this.innerLabel.setRadialAngle(135 * Avionics.Utils.DEG2RAD);
        this.outerLabel = this.outerRangeLayerRef.instance.createLabel(FSComponent.buildComponent(MapRangeDisplay, { range: this.outerRangeSub, displayUnit: Subject.create(UnitType.NMILE) }));
        this.outerLabel.setAnchor(new Float64Array([0.5, 0.5]));
        this.outerLabel.setRadialAngle(135 * Avionics.Utils.DEG2RAD);
    }
    /**
     * Initializes ring styles.
     */
    initStyles() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.tickLayerRef.instance.display.context.fillStyle = this.props.strokeColor;
        this.innerRangeLayerRef.instance.setRingStrokeStyles(this.props.strokeWidth, this.props.strokeColor, this.props.strokeDash);
        this.outerRangeLayerRef.instance.setRingStrokeStyles(this.props.strokeWidth, this.props.strokeColor, this.props.strokeDash);
    }
    /**
     * Initializes modules listeners.
     */
    initModuleListeners() {
        const innerRangeCallback = this.updateInnerRange.bind(this);
        const outerRangeCallback = this.updateOuterRange.bind(this);
        this.rangeModule.nominalRanges.sub(innerRangeCallback);
        this.rangeModule.nominalRanges.sub(outerRangeCallback);
        this.trafficModule.innerRangeIndex.sub(innerRangeCallback);
        this.trafficModule.outerRangeIndex.sub(outerRangeCallback);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.tickLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        this.innerRangeLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        this.outerRangeLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        this.needUpdateRings = BitFlags.isAny(changeFlags, MapProjectionChangeType.TargetProjected | MapProjectionChangeType.ProjectedResolution);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        this.tickLayerRef.instance.onUpdated(time, elapsed);
        if (this.needUpdateRings) {
            this.updateRings();
            this.needUpdateRings = false;
        }
        this.innerRangeLayerRef.instance.onUpdated(time, elapsed);
        this.outerRangeLayerRef.instance.onUpdated(time, elapsed);
    }
    /**
     * Updates the rings.
     */
    updateRings() {
        const center = this.props.mapProjection.getTargetProjected();
        const innerRadius = this.innerRangeSub.get().asUnit(UnitType.GA_RADIAN) / this.props.mapProjection.getProjectedResolution();
        const outerRadius = this.outerRangeSub.get().asUnit(UnitType.GA_RADIAN) / this.props.mapProjection.getProjectedResolution();
        if (innerRadius > 0) {
            this.innerRangeLayerRef.instance.setVisible(true);
            this.innerRangeLayerRef.instance.setRingPosition(center, innerRadius);
        }
        else {
            this.innerRangeLayerRef.instance.setVisible(false);
        }
        if (outerRadius > 0) {
            this.outerRangeLayerRef.instance.setVisible(true);
            this.outerRangeLayerRef.instance.setRingPosition(center, outerRadius);
        }
        else {
            this.outerRangeLayerRef.instance.setVisible(false);
        }
        this.updateTicks(center, innerRadius, outerRadius);
    }
    /**
     * Updates the ring tick marks.
     * @param center The projected center of the rings.
     * @param innerRadius The radius of the inner ring, in pixels.
     * @param outerRadius The radius of the outer ring, in pixels.
     */
    updateTicks(center, innerRadius, outerRadius) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const display = this.tickLayerRef.instance.display;
        display.clear();
        if (innerRadius > 0) {
            this.drawInnerTicks(display.context, center, innerRadius);
        }
        if (outerRadius > 0) {
            this.drawOuterTicks(display.context, center, outerRadius);
        }
    }
    /**
     * Draws the inner ring ticks to a canvas.
     * @param context A canvas 2D rendering context.
     * @param center The projected center of the inner ring.
     * @param radius The radius of the inner ring, in pixels.
     */
    drawInnerTicks(context, center, radius) {
        const step = Math.PI / 2;
        for (let i = 0; i < 4; i++) {
            const pos = Vec2Math.setFromPolar(radius, i * step, TrafficMapRangeLayer.vec2Cache[0]);
            this.drawTick(context, center[0] + pos[0], center[1] + pos[1], this.props.majorTickSize);
        }
    }
    /**
     * Draws the outer ring ticks to a canvas.
     * @param context A canvas 2D rendering context.
     * @param center The projected center of the outer ring.
     * @param radius The radius of the outer ring, in pixels.
     */
    drawOuterTicks(context, center, radius) {
        const step = Math.PI / 6;
        for (let i = 0; i < 12; i++) {
            const pos = Vec2Math.setFromPolar(radius, i * step, TrafficMapRangeLayer.vec2Cache[0]);
            this.drawTick(context, center[0] + pos[0], center[1] + pos[1], i % 3 === 0 ? this.props.majorTickSize : this.props.minorTickSize);
        }
    }
    /**
     * Draws a tick to a canvas.
     * @param context A canvas 2D rendering context.
     * @param x The x-coordinate of the center of the tick.
     * @param y The y-coordinate of the center of the tick.
     * @param size The size of the tick, in pixels.
     */
    drawTick(context, x, y, size) {
        context.fillRect(x - size / 2, y - size / 2, size, size);
    }
    /**
     * Updates the inner ring range.
     */
    updateInnerRange() {
        const range = this.rangeModule.nominalRanges.get()[this.trafficModule.innerRangeIndex.get()];
        this.innerRangeSub.set(range !== null && range !== void 0 ? range : 0);
    }
    /**
     * Updates the outer ring range.
     */
    updateOuterRange() {
        const range = this.rangeModule.nominalRanges.get()[this.trafficModule.outerRangeIndex.get()];
        this.outerRangeSub.set(range !== null && range !== void 0 ? range : 0);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent("div", null,
            FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.tickLayerRef, model: this.props.model, mapProjection: this.props.mapProjection }),
            FSComponent.buildComponent(MapLabeledRingLayer, { ref: this.innerRangeLayerRef, model: this.props.model, mapProjection: this.props.mapProjection }),
            FSComponent.buildComponent(MapLabeledRingLayer, { ref: this.outerRangeLayerRef, model: this.props.model, mapProjection: this.props.mapProjection })));
    }
}
TrafficMapRangeLayer.vec2Cache = [new Float64Array(2)];

/**
 * Displays a traffic system operating mode indication.
 */
class TrafficMapOperatingModeIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.textSub = this.props.operatingMode.map(mode => this.props.text[mode]);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent("div", { class: 'map-traffic-opmode' }, this.textSub));
    }
}

/**
 * Displays a traffic system altitude restriction mode indication.
 */
class TrafficMapAltitudeModeIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.textSub = this.props.altitudeRestrictionMode.map(mode => this.props.text[mode]);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent("div", { class: 'map-traffic-altmode' }, this.textSub));
    }
}

/**
 * Displays a traffic system standby mode banner indicator.
 */
class TrafficMapStandbyBannerIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.rootRef = FSComponent.createRef();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        this.props.operatingMode.sub(mode => {
            this.rootRef.instance.style.display = mode === TCASOperatingMode.Standby ? '' : 'none';
        }, true);
        this.props.isOnGround.sub(isOnGround => {
            isOnGround
                ? this.rootRef.instance.classList.add('map-traffic-standby-onground')
                : this.rootRef.instance.classList.remove('map-traffic-standby-onground');
        }, true);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent("div", { ref: this.rootRef, class: 'map-traffic-standby' }, "STANDBY"));
    }
}

/**
 * A traffic map component.
 */
class TrafficMapComponent extends MapComponent {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.rootRef = FSComponent.createRef();
        this.flightPlanLayerRef = FSComponent.createRef();
        this.textLayerRef = FSComponent.createRef();
        this.rangeLayerRef = FSComponent.createRef();
        this.intruderLayerRef = FSComponent.createRef();
        this.ownAirplaneLayerRef = FSComponent.createRef();
        this.miniCompassLayerRef = FSComponent.createRef();
        this.textManager = new MapCullableTextLabelManager();
        this.waypointRenderer = new MapWaypointRenderer(this.textManager);
        this.trafficSettingManager = TrafficUserSettings.getManager(this.props.bus);
        this.rangeSettingManager = MapRangeSettings.getManager(this.props.bus);
        this.trafficController = new MapTrafficController(this.props.model, TrafficUserSettings.getManager(this.props.bus));
        this.rangeTargetRotationController = this.createRangeTargetRotationController();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        super.onAfterRender();
        this.setRootSize(this.mapProjection.getProjectedSize());
        this.initEventBusHandlers();
        this.rangeTargetRotationController.init();
        this.initControllers();
        this.initLayers();
    }
    /**
     * Sets the size of this map's root HTML element.
     * @param size The new size, in pixels.
     */
    setRootSize(size) {
        this.rootRef.instance.style.width = `${size[0]}px`;
        this.rootRef.instance.style.height = `${size[1]}px`;
    }
    /**
     * Initializes event bus handlers.
     */
    initEventBusHandlers() {
        this.props.model.getModule('ownAirplaneProps').beginSync(this.props.bus, this.props.updateFreq);
    }
    /**
     * Initializes model controllers.
     */
    initControllers() {
        this.trafficController.init();
    }
    /**
     * Initializes this map's layers.
     */
    initLayers() {
        this.attachLayer(this.flightPlanLayerRef.instance);
        this.attachLayer(this.textLayerRef.instance);
        this.attachLayer(this.rangeLayerRef.instance);
        this.attachLayer(this.intruderLayerRef.instance);
        this.attachLayer(this.ownAirplaneLayerRef.instance);
        this.attachLayer(this.miniCompassLayerRef.instance);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onProjectedSizeChanged() {
        this.setRootSize(this.mapProjection.getProjectedSize());
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        this.updateRangeTargetRotationController();
        this.waypointRenderer.update(this.mapProjection);
        super.onUpdated(time, elapsed);
    }
    /**
     * Updates this map's range/target/rotation controller.
     */
    updateRangeTargetRotationController() {
        this.rangeTargetRotationController.update();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { ref: this.rootRef, class: `traffic-map ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}` },
            FSComponent.buildComponent(MapFlightPlanLayer, { ref: this.flightPlanLayerRef, model: this.props.model, mapProjection: this.mapProjection, bus: this.props.bus, dataProvider: new MapActiveFlightPlanDataProvider(this.props.bus, this.props.flightPlanner), drawEntirePlan: Subject.create(false), waypointRenderer: this.waypointRenderer, textManager: this.textManager, inactiveWaypointStyles: this.getFlightPlanLayerInactiveWaypointsStyles(), activeWaypointStyles: this.getFlightPlanLayerActiveWaypointsStyles() }),
            FSComponent.buildComponent(MapCullableTextLayer, { ref: this.textLayerRef, model: this.props.model, mapProjection: this.mapProjection, manager: this.textManager }),
            FSComponent.buildComponent(TrafficMapRangeLayer, { ref: this.rangeLayerRef, model: this.props.model, mapProjection: this.mapProjection, strokeWidth: 2, strokeColor: 'white', strokeDash: [4, 4], majorTickSize: 10, minorTickSize: 5 }),
            FSComponent.buildComponent(MapTrafficIntruderLayer, { ref: this.intruderLayerRef, model: this.props.model, mapProjection: this.mapProjection, bus: this.props.bus, fontSize: this.props.trafficIntruderLayerProps.fontSize, iconSize: this.props.trafficIntruderLayerProps.iconSize, useOuterRangeMaxScale: true }),
            FSComponent.buildComponent(MapOwnAirplaneLayer, { ref: this.ownAirplaneLayerRef, model: this.props.model, mapProjection: this.mapProjection, imageFilePath: this.props.ownAirplaneLayerProps.imageFilePath, iconSize: this.props.ownAirplaneLayerProps.iconSize, iconAnchor: this.props.ownAirplaneLayerProps.iconAnchor }),
            FSComponent.buildComponent(MapMiniCompassLayer, { ref: this.miniCompassLayerRef, class: 'minicompass-layer', model: this.props.model, mapProjection: this.mapProjection, imgSrc: 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/map_mini_compass.png' }),
            FSComponent.buildComponent(MapOrientationIndicator, { orientation: this.props.model.getModule('orientation').orientation, text: {
                    [MapOrientation.NorthUp]: 'NORTH UP',
                    [MapOrientation.TrackUp]: 'TRK UP',
                    [MapOrientation.HeadingUp]: 'HDG UP'
                }, isVisible: Subject.create(true) }),
            this.renderIndicatorGroups(),
            FSComponent.buildComponent(TrafficMapStandbyBannerIndicator, { operatingMode: this.props.model.getModule('traffic').operatingMode, isOnGround: this.props.model.getModule('ownAirplaneProps').isOnGround })));
    }
    /**
     * Gets inactive waypoint styles for the flight plan layer.
     * @returns Inactive waypoint styles for the flight plan layer.
     */
    getFlightPlanLayerInactiveWaypointsStyles() {
        return MapWaypointStyles.getFlightPlanStyles(false, 1, 20);
    }
    /**
     * Gets active waypoint styles for the flight plan layer.
     * @returns Active waypoint styles for the flight plan layer.
     */
    getFlightPlanLayerActiveWaypointsStyles() {
        return MapWaypointStyles.getFlightPlanStyles(true, 2, 21);
    }
    /**
     * Renders this map's indicator groups.
     * @returns An array of this map's indicator groups.
     */
    renderIndicatorGroups() {
        return [
            this.renderTopRightIndicatorGroup()
        ];
    }
    /**
     * Renders the top-right indicator group.
     * @returns The top-right indicator group.
     */
    renderTopRightIndicatorGroup() {
        return (FSComponent.buildComponent("div", { class: 'trafficmap-indicators-top-right' }, this.renderTopRightIndicators()));
    }
    /**
     * Renders indicators in the top-right indicator group.
     * @returns Indicators in the top-right indicator group.
     */
    renderTopRightIndicators() {
        return [
            this.renderOperatingModeIndicator(),
            this.renderAltitudeModeIndicator()
        ];
    }
    /**
     * Renders the traffic system operating mode indicator.
     * @returns The traffic system operating mode indicator.
     */
    renderOperatingModeIndicator() {
        const trafficModule = this.props.model.getModule('traffic');
        return (FSComponent.buildComponent(TrafficMapOperatingModeIndicator, { operatingMode: trafficModule.operatingMode, text: {
                [TCASOperatingMode.Standby]: 'TAS: STANDBY',
                [TCASOperatingMode.TAOnly]: 'TAS: OPERATING',
                [TCASOperatingMode.TA_RA]: 'TAS: OPERATING'
            } }));
    }
    /**
     * Renders the traffic altitude restriction mode indicator.
     * @returns The traffic altitude restriction mode indicator.
     */
    renderAltitudeModeIndicator() {
        const trafficModule = this.props.model.getModule('traffic');
        return (FSComponent.buildComponent(TrafficMapAltitudeModeIndicator, { altitudeRestrictionMode: trafficModule.altitudeRestrictionMode, text: {
                [MapTrafficAltitudeRestrictionMode.Above]: 'ABOVE',
                [MapTrafficAltitudeRestrictionMode.Below]: 'BELOW',
                [MapTrafficAltitudeRestrictionMode.Normal]: 'NORMAL',
                [MapTrafficAltitudeRestrictionMode.Unrestricted]: 'UNRESTRICTED'
            } }));
    }
}
TrafficMapComponent.tempGeoPoint_1 = new GeoPoint(0, 0);
/**
 * A controller for handling map range, target, and rotation changes.
 */
class TrafficMapRangeTargetRotationController {
    /**
     * Creates an instance of a MapRangeController.
     * @param mapModel The map model.
     * @param mapProjection The map projection.
     * @param mapRanges An array of valid map ranges.
     * @param rangeSettingManager This controller's map range settings manager.
     * @param rangeSettingName The name of this controller's map range setting.
     */
    constructor(mapModel, mapProjection, mapRanges, rangeSettingManager, rangeSettingName) {
        this.mapModel = mapModel;
        this.mapProjection = mapProjection;
        this.mapRanges = mapRanges;
        this.rangeSettingManager = rangeSettingManager;
        this.rangeSettingName = rangeSettingName;
        this.innerRangeIndexMap = this.mapRanges.map((range, index, array) => {
            while (--index >= 0) {
                if (array[index].compare(range) < 0) {
                    return index;
                }
            }
            return -1;
        });
        this.currentMapRangeIndex = TrafficMapRangeTargetRotationController.DEFAULT_MAP_RANGE_INDEX;
        this.needUpdate = false;
        this.currentMapParameters = {
            range: 0,
            target: new GeoPoint(0, 0),
            rotation: 0
        };
        this.rangeModule = this.mapModel.getModule('range');
        this.airplanePropsModule = this.mapModel.getModule('ownAirplaneProps');
        this.trafficModule = this.mapModel.getModule('traffic');
        this.rangeSetting = this.rangeSettingManager.getSetting(this.rangeSettingName);
    }
    /**
     * Executes this controller's first-run initialization code.
     */
    init() {
        this.mapModel.getModule('range').nominalRanges.set(this.mapRanges);
        this.updateRangeFromIndex();
        this.mapProjection.addChangeListener(this.onMapProjectionChanged.bind(this));
        this.initSettingsListeners();
        this.initModuleListeners();
        this.initState();
        this.scheduleUpdate();
    }
    /**
     * Initializes settings listeners.
     */
    initSettingsListeners() {
        this.rangeSettingManager.whenSettingChanged(this.rangeSettingName).handle(this.onRangeSettingChanged.bind(this));
    }
    /**
     * Initializes module listeners.
     */
    initModuleListeners() {
        this.airplanePropsModule.position.sub(this.onAirplanePositionChanged.bind(this));
        this.airplanePropsModule.hdgTrue.sub(this.onAirplaneRotationChanged.bind(this));
    }
    /**
     * Initializes this controller's state.
     */
    initState() {
        this.updateTarget();
        this.updateRotation();
    }
    /**
     * Updates the range index.
     */
    updateRangeIndex() {
        const newIndex = Utils.Clamp(this.rangeSetting.value, 0, this.mapRanges.length - 1);
        if (newIndex !== this.currentMapRangeIndex) {
            this.currentMapRangeIndex = newIndex;
            this.updateRangeFromIndex();
            this.scheduleUpdate();
        }
    }
    /**
     * Updates the current range from the current range index.
     */
    updateRangeFromIndex() {
        const nominalRange = this.mapRanges[this.currentMapRangeIndex];
        this.currentMapParameters.range = this.convertToTrueRange(nominalRange);
    }
    /**
     * Updates the map target.
     */
    updateTarget() {
        const ppos = this.airplanePropsModule.position.get();
        this.currentMapParameters.target.set(ppos);
    }
    /**
     * Updates the map rotation.
     */
    updateRotation() {
        this.currentMapParameters.rotation = -this.airplanePropsModule.hdgTrue.get() * Avionics.Utils.DEG2RAD;
    }
    /**
     * A callback which is called when the map projection changes.
     * @param mapProjection The map projection that changed.
     * @param changeFlags The types of changes made to the projection.
     */
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.onProjectedSizeChanged();
        }
    }
    /**
     * A callback which is called when the size of the projected map window changes.
     */
    onProjectedSizeChanged() {
        this.updateRangeFromIndex();
        this.scheduleUpdate();
    }
    /**
     * A callback which is called when the range setting changes.
     */
    onRangeSettingChanged() {
        this.updateRangeIndex();
    }
    /**
     * A callback which is called when the airplane's position changes.
     */
    onAirplanePositionChanged() {
        this.updateTarget();
        this.scheduleUpdate();
    }
    /**
     * A callback which is called when the airplane's heading changes.
     */
    onAirplaneRotationChanged() {
        this.updateRotation();
        this.scheduleUpdate();
    }
    /**
     * Schedules an update.
     */
    scheduleUpdate() {
        this.needUpdate = true;
    }
    /**
     * Updates this controller.
     */
    update() {
        if (!this.needUpdate) {
            return;
        }
        this.updateModules();
        this.updateMapProjection();
        this.needUpdate = false;
    }
    /**
     * Updates map model modules.
     */
    updateModules() {
        this.rangeModule.setNominalRangeIndex(this.currentMapRangeIndex);
        this.trafficModule.outerRangeIndex.set(this.currentMapRangeIndex);
        this.trafficModule.innerRangeIndex.set(this.innerRangeIndexMap[this.currentMapRangeIndex]);
    }
    /**
     * Updates the map projection with the latest range, target, and rotation values.
     */
    updateMapProjection() {
        this.mapProjection.set(this.currentMapParameters);
    }
}
TrafficMapRangeTargetRotationController.DEFAULT_RANGES = [
    ...[
        500,
        500,
        500,
        1000,
        1000,
        1000,
        2000,
        2000
    ].map(value => UnitType.FOOT.createNumber(value)),
    ...[
        1,
        1,
        2,
        2,
        6,
        6,
        12,
        12,
        24,
        24,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40,
        40
    ].map(value => UnitType.NMILE.createNumber(value))
];
TrafficMapRangeTargetRotationController.DEFAULT_MAP_RANGE_INDEX = 11;

/**
 * A MFD traffic map component.
 */
class MFDTrafficMapComponent extends TrafficMapComponent {
    // eslint-disable-next-line jsdoc/require-jsdoc
    createRangeTargetRotationController() {
        return new MFDTrafficMapRangeTargetRotationController(this.props.model, this.mapProjection, TrafficMapRangeTargetRotationController.DEFAULT_RANGES, this.rangeSettingManager, 'mfdMapRangeIndex');
    }
}
/**
 * A controller for handling map range, target, and rotation changes.
 */
class MFDTrafficMapRangeTargetRotationController extends TrafficMapRangeTargetRotationController {
    // eslint-disable-next-line jsdoc/require-jsdoc
    convertToTrueRange(nominalRange) {
        return nominalRange.asUnit(UnitType.GA_RADIAN) / 0.45;
    }
}

/**
 * The MFD traffic map page.
 */
class MFDTrafficMapPage extends MFDUiPage {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.mapRef = FSComponent.createRef();
        this.mapModel = TrafficMapModel.createModel(this.props.tas);
        this.mapRangeSettingManager = MapRangeSettings.getManager(this.props.bus);
        this.mapRangeSetting = this.mapRangeSettingManager.getSetting('mfdMapRangeIndex');
        this.trafficSettingManager = TrafficUserSettings.getManager(this.props.bus);
        this.pageMenuItems = [
            {
                id: 'tas-operate',
                renderContent: () => FSComponent.buildComponent("span", null,
                    "TAS ",
                    this.trafficSettingManager.getSetting('trafficOperatingMode').value === TrafficOperatingModeSetting.Operating ? 'Standby' : 'Operate',
                    " Mode"),
                action: () => { this.trafficSettingManager.getSetting('trafficOperatingMode').value = TrafficOperatingModeSetting.Operating; }
            },
            {
                id: 'test',
                renderContent: () => FSComponent.buildComponent("span", null, "Test Mode"),
                isEnabled: false
            },
            {
                id: 'below',
                renderContent: () => FSComponent.buildComponent("span", null, "Below"),
                action: () => { this.trafficSettingManager.getSetting('trafficAltitudeMode').value = TrafficAltitudeModeSetting.Below; },
                isEnabled: this.trafficSettingManager.getSetting('trafficAltitudeMode').value !== TrafficAltitudeModeSetting.Below
            },
            {
                id: 'normal',
                renderContent: () => FSComponent.buildComponent("span", null, "Normal"),
                action: () => { this.trafficSettingManager.getSetting('trafficAltitudeMode').value = TrafficAltitudeModeSetting.Normal; },
                isEnabled: this.trafficSettingManager.getSetting('trafficAltitudeMode').value !== TrafficAltitudeModeSetting.Normal
            },
            {
                id: 'above',
                renderContent: () => FSComponent.buildComponent("span", null, "Above"),
                action: () => { this.trafficSettingManager.getSetting('trafficAltitudeMode').value = TrafficAltitudeModeSetting.Above; },
                isEnabled: this.trafficSettingManager.getSetting('trafficAltitudeMode').value !== TrafficAltitudeModeSetting.Above
            },
            {
                id: 'unrestricted',
                renderContent: () => FSComponent.buildComponent("span", null, "Unrestricted"),
                action: () => { this.trafficSettingManager.getSetting('trafficAltitudeMode').value = TrafficAltitudeModeSetting.Unrestricted; },
                isEnabled: this.trafficSettingManager.getSetting('trafficAltitudeMode').value !== TrafficAltitudeModeSetting.Unrestricted
            },
        ];
        this._title.set('Map – Traffic Map');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        super.onAfterRender();
        this.mapRef.instance.sleep();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.RANGE_DEC:
                this.changeMapRangeIndex(-1);
                return true;
            case FmsHEvent.RANGE_INC:
                this.changeMapRangeIndex(1);
                return true;
        }
        return super.onInteractionEvent(evt);
    }
    /**
     * Changes the MFD map range index setting.
     * @param delta The change in index to apply.
     */
    changeMapRangeIndex(delta) {
        const ranges = this.mapModel.getModule('range').nominalRanges.get();
        const currentIndex = this.mapRangeSetting.value;
        const currentRange = ranges[currentIndex];
        let index = currentIndex;
        let newIndex = currentIndex;
        if (delta === 1) {
            while (++index < ranges.length) {
                if (!ranges[index].equals(currentRange)) {
                    newIndex = index;
                    break;
                }
            }
        }
        else {
            while (--index >= 0) {
                if (!ranges[index].equals(currentRange)) {
                    newIndex = index;
                    break;
                }
            }
        }
        this.mapRangeSetting.value = newIndex;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewOpened() {
        this.props.menuSystem.clear();
        this.props.menuSystem.pushMenu('traffic-root');
        this.mapRef.instance.wake();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewClosed() {
        super.onViewClosed();
        this.mapRef.instance.sleep();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMenuPressed() {
        this.props.menuSystem.pushMenu('empty');
        const pageMenu = this.props.viewService.open('PageMenuDialog');
        pageMenu.setMenuItems(this.pageMenuItems);
        pageMenu.onClose.on(() => { this.props.menuSystem.back(); });
        return true;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent("div", { ref: this.viewContainerRef, class: 'mfd-page' },
            FSComponent.buildComponent(MFDTrafficMapComponent, { ref: this.mapRef, model: this.mapModel, bus: this.props.bus, updateFreq: MFDTrafficMapPage.UPDATE_FREQ, projectedWidth: 876, projectedHeight: 678, flightPlanner: this.props.flightPlanner, id: 'mfd_trafficmap', ownAirplaneLayerProps: {
                    imageFilePath: 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/own_airplane_icon.svg',
                    iconSize: 40,
                    iconAnchor: new Float64Array([0.5, 0])
                }, trafficIntruderLayerProps: {
                    fontSize: 28,
                    iconSize: 52
                }, class: 'mfd-trafficmap' })));
    }
}
MFDTrafficMapPage.UPDATE_FREQ = 30; // Hz

/**
 * A controller which binds a status bar softkey to a user setting that takes a boolean value. Once bound, each press
 * of the softkey will toggle the value of the setting.
 */
/**
 * A controller which binds one or more status bar softkeys to a user setting. Each softkey is bound to a specific
 * setting value. Once bound, each press of the softkey will set the setting to its bound value.
 */
class MultipleSoftKeyUserSettingController {
    /**
     * Constructor.
     * @param softkeyMenu The softkey menu to which this controller's bound softkeys belong.
     * @param settingManager This controller's setting manager.
     * @param settingName The name of this controller's setting.
     * @param softkeyDefs The definitions for the softkeys bound to this controller's setting.
     */
    constructor(softkeyMenu, settingManager, settingName, softkeyDefs) {
        this.softkeyMenu = softkeyMenu;
        this.settingManager = settingManager;
        this.settingName = settingName;
        this.softkeyDefs = softkeyDefs;
        this.setting = this.settingManager.getSetting(this.settingName);
        this.settingConsumer = null;
        this.settingHandler = (value) => {
            for (let i = 0; i < this.softkeyDefs.length; i++) {
                const def = this.softkeyDefs[i];
                this.softkeyMenu.getItem(def.index).value.set(def.value === value);
            }
        };
        this.isInit = false;
    }
    /**
     * Initializes this controller. This will create softkey menu items and bind them to this controller's setting.
     */
    init() {
        if (this.isInit) {
            return;
        }
        for (let i = 0; i < this.softkeyDefs.length; i++) {
            const def = this.softkeyDefs[i];
            this.softkeyMenu.addItem(def.index, def.label, () => { this.setting.value = def.value; });
        }
        this.settingConsumer = this.settingManager.whenSettingChanged(this.settingName);
        this.settingConsumer.handle(this.settingHandler);
        this.isInit = true;
    }
    /**
     * Destroys this controller. This will remove the softkey menu items bound to this controller's setting.
     */
    destroy() {
        var _a;
        if (!this.isInit) {
            return;
        }
        for (let i = 0; i < this.softkeyDefs.length; i++) {
            const def = this.softkeyDefs[i];
            this.softkeyMenu.removeItem(def.index);
        }
        (_a = this.settingConsumer) === null || _a === void 0 ? void 0 : _a.off(this.settingHandler);
        this.settingConsumer = null;
        this.isInit = false;
    }
}

/**
 * The MFD traffic map page root softkey menu.
 */
class MFDTrafficMapRootMenu extends MFDRootMenu {
    /** @inheritdoc */
    constructor(menuSystem) {
        super(menuSystem);
        this.trafficSettingManager = TrafficUserSettings.getManager(this.menuSystem.bus);
        this.operatingModeController = new MultipleSoftKeyUserSettingController(this, this.trafficSettingManager, 'trafficOperatingMode', [
            { index: 4, label: 'TAS STBY', value: TrafficOperatingModeSetting.Standby },
            { index: 5, label: 'TAS OPER', value: TrafficOperatingModeSetting.Operating }
        ]);
        // TODO: At some point actually add support for ADS-B on/off states in TAS
        this.addItem(2, 'ADS-B', undefined, true);
        this.addItem(6, 'Test', undefined, false);
        this.addItem(9, 'Motion', () => { this.menuSystem.pushMenu('traffic-motion'); });
        this.addItem(10, 'ALT Mode', () => { this.menuSystem.pushMenu('traffic-alt'); });
        this.operatingModeController.init();
    }
}

/**
 * The traffic map altitude restriction mode softkey menu.
 */
class MFDTrafficMapAltitudeMenu extends SoftKeyMenu {
    /** @inheritdoc */
    constructor(menuSystem) {
        super(menuSystem);
        this.trafficSettingManager = TrafficUserSettings.getManager(this.menuSystem.bus);
        this.altitudeModeController = new MultipleSoftKeyUserSettingController(this, this.trafficSettingManager, 'trafficAltitudeMode', [
            { index: 4, label: 'Below', value: TrafficAltitudeModeSetting.Below },
            { index: 5, label: 'Normal', value: TrafficAltitudeModeSetting.Normal },
            { index: 6, label: 'Above', value: TrafficAltitudeModeSetting.Above },
            { index: 7, label: 'UNREST', value: TrafficAltitudeModeSetting.Unrestricted }
        ]);
        this.addItem(10, 'Back', () => { this.menuSystem.back(); });
        this.altitudeModeController.init();
    }
}

/**
 * The traffic map motion vector softkey menu.
 */
class MFDTrafficMapMotionMenu extends SoftKeyMenu {
    /** @inheritdoc */
    constructor(menuSystem) {
        super(menuSystem);
        this.trafficSettingManager = TrafficUserSettings.getManager(this.menuSystem.bus);
        this.motionVectorModeController = new MultipleSoftKeyUserSettingController(this, this.trafficSettingManager, 'trafficMotionVectorMode', [
            { index: 4, label: 'Absolute', value: TrafficMotionVectorModeSetting.Absolute },
            { index: 5, label: 'Relative', value: TrafficMotionVectorModeSetting.Relative },
            { index: 6, label: 'Off', value: TrafficMotionVectorModeSetting.Off },
        ]);
        this.addItem(8, 'Duration', () => { this.menuSystem.pushMenu('traffic-motion-duration'); });
        this.addItem(10, 'Back', () => { this.menuSystem.back(); });
        this.motionVectorModeController.init();
    }
}

/**
 * The traffic map motion vector duration softkey menu.
 */
class MFDTrafficMapMotionDurationMenu extends SoftKeyMenu {
    /** @inheritdoc */
    constructor(menuSystem) {
        super(menuSystem);
        this.trafficSettingManager = TrafficUserSettings.getManager(this.menuSystem.bus);
        this.motionVectorLookaheadController = new MultipleSoftKeyUserSettingController(this, this.trafficSettingManager, 'trafficMotionVectorLookahead', [
            { index: 4, label: '30 SEC', value: 30 },
            { index: 5, label: '1 MIN', value: 60 },
            { index: 6, label: '2 MIN', value: 120 },
            { index: 7, label: '5 MIN', value: 300 },
        ]);
        this.addItem(10, 'Back', () => { this.menuSystem.back(); });
        this.motionVectorLookaheadController.init();
    }
}

const xmlConfig$6 = `
<EngineDisplay override="true">
  <EnginePage>
    <Gauge>
      <Type>Circular</Type>
      <ID>Piston_RPMGauge</ID>
      <Style>
        <TextIncrement>10</TextIncrement>
        <ForceTextColor>white</ForceTextColor>
      </Style>
      <Title></Title>
      <Unit>RPM</Unit>
      <Minimum>0</Minimum>
      <Maximum>3000</Maximum>
      <Value>
        <Simvar name="PROP RPM:1" unit="rpm"/>
      </Value>
      <ColorZone>
        <Color>white</Color>
        <Begin>0</Begin>
        <End>3000</End>
      </ColorZone>
      <ColorZone>
        <Color>green</Color>
        <Begin>2100</Begin>
        <End>
          <StateMachine>
            <State id="LowAlt" value="2500">
              <Transition to="MedAlt">
                <Greater>
                  <Simvar name="INDICATED ALTITUDE" unit="feet"/>
                  <Constant>5300</Constant>
                </Greater>
              </Transition>
            </State>
            <State id="MedAlt" value="2600">
              <Transition to="LowAlt">
                <Lower>
                  <Simvar name="INDICATED ALTITUDE" unit="feet"/>
                  <Constant>4700</Constant>
                </Lower>
              </Transition>
              <Transition to="HighAlt">
                <Greater>
                  <Simvar name="INDICATED ALTITUDE" unit="feet"/>
                  <Constant>10300</Constant>
                </Greater>
              </Transition>
            </State>
            <State id="HighAlt" value="2700">
              <Transition to="MedAlt">
                <Lower>
                  <Simvar name="INDICATED ALTITUDE" unit="feet"/>
                  <Constant>9700</Constant>
                </Lower>
              </Transition>
            </State>
          </StateMachine>
        </End>
      </ColorZone>
      <ColorZone>
        <Color>red</Color>
        <Begin>2700</Begin>
        <End>3000</End>
      </ColorZone>
      <RedBlink>
        <Greater>
          <Simvar name="PROP RPM:1" unit="rpm"/>
          <Constant>2700</Constant>
        </Greater>
      </RedBlink>
    </Gauge>

    <Gauge>
      <Type>Horizontal</Type>
      <ID>Piston_FFlowGauge</ID>
      <Title>FFLOW</Title>
      <Unit>GPH</Unit>
      <Minimum>0</Minimum>
      <Maximum>20</Maximum>
      <Value>
        <Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
      </Value>
      <ColorZone>
        <Color>green</Color>
        <Begin>0</Begin>
        <End>12</End>
      </ColorZone>
      <GraduationLength>2</GraduationLength>
      <GraduationTextLength>20</GraduationTextLength>
    </Gauge>

    <Gauge>
      <Type>Horizontal</Type>
      <ID>Piston_OilPressGauge</ID>
      <Title>Oil PRES</Title>
      <Unit></Unit>
      <Minimum>0</Minimum>
      <Maximum>120</Maximum>
      <Value>
        <Simvar name="GENERAL ENG OIL PRESSURE:1" unit="psi"/>
      </Value>
      <ColorZone>
        <Color>red</Color>
        <Begin>0</Begin>
        <End>20</End>
      </ColorZone>
      <ColorZone>
        <Color>green</Color>
        <Begin>50</Begin>
        <End>90</End>
      </ColorZone>
      <ColorZone>
        <Color>red</Color>
        <Begin>115</Begin>
        <End>120</End>
      </ColorZone>
      <BeginText></BeginText>
      <EndText></EndText>
      <RedBlink>
        <Or>
          <Greater>
            <Simvar name="GENERAL ENG OIL PRESSURE:1" unit="psi"/>
            <Constant>115</Constant>
          </Greater>
          <Lower>
            <Simvar name="GENERAL ENG OIL PRESSURE:1" unit="psi"/>
            <Constant>20</Constant>
          </Lower>
        </Or>
      </RedBlink>
    </Gauge>

    <Gauge>
      <Type>Horizontal</Type>
      <ID>Piston_OilTempGauge</ID>
      <Title>Oil TEMP</Title>
      <Unit></Unit>
      <Minimum>75</Minimum>
      <Maximum>250</Maximum>
      <Value>
        <Simvar name="GENERAL ENG OIL TEMPERATURE:1" unit="farenheit"/>
      </Value>
      <ColorZone>
        <Color>green</Color>
        <Begin>100</Begin>
        <End>245</End>
      </ColorZone>
      <ColorZone>
        <Color>red</Color>
        <Begin>245</Begin>
        <End>250</End>
      </ColorZone>
      <BeginText></BeginText>
      <EndText></EndText>
      <RedBlink>
        <Greater>
          <Simvar name="GENERAL ENG OIL TEMPERATURE:1" unit="farenheit"/>
          <Constant>245</Constant>
        </Greater>
      </RedBlink>
    </Gauge>

    <Gauge>
      <Type>Horizontal</Type>
      <ID>Piston_EgtGauge</ID>
      <Title>EGT</Title>
      <Unit></Unit>
      <Minimum>1250</Minimum>
      <Maximum>1650</Maximum>
      <Value>
        <Simvar name="GENERAL ENG EXHAUST GAS TEMPERATURE:1" unit="farenheit"/>
      </Value>
      <GraduationLength>50</GraduationLength>
      <BeginText></BeginText>
      <EndText></EndText>
      <CursorText>1</CursorText>
    </Gauge>

    <Gauge>
      <Type>Horizontal</Type>
      <ID>Piston_VacGauge</ID>
      <Title>VAC</Title>
      <Unit></Unit>
      <Minimum>3</Minimum>
      <Maximum>7</Maximum>
      <Value>
        <Simvar name="SUCTION PRESSURE" unit="inch of mercury"/>
      </Value>
      <ColorZone>
        <Color>green</Color>
        <Begin>4.5</Begin>
        <End>5.5</End>
      </ColorZone>
      <BeginText></BeginText>
      <EndText></EndText>
    </Gauge>

    <Gauge>
      <Type>DoubleHorizontal</Type>
      <ID>Piston_FuelGauge</ID>
      <Title>FUEL QTY</Title>
      <Unit>GAL</Unit>
      <CursorText>R</CursorText>
      <CursorText2>L</CursorText2>
      <Minimum>0</Minimum>
      <Maximum>30</Maximum>
      <Value>
        <Simvar name="FUEL RIGHT QUANTITY" unit="gallons"/>
      </Value>
      <Value2>
        <Simvar name="FUEL LEFT QUANTITY" unit="gallons"/>
      </Value2>
      <ColorZone>
        <Color>red</Color>
        <Begin>0</Begin>
        <End>1.5</End>
      </ColorZone>
      <ColorZone>
        <Color>yellow</Color>
        <Begin>1.5</Begin>
        <End>5</End>
      </ColorZone>
      <ColorZone>
        <Color>green</Color>
        <Begin>5</Begin>
        <End>24</End>
      </ColorZone>
      <GraduationLength text="True">10</GraduationLength>
      <EndText>F</EndText>
    </Gauge>

    <Text>
      <Style>
        <Margins>
          <Top>20</Top>
          <Bottom>20</Bottom>
        </Margins>
      </Style>
      <Left>ENG HRS</Left>
      <Right id="Piston_EngineHours">
        <ToFixed precision="1">
          <Simvar name="GENERAL ENG ELAPSED TIME:1" unit="hour"/>
        </ToFixed>
      </Right>
    </Text>

    <Text>
      <Left>--------</Left>
      <Center>Electrical</Center>
      <Right>--------</Right>
    </Text>

    <Text>
      <Left>M</Left>
      <Center fontsize="8">Bus</Center>
      <Right>E</Right>
    </Text>

    <Text>
      <Left id="Piston_Bus_M">
        <ToFixed precision="1">
          <Simvar name="ELECTRICAL MAIN BUS VOLTAGE:3" unit="volts"/>
        </ToFixed>
      </Left>
      <Center fontsize="8">Volts</Center>
      <Right id="Piston_Bus_E">
        <ToFixed precision="1">
          <Simvar name="ELECTRICAL MAIN BUS VOLTAGE:6" unit="volts"/>
        </ToFixed>
      </Right>
    </Text>

    <Text>
      <Left>M</Left>
      <Center fontsize="8">Battery</Center>
      <Right>S</Right>
    </Text>

    <Text>
      <Left id="Piston_Batt_M">
        <ToFixed precision="0">
          <Substract>
            <Constant>0</Constant>
            <Simvar name="ELECTRICAL BATTERY LOAD:1" unit="amperes"/>
          </Substract>
        </ToFixed>
      </Left>
      <Center fontsize="8">Amps</Center>
      <Right id="Piston_Batt_S">
        <ToFixed precision="0">
          <Substract>
            <Constant>0</Constant>
            <Simvar name="ELECTRICAL BATTERY LOAD:2" unit="amperes"/>
          </Substract>
        </ToFixed>
      </Right>
    </Text>
  </EnginePage>

  <LeanPage>
    <Gauge>
      <Type>Circular</Type>
      <ID>Piston_RPMGauge</ID>
      <Style>
        <TextIncrement>10</TextIncrement>
        <ForceTextColor>white</ForceTextColor>
      </Style>
      <Title></Title>
      <Unit>RPM</Unit>
      <Minimum>0</Minimum>
      <Maximum>3000</Maximum>
      <Value>
        <Simvar name="PROP RPM:1" unit="rpm"/>
      </Value>
      <ColorZone>
        <Color>white</Color>
        <Begin>0</Begin>
        <End>3000</End>
      </ColorZone>
      <ColorZone>
        <Color>green</Color>
        <Begin>2100</Begin>
        <End>
          <StateMachine>
            <State id="LowAlt" value="2500">
              <Transition to="MedAlt">
                <Greater>
                  <Simvar name="INDICATED ALTITUDE" unit="feet"/>
                  <Constant>5300</Constant>
                </Greater>
              </Transition>
            </State>
            <State id="MedAlt" value="2600">
              <Transition to="LowAlt">
                <Lower>
                  <Simvar name="INDICATED ALTITUDE" unit="feet"/>
                  <Constant>4700</Constant>
                </Lower>
              </Transition>
              <Transition to="HighAlt">
                <Greater>
                  <Simvar name="INDICATED ALTITUDE" unit="feet"/>
                  <Constant>10300</Constant>
                </Greater>
              </Transition>
            </State>
            <State id="HighAlt" value="2700">
              <Transition to="MedAlt">
                <Lower>
                  <Simvar name="INDICATED ALTITUDE" unit="feet"/>
                  <Constant>9700</Constant>
                </Lower>
              </Transition>
            </State>
          </StateMachine>
        </End>
      </ColorZone>
      <ColorZone>
        <Color>red</Color>
        <Begin>2700</Begin>
        <End>3000</End>
      </ColorZone>
      <RedBlink>
        <Greater>
          <Simvar name="PROP RPM:1" unit="rpm"/>
          <Constant>2700</Constant>
        </Greater>
      </RedBlink>
    </Gauge>

    <Gauge>
      <Type>Cylinder</Type>
      <ID>EGT_Gauge</ID>
      <Title>EGT</Title>
      <Unit>°F</Unit>
      <Rows>13</Rows>
      <Columns>4</Columns>
      <Minimum>1300</Minimum>
      <Maximum>1600</Maximum>
      <TempOrder>4,2,1,3</TempOrder>
      <Value>
        <Simvar name="GENERAL ENG EXHAUST GAS TEMPERATURE:1" unit="farenheit"/>
      </Value>
      <Style>
        <ShowPeak>True</ShowPeak>
        <TextIncrement>5</TextIncrement>
      </Style>
    </Gauge>

    <Gauge>
      <Type>Cylinder</Type>
      <ID>CHT_Gauge</ID>
      <Title>CHT</Title>
      <Unit>°F</Unit>
      <Rows>13</Rows>
      <Columns>4</Columns>
      <Minimum>200</Minimum>
      <Maximum>500</Maximum>
      <TempOrder>4,2,1,3</TempOrder>
      <Value>
        <Simvar name="ENG CYLINDER HEAD TEMPERATURE:1" unit="farenheit"/>
      </Value>
      <Style>
        <ShowRedline>True</ShowRedline>
        <TextIncrement>5</TextIncrement>
      </Style>
    </Gauge>

    <Text>
      <Left fontsize="10">FFLOW GPH</Left>
      <Right fontsize="10">
        <ToFixed precision="1">
          <Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
        </ToFixed>
      </Right>
    </Text>

    <Gauge>
      <Style>
        <Margins>
          <Top>20</Top>
        </Margins>
      </Style>
      <Type>DoubleHorizontal</Type>
      <ID>Piston_FuelGauge</ID>
      <Title>Fuel QTY</Title>
      <Unit>GAL</Unit>
      <CursorText>R</CursorText>
      <CursorText2>L</CursorText2>
      <Minimum>0</Minimum>
      <Maximum>30</Maximum>
      <Value>
        <Simvar name="FUEL RIGHT QUANTITY" unit="gallons"/>
      </Value>
      <Value2>
        <Simvar name="FUEL LEFT QUANTITY" unit="gallons"/>
      </Value2>
      <ColorZone>
        <Color>red</Color>
        <Begin>0</Begin>
        <End>1.5</End>
      </ColorZone>
      <ColorZone>
        <Color>yellow</Color>
        <Begin>1.5</Begin>
        <End>5</End>
      </ColorZone>
      <ColorZone>
        <Color>green</Color>
        <Begin>5</Begin>
        <End>24</End>
      </ColorZone>
      <GraduationLength text="True">10</GraduationLength>
      <EndText>F</EndText>
    </Gauge>
  </LeanPage>

  <SystemPage>
    <Gauge>
      <Type>Circular</Type>
      <ID>Piston_RPMGauge</ID>
      <Style>
        <TextIncrement>10</TextIncrement>
        <ForceTextColor>white</ForceTextColor>
      </Style>
      <Title></Title>
      <Unit>RPM</Unit>
      <Minimum>0</Minimum>
      <Maximum>3000</Maximum>
      <Value>
        <Simvar name="PROP RPM:1" unit="rpm"/>
      </Value>
      <ColorZone>
        <Color>white</Color>
        <Begin>0</Begin>
        <End>3000</End>
      </ColorZone>
      <ColorZone>
        <Color>green</Color>
        <Begin>2100</Begin>
        <End>
          <StateMachine>
            <State id="LowAlt" value="2500">
              <Transition to="MedAlt">
                <Greater>
                  <Simvar name="INDICATED ALTITUDE" unit="feet"/>
                  <Constant>5300</Constant>
                </Greater>
              </Transition>
            </State>
            <State id="MedAlt" value="2600">
              <Transition to="LowAlt">
                <Lower>
                  <Simvar name="INDICATED ALTITUDE" unit="feet"/>
                  <Constant>4700</Constant>
                </Lower>
              </Transition>
              <Transition to="HighAlt">
                <Greater>
                  <Simvar name="INDICATED ALTITUDE" unit="feet"/>
                  <Constant>10300</Constant>
                </Greater>
              </Transition>
            </State>
            <State id="HighAlt" value="2700">
              <Transition to="MedAlt">
                <Lower>
                  <Simvar name="INDICATED ALTITUDE" unit="feet"/>
                  <Constant>9700</Constant>
                </Lower>
              </Transition>
            </State>
          </StateMachine>
        </End>
      </ColorZone>
      <ColorZone>
        <Color>red</Color>
        <Begin>2700</Begin>
        <End>3000</End>
      </ColorZone>
      <RedBlink>
        <Greater>
          <Simvar name="PROP RPM:1" unit="rpm"/>
          <Constant>2700</Constant>
        </Greater>
      </RedBlink>
    </Gauge>

    <Text>
      <Left fontsize="10">OIL PSI</Left>
      <Right fontsize="10">
        <ToFixed precision="1">
          <Simvar name="GENERAL ENG OIL PRESSURE:1" unit="psi"/>
        </ToFixed>
      </Right>
    </Text>

    <Text>
      <Left fontsize="10">OIL °F</Left>
      <Right fontsize="10">
        <ToFixed precision="0">
          <Simvar name="GENERAL ENG OIL TEMPERATURE:1" unit="farenheit"/>
        </ToFixed>
      </Right>
    </Text>

    <Text>
      <Style>
        <Margins>
          <Top>30</Top>
        </Margins>
      </Style>
      <Left>-------</Left>
      <Center>Fuel Calc</Center>
      <Right>-------</Right>
    </Text>

    <Text>
      <Left fontsize="10">FFLOW GPH</Left>
      <Right fontsize="10">
        <ToFixed precision="1">
          <Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
        </ToFixed>
      </Right>
    </Text>

    <Text>
      <Left fontsize="10">GAL Used</Left>
      <Right fontsize="10">
        <ToFixed precision="1">
          <Simvar name="L:WT1000_Fuel_GalBurned" unit="gallon"/>
        </ToFixed>
      </Right>
    </Text>

    <Text>
      <Left fontsize="10">GAL REM</Left>
      <Right fontsize="10">
        <ToFixed precision="1">
          <Simvar name="L:WT1000_Fuel_GalRemaining" unit="gallon"/>
        </ToFixed>
      </Right>
    </Text>

    <Gauge>
      <Style>
        <Margins>
          <Top>20</Top>
        </Margins>
      </Style>
      <Type>DoubleHorizontal</Type>
      <ID>Piston_FuelGauge</ID>
      <Title>Fuel QTY</Title>
      <Unit>GAL</Unit>
      <CursorText>R</CursorText>
      <CursorText2>L</CursorText2>
      <Minimum>0</Minimum>
      <Maximum>30</Maximum>
      <Value>
        <Simvar name="FUEL RIGHT QUANTITY" unit="gallons"/>
      </Value>
      <Value2>
        <Simvar name="FUEL LEFT QUANTITY" unit="gallons"/>
      </Value2>
      <ColorZone>
        <Color>red</Color>
        <Begin>0</Begin>
        <End>1.5</End>
      </ColorZone>
      <ColorZone>
        <Color>yellow</Color>
        <Begin>1.5</Begin>
        <End>5</End>
      </ColorZone>
      <ColorZone>
        <Color>green</Color>
        <Begin>5</Begin>
        <End>24</End>
      </ColorZone>
      <GraduationLength text="True">10</GraduationLength>
      <EndText>F</EndText>
    </Gauge>

    <Text>
      <Style>
        <Margins>
          <Top>30</Top>
        </Margins>
      </Style>
      <Left>--------</Left>
      <Center>Electrical</Center>
      <Right>--------</Right>
    </Text>

    <Text>
      <Left>M</Left>
      <Center fontsize="8">Bus</Center>
      <Right>E</Right>
    </Text>

    <Text>
      <Left id="Piston_Bus_M">
        <ToFixed precision="1">
          <Simvar name="ELECTRICAL MAIN BUS VOLTAGE:3" unit="volts"/>
        </ToFixed>
      </Left>
      <Center fontsize="8">Volts</Center>
      <Right id="Piston_Bus_E">
        <ToFixed precision="1">
          <Simvar name="ELECTRICAL MAIN BUS VOLTAGE:6" unit="volts"/>
        </ToFixed>
      </Right>
    </Text>

    <Text>
      <Left>M</Left>
      <Center fontsize="8">Battery</Center>
      <Right>S</Right>
    </Text>

    <Text>
      <Left id="Piston_Batt_M">
        <ToFixed precision="0">
          <Substract>
            <Constant>0</Constant>
            <Simvar name="ELECTRICAL BATTERY LOAD:1" unit="amperes"/>
          </Substract>
        </ToFixed>
      </Left>
      <Center fontsize="8">Amps</Center>
      <Right id="Piston_Batt_S">
        <ToFixed precision="0">
          <Substract>
            <Constant>0</Constant>
            <Simvar name="ELECTRICAL BATTERY LOAD:2" unit="amperes"/>
          </Substract>
        </ToFixed>
      </Right>
    </Text>
  </SystemPage>
</EngineDisplay>
`;

const xmlConfig$5 = `
<EngineDisplay>
	<EnginePage>
		<Gauge>
			<Type>Circular</Type>
			<Style>
				<BeginAngle>-50</BeginAngle>
				<EndAngle>190</EndAngle>
				<ValuePos>End</ValuePos>
				<CursorType>Triangle</CursorType>
				<SizePercent>90</SizePercent>
			</Style>
			<BeginText></BeginText>
			<EndText></EndText>
			<ID>Turbo_TorqueGauge</ID>
			<Title>FT-LB</Title>
			<Unit>x100</Unit>
			<Minimum>0</Minimum>
			<Maximum>3000</Maximum>
			<Value>
				<Simvar name="TURB ENG FREE TURBINE TORQUE:1" unit="Foot pounds"/>
			</Value>
			<ColorZone>
				<Color>green</Color>
				<Begin>0</Begin>
				<End>2397</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>2397</Begin>
				<End>2450</End>
			</ColorZone>
			<GraduationLength>100</GraduationLength>
			<GraduationTextLength>500</GraduationTextLength>
			<RedBlink>
				<Greater>
					<Simvar name="ENG TORQUE:1" unit="Foot pounds"/>
					<Constant>2400</Constant>
				</Greater>
			</RedBlink>
		</Gauge>

		<Gauge>
			<Type>Circular</Type>
			<Style>
				<BeginAngle>-10</BeginAngle>
				<EndAngle>160</EndAngle>
				<CursorType>Triangle</CursorType>
				<ValuePos>End</ValuePos>
				<SizePercent>90</SizePercent>
			</Style>
			<BeginText></BeginText>
			<EndText></EndText>
			<ID>Turbo_IttGauge</ID>
			<Title>ITT</Title>
			<Unit>°C</Unit>
			<Minimum>0</Minimum>
			<Maximum>
				<StateMachine>
					<State id="Start" value="1100">
						<Transition to="Normal">
							<Greater>
								<Simvar name="TURB ENG N1:1" unit="percent"/>
								<Constant>52</Constant>
							</Greater>
						</Transition>
					</State>
					<State id="Normal" value="950">
						<Transition to="Start">
							<Lower>
								<Simvar name="TURB ENG N1:1" unit="percent"/>
								<Constant>10</Constant>
							</Lower>
						</Transition>
					</State>
				</StateMachine>
			</Maximum>
			<Value>
				<Simvar name="TURB ENG1 ITT" unit="celsius"/>
			</Value>
			<ColorZone>
				<Color>green</Color>
				<Begin>100</Begin>
				<End>805</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>805</Begin>
				<End>825</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>825</Begin>
				<End>850</End>
			</ColorZone>
			<ColorLine>
				<Color>red</Color>
				<Position>
					<StateMachine>
						<State id="Start" value="1090">
							<Transition to="Normal">
								<Greater>
									<Simvar name="TURB ENG N1:1" unit="percent"/>
									<Constant>52</Constant>
								</Greater>
							</Transition>
						</State>
						<State id="Normal" value="850">
							<Transition to="Start">
								<Lower>
									<Simvar name="TURB ENG N1:1" unit="percent"/>
									<Constant>10</Constant>
								</Lower>
							</Transition>
						</State>
					</StateMachine>
				</Position>
			</ColorLine>

			<RedBlink>
				<Greater>
					<Simvar name="TURB ENG1 ITT" unit="celsius"/>
					<StateMachine>
						<State id="Start" value="1090">
							<Transition to="Normal">
								<Greater>
									<Simvar name="TURB ENG N1:1" unit="percent"/>
									<Constant>52</Constant>
								</Greater>
							</Transition>
						</State>
						<State id="Normal" value="850">
							<Transition to="Start">
								<Lower>
									<Simvar name="TURB ENG N1:1" unit="percent"/>
									<Constant>10</Constant>
								</Lower>
							</Transition>
						</State>
					</StateMachine>
				</Greater>
			</RedBlink>
			<GraduationLength>50</GraduationLength>
		</Gauge>

		<Gauge>
			<Type>Circular</Type>
			<Style>
				<BeginAngle>-10</BeginAngle>
				<EndAngle>160</EndAngle>
				<CursorType>Triangle</CursorType>
				<ValuePos>End</ValuePos>
				<SizePercent>90</SizePercent>
			</Style>
			<BeginText></BeginText>
			<EndText></EndText>
			<ID>Turbo_NgGauge</ID>
			<Title>NG</Title>
			<Unit>% RPM</Unit>
			<Minimum>10</Minimum>
			<Maximum>110</Maximum>
			<Value>
				<Simvar name="TURB ENG N2:1" unit="percent"/>
			</Value>
			<ColorZone>
				<Color>green</Color>
				<Begin>51</Begin>
				<End>101.6</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>101.6</Begin>
				<End>104</End>
			</ColorZone>
			<GraduationLength>10</GraduationLength>
			<RedBlink>
				<Greater>
					<Simvar name="TURB ENG N2:1" unit="percent"/>
					<Constant>101.6</Constant>
				</Greater>
			</RedBlink>
		</Gauge>

		<Text>
			<Style>
				<Margins>
					<Top>20</Top>
				</Margins>
			</Style>
			<Center>---------------------------------</Center>
		</Text>

		<Text>
			<Style>
				<Margins>
					<Bottom>10</Bottom>
				</Margins>
			</Style>
			<Left>Prop RPM</Left>
			<Right id="Turbo_RPMGauge">
				<Content>
					<ToFixed precision="0">
						<Simvar name="PROP RPM:1" unit="rpm"/>
					</ToFixed>
				</Content>
				<Color>
					<If>
						<Condition>
							<Greater>
								<Simvar name="PROP RPM:1" unit="rpm"/>
								<Constant>1600</Constant>
							</Greater>
						</Condition>
						<Then>
							<If>
								<Condition>
									<Greater>
										<Simvar name="PROP RPM:1" unit="rpm"/>
										<Constant>1900</Constant>
									</Greater>
								</Condition>
								<Then>
									<Constant>red</Constant>
								</Then>
								<Else>
									<Constant>green</Constant>
								</Else>
							</If>
						</Then>
						<Else>
							<Constant>white</Constant>
						</Else>
					</If>
				</Color>
			</Right>
		</Text>

		<Gauge>
			<Type>Horizontal</Type>
			<Style>
				<ValuePos>End</ValuePos>
			</Style>
			<ID>Turbo_OilPressGauge</ID>
			<Title>Oil</Title>
			<Unit>PSI</Unit>
			<Minimum>0</Minimum>
			<Maximum>120</Maximum>
			<Value>
				<Simvar name="GENERAL ENG OIL PRESSURE:1" unit="psi"/>
			</Value>
			<ColorZone>
				<Color>green</Color>
				<Begin>85</Begin>
				<End>105</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>40</Begin>
				<End>85</End>
			</ColorZone>
			<ColorLine>
				<Color>red</Color>
				<Position>40</Position>
			</ColorLine>
			<ColorLine>
				<Color>red</Color>
				<Position>105</Position>
			</ColorLine>
			<BeginText></BeginText>
			<EndText></EndText>
			<RedBlink>
				<Or>
					<Greater>
						<Simvar name="GENERAL ENG OIL PRESSURE:1" unit="psi"/>
						<Constant>101.6</Constant>
					</Greater>
					<Lower>
						<Simvar name="GENERAL ENG OIL PRESSURE:1" unit="psi"/>
						<Constant>40</Constant>
					</Lower>
				</Or>
			</RedBlink>
		</Gauge>

		<Gauge>
			<Type>Horizontal</Type>
			<Style>
				<ValuePos>End</ValuePos>
			</Style>
			<ID>Turbo_OilTempGauge</ID>
			<Title>Oil</Title>
			<Unit>°C</Unit>
			<Minimum>-50</Minimum>
			<Maximum>120</Maximum>
			<Value>
				<Simvar name="GENERAL ENG OIL TEMPERATURE:1" unit="celsius"/>
			</Value>
			<ColorZone>
				<Color>green</Color>
				<Begin>10</Begin>
				<End>100</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>-40</Begin>
				<End>10</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>100</Begin>
				<End>105</End>
			</ColorZone>
			<ColorLine>
				<Color>red</Color>
				<Position>-41</Position>
			</ColorLine>
			<ColorLine>
				<Color>red</Color>
				<Position>105</Position>
			</ColorLine>
			<BeginText></BeginText>
			<EndText></EndText>
			<RedBlink>
				<Or>
					<Greater>
						<Simvar name="GENERAL ENG OIL TEMPERATURE:1" unit="celsius"/>
						<Constant>105</Constant>
					</Greater>
					<Lower>
						<Simvar name="GENERAL ENG OIL TEMPERATURE:1" unit="celsius"/>
						<Constant>-41</Constant>
					</Lower>
				</Or>
			</RedBlink>
		</Gauge>

		<Text>
			<Style>
				<Margins>
					<Top>10</Top>
				</Margins>
			</Style>
			<Left>L</Left>
			<Center>Fuel Qty</Center>
			<Right>R</Right>
		</Text>

		<Gauge>
			<Type>DoubleVertical</Type>
			<ID>Turbo_FuelGauge</ID>
			<Title></Title>
			<Unit>LBS</Unit>
			<Minimum>0</Minimum>
			<Maximum>1100</Maximum>
			<Style>
				<Height>70</Height>
			</Style>
			<Value>
				<Multiply>
					<Simvar name="FUEL LEFT QUANTITY" unit="gallons"/>
					<Simvar name="FUEL WEIGHT PER GALLON" unit="pounds"/>
				</Multiply>
			</Value>
			<Value2>
				<Multiply>
					<Simvar name="FUEL RIGHT QUANTITY" unit="gallons"/>
					<Simvar name="FUEL WEIGHT PER GALLON" unit="pounds"/>
				</Multiply>
			</Value2>
			<ColorLine>
				<Color>red</Color>
				<Position>0</Position>
			</ColorLine>
			<ColorZone>
				<Color>red</Color>
				<Begin>0</Begin>
				<End>25</End>
			</ColorZone>
			<GraduationLength text="True">200</GraduationLength>
			<EndText></EndText>
		</Gauge>

		<Text>
			<Style>
				<Margins>
					<Top>10</Top>
				</Margins>
			</Style>
			<Left>FFlow PPH</Left>
			<Right id="FuelFlow">
				<ToFixed precision="0">
					<Simvar name="ENG FUEL FLOW PPH:1" unit="Pounds per hour"/>
				</ToFixed>
			</Right>
		</Text>
	</EnginePage>

	<SystemPage>
		<Gauge>
			<Type>Circular</Type>
			<Style>
				<BeginAngle>-50</BeginAngle>
				<EndAngle>190</EndAngle>
				<ValuePos>End</ValuePos>
				<CursorType>Triangle</CursorType>
				<SizePercent>90</SizePercent>
			</Style>
			<BeginText></BeginText>
			<EndText></EndText>
			<ID>Turbo_TorqueGauge</ID>
			<Title>FT-LB</Title>
			<Unit>x100</Unit>
			<Minimum>0</Minimum>
			<Maximum>3000</Maximum>
			<Value>
				<Simvar name="TURB ENG FREE TURBINE TORQUE:1" unit="Foot pounds"/>
			</Value>
			<ColorZone>
				<Color>green</Color>
				<Begin>0</Begin>
				<End>2397</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>2397</Begin>
				<End>2450</End>
			</ColorZone>
			<GraduationLength>100</GraduationLength>
			<GraduationTextLength>500</GraduationTextLength>
			<RedBlink>
				<Greater>
					<Simvar name="ENG TORQUE:1" unit="Foot pounds"/>
					<Constant>2400</Constant>
				</Greater>
			</RedBlink>
		</Gauge>

		<Gauge>
			<Type>Circular</Type>
			<Style>
				<BeginAngle>-10</BeginAngle>
				<EndAngle>160</EndAngle>
				<CursorType>Triangle</CursorType>
				<ValuePos>End</ValuePos>
				<SizePercent>90</SizePercent>
			</Style>
			<BeginText></BeginText>
			<EndText></EndText>
			<ID>Turbo_IttGauge</ID>
			<Title>ITT</Title>
			<Unit>°C</Unit>
			<Minimum>0</Minimum>
			<Maximum>
				<StateMachine>
					<State id="Start" value="1100">
						<Transition to="Normal">
							<Greater>
								<Simvar name="TURB ENG N1:1" unit="percent"/>
								<Constant>52</Constant>
							</Greater>
						</Transition>
					</State>
					<State id="Normal" value="950">
						<Transition to="Start">
							<Lower>
								<Simvar name="TURB ENG N1:1" unit="percent"/>
								<Constant>10</Constant>
							</Lower>
						</Transition>
					</State>
				</StateMachine>
			</Maximum>
			<Value>
				<Simvar name="TURB ENG1 ITT" unit="celsius"/>
			</Value>
			<ColorZone>
				<Color>green</Color>
				<Begin>100</Begin>
				<End>805</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>805</Begin>
				<End>825</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>825</Begin>
				<End>850</End>
			</ColorZone>
			<ColorLine>
				<Color>red</Color>
				<Position>
					<StateMachine>
						<State id="Start" value="1090">
							<Transition to="Normal">
								<Greater>
									<Simvar name="TURB ENG N1:1" unit="percent"/>
									<Constant>52</Constant>
								</Greater>
							</Transition>
						</State>
						<State id="Normal" value="850">
							<Transition to="Start">
								<Lower>
									<Simvar name="TURB ENG N1:1" unit="percent"/>
									<Constant>10</Constant>
								</Lower>
							</Transition>
						</State>
					</StateMachine>
				</Position>
			</ColorLine>
			<RedBlink>
				<Greater>
					<Simvar name="TURB ENG1 ITT" unit="celsius"/>
					<StateMachine>
						<State id="Start" value="1090">
							<Transition to="Normal">
								<Greater>
									<Simvar name="TURB ENG N1:1" unit="percent"/>
									<Constant>52</Constant>
								</Greater>
							</Transition>
						</State>
						<State id="Normal" value="850">
							<Transition to="Start">
								<Lower>
									<Simvar name="TURB ENG N1:1" unit="percent"/>
									<Constant>10</Constant>
								</Lower>
							</Transition>
						</State>
					</StateMachine>
				</Greater>
			</RedBlink>
			<GraduationLength>50</GraduationLength>
		</Gauge>

		<Gauge>
			<Type>Circular</Type>
			<Style>
				<BeginAngle>-10</BeginAngle>
				<EndAngle>160</EndAngle>
				<CursorType>Triangle</CursorType>
				<ValuePos>End</ValuePos>
				<SizePercent>90</SizePercent>
			</Style>
			<BeginText></BeginText>
			<EndText></EndText>
			<ID>Turbo_NgGauge</ID>
			<Title>NG</Title>
			<Unit>% RPM</Unit>
			<Minimum>10</Minimum>
			<Maximum>110</Maximum>
			<Value>
				<Simvar name="TURB ENG N2:1" unit="percent"/>
			</Value>
			<ColorZone>
				<Color>green</Color>
				<Begin>51</Begin>
				<End>101.6</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>101.6</Begin>
				<End>104</End>
			</ColorZone>
			<GraduationLength>10</GraduationLength>
			<RedBlink>
				<Greater>
					<Simvar name="TURB ENG N2:1" unit="percent"/>
					<Constant>101.6</Constant>
				</Greater>
			</RedBlink>
		</Gauge>

		<Text>
			<Center>---------------------------------</Center>
		</Text>

		<Text>
			<Left>Prop RPM</Left>
			<Right>
				<Content>
					<ToFixed precision="0">
						<Simvar name="PROP RPM:1" unit="rpm"/>
					</ToFixed>
				</Content>
				<Color>
					<If>
						<Condition>
							<Greater>
								<Simvar name="PROP RPM:1" unit="rpm"/>
								<Constant>1600</Constant>
							</Greater>
						</Condition>
						<Then>
							<If>
								<Condition>
									<Greater>
										<Simvar name="PROP RPM:1" unit="rpm"/>
										<Constant>1900</Constant>
									</Greater>
								</Condition>
								<Then>
									<Constant>red</Constant>
								</Then>
								<Else>
									<Constant>green</Constant>
								</Else>
							</If>
						</Then>
						<Else>
							<Constant>white</Constant>
						</Else>
					</If>
				</Color>
			</Right>
		</Text>

		<Text>
			<Left>------------</Left>
			<Center>Fuel</Center>
			<Right>------------</Right>
		</Text>

		<Text>
			<Left>Qty L LBS</Left>
			<Right>
				<ToFixed precision="0">
					<Multiply>
						<Simvar name="FUEL LEFT QUANTITY" unit="gallons"/>
						<Simvar name="FUEL WEIGHT PER GALLON" unit="pounds"/>
					</Multiply>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left>Qty R LBS</Left>
			<Right>
				<ToFixed precision="0">
					<Multiply>
						<Simvar name="FUEL RIGHT QUANTITY" unit="gallons"/>
						<Simvar name="FUEL WEIGHT PER GALLON" unit="pounds"/>
					</Multiply>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left>FFlow PPH</Left>
			<Right>
				<ToFixed precision="0">
					<Simvar name="ENG FUEL FLOW PPH:1" unit="Pounds per hour"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left>--</Left>
			<Center>Fuel Totalizer</Center>
			<Right>--</Right>
		</Text>

		<Text>
			<Left>LB Rem</Left>
			<Right>
				<ToFixed precision="0">
					<Multiply>
						<Simvar name="L:WT1000_Fuel_GalRemaining" unit="gallon"/>
						<Simvar name="FUEL WEIGHT PER GALLON" unit="pounds"/>
					</Multiply>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left>LB Used</Left>
			<Right>
				<ToFixed precision="0">
					<Multiply>
						<Simvar name="L:WT1000_Fuel_GalBurned" unit="gallon"/>
						<Simvar name="FUEL WEIGHT PER GALLON" unit="pounds"/>
					</Multiply>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left>------</Left>
			<Center>Electrical</Center>
			<Right>-----</Right>
		</Text>

		<Text>
			<Left>Gen Amps</Left>
			<Right>
				<ToFixed precision="0">
					<Simvar name="ELECTRICAL GENALT BUS AMPS:1" unit="amps"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left>Alt Amps</Left>
			<Right>
				<ToFixed precision="0">
					<Simvar name="ELECTRICAL GENALT BUS AMPS:1" unit="amps"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left>Bat Amps</Left>
			<Right>
				<ToFixed precision="0">
					<Simvar name="ELECTRICAL BATTERY BUS AMPS" unit="amps"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left>Bus VoltsS</Left>
			<Right>
				<ToFixed precision="1">
					<Simvar name="ELECTRICAL MAIN BUS VOLTAGE" unit="volts"/>
				</ToFixed>
			</Right>
		</Text>
		<SystemPage/>
	</EngineDisplay>
`;

const xmlConfig$4 = `
<EngineDisplay>
	<EnginePage>
		<Gauge>
			<Type>Circular</Type>
			<Style>
				<SizePercent>90</SizePercent>
			</Style>
			<ID>Piston_LoadGauge</ID>
			<Title>%</Title>
			<Unit>Load</Unit>
			<Minimum>0</Minimum>
			<Maximum>100</Maximum>
			<Value>
				<Max>
					<Min>
						<Multiply>
							<Divide>
								<Multiply>
									<Simvar name="ENG TORQUE:1" unit="Foot pounds"/>
									<Divide>
										<Simvar name="GENERAL ENG RPM:1" unit="rpm"/>
										<Constant>5252</Constant>
									</Divide>
									<Constant>550</Constant>
								</Multiply>
								<Divide>
									<Gamevar name="AIRCRAFT MAX RATED HP" unit="ft lb per second"/>
									<Simvar name="NUMBER OF ENGINES" unit="number"/>
								</Divide>
							</Divide>
							<Constant>100</Constant>
						</Multiply>
						<Constant>100</Constant>
					</Min>
					<Constant>0</Constant>
				</Max>
			</Value>
			<ColorZone>
				<Color>green</Color>
				<Begin>0</Begin>
				<End>92</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>92</Begin>
				<End>100</End>
			</ColorZone>
		</Gauge>

		<Gauge>
			<Type>Circular</Type>
			<Style>
				<SizePercent>90</SizePercent>
			</Style>
			<ID>Piston_RPMGauge</ID>
			<Title></Title>
			<Unit>RPM</Unit>
			<Minimum>0</Minimum>
			<Maximum>2800</Maximum>
			<Style>
				<TextIncrement>10</TextIncrement>
			</Style>
			<Value>
				<Simvar name="PROP RPM:1" unit="rpm"/>
			</Value>
			<ColorZone>
				<Color>white</Color>
				<Begin>0</Begin>
				<End>2800</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>0</Begin>
				<End>2100</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>2100</Begin>
				<End>2300</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>2300</Begin>
				<End>2800</End>
			</ColorZone>
			<RedBlink>
				<Greater>
					<Simvar name="PROP RPM:1" unit="rpm"/>
					<Constant>2300</Constant>
				</Greater>
			</RedBlink>
		</Gauge>

		<Gauge>
			<Type>Horizontal</Type>
			<Style>
				<Margins>
					<Top>20</Top>
				</Margins>
			</Style>
			<ID>FFlow</ID>
			<Title>Fuel Flow</Title>
			<Unit>GPH</Unit>
			<Minimum>0</Minimum>
			<Maximum>25</Maximum>
			<GraduationLength>2.5</GraduationLength>
			<Value>
				<Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
			</Value>
			<ColorZone>
				<Color>green</Color>
				<Begin>1</Begin>
				<End>20</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>20</Begin>
				<End>25</End>
			</ColorZone>
		</Gauge>

		<Gauge>
			<Type>Horizontal</Type>
			<ID>FPress</ID>
			<Title>Fuel Press</Title>
			<Minimum>0</Minimum>
			<Maximum>25</Maximum>
			<BeginText/>
			<EndText/>
			<Value>
				<Simvar name="GENERAL ENG FUEL PRESSURE:1" unit="psi"/>
			</Value>
			<ColorZone>
				<Color>red</Color>
				<Begin>0</Begin>
				<End>7</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>7</Begin>
				<End>20</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>20</Begin>
				<End>25</End>
			</ColorZone>
		</Gauge>

		<Gauge>
			<Type>Horizontal</Type>
			<ID>CHT</ID>
			<Title>CHT</Title>
			<Minimum>100</Minimum>
			<Maximum>500</Maximum>
			<BeginText/>
			<EndText/>
			<Value>
				<Simvar name="ENG CYLINDER HEAD TEMPERATURE:1" unit="farenheit"/>
			</Value>
			<ColorZone>
				<Color>green</Color>
				<Begin>150</Begin>
				<End>450</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>450</Begin>
				<End>475</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>475</Begin>
				<End>500</End>
			</ColorZone>
		</Gauge>

		<Gauge>
			<Type>Horizontal</Type>
			<ID>Piston_OilTempGauge</ID>
			<Title>Oil Temp</Title>
			<Unit></Unit>
			<Minimum>-35</Minimum>
			<Maximum>145</Maximum>
			<Value>
				<Simvar name="GENERAL ENG OIL TEMPERATURE:1" unit="celsius"/>
			</Value>
			<ColorZone>
				<Color>red</Color>
				<Begin>-35</Begin>
				<End>-30</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>-30</Begin>
				<End>50</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>50</Begin>
				<End>135</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>135</Begin>
				<End>140</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>140</Begin>
				<End>145</End>
			</ColorZone>
			<BeginText></BeginText>
			<EndText></EndText>
			<RedBlink>
				<Or>
					<Greater>
						<Simvar name="GENERAL ENG OIL TEMPERATURE:1" unit="celsius"/>
						<Constant>140</Constant>
					</Greater>
					<Lower>
						<Simvar name="GENERAL ENG OIL TEMPERATURE:1" unit="celsius"/>
						<Constant>-30</Constant>
					</Lower>
				</Or>
			</RedBlink>
		</Gauge>

		<Gauge>
			<Type>Horizontal</Type>
			<ID>Piston_OilPressGauge</ID>
			<Title>Oil Press</Title>
			<Unit></Unit>
			<Minimum>0</Minimum>
			<Maximum>7</Maximum>
			<Value>
				<Simvar name="GENERAL ENG OIL PRESSURE:1" unit="bar"/>
			</Value>
			<ColorZone>
				<Color>red</Color>
				<Begin>0</Begin>
				<End>0.9</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>0.9</Begin>
				<End>2.5</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>2.5</Begin>
				<End>6.0</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>6.0</Begin>
				<End>6.5</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>6.5</Begin>
				<End>7.0</End>
			</ColorZone>
			<BeginText></BeginText>
			<EndText></EndText>
			<RedBlink>
				<Or>
					<Greater>
						<Simvar name="GENERAL ENG OIL PRESSURE:1" unit="bar"/>
						<Constant>6.5</Constant>
					</Greater>
					<Lower>
						<Simvar name="GENERAL ENG OIL PRESSURE:1" unit="bar"/>
						<Constant>0.9</Constant>
					</Lower>
				</Or>
			</RedBlink>
		</Gauge>

		<Text>
			<Style>
				<Margins>
					<Top>10</Top>
				</Margins>
			</Style>
			<Left>Amps</Left>
			<Right id="Piston_AmpsGauge">
				<ToFixed precision="1">
					<Simvar name="ELECTRICAL MAIN BUS AMPS" unit="amperes"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left>Volts</Left>
			<Right id="Piston_VoltsGauge">
				<ToFixed precision="1">
					<Simvar name="ELECTRICAL MAIN BUS VOLTAGE" unit="volts"/>
				</ToFixed>
			</Right>
		</Text>

		<Gauge>
			<Type>DoubleHorizontal</Type>
			<ID>Piston_FuelGauge</ID>
			<Title>Fuel Qty</Title>
			<Unit>Gal</Unit>
			<CursorText>R</CursorText>
			<CursorText2>L</CursorText2>
			<Minimum>0</Minimum>
			<Maximum>15</Maximum>
			<Value>
				<Simvar name="FUEL RIGHT QUANTITY" unit="gallons"/>
			</Value>
			<Value2>
				<Simvar name="FUEL LEFT QUANTITY" unit="gallons"/>
			</Value2>
			<ColorZone>
				<Color>red</Color>
				<Begin>0</Begin>
				<End>1</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>1</Begin>
				<End>15</End>
			</ColorZone>
			<GraduationLength text="True">5</GraduationLength>
		</Gauge>
	</EnginePage>

	<SystemPage>
		<Gauge>
			<Type>Circular</Type>
			<Style>
				<SizePercent>90</SizePercent>
			</Style>
			<ID>Piston_LoadGauge</ID>
			<Title>%</Title>
			<Unit>Load</Unit>
			<Minimum>0</Minimum>
			<Maximum>100</Maximum>
			<Value>
				<Max>
					<Min>
						<Multiply>
							<Divide>
								<Multiply>
									<Simvar name="ENG TORQUE:1" unit="Foot pounds"/>
									<Divide>
										<Simvar name="GENERAL ENG RPM:1" unit="rpm"/>
										<Constant>5252</Constant>
									</Divide>
									<Constant>550</Constant>
								</Multiply>
								<Divide>
									<Gamevar name="AIRCRAFT MAX RATED HP" unit="ft lb per second"/>
									<Simvar name="NUMBER OF ENGINES" unit="number"/>
								</Divide>
							</Divide>
							<Constant>100</Constant>
						</Multiply>
						<Constant>100</Constant>
					</Min>
					<Constant>0</Constant>
				</Max>
			</Value>
			<ColorZone>
				<Color>green</Color>
				<Begin>0</Begin>
				<End>92</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>92</Begin>
				<End>100</End>
			</ColorZone>
		</Gauge>

		<Gauge>
			<Type>Circular</Type>
			<Style>
				<SizePercent>90</SizePercent>
			</Style>
			<ID>Piston_RPMGauge</ID>
			<Title></Title>
			<Unit>RPM</Unit>
			<Minimum>0</Minimum>
			<Maximum>2800</Maximum>
			<Style>
				<TextIncrement>10</TextIncrement>
			</Style>
			<Value>
				<Simvar name="PROP RPM:1" unit="rpm"/>
			</Value>
			<ColorZone>
				<Color>white</Color>
				<Begin>0</Begin>
				<End>2800</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>0</Begin>
				<End>2100</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>2100</Begin>
				<End>2300</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>2300</Begin>
				<End>2800</End>
			</ColorZone>
			<RedBlink>
				<Greater>
					<Simvar name="PROP RPM:1" unit="rpm"/>
					<Constant>2300</Constant>
				</Greater>
			</RedBlink>
		</Gauge>

		<Gauge>
			<Type>Cylinder</Type>
			<ID>EGT_Gauge</ID>
			<Title>EGT</Title>
			<Unit>°F</Unit>
			<Rows>13</Rows>
			<Columns>4</Columns>
			<Minimum>800</Minimum>
			<Maximum>1300</Maximum>
			<TempOrder>1,3,2,4</TempOrder>
			<Value>
				<Simvar name="GENERAL ENG EXHAUST GAS TEMPERATURE:1" unit="farenheit"/>
			</Value>
			<Style>
				<ShowPeak>True</ShowPeak>
				<TextIncrement>5</TextIncrement>
			</Style>
		</Gauge>

		<Gauge>
			<Type>Cylinder</Type>
			<ID>CHT_Gauge</ID>
			<Title>CHT</Title>
			<Unit>°F</Unit>
			<Rows>13</Rows>
			<Columns>4</Columns>
			<Minimum>100</Minimum>
			<Maximum>500</Maximum>
			<TempOrder>1,3,2,4</TempOrder>
			<Value>
				<Simvar name="ENG CYLINDER HEAD TEMPERATURE:1" unit="farenheit"/>
			</Value>
			<Style>
				<ShowRedline>True</ShowRedline>
				<TextIncrement>5</TextIncrement>
			</Style>
		</Gauge>

		<Text>
			<Left>FFlow GPH</Left>
			<Right>
				<ToFixed precision="1">
					<Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left>Gal Rem</Left>
			<Right>
				<ToFixed precision="1">
					<Simvar name="L:WT1000_Fuel_GalRemaining" unit="gallon"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left>Gal Used</Left>
			<Right>
				<ToFixed precision="1">
					<Simvar name="L:WT1000_Fuel_GalBurned" unit="gallon"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left>Endur</Left>
			<Right>
				<If>
					<Condition>
						<Greater>
							<Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
							<Constant>0.1</Constant>
						</Greater>
					</Condition>
					<Then>
						<Add>
							<ToFixed precision="2">
								<Divide>
									<Simvar name="L:WT1000_Fuel_GalRemaining" unit="gallon"/>
									<Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
								</Divide>
							</ToFixed>
							<Constant>h</Constant>
						</Add>
					</Then>
					<Else>
						<Constant>X</Constant>
					</Else>
				</If>
			</Right>
		</Text>

		<Text>
			<Left>Range NM</Left>
			<Right>
				<If>
					<Condition>
						<Greater>
							<Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
							<Constant>0.1</Constant>
						</Greater>
					</Condition>
					<Then>
						<ToFixed precision="0">
							<Multiply>
								<Simvar name="GROUND VELOCITY:1" unit="knots"/>
								<Divide>
									<Simvar name="L:WT1000_Fuel_GalRemaining" unit="gallon"/>
									<Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
								</Divide>
							</Multiply>
						</ToFixed>
					</Then>
					<Else>
						<Constant>X</Constant>
					</Else>
				</If>
			</Right>
		</Text>
	</SystemPage>
</EngineDisplay>
`;

const xmlConfig$3 = `
<EngineDisplay>
	<EnginePage>
		<Gauge>
			<Type>DoubleVertical</Type>
			<Style>
				<Height>70</Height>
				<TextIncrement>1</TextIncrement>
			</Style>
			<ID>Piston_LoadGauge</ID>
			<Title>Load</Title>
			<Unit></Unit>
			<Minimum>0</Minimum>
			<Maximum>100</Maximum>
			<Value>
				<Max>
					<Min>
						<Multiply>
							<Divide>
								<Multiply>
									<Simvar name="ENG TORQUE:1" unit="Foot pounds"/>
									<Divide>
										<Simvar name="GENERAL ENG RPM:1" unit="rpm"/>
										<Constant>5252</Constant>
									</Divide>
									<Constant>550</Constant>
								</Multiply>
								<Divide>
									<Gamevar name="AIRCRAFT MAX RATED HP" unit="ft lb per second"/>
									<Simvar name="NUMBER OF ENGINES" unit="number"/>
								</Divide>
							</Divide>
							<Constant>100</Constant>
						</Multiply>
						<Constant>100</Constant>
					</Min>
					<Constant>0</Constant>
				</Max>
			</Value>
			<Value2>
				<Max>
					<Min>
						<Multiply>
							<Divide>
								<Multiply>
									<Simvar name="ENG TORQUE:2" unit="Foot pounds"/>
									<Divide>
										<Simvar name="GENERAL ENG RPM:2" unit="rpm"/>
										<Constant>5252</Constant>
									</Divide>
									<Constant>550</Constant>
								</Multiply>
								<Divide>
									<Gamevar name="AIRCRAFT MAX RATED HP" unit="ft lb per second"/>
									<Simvar name="NUMBER OF ENGINES" unit="number"/>
								</Divide>
							</Divide>
							<Constant>100</Constant>
						</Multiply>
						<Constant>100</Constant>
					</Min>
					<Constant>0</Constant>
				</Max>
			</Value2>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>95</Begin>
				<End>100</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>0</Begin>
				<End>95</End>
			</ColorZone>
			<GraduationLength text="True">20</GraduationLength>
			<BeginText>%</BeginText>
		</Gauge>

		<Gauge>
			<Type>DoubleVertical</Type>
			<Style>
				<Height>70</Height>
			</Style>
			<ID>Piston_RPMGauge</ID>
			<Title></Title>
			<Unit>RPM</Unit>
			<Minimum>0</Minimum>
			<Maximum>3000</Maximum>
			<Value>
				<Simvar name="PROP RPM:1" unit="rpm"/>
			</Value>
			<Value2>
				<Simvar name="PROP RPM:2" unit="rpm"/>
			</Value2>
			<ColorZone>
				<Color>green</Color>
				<Begin>0</Begin>
				<End>2325</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>2325</Begin>
				<End>2375</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>2375</Begin>
				<End>3000</End>
			</ColorZone>
			<GraduationLength text="True">600</GraduationLength>
		</Gauge>

		<Text>
			<Center>Fuel Flow</Center>
		</Text>

		<Text>
			<Left>
				<ToFixed precision="1">
					<Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
				</ToFixed>
			</Left>
			<Center>GPH</Center>
			<Right>
				<ToFixed precision="1">
					<Simvar name="ENG FUEL FLOW GPH:2" unit="gallons per hour"/>
				</ToFixed>
			</Right>
		</Text>

		<Gauge>
			<Type>DoubleHorizontal</Type>
			<ID>Piston_OilTempGauge</ID>
			<Title>Oil Temp</Title>
			<Unit></Unit>
			<CursorText>L</CursorText>
			<CursorText2>R</CursorText2>
			<Minimum>-40</Minimum>			<!-- Not Sure -->
			<Maximum>150</Maximum>			<!-- Not Sure -->
			<Value>
				<Simvar name="GENERAL ENG OIL TEMPERATURE:1" unit="celsius"/>
			</Value>
			<Value2>
				<Simvar name="GENERAL ENG OIL TEMPERATURE:2" unit="celsius"/>
			</Value2>
			<ColorZone>
				<Color>red</Color>
				<Begin>-40</Begin>				<!-- Not Sure -->
				<End>-30</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>-30</Begin>
				<End>50</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>50</Begin>
				<End>135</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>135</Begin>
				<End>139</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>139</Begin>
				<End>150</End>				<!-- Not Sure -->
			</ColorZone>
			<BeginText></BeginText>
			<EndText></EndText>
		</Gauge>

		<Gauge>
			<Type>DoubleHorizontal</Type>
			<ID>Piston_OilPressGauge</ID>
			<Title>Oil Press</Title>
			<Unit></Unit>
			<CursorText>L</CursorText>
			<CursorText2>R</CursorText2>
			<Minimum>0</Minimum>			<!-- Not Sure -->
			<Maximum>7</Maximum>			<!-- Not Sure -->
			<Value>
				<Simvar name="GENERAL ENG OIL PRESSURE:1" unit="bar"/>
			</Value>
			<Value2>
				<Simvar name="GENERAL ENG OIL PRESSURE:2" unit="bar"/>
			</Value2>
			<ColorZone>
				<Color>red</Color>
				<Begin>0</Begin>				<!-- Not Sure -->
				<End>0.9</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>0.9</Begin>
				<End>2.5</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>2.5</Begin>
				<End>6</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>6</Begin>
				<End>6.5</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>6.5</Begin>
				<End>7</End>				<!-- Not Sure -->
			</ColorZone>
			<BeginText></BeginText>
			<EndText></EndText>
		</Gauge>

		<Gauge>
			<Type>DoubleHorizontal</Type>
			<ID>Piston_CoolantTempGauge</ID>
			<Title>Coolant Temp</Title>
			<Unit></Unit>
			<CursorText>L</CursorText>
			<CursorText2>R</CursorText2>
			<Minimum>-40</Minimum>			<!-- Not Sure -->
			<Maximum>150</Maximum>			<!-- Not Sure -->
			<Value>
				<Simvar name="RECIP ENG RADIATOR TEMPERATURE:1" unit="celsius"/>
			</Value>
			<Value2>
				<Simvar name="RECIP ENG RADIATOR TEMPERATURE:2" unit="celsius"/>
			</Value2>
			<ColorZone>
				<Color>red</Color>
				<Begin>-40</Begin>				<!-- Not Sure -->
				<End>-30</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>-30</Begin>
				<End>60</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>60</Begin>
				<End>95</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>95</Begin>
				<End>100</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>100</Begin>
				<End>150</End>				<!-- Not Sure -->
			</ColorZone>
			<BeginText></BeginText>
			<EndText></EndText>
		</Gauge>

		<Gauge>
			<Type>DoubleHorizontal</Type>
			<ID>Piston_FuelTempGauge</ID>
			<Title>Fuel Temp</Title>
			<Unit></Unit>
			<CursorText>L</CursorText>
			<CursorText2>R</CursorText2>
			<Minimum>-40</Minimum>			<!-- Not Sure -->
			<Maximum>100</Maximum>			<!-- Not Sure -->
			<Value>
				30
			</Value>
			<Value2>
				30
			</Value2>
			<ColorZone>
				<Color>red</Color>
				<Begin>-40</Begin>				<!-- Not Sure -->
				<End>-30</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>-30</Begin>
				<End>55</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>55</Begin>
				<End>60</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>60</Begin>
				<End>100</End>				<!-- Not Sure -->
			</ColorZone>
			<BeginText></BeginText>
			<EndText></EndText>
		</Gauge>

		<Gauge>
			<Type>DoubleHorizontal</Type>
			<ID>Piston_FuelGauge</ID>
			<Title>Fuel QTY</Title>
			<Unit>GAL</Unit>
			<CursorText>L</CursorText>
			<CursorText2>R</CursorText2>
			<Minimum>0</Minimum>
			<Maximum>25</Maximum>
			<Value>
				<Simvar name="FUEL TANK LEFT MAIN QUANTITY" unit="gallons"/>
			</Value>
			<Value2>
				<Simvar name="FUEL TANK RIGHT MAIN QUANTITY" unit="gallons"/>
			</Value2>
			<ColorZone>
				<Color>red</Color>
				<Begin>0</Begin>
				<End>1</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>1</Begin>
				<End>25</End>
			</ColorZone>
			<GraduationLength text="True">5</GraduationLength>
		</Gauge>

		<Text>
			<Left>
				<ToFixed precison="0">
					<Simvar name="FUEL TANK LEFT AUX QUANTITY" unit="gallons"/>
				</ToFixed>
			</Left>
			<Center>Aux Fuel</Center>
			<Right>
				<ToFixed precison="0">
					<Simvar name="FUEL TANK RIGHT AUX QUANTITY" unit="gallons"/>
				</ToFixed>
			</Right>
		</Text>
	</EnginePage>

	<SystemPage>
		<Gauge>
			<Type>DoubleVertical</Type>
			<Style>
				<Height>70</Height>
				<TextIncrement>1</TextIncrement>
			</Style>
			<ID>Piston_LoadGauge</ID>
			<Title>Load</Title>
			<Unit></Unit>
			<Minimum>0</Minimum>
			<Maximum>100</Maximum>
			<Value>
				<Max>
					<Min>
						<Multiply>
							<Divide>
								<Multiply>
									<Simvar name="ENG TORQUE:1" unit="Foot pounds"/>
									<Divide>
										<Simvar name="GENERAL ENG RPM:1" unit="rpm"/>
										<Constant>5252</Constant>
									</Divide>
									<Constant>550</Constant>
								</Multiply>
								<Divide>
									<Gamevar name="AIRCRAFT MAX RATED HP" unit="ft lb per second"/>
									<Simvar name="NUMBER OF ENGINES" unit="number"/>
								</Divide>
							</Divide>
							<Constant>100</Constant>
						</Multiply>
						<Constant>100</Constant>
					</Min>
					<Constant>0</Constant>
				</Max>
			</Value>
			<Value2>
				<Max>
					<Min>
						<Multiply>
							<Divide>
								<Multiply>
									<Simvar name="ENG TORQUE:2" unit="Foot pounds"/>
									<Divide>
										<Simvar name="GENERAL ENG RPM:2" unit="rpm"/>
										<Constant>5252</Constant>
									</Divide>
									<Constant>550</Constant>
								</Multiply>
								<Divide>
									<Gamevar name="AIRCRAFT MAX RATED HP" unit="ft lb per second"/>
									<Simvar name="NUMBER OF ENGINES" unit="number"/>
								</Divide>
							</Divide>
							<Constant>100</Constant>
						</Multiply>
						<Constant>100</Constant>
					</Min>
					<Constant>0</Constant>
				</Max>
			</Value2>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>95</Begin>
				<End>100</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>0</Begin>
				<End>95</End>
			</ColorZone>
			<GraduationLength text="True">20</GraduationLength>
			<BeginText>%</BeginText>
		</Gauge>

		<Gauge>
			<Type>DoubleVertical</Type>
			<Style>
				<Height>70</Height>
			</Style>
			<ID>Piston_RPMGauge</ID>
			<Title></Title>
			<Unit>RPM</Unit>
			<Minimum>0</Minimum>
			<Maximum>3000</Maximum>
			<Value>
				<Simvar name="PROP RPM:1" unit="rpm"/>
			</Value>
			<Value2>
				<Simvar name="PROP RPM:2" unit="rpm"/>
			</Value2>
			<ColorZone>
				<Color>green</Color>
				<Begin>0</Begin>
				<End>2325</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>2325</Begin>
				<End>2375</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>2375</Begin>
				<End>3000</End>
			</ColorZone>
			<GraduationLength text="True">600</GraduationLength>
		</Gauge>

		<Gauge>
			<Type>Cylinder</Type>
			<ID>EGT_Gauge</ID>
			<Title>EGT</Title>
			<Unit>°F</Unit>
			<Rows>13</Rows>
			<Columns>4</Columns>
			<Minimum>1000</Minimum>
			<Maximum>1700</Maximum>
			<TempOrder>1,3,2,4</TempOrder>
			<Value>
				<Simvar name="GENERAL ENG EXHAUST GAS TEMPERATURE:1" unit="farenheit"/>
			</Value>
			<Style>
				<ShowPeak>True</ShowPeak>
				<TextIncrement>5</TextIncrement>
			</Style>
		</Gauge>

		<Gauge>
			<Type>Cylinder</Type>
			<ID>CHT_Gauge</ID>
			<Title>CHT</Title>
			<Unit>°F</Unit>
			<Rows>13</Rows>
			<Columns>4</Columns>
			<Minimum>100</Minimum>
			<Maximum>500</Maximum>
			<TempOrder>1,3,2,4</TempOrder>
			<Value>
				<Simvar name="ENG CYLINDER HEAD TEMPERATURE:1" unit="farenheit"/>
			</Value>
			<Style>
				<ShowRedline>True</ShowRedline>
				<TextIncrement>5</TextIncrement>
			</Style>
		</Gauge>

		<Text>
			<Left>FFlow GPH</Left>
			<Right>
				<ToFixed precision="1">
					<Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left>Gal Rem</Left>
			<Right>
				<ToFixed precision="1">
					<Simvar name="L:WT1000_Fuel_GalRemaining" unit="gallon"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left>Gal Used</Left>
			<Right>
				<ToFixed precision="1">
					<Simvar name="L:WT1000_Fuel_GalBurned" unit="gallon"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left>Endur</Left>
			<Right>
				<If>
					<Condition>
						<Greater>
							<Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
							<Constant>0.1</Constant>
						</Greater>
					</Condition>
					<Then>
						<Add>
							<ToFixed precision="2">
								<Divide>
									<Simvar name="L:WT1000_Fuel_GalRemaining" unit="gallon"/>
									<Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
								</Divide>
							</ToFixed>
							<Constant>h</Constant>
						</Add>
					</Then>
					<Else>
						<Constant>X</Constant>
					</Else>
				</If>
			</Right>
		</Text>

		<Text>
			<Left>Range NM</Left>
			<Right>
				<If>
					<Condition>
						<Greater>
							<Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
							<Constant>0.1</Constant>
						</Greater>
					</Condition>
					<Then>
						<ToFixed precision="0">
							<Multiply>
								<Simvar name="GROUND VELOCITY:1" unit="knots"/>
								<Divide>
									<Simvar name="L:WT1000_Fuel_GalRemaining" unit="gallon"/>
									<Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
								</Divide>
							</Multiply>
						</ToFixed>
					</Then>
					<Else>
						<Constant>X</Constant>
					</Else>
				</If>
			</Right>
		</Text>
	</SystemPage>
</EngineDisplay>
`;

const xmlConfig$2 = `
<EngineDisplay>
  <EnginePage>
    <Gauge>
      <Type>Circular</Type>
      <ID>MANIN_Gauge</ID>
      <Title>MAN IN</Title>
      <Minimum>0</Minimum>
      <Maximum>40</Maximum>
      <Value>
        <Simvar name="RECIP ENG MANIFOLD PRESSURE:1" unit="inHG"/>
      </Value>
      <ColorZone>
        <Color>white</Color>
        <Begin>0</Begin>
        <End>40</End>
      </ColorZone>
      <ColorZone>
        <Color>green</Color>
        <Begin>15</Begin>
        <End>29.6</End>
      </ColorZone>
    </Gauge>

    <Gauge>
      <Type>Circular</Type>
      <ID>Piston_RPMGauge</ID>
      <Title></Title>
      <Unit>RPM</Unit>
      <Minimum>0</Minimum>
      <Maximum>3000</Maximum>
      <Style>
        <TextIncrement>10</TextIncrement>
      </Style>
      <Value>
        <Simvar name="PROP RPM:1" unit="rpm"/>
      </Value>
      <ColorZone>
        <Color>white</Color>
        <Begin>0</Begin>
        <End>3000</End>
      </ColorZone>
      <ColorZone>
        <Color>green</Color>
        <Begin>1800</Begin>
        <End>2700</End>
      </ColorZone>
      <ColorZone>
        <Color>red</Color>
        <Begin>2700</Begin>
        <End>3000</End>
      </ColorZone>
      <RedBlink>
        <Greater>
          <Simvar name="PROP RPM:1" unit="rpm"/>
          <Constant>2700</Constant>
        </Greater>
      </RedBlink>
    </Gauge>

    <Text>
      <Left>FFlow GPH</Left>
      <Right>
        <ToFixed precision="1">
          <Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
        </ToFixed>
      </Right>
    </Text>

    <Gauge>
      <Type>Horizontal</Type>
      <ID>Piston_FFlowGauge</ID>
      <Title></Title>
      <Unit></Unit>
      <Minimum>0</Minimum>
      <Maximum>30</Maximum>
      <Value>
        <Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
      </Value>
      <ColorZone>
        <Color>green</Color>
        <Begin>3</Begin>
        <End>27.4</End>
      </ColorZone>
      <ColorZone>
        <Color>red</Color>
        <Begin>27.4</Begin>
        <End>30</End>
      </ColorZone>
      <GraduationLength>2</GraduationLength>
      <GraduationTextLength>30</GraduationTextLength>
    </Gauge>

    <Gauge>
      <Type>Horizontal</Type>
      <ID>Piston_ChtGauge</ID>
      <Title>CHT</Title>
      <Unit></Unit>
      <Minimum>0</Minimum>
      <Maximum>250</Maximum>
      <Value>
        <Simvar name="ENG CYLINDER HEAD TEMPERATURE:1" unit="celsius"/>
      </Value>
      <GraduationLength></GraduationLength>
      <BeginText></BeginText>
      <EndText></EndText>
      <ColorZone>
        <Color>green</Color>
        <Begin>116</Begin>
        <End>238</End>
      </ColorZone>
      <ColorZone>
        <Color>red</Color>
        <Begin>238</Begin>
        <End>250</End>
      </ColorZone>
    </Gauge>

    <Gauge>
      <Type>Horizontal</Type>
      <ID>Piston_OilTempGauge</ID>
      <Title>Oil Temp</Title>
      <Unit></Unit>
      <Minimum>0</Minimum>
      <Maximum>120</Maximum>
      <Value>
        <Simvar name="GENERAL ENG OIL TEMPERATURE:1" unit="celsius"/>
      </Value>
      <ColorZone>
        <Color>yellow</Color>
        <Begin>0</Begin>
        <End>24</End>
      </ColorZone>
      <ColorZone>
        <Color>green</Color>
        <Begin>24</Begin>
        <End>116</End>
      </ColorZone>
      <ColorZone>
        <Color>red</Color>
        <Begin>116</Begin>
        <End>120</End>
      </ColorZone>
      <BeginText></BeginText>
      <EndText></EndText>
      <RedBlink>
        <Greater>
          <Simvar name="GENERAL ENG OIL TEMPERATURE:1" unit="celsius"/>
          <Constant>120</Constant>
        </Greater>
      </RedBlink>
    </Gauge>

    <Gauge>
      <Type>Horizontal</Type>
      <ID>Piston_OilPressGauge</ID>
      <Title>Oil Press</Title>
      <Unit></Unit>
      <Minimum>0</Minimum>
      <Maximum>105</Maximum>
      <Value>
        <Simvar name="GENERAL ENG OIL PRESSURE:1" unit="psi"/>
      </Value>
      <ColorZone>
        <Color>red</Color>
        <Begin>0</Begin>
        <End>10</End>
      </ColorZone>
      <ColorZone>
        <Color>yellow</Color>
        <Begin>10</Begin>
        <End>30</End>
      </ColorZone>
      <ColorZone>
        <Color>green</Color>
        <Begin>30</Begin>
        <End>60</End>
      </ColorZone>
      <ColorZone>
        <Color>red</Color>
        <Begin>100</Begin>
        <End>105</End>
      </ColorZone>
      <BeginText></BeginText>
      <EndText></EndText>
      <RedBlink>
        <Or>
          <Greater>
            <Simvar name="GENERAL ENG OIL PRESSURE:1" unit="psi"/>
            <Constant>100</Constant>
          </Greater>
          <Lower>
            <Simvar name="GENERAL ENG OIL PRESSURE:1" unit="psi"/>
            <Constant>10</Constant>
          </Lower>
        </Or>
      </RedBlink>
    </Gauge>

    <Gauge>
      <Type>DoubleHorizontal</Type>
      <ID>Piston_AltLoad</ID>
      <Title>Alt Load</Title>
      <Unit></Unit>
      <CursorText>1</CursorText>
      <CursorText2>2</CursorText2>
      <Minimum>0</Minimum>
      <Maximum>120</Maximum>
      <Value>
        <Simvar name="ELECTRICAL GENALT BUS AMPS:1" unit="amps"/>
      </Value>
      <Value2>
        <Simvar name="ELECTRICAL GENALT BUS AMPS:2" unit="amps"/>
      </Value2>
      <ColorZone>
        <Color>green</Color>
        <Begin>0</Begin>
        <End>100</End>
      </ColorZone>
      <ColorZone>
        <Color>yellow</Color>
        <Begin>100</Begin>
        <End>120</End>
      </ColorZone>
      <BeginText></BeginText>
      <EndText></EndText>
    </Gauge>

    <Gauge>
      <Type>DoubleHorizontal</Type>
      <ID>Piston_VoltsGauge</ID>
      <Title>Bus Volts</Title>
      <Unit></Unit>
      <CursorText>1</CursorText>
      <CursorText2>2</CursorText2>
      <Minimum>0</Minimum>
      <Maximum>33</Maximum>
      <Value>
        <Simvar name="ELECTRICAL MAIN BUS VOLTAGE:2" unit="volts"/>
      </Value>
      <Value2>
        <Simvar name="ELECTRICAL MAIN BUS VOLTAGE:3" unit="volts"/>
      </Value2>
      <ColorZone>
        <Color>yellow</Color>
        <Begin>10</Begin>
        <End>24</End>
      </ColorZone>
      <ColorZone>
        <Color>green</Color>
        <Begin>24</Begin>
        <End>30</End>
      </ColorZone>
      <ColorZone>
        <Color>yellow</Color>
        <Begin>30</Begin>
        <End>33</End>
      </ColorZone>
      <BeginText></BeginText>
      <EndText></EndText>
    </Gauge>

    <Gauge>
      <Type>DoubleHorizontal</Type>
      <ID>Piston_FuelGauge</ID>
      <Title>Fuel Qty</Title>
      <Unit>Gal</Unit>
      <CursorText>R</CursorText>
      <CursorText2>L</CursorText2>
      <Minimum>0</Minimum>
      <Maximum>37</Maximum>
      <Value>
        <Simvar name="FUEL RIGHT QUANTITY" unit="gallons"/>
      </Value>
      <Value2>
        <Simvar name="FUEL LEFT QUANTITY" unit="gallons"/>
      </Value2>
      <ColorZone>
        <Color>red</Color>
        <Begin>0</Begin>
        <End>3</End>
      </ColorZone>
      <ColorZone>
        <Color>yellow</Color>
        <Begin>3</Begin>
        <End>13</End>
      </ColorZone>
      <ColorZone>
        <Color>green</Color>
        <Begin>13</Begin>
        <End>37</End>
      </ColorZone>
      <GraduationLength text="True">10</GraduationLength>
      <EndText>F</EndText>
    </Gauge>
  </EnginePage>

  <LeanPage>
    <Gauge>
      <Type>Circular</Type>
      <ID>MANIN_Gauge</ID>
      <Title>MAN IN</Title>
      <Minimum>0</Minimum>
      <Maximum>40</Maximum>
      <Value>
        <Simvar name="RECIP ENG MANIFOLD PRESSURE:1" unit="inHG"/>
      </Value>
      <ColorZone>
        <Color>white</Color>
        <Begin>0</Begin>
        <End>40</End>
      </ColorZone>
      <ColorZone>
        <Color>green</Color>
        <Begin>15</Begin>
        <End>29.6</End>
      </ColorZone>
    </Gauge>

    <Gauge>
      <Type>Circular</Type>
      <ID>Piston_RPMGauge</ID>
      <Title></Title>
      <Unit>RPM</Unit>
      <Minimum>0</Minimum>
      <Maximum>3000</Maximum>
      <Style>
        <TextIncrement>10</TextIncrement>
      </Style>
      <Value>
        <Simvar name="PROP RPM:1" unit="rpm"/>
      </Value>
      <ColorZone>
        <Color>white</Color>
        <Begin>0</Begin>
        <End>3000</End>
      </ColorZone>
      <ColorZone>
        <Color>green</Color>
        <Begin>1800</Begin>
        <End>2700</End>
      </ColorZone>
      <ColorZone>
        <Color>red</Color>
        <Begin>2700</Begin>
        <End>3000</End>
      </ColorZone>
      <RedBlink>
        <Greater>
          <Simvar name="PROP RPM:1" unit="rpm"/>
          <Constant>2700</Constant>
        </Greater>
      </RedBlink>
    </Gauge>

    <Text>
      <Left>FFlow GPH</Left>
      <Right>
        <ToFixed precision="1">
          <Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
        </ToFixed>
      </Right>
    </Text>

    <Gauge>
      <Type>Cylinder</Type>
      <ID>EGT_Gauge</ID>
      <Title>EGT</Title>
      <Unit>°F</Unit>
      <Rows>13</Rows>
      <Columns>6</Columns>
      <Minimum>800</Minimum>
      <Maximum>1300</Maximum>
      <TempOrder>1,4,2,5,3,6</TempOrder>
      <Value>
        <Simvar name="GENERAL ENG EXHAUST GAS TEMPERATURE:1" unit="farenheit"/>
      </Value>
      <Style>
        <ShowPeak>True</ShowPeak>
        <TextIncrement>5</TextIncrement>
      </Style>
    </Gauge>

    <Gauge>
      <Type>Cylinder</Type>
      <ID>CHT_Gauge</ID>
      <Title>CHT</Title>
      <Unit>°F</Unit>
      <Rows>13</Rows>
      <Columns>6</Columns>
      <Minimum>200</Minimum>
      <Maximum>500</Maximum>
      <TempOrder>1,4,2,5,3,6</TempOrder>
      <Value>
        <Simvar name="ENG CYLINDER HEAD TEMPERATURE:1" unit="farenheit"/>
      </Value>
      <Style>
        <ShowRedline>True</ShowRedline>
        <TextIncrement>5</TextIncrement>
      </Style>
    </Gauge>
  </LeanPage>

  <SystemPage>
    <Gauge>
      <Type>Circular</Type>
      <ID>MANIN_Gauge</ID>
      <Title>MAN IN</Title>
      <Minimum>0</Minimum>
      <Maximum>40</Maximum>
      <Value>
        <Simvar name="RECIP ENG MANIFOLD PRESSURE:1" unit="inHG"/>
      </Value>
      <ColorZone>
        <Color>white</Color>
        <Begin>0</Begin>
        <End>40</End>
      </ColorZone>
      <ColorZone>
        <Color>green</Color>
        <Begin>15</Begin>
        <End>29.6</End>
      </ColorZone>
    </Gauge>

    <Gauge>
      <Type>Circular</Type>
      <ID>Piston_RPMGauge</ID>
      <Title></Title>
      <Unit>RPM</Unit>
      <Minimum>0</Minimum>
      <Maximum>3000</Maximum>
      <Style>
        <TextIncrement>10</TextIncrement>
      </Style>
      <Value>
        <Simvar name="PROP RPM:1" unit="rpm"/>
      </Value>
      <ColorZone>
        <Color>white</Color>
        <Begin>0</Begin>
        <End>3000</End>
      </ColorZone>
      <ColorZone>
        <Color>green</Color>
        <Begin>1800</Begin>
        <End>2700</End>
      </ColorZone>
      <ColorZone>
        <Color>red</Color>
        <Begin>2700</Begin>
        <End>3000</End>
      </ColorZone>
      <RedBlink>
        <Greater>
          <Simvar name="PROP RPM:1" unit="rpm"/>
          <Constant>2700</Constant>
        </Greater>
      </RedBlink>
    </Gauge>

    <Text>
      <Style>
        <Margins>
          <Top>10</Top>
        </Margins>
      </Style>
      <Left>----------</Left>
      <Center>System</Center>
      <Right>----------</Right>
    </Text>

    <Text>
      <Left>Oil °F</Left>
      <Right>
        <ToFixed precision="0">
          <Simvar name="GENERAL ENG OIL TEMPERATURE:1" unit="farenheit"/>
        </ToFixed>
      </Right>
    </Text>
    <Text>
      <Left>Oil PSI</Left>
      <Right>
        <ToFixed precision="1">
          <Simvar name="GENERAL ENG OIL PRESSURE:1" unit="psi"/>
        </ToFixed>
      </Right>
    </Text>

    <Text>
      <Style>
        <Margins>
          <Top>10</Top>
        </Margins>
      </Style>
      <Left>--------</Left>
      <Center>Fuel Calc</Center>
      <Right>--------</Right>
    </Text>

    <Text>
      <Left>FFlow GPH</Left>
      <Right>
        <ToFixed precision="1">
          <Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
        </ToFixed>
      </Right>
    </Text>

    <Text>
      <Left>Gal Rem</Left>
      <Right>
        <ToFixed precision="1">
          <Simvar name="L:WT1000_Fuel_GalRemaining" unit="gallon"/>
        </ToFixed>
      </Right>
    </Text>

    <Text>
      <Left>Gal Used</Left>
      <Right>
        <ToFixed precision="1">
          <Simvar name="L:WT1000_Fuel_GalBurned" unit="gallon"/>
        </ToFixed>
      </Right>
    </Text>

    <Text>
      <Left>Endur</Left>
      <Right>
        <If>
          <Condition>
            <Greater>
              <Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
              <Constant>0.1</Constant>
            </Greater>
          </Condition>
          <Then>
            <Add>
              <ToFixed precision="2">
                <Divide>
                  <Simvar name="L:WT1000_Fuel_GalRemaining" unit="gallon"/>
                  <Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
                </Divide>
              </ToFixed>
              <Constant>h</Constant>
            </Add>
          </Then>
          <Else>
            <Constant>X</Constant>
          </Else>
        </If>
      </Right>
    </Text>

    <Text>
      <Left>Range NM</Left>
      <Right>
        <If>
          <Condition>
            <Greater>
              <Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
              <Constant>0.1</Constant>
            </Greater>
          </Condition>
          <Then>
            <ToFixed precision="0">
              <Multiply>
                <Simvar name="GROUND VELOCITY:1" unit="knots"/>
                <Divide>
                  <Simvar name="L:WT1000_Fuel_GalRemaining" unit="gallon"/>
                  <Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
                </Divide>
              </Multiply>
            </ToFixed>
          </Then>
          <Else>
            <Constant>X</Constant>
          </Else>
        </If>
      </Right>
    </Text>

    <Text>
      <Style>
        <Margins>
          <Top>10</Top>
        </Margins>
      </Style>
      <Left>--------</Left>
      <Center>Electrical</Center>
      <Right>--------</Right>
    </Text>

    <Text>
      <Left>1</Left>
      <Center>Alt Load</Center>
      <Right>2</Right>
    </Text>

    <Text>
      <Left>
        <ToFixed precision="0">
          <Simvar name="ELECTRICAL GENALT BUS AMPS:1" unit="amps"/>
        </ToFixed>
      </Left>
      <Right>
        <ToFixed precision="0">
          <Simvar name="ELECTRICAL GENALT BUS AMPS:2" unit="amps"/>
        </ToFixed>
      </Right>
    </Text>

    <Text>
      <Left>1</Left>
      <Center>Bus Volts</Center>
      <Right>2</Right>
    </Text>

    <Text>
      <Left>
        <ToFixed precision="1">
          <Simvar name="ELECTRICAL MAIN BUS VOLTAGE:1" unit="volts"/>
        </ToFixed>
      </Left>
      <Right>
        <ToFixed precision="1">
          <Simvar name="ELECTRICAL MAIN BUS VOLTAGE:2" unit="volts"/>
        </ToFixed>
      </Right>
    </Text>
  </SystemPage>
</EngineDisplay>
`;

const xmlConfig$1 = `
<EngineDisplay>
	<EnginePage>
		<Gauge>
			<Type>DoubleVertical</Type>
			<Style>
				<Height>70</Height>
			</Style>
			<ID>Piston_ManifoldGauge</ID>
			<Title>MAN</Title>
			<Unit></Unit>
			<Minimum>10</Minimum>
			<Maximum>35</Maximum>
			<Value>
				<Simvar name="ENG MANIFOLD PRESSURE:1" unit="inHg"/>
			</Value>
			<Value2>
				<Simvar name="ENG MANIFOLD PRESSURE:2" unit="inHg"/>
			</Value2>
			<ColorZone>
				<Color>white</Color>
				<Begin>10</Begin>
				<End>15</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>15</Begin>
				<End>29.6</End>
			</ColorZone>
			<ColorZone>
				<Color>white</Color>
				<Begin>29.6</Begin>
				<End>35</End>
			</ColorZone>
			<GraduationLength text="False">5</GraduationLength>
		</Gauge>

		<Gauge>
			<Type>DoubleVertical</Type>
			<Style>
				<Height>70</Height>
				<TextIncrement>10</TextIncrement>
			</Style>
			<ID>Piston_RPMGauge</ID>
			<Title></Title>
			<Unit>RPM</Unit>
			<Minimum>0</Minimum>
			<Maximum>3000</Maximum>
			<Value>
				<Simvar name="PROP RPM:1" unit="rpm"/>
			</Value>
			<Value2>
				<Simvar name="PROP RPM:2" unit="rpm"/>
			</Value2>
			<ColorZone>
				<Color>white</Color>
				<Begin>0</Begin>
				<End>1800</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>1800</Begin>
				<End>2700</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>2700</Begin>
				<End>3000</End>
			</ColorZone>
			<GraduationLength text="False">500</GraduationLength>
		</Gauge>

		<Text>
			<Center>FFLOW</Center>
		</Text>

		<Text>
			<Left>
				<ToFixed precision="1">
					<Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
				</ToFixed>
			</Left>
			<Center>GPH</Center>
			<Right>
				<ToFixed precision="1">
					<Simvar name="ENG FUEL FLOW GPH:2" unit="gallons per hour"/>
				</ToFixed>
			</Right>
		</Text>

		<Gauge>
			<Type>DoubleHorizontal</Type>
			<ID>Piston_FuelFlow</ID>
			<Title></Title>
			<Unit></Unit>
			<CursorText>L</CursorText>
			<CursorText2>R</CursorText2>
			<Minimum>0</Minimum>			<!-- Not Sure -->
			<Maximum>30</Maximum>			<!-- Not Sure -->
			<Value>
				<Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
			</Value>
			<Value2>
				<Simvar name="ENG FUEL FLOW GPH:2" unit="gallons per hour"/>
			</Value2>
			<ColorZone>
				<Color>green</Color>
				<Begin>3</Begin>
				<End>27.4</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>27.4</Begin>
				<End>30</End>				<!-- Not Sure -->
			</ColorZone>
			<GraduationLength text="False">5</GraduationLength>
		</Gauge>

		<Gauge>
			<Type>DoubleHorizontal</Type>
			<ID>Piston_CylinderHeadTemp</ID>
			<Title>CHT</Title>
			<Unit></Unit>
			<CursorText>L</CursorText>
			<CursorText2>R</CursorText2>
			<Minimum>0</Minimum>			<!-- Not Sure -->
			<Maximum>250</Maximum>			<!-- Not Sure -->
			<Value>
				<Simvar name="ENG CYLINDER HEAD TEMPERATURE:1" unit="celsius"/>
			</Value>
			<Value2>
				<Simvar name="ENG CYLINDER HEAD TEMPERATURE:2" unit="celsius"/>
			</Value2>
			<ColorZone>
				<Color>green</Color>
				<Begin>116</Begin>
				<End>238</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>238</Begin>
				<End>250</End>				<!-- Not Sure -->
			</ColorZone>
			<BeginText></BeginText>
			<EndText></EndText>
		</Gauge>

		<Gauge>
			<Type>DoubleHorizontal</Type>
			<ID>Piston_OilTempGauge</ID>
			<Title>Oil Temp</Title>
			<Unit></Unit>
			<CursorText>L</CursorText>
			<CursorText2>R</CursorText2>
			<Minimum>0</Minimum>			<!-- Not Sure -->
			<Maximum>120</Maximum>			<!-- Not Sure -->
			<Value>
				<Simvar name="GENERAL ENG OIL TEMPERATURE:1" unit="celsius"/>
			</Value>
			<Value2>
				<Simvar name="GENERAL ENG OIL TEMPERATURE:2" unit="celsius"/>
			</Value2>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>0</Begin>
				<End>24</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>24</Begin>
				<End>116</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>116</Begin>
				<End>120</End>				<!-- Not Sure -->
			</ColorZone>
			<BeginText></BeginText>
			<EndText></EndText>
		</Gauge>

		<Gauge>
			<Type>DoubleHorizontal</Type>
			<ID>Piston_OilPressGauge</ID>
			<Title>Oil Pres</Title>
			<Unit></Unit>
			<CursorText>L</CursorText>
			<CursorText2>R</CursorText2>
			<Minimum>0</Minimum>			<!-- Not Sure -->
			<Maximum>200</Maximum>			<!-- Not Sure -->
			<Value>
				<Simvar name="GENERAL ENG OIL PRESSURE:1" unit="psi"/>
			</Value>
			<Value2>
				<Simvar name="GENERAL ENG OIL PRESSURE:2" unit="psi"/>
			</Value2>
			<ColorZone>
				<Color>red</Color>
				<Begin>0</Begin>				<!-- Not Sure -->
				<End>10</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>10</Begin>
				<End>30</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>30</Begin>
				<End>60</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>100</Begin>
				<End>105</End>				<!-- Not Sure -->
			</ColorZone>
			<BeginText></BeginText>
			<EndText></EndText>
		</Gauge>

		<Gauge>
			<Type>DoubleHorizontal</Type>
			<ID>Piston_AlternatorLoad</ID>
			<Title>Alt Load</Title>
			<Unit></Unit>
			<CursorText>L</CursorText>
			<CursorText2>R</CursorText2>
			<Minimum>0</Minimum>			<!-- Not Sure -->
			<Maximum>110</Maximum>			<!-- Not Sure -->
			<Value>
				<Simvar name="ELECTRICAL GENALT BUS AMPS:1" unit="amps"/>
			</Value>
			<Value2>
				<Simvar name="ELECTRICAL GENALT BUS AMPS:2" unit="amps"/>
			</Value2>
			<ColorZone>
				<Color>green</Color>
				<Begin>0</Begin>
				<End>100</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>100</Begin>
				<End>110</End>
			</ColorZone>
			<BeginText></BeginText>
			<EndText></EndText>
		</Gauge>

		<Gauge>
			<Type>DoubleHorizontal</Type>
			<ID>Piston_FuelGauge</ID>
			<Title>Fuel Qty</Title>
			<Unit>Gal</Unit>
			<CursorText>L</CursorText>
			<CursorText2>R</CursorText2>
			<Minimum>0</Minimum>
			<Maximum>75</Maximum>
			<Value>
				<Simvar name="FUEL LEFT QUANTITY" unit="gallons"/>
			</Value>
			<Value2>
				<Simvar name="FUEL RIGHT QUANTITY" unit="gallons"/>
			</Value2>
			<ColorZone>
				<Color>red</Color>
				<Begin>0</Begin>
				<End>1</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>1</Begin>
				<End>13</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>13</Begin>
				<End>75</End>
			</ColorZone>
			<GraduationLength text="False">10</GraduationLength>
		</Gauge>
	</EnginePage>

	<LeanPage>
		<Gauge>
			<Type>DoubleVertical</Type>
			<Style>
				<Height>70</Height>
			</Style>
			<ID>Piston_ManifoldGauge</ID>
			<Title>MAN</Title>
			<Unit></Unit>
			<Minimum>10</Minimum>
			<Maximum>35</Maximum>
			<Value>
				<Simvar name="ENG MANIFOLD PRESSURE:1" unit="inHg"/>
			</Value>
			<Value2>
				<Simvar name="ENG MANIFOLD PRESSURE:2" unit="inHg"/>
			</Value2>
			<ColorZone>
				<Color>white</Color>
				<Begin>10</Begin>
				<End>15</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>15</Begin>
				<End>29.6</End>
			</ColorZone>
			<ColorZone>
				<Color>white</Color>
				<Begin>29.6</Begin>
				<End>35</End>
			</ColorZone>
			<GraduationLength text="False">5</GraduationLength>
		</Gauge>

		<Gauge>
			<Type>DoubleVertical</Type>
			<Style>
				<Height>70</Height>
				<TextIncrement>10</TextIncrement>
			</Style>
			<ID>Piston_RPMGauge</ID>
			<Title></Title>
			<Unit>RPM</Unit>
			<Minimum>0</Minimum>
			<Maximum>3000</Maximum>
			<Value>
				<Simvar name="PROP RPM:1" unit="rpm"/>
			</Value>
			<Value2>
				<Simvar name="PROP RPM:2" unit="rpm"/>
			</Value2>
			<ColorZone>
				<Color>white</Color>
				<Begin>0</Begin>
				<End>1800</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>1800</Begin>
				<End>2700</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>2700</Begin>
				<End>3000</End>
			</ColorZone>
			<GraduationLength text="False">500</GraduationLength>
		</Gauge>

		<Text>
			<Center>FFLOW</Center>
		</Text>

		<Text>
			<Left>
				<ToFixed precision="1">
					<Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
				</ToFixed>
			</Left>
			<Center>GPH</Center>
			<Right>
				<ToFixed precision="1">
					<Simvar name="ENG FUEL FLOW GPH:2" unit="gallons per hour"/>
				</ToFixed>
			</Right>
		</Text>

		<Gauge>
			<Type>TwinCylinder</Type>
			<Style>
				<Margins>
					<Bottom>10</Bottom>
				</Margins>
			</Style>
			<ID>EGT_Gauge</ID>
			<Title>EGT</Title>
			<Unit>°F</Unit>
			<Rows>13</Rows>
			<Columns>6</Columns>
			<Minimum>1300</Minimum>
			<Maximum>1600</Maximum>
			<TempOrder>1,4,2,5,3,6</TempOrder>
			<Value>
				<Simvar name="GENERAL ENG EXHAUST GAS TEMPERATURE:1" unit="farenheit"/>
			</Value>
			<Value2>
				<Simvar name="GENERAL ENG EXHAUST GAS TEMPERATURE:2" unit="farenheit"/>
			</Value2>
			<Style>
				<ShowPeak>True</ShowPeak>
				<TextIncrement>5</TextIncrement>
			</Style>
		</Gauge>

		<Gauge>
			<Type>TwinCylinder</Type>
			<ID>CHT_Gauge</ID>
			<Title>CHT</Title>
			<Unit>°F</Unit>
			<Rows>13</Rows>
			<Columns>6</Columns>
			<Minimum>200</Minimum>
			<Maximum>500</Maximum>
			<TempOrder>1,4,2,5,3,6</TempOrder>
			<Value>
				<Simvar name="ENG CYLINDER HEAD TEMPERATURE:1" unit="farenheit"/>
			</Value>
			<Value2>
				<Simvar name="ENG CYLINDER HEAD TEMPERATURE:2" unit="farenheit"/>
			</Value2>
			<Style>
				<ShowPeak>True</ShowPeak>
				<TextIncrement>5</TextIncrement>
			</Style>
		</Gauge>
	</LeanPage>

	<SystemPage>
		<Gauge>
			<Type>DoubleVertical</Type>
			<Style>
				<Height>70</Height>
			</Style>
			<ID>Piston_ManifoldGauge</ID>
			<Title>MAN</Title>
			<Unit></Unit>
			<Minimum>10</Minimum>
			<Maximum>35</Maximum>
			<Value>
				<Simvar name="ENG MANIFOLD PRESSURE:1" unit="inHg"/>
			</Value>
			<Value2>
				<Simvar name="ENG MANIFOLD PRESSURE:2" unit="inHg"/>
			</Value2>
			<ColorZone>
				<Color>white</Color>
				<Begin>10</Begin>
				<End>15</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>15</Begin>
				<End>29.6</End>
			</ColorZone>
			<ColorZone>
				<Color>white</Color>
				<Begin>29.6</Begin>
				<End>35</End>
			</ColorZone>
			<GraduationLength text="False">5</GraduationLength>
		</Gauge>

		<Gauge>
			<Type>DoubleVertical</Type>
			<Style>
				<Height>70</Height>
				<TextIncrement>10</TextIncrement>
			</Style>
			<ID>Piston_RPMGauge</ID>
			<Title></Title>
			<Unit>RPM</Unit>
			<Minimum>0</Minimum>
			<Maximum>3000</Maximum>
			<Value>
				<Simvar name="PROP RPM:1" unit="rpm"/>
			</Value>
			<Value2>
				<Simvar name="PROP RPM:2" unit="rpm"/>
			</Value2>
			<ColorZone>
				<Color>white</Color>
				<Begin>0</Begin>
				<End>1800</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>1800</Begin>
				<End>2700</End>
			</ColorZone>
			<ColorZone>
				<Color>red</Color>
				<Begin>2700</Begin>
				<End>3000</End>
			</ColorZone>
			<GraduationLength text="False">500</GraduationLength>
		</Gauge>

		<Text>
			<Left>----------</Left>
			<Center>System</Center>
			<Right>----------</Right>
		</Text>

		<Text>
			<Left>L</Left>
			<Center>Oil</Center>
			<Right>R</Right>
		</Text>

		<Text>
			<Left>
				<ToFixed precision="0">
					<Simvar name="GENERAL ENG OIL TEMPERATURE:1" unit="farenheit"/>
				</ToFixed>
			</Left>
			<Center>°F</Center>
			<Right>
				<ToFixed precision="0">
					<Simvar name="GENERAL ENG OIL TEMPERATURE:2" unit="farenheit"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Center>PSI</Center>
		</Text>

		<Text>
			<Left>
				<ToFixed precision="1">
					<Simvar name="GENERAL ENG OIL PRESSURE:1" unit="psi"/>
				</ToFixed>
			</Left>
			<Right>
				<ToFixed precision="1">
					<Simvar name="GENERAL ENG OIL PRESSURE:1" unit="psi"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left>--------</Left>
			<Center>Fuel Calc</Center>
			<Right>--------</Right>
		</Text>

		<Text>
			<Left>Gal Rem</Left>
			<Right>
				<ToFixed precision="1">
					<Simvar name="L:WT1000_Fuel_GalRemaining" unit="gallon"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left>Gal Used</Left>
			<Right>
				<ToFixed precision="1">
					<Simvar name="L:WT1000_Fuel_GalBurned" unit="gallon"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left>--------</Left>
			<Center>Electrical</Center>
			<Right>--------</Right>
		</Text>

		<Text>
			<Left>L</Left>
			<Center>Alt Load</Center>
			<Right>R</Right>
		</Text>

		<Text>
			<Left>
				<ToFixed precision="0">
					<Simvar name="ELECTRICAL GENALT BUS AMPS:1" unit="amps"/>
				</ToFixed>
			</Left>
			<Right>
				<ToFixed precision="0">
					<Simvar name="ELECTRICAL GENALT BUS AMPS:2" unit="amps"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left>L</Left>
			<Center>Bus Volts</Center>
			<Right>R</Right>
		</Text>

		<Text>
			<Left>
				<ToFixed precision="1">
					<Simvar name="ELECTRICAL MAIN BUS VOLTAGE:1" unit="volts"/>
				</ToFixed>
			</Left>
			<Right>
				<ToFixed precision="1">
					<Simvar name="ELECTRICAL MAIN BUS VOLTAGE:2" unit="volts"/>
				</ToFixed>
			</Right>
		</Text>
	</SystemPage>
</EngineDisplay>
`;

const xmlConfig = `
<EngineDisplay>
	<EnginePage>
		<Gauge>
			<Type>Circular</Type>
			<Style>
				<Margins>
					<Top>10</Top>
				</Margins>
			</Style>
			<ID>PWRGauge</ID>
			<Style>
				<BeginAngle>0</BeginAngle>
				<EndAngle>145</EndAngle>
				<CursorType>Triangle</CursorType>
				<ValuePos>End</ValuePos>
			</Style>
			<Title/>
			<Unit>% Pwr</Unit>
			<Minimum>0</Minimum>
			<Maximum>100</Maximum>
			<Value>
				<Max>
					<Min>
						<Multiply>
							<Divide>
								<Multiply>
									<Simvar name="ENG TORQUE:1" unit="Foot pounds"/>
									<Divide>
										<Simvar name="GENERAL ENG RPM:1" unit="rpm"/>
										<Constant>5252</Constant>
									</Divide>
									<Constant>550</Constant>
								</Multiply>
								<Divide>
									<Gamevar name="AIRCRAFT MAX RATED HP" unit="ft lb per second"/>
									<Simvar name="NUMBER OF ENGINES" unit="number"/>
								</Divide>
							</Divide>
							<Constant>100</Constant>
						</Multiply>
						<Constant>100</Constant>
					</Min>
					<Constant>0</Constant>
				</Max>
			</Value>
			<ColorZone>
				<Color>green</Color>
				<Begin>0</Begin>
				<End>100</End>
			</ColorZone>
			<BeginText></BeginText>
			<EndText></EndText>
		</Gauge>

		<Text>
			<Left>RPM</Left>
			<Right>
				<ToFixed precision="0">
					<Simvar name="GENERAL ENG RPM:1" unit="rpm"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left>Man "Hg</Left>
			<Right>
				<ToFixed precision="1">
					<Simvar name="RECIP ENG MANIFOLD PRESSURE:1" unit="inHG"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Center>----------------------------------</Center>
		</Text>

		<Gauge>
			<Type>DoubleHorizontal</Type>
			<ID>Piston_FuelGauge</ID>
			<Title>Fuel Qty</Title>
			<Unit>Gal</Unit>
			<CursorText>R</CursorText>
			<CursorText2>L</CursorText2>
			<Minimum>0</Minimum>
			<Maximum>30</Maximum>
			<Value>
				<Simvar name="FUEL RIGHT QUANTITY" unit="gallons"/>
			</Value>
			<Value2>
				<Simvar name="FUEL LEFT QUANTITY" unit="gallons"/>
			</Value2>
			<ColorZone>
				<Color>red</Color>
				<Begin>0</Begin>
				<End>1.5</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>1.5</Begin>
				<End>5</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>5</Begin>
				<End>24</End>
			</ColorZone>
			<GraduationLength text="True">10</GraduationLength>
			<EndText>F</EndText>
		</Gauge>

		<Gauge>
			<Type>Horizontal</Type>
			<ID>FuelFlow_Gauge</ID>
			<Title>Fuel Flow</Title>
			<Unit>GPH</Unit>
			<Minimum>0</Minimum>
			<Maximum>30</Maximum>
			<Style>
				<ValuePos>End</ValuePos>
			</Style>
			<Value>
				<Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
			</Value>
			<ColorZone>
				<Begin>10</Begin>
				<End>20</End>
				<Color>green</Color>
			</ColorZone>
			<BeginText/>
			<EndText/>
		</Gauge>

		<Text>
			<Left fontsize="10">Gal Used</Left>
			<Right fontsize="10">
				<ToFixed precision="1">
					<Simvar name="L:WT1000_Fuel_GalBurned" unit="gallon"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Center>----------------------------------</Center>
		</Text>

		<Gauge>
			<Type>Horizontal</Type>
			<ID>OilTemp_Gauge</ID>
			<Title>Oil</Title>
			<Unit>°F</Unit>
			<Minimum>50</Minimum>
			<Maximum>245</Maximum>
			<Style>
				<ValuePos>End</ValuePos>
			</Style>
			<Value>
				<Simvar name="GENERAL ENG OIL TEMPERATURE:1" unit="farenheit"/>
			</Value>
			<ColorZone>
				<Color>green</Color>
				<Begin>100</Begin>
				<End>240</End>
			</ColorZone>
			<ColorLine>
				<Color>red</Color>
				<Position>240</Position>
			</ColorLine>
			<BeginText/>
			<EndText/>
			<RedBlink>
				<Greater>
					<Simvar name="GENERAL ENG OIL TEMPERATURE:1" unit="farenheit"/>
					<Constant>240</Constant>
				</Greater>
			</RedBlink>
		</Gauge>

		<Gauge>
			<Type>Horizontal</Type>
			<ID>OilPsi_Gauge</ID>
			<Title>Oil</Title>
			<Unit>PSI</Unit>
			<Minimum>0</Minimum>
			<Maximum>102</Maximum>			<!-- Not Sure -->
			<Style>
				<ValuePos>End</ValuePos>
			</Style>
			<Value>
				<Simvar name="GENERAL ENG OIL PRESSURE:1" unit="psi"/>
			</Value>
			<ColorLine>
				<Color>red</Color>
				<Position>10</Position>
			</ColorLine>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>10</Begin>
				<End>30</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>30</Begin>
				<End>60</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>60</Begin>
				<End>100</End>
			</ColorZone>
			<ColorLine>
				<Color>red</Color>
				<Position>100</Position>
			</ColorLine>
			<BeginText></BeginText>
			<EndText></EndText>
			<RedBlink>
				<Or>
					<Greater>
						<Simvar name="GENERAL ENG OIL PRESSURE:1" unit="psi"/>
						<Constant>115</Constant>
					</Greater>
					<Lower>
						<Simvar name="GENERAL ENG OIL PRESSURE:1" unit="psi"/>
						<Constant>25</Constant>
					</Lower>
				</Or>
			</RedBlink>
		</Gauge>

		<Text>
			<Center>----------------------------------</Center>
		</Text>

		<Text>
			<Left fontsize="10">Batt1 A</Left>
			<Right fontsize="10">
				<ToFixed precision="0">
					<Substract>
						<Constant>0</Constant>
						<Simvar name="ELECTRICAL BATTERY LOAD" unit="Amperes"/>
					</Substract>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left fontsize="10">Ess Bus V</Left>
			<Right fontsize="10">
				<ToFixed precision="1">
					<Simvar name="ELECTRICAL MAIN BUS VOLTAGE:2" unit="volts"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Center>----------------------------------</Center>
		</Text>

		<Text>
			<Left>CHT °F</Left>
			<Right>
				<ToFixed precision="0">
					<Simvar name="ENG CYLINDER HEAD TEMPERATURE:1" unit="farenheit"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left>EGT °F</Left>
			<Right>
				<ToFixed precision="0">
					<Simvar name="ENG EXHAUST GAS TEMPERATURE:1" unit="farenheit"/>
				</ToFixed>
			</Right>
		</Text>
	</EnginePage>

	<LeanPage>
		<Gauge>
			<Type>Circular</Type>
			<ID>PWRGauge</ID>
			<Style>
				<BeginAngle>0</BeginAngle>
				<EndAngle>145</EndAngle>
				<CursorType>Triangle</CursorType>
				<ValuePos>End</ValuePos>
			</Style>
			<Title/>
			<Unit>% Pwr</Unit>
			<Minimum>0</Minimum>
			<Maximum>100</Maximum>
			<Value>
				<Max>
					<Min>
						<Multiply>
							<Divide>
								<Multiply>
									<Simvar name="ENG TORQUE:1" unit="Foot pounds"/>
									<Divide>
										<Simvar name="GENERAL ENG RPM:1" unit="rpm"/>
										<Constant>5252</Constant>
									</Divide>
									<Constant>550</Constant>
								</Multiply>
								<Divide>
									<Gamevar name="AIRCRAFT MAX RATED HP" unit="ft lb per second"/>
									<Simvar name="NUMBER OF ENGINES" unit="number"/>
								</Divide>
							</Divide>
							<Constant>100</Constant>
						</Multiply>
						<Constant>100</Constant>
					</Min>
					<Constant>0</Constant>
				</Max>
			</Value>
			<ColorZone>
				<Color>green</Color>
				<Begin>0</Begin>
				<End>100</End>
			</ColorZone>
			<BeginText></BeginText>
			<EndText></EndText>
		</Gauge>

		<Gauge>
			<Type>Cylinder</Type>
			<Style>
				<Margins>
					<Top>10</Top>
				</Margins>
			</Style>
			<ID>EGT_Gauge</ID>
			<Title>EGT</Title>
			<Unit>°F</Unit>
			<Rows>13</Rows>
			<Columns>6</Columns>
			<Minimum>800</Minimum>
			<Maximum>1300</Maximum>
			<TempOrder>1,4,2,5,3,6</TempOrder>
			<Value>
				<Simvar name="GENERAL ENG EXHAUST GAS TEMPERATURE:1" unit="farenheit"/>
			</Value>
			<Style>
				<ShowPeak>True</ShowPeak>
				<TextIncrement>5</TextIncrement>
			</Style>
		</Gauge>

		<Gauge>
			<Type>Cylinder</Type>
			<ID>CHT_Gauge</ID>
			<Title>CHT</Title>
			<Unit>°F</Unit>
			<Rows>13</Rows>
			<Columns>6</Columns>
			<Minimum>200</Minimum>
			<Maximum>500</Maximum>
			<TempOrder>1,4,2,5,3,6</TempOrder>
			<Value>
				<Simvar name="ENG CYLINDER HEAD TEMPERATURE:1" unit="farenheit"/>
			</Value>
			<Style>
				<ShowRedline>True</ShowRedline>
				<TextIncrement>5</TextIncrement>
			</Style>
		</Gauge>

		<Text>
			<Left fontsize="10">Fuel GPH</Left>
			<Right fontsize="10">
				<ToFixed precision="1">
					<Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
				</ToFixed>
			</Right>
		</Text>

		<Gauge>
			<Type>DoubleHorizontal</Type>
			<ID>Piston_FuelGauge</ID>
			<Title>Fuel Qty</Title>
			<Unit>Gal</Unit>
			<CursorText>R</CursorText>
			<CursorText2>L</CursorText2>
			<Minimum>0</Minimum>
			<Maximum>30</Maximum>
			<Value>
				<Simvar name="FUEL RIGHT QUANTITY" unit="gallons"/>
			</Value>
			<Value2>
				<Simvar name="FUEL LEFT QUANTITY" unit="gallons"/>
			</Value2>
			<ColorZone>
				<Color>red</Color>
				<Begin>0</Begin>
				<End>1.5</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>1.5</Begin>
				<End>5</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>5</Begin>
				<End>24</End>
			</ColorZone>
			<GraduationLength text="True">10</GraduationLength>
			<EndText>F</EndText>
		</Gauge>
	</LeanPage>

	<SystemPage>
		<Gauge>
			<Type>Circular</Type>
			<ID>PWRGauge</ID>
			<Style>
				<BeginAngle>0</BeginAngle>
				<EndAngle>145</EndAngle>
				<CursorType>Triangle</CursorType>
				<ValuePos>End</ValuePos>
			</Style>
			<Title/>
			<Unit>% Pwr</Unit>
			<Minimum>0</Minimum>
			<Maximum>100</Maximum>
			<Value>
				<Max>
					<Min>
						<Multiply>
							<Divide>
								<Multiply>
									<Simvar name="ENG TORQUE:1" unit="Foot pounds"/>
									<Divide>
										<Simvar name="GENERAL ENG RPM:1" unit="rpm"/>
										<Constant>5252</Constant>
									</Divide>
									<Constant>550</Constant>
								</Multiply>
								<Divide>
									<Gamevar name="AIRCRAFT MAX RATED HP" unit="ft lb per second"/>
									<Simvar name="NUMBER OF ENGINES" unit="number"/>
								</Divide>
							</Divide>
							<Constant>100</Constant>
						</Multiply>
						<Constant>100</Constant>
					</Min>
					<Constant>0</Constant>
				</Max>
			</Value>
			<ColorZone>
				<Color>green</Color>
				<Begin>0</Begin>
				<End>100</End>
			</ColorZone>
			<BeginText></BeginText>
			<EndText></EndText>
		</Gauge>

		<Text>
			<Center>
				<Content>-</Content>
				<Color>black</Color>
			</Center>
		</Text>

		<Text>
			<Left fontsize="10">Oil PSI</Left>
			<Right fontsize="10">
				<ToFixed precision="1">
					<Simvar name="GENERAL ENG OIL PRESSURE:1" unit="psi"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left fontsize="10">Oil °F</Left>
			<Right fontsize="10">
				<ToFixed precision="1">
					<Simvar name="GENERAL ENG OIL TEMPERATURE:1" unit="farenheit"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Style>
				<Margins>
					<Top>20</Top>
				</Margins>
			</Style>
			<Left>---</Left>
			<Center>Fuel Calc</Center>
			<Right>---</Right>
		</Text>

		<Text>
			<Left fontsize="10">Fuel GPH</Left>
			<Right fontsize="10">
				<ToFixed precision="1">
					<Simvar name="ENG FUEL FLOW GPH:1" unit="gallons per hour"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left fontsize="10">Gal Used</Left>
			<Right fontsize="10">
				<ToFixed precision="1">
					<Simvar name="L:WT1000_Fuel_GalBurned" unit="gallon"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left fontsize="10">Gal Rem</Left>
			<Right fontsize="10">
				<ToFixed precision="1">
					<Simvar name="L:WT1000_Fuel_GalRemaining" unit="gallon"/>
				</ToFixed>
			</Right>
		</Text>

		<Gauge>
			<Type>DoubleHorizontal</Type>
			<ID>Piston_FuelGauge</ID>
			<Title>Fuel Qty</Title>
			<Unit>Gal</Unit>
			<CursorText>R</CursorText>
			<CursorText2>L</CursorText2>
			<Minimum>0</Minimum>
			<Maximum>30</Maximum>
			<Value>
				<Simvar name="FUEL RIGHT QUANTITY" unit="gallons"/>
			</Value>
			<Value2>
				<Simvar name="FUEL LEFT QUANTITY" unit="gallons"/>
			</Value2>
			<ColorZone>
				<Color>red</Color>
				<Begin>0</Begin>
				<End>1.5</End>
			</ColorZone>
			<ColorZone>
				<Color>yellow</Color>
				<Begin>1.5</Begin>
				<End>5</End>
			</ColorZone>
			<ColorZone>
				<Color>green</Color>
				<Begin>5</Begin>
				<End>24</End>
			</ColorZone>
			<GraduationLength text="True">10</GraduationLength>
			<EndText>F</EndText>
		</Gauge>

		<Text>
			<Style>
				<Margins>
					<Top>20</Top>
				</Margins>
			</Style>
			<Left>---</Left>
			<Center>Electrical</Center>
			<Right>--</Right>
		</Text>

		<Text>
			<Left>M</Left>
			<Center fontsize="8">Bus</Center>
			<Right>E</Right>
		</Text>

		<Text>
			<Left id="Piston_Bus_M">
				<ToFixed precision="1">
					<Simvar name="ELECTRICAL MAIN BUS VOLTAGE:3" unit="volts"/>
				</ToFixed>
			</Left>
			<Center fontsize="8">Volts</Center>
			<Right id="Piston_Bus_E">
				<ToFixed precision="1">
					<Simvar name="ELECTRICAL MAIN BUS VOLTAGE:6" unit="volts"/>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left>M</Left>
			<Center fontsize="8">Batt</Center>
			<Right>S</Right>
		</Text>

		<Text>
			<Left id="Piston_Batt_M">
				<ToFixed precision="0">
					<Substract>
						<Constant>0</Constant>
						<Simvar name="ELECTRICAL BATTERY LOAD:1" unit="amperes"/>
					</Substract>
				</ToFixed>
			</Left>
			<Center fontsize="8">Amps</Center>
			<Right id="Piston_Batt_S">
				<ToFixed precision="0">
					<Substract>
						<Constant>0</Constant>
						<Simvar name="ELECTRICAL BATTERY LOAD:2" unit="amperes"/>
					</Substract>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Style>
				<Margins>
					<Top>20</Top>
				</Margins>
			</Style>
			<Left>---</Left>
			<Center>Air Data</Center>
			<Right>--</Right>
		</Text>

		<Text>
			<Left fontsize="8">Density Alt</Left>
			<Right>
				<ToFixed precision="0">
					<Add>
						<Simvar name="PRESSURE ALTITUDE" unit="feet"/>
						<Multiply>
							<Constant>120</Constant>
							<Substract>
								<Simvar name="AMBIENT TEMPERATURE" unit="celsius"/>
								<Substract>
									<Constant>15</Constant>
									<Divide>
										<Simvar name="PRESSURE ALTITUDE" unit="feet"/>
										<Constant>500</Constant>
									</Divide>
								</Substract>
							</Substract>
						</Multiply>
					</Add>
				</ToFixed>
			</Right>
		</Text>

		<Text>
			<Left fontsize="8">OAT</Left>
			<Center>
				<ToFixed precision="0">
					<Simvar name="AMBIENT TEMPERATURE" unit="celsius"/>
				</ToFixed>
			</Center>
			<Right fontsize="8">°C</Right>
		</Text>

		<Text>
			<Left fontsize="8">ISA</Left>
			<Center>
				<ToFixed precision="0">
					<Substract>
						<Simvar name="AMBIENT TEMPERATURE" unit="celsius"/>
						<Substract>
							<Constant>15</Constant>
							<Divide>
								<Simvar name="PRESSURE ALTITUDE" unit="feet"/>
								<Constant>500</Constant>
							</Divide>
						</Substract>
					</Substract>
				</ToFixed>
			</Center>
			<Right fontsize="8">°C</Right>
		</Text>
	</SystemPage>
</EngineDisplay>
`;

/**
 * This is temporary code to allow the loading of new panel configurations for
 * default planes until we get these into SU6.
 */
class PanelLoader {
    /**
     * Create a panel loader.
     * @param factory A configured XML gauge factory.
     */
    constructor(factory) {
        this.parser = new DOMParser();
        this.panelMapping = new Map([
            ['TT:ATCCOM.AC_MODEL C172.0.text', xmlConfig$6],
            ['TT:ATCCOM.AC_MODEL C208.0.text', xmlConfig$5],
            ['TT:ATCCOM.AC_MODEL_DA40.0.text', xmlConfig$4],
            ['TT:ATCCOM.AC_MODEL_DA62.0.text', xmlConfig$3],
            ['TT:ATCCOM.AC_MODEL_BE36.0.text', xmlConfig$2],
            ['TT:ATCCOM.AC_MODEL_BE58.0.text', xmlConfig$1],
            ['TT:ATCCOM.AC_MODEL_SR22.0.text', xmlConfig],
        ]);
        this.factory = factory;
    }
    /**
     * Given an ATC model, load the corresponding panel configuration.
     * @param model The ATC model.
     * @returns A full XMLExtendedGaugeConfig object or undefined.
     */
    loadConfigForModel(model) {
        const config = this.panelMapping.get(model);
        if (config) {
            return this.factory.parseConfig(this.parser.parseFromString(config, 'application/xml'));
        }
    }
}

/**
 * A class that synchronizes the local NXi state to the sim GPS system.
 */
class GpsSynchronizer {
    /**
     * Creates an instance of GpsSynchronizer.
     * @param bus The bus to source events from.
     * @param flightPlanner An instance of the flight planner.
     * @param facLoader An instance of the facility loader.
     */
    constructor(bus, flightPlanner, facLoader) {
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.facLoader = facLoader;
        this.magvar = 0;
        this.distanceToCurrentLeg = -1;
        this.groundSpeed = 0;
        this.trueTrack = 0;
        this.zuluTime = 0;
        this.numPlanLegs = Subject.create(0);
        this.hasReachedDestination = Subject.create(false);
        this.isDestinationLegActive = Subject.create(false);
        this.isDirectToActive = Subject.create(false);
        const lnavVars = bus.getSubscriber();
        lnavVars.on('lnavDtkMag').handle(this.onDtkChanged.bind(this));
        lnavVars.on('lnavXtk').handle(this.onXtkChanged.bind(this));
        lnavVars.on('lnavDis').handle(this.onLnavDistanceChanged.bind(this));
        lnavVars.on('lnavBrgMag').handle(this.onLnavBearingChanged.bind(this));
        lnavVars.on('lnavDistanceToDestination').handle(this.onLnavDistanceToDestinationChanged.bind(this));
        const lnav = bus.getSubscriber();
        lnav.on('dataChanged').handle(this.onLNavDataChanged.bind(this));
        const adc = bus.getSubscriber();
        adc.on('magvar').handle(this.onMagvarChanged.bind(this));
        adc.on('hdg_deg_true').handle(this.onTrueHeadingChanged.bind(this));
        const vnav = bus.getSubscriber();
        vnav.on('vnavRequiredVs').handle(this.requiredVsChanged.bind(this));
        const gnss = bus.getSubscriber();
        gnss.on('gps-position').handle(this.onPositionChanged.bind(this));
        gnss.on('zulu_time').handle(t => this.zuluTime = t);
        gnss.on('track_deg_true').handle(this.onTrackTrueChanged.bind(this));
        gnss.on('ground_speed').handle(this.onGroundSpeedChanged.bind(this));
        const plan = bus.getSubscriber();
        plan.on('fplActiveLegChange').handle(() => {
            this.hasReachedDestination.set(false);
            if (this.flightPlanner.hasActiveFlightPlan()) {
                const activeFlightplan = this.flightPlanner.getActiveFlightPlan();
                this.checkDestinationLegActive(activeFlightplan);
                this.checkDirectToState(activeFlightplan);
                this.onIsPrevLegChanged(activeFlightplan);
                this.onWaypointIndexChanged(activeFlightplan);
            }
        });
        plan.on('fplSegmentChange').handle(this.onPlanSegmentChanged.bind(this));
        plan.on('fplIndexChanged').handle(this.onPlanSegmentChanged.bind(this));
        this.numPlanLegs.sub(this.onNumLegsChanged.bind(this));
    }
    /**
     * Updates the GpsSynchronizer.
     */
    update() {
        const isGpsOverridden = SimVar.GetSimVarValue('GPS OVERRIDDEN', SimVarValueType.Bool);
        if (!isGpsOverridden) {
            SimVar.SetSimVarValue('GPS OVERRIDDEN', SimVarValueType.Bool, true);
        }
        let numPlanLegs = 0;
        if (this.flightPlanner.hasActiveFlightPlan()) {
            const plan = this.flightPlanner.getActiveFlightPlan();
            numPlanLegs = plan.length;
        }
        this.numPlanLegs.set(numPlanLegs);
    }
    /**
     * Handles when the active plan segments are changed.
     */
    onPlanSegmentChanged() {
        const plan = this.flightPlanner.getActiveFlightPlan();
        const approachSegments = [...plan.segmentsOfType(FlightPlanSegmentType.Approach)];
        if (approachSegments && approachSegments.length > 0) {
            SimVar.SetSimVarValue('GPS IS APPROACH LOADED', SimVarValueType.Bool, true);
            //SimVar.SetSimVarValue('GPS APPROACH WP COUNT', SimVarValueType.Number, approachSegments[0].legs.length);
        }
        else {
            SimVar.SetSimVarValue('GPS IS APPROACH LOADED', SimVarValueType.Bool, false);
            //SimVar.SetSimVarValue('GPS APPROACH WP COUNT', SimVarValueType.Number, 0);
        }
        //SimVar.SetSimVarValue('GPS APPROACH APPROACH INDEX', SimVarValueType.Number, plan.procedureDetails.approachIndex);
        //SimVar.SetSimVarValue('GPS APPROACH TRANSITION INDEX', SimVarValueType.Number, plan.procedureDetails.approachTransitionIndex);
        this.checkApproachTypeAndTimezone(plan, plan.procedureDetails.approachIndex);
    }
    /**
     * Handles when LNAV data is changed.
     * @param lnavData The LNAV data to process.
     */
    onLNavDataChanged(lnavData) {
        SimVar.SetSimVarValue('GPS COURSE TO STEER', SimVarValueType.Degree, lnavData.courseToSteer);
        const currentLeg = lnavData.currentLeg;
        if (currentLeg !== undefined && currentLeg.calculated !== undefined) {
            SimVar.SetSimVarValue('GPS WP NEXT LAT', SimVarValueType.Degree, currentLeg.calculated.endLat);
            SimVar.SetSimVarValue('GPS WP NEXT LON', SimVarValueType.Degree, currentLeg.calculated.endLon);
        }
    }
    /**
     * Checks to see if we are in a direct to state.
     * @param plan The Active Flight Plan.
     */
    checkDirectToState(plan) {
        let isDirectToActive = false;
        if (plan.activeLateralLeg >= 0 && plan.activeLateralLeg < plan.length) {
            const activeLeg = plan.getLeg(plan.activeLateralLeg);
            isDirectToActive = activeLeg.isInDirectToSequence;
        }
        this.isDirectToActive.set(isDirectToActive);
    }
    /**
     * Checks to see if we have reached the plan destination.
     * @param plan The Active Flight Plan
     */
    checkDestinationLegActive(plan) {
        if (plan.length > 1) {
            const finalSegment = plan.getSegment(plan.getSegmentIndex(plan.length - 1));
            const isApproachActive = plan.activeLateralLeg >= finalSegment.offset && finalSegment.segmentType === FlightPlanSegmentType.Approach;
            SimVar.SetSimVarValue('GPS IS APPROACH ACTIVE', SimVarValueType.Bool, isApproachActive);
            let destinationLegIndex = plan.length - 1;
            let fafIndex = -1;
            if (isApproachActive) {
                for (let i = finalSegment.legs.length - 1; i >= 0; i--) {
                    const leg = finalSegment.legs[i];
                    if (!leg.isInMissedApproachSequence) {
                        destinationLegIndex = i + finalSegment.offset;
                    }
                    if (leg.leg.fixTypeFlags === FixTypeFlags.FAF) {
                        fafIndex = i + finalSegment.offset;
                        break;
                    }
                }
            }
            this.checkApproachMode(plan, isApproachActive, fafIndex);
            if (!this.hasReachedDestination.get() && destinationLegIndex === plan.activeLateralLeg) {
                this.isDestinationLegActive.set(true);
                return;
            }
        }
        else {
            this.checkApproachMode(plan, false, -1);
        }
        this.isDestinationLegActive.set(false);
    }
    /**
     * Checks the approach mode on leg change.
     * @param plan The Active Flight Plan.
     * @param isApproachActive Whether the approach is active.
     * @param fafIndex The destination leg index.
     */
    checkApproachMode(plan, isApproachActive, fafIndex) {
        let approachMode = 0;
        let currentLeg;
        if (isApproachActive && plan.activeLateralLeg >= 0 && plan.activeLateralLeg < plan.length) {
            currentLeg = plan.getLeg(plan.activeLateralLeg);
            if (currentLeg.isInMissedApproachSequence) {
                approachMode = 3;
            }
            else if (fafIndex > -1 && plan.activeLateralLeg >= fafIndex) {
                approachMode = 2;
            }
            else {
                approachMode = 1;
            }
        }
        this.checkApproachWaypointType(currentLeg);
        SimVar.SetSimVarValue('GPS APPROACH MODE', SimVarValueType.Number, approachMode);
        SimVar.SetSimVarValue('GPS APPROACH IS FINAL', SimVarValueType.Bool, approachMode === 2);
    }
    /**
     * Handles when the active leg index changes.
     * @param plan The Active Flight Plan.
     */
    onWaypointIndexChanged(plan) {
        var _a;
        if (plan.activeLateralLeg >= 0 && plan.activeLateralLeg < plan.length) {
            const leg = plan.getLeg(plan.activeLateralLeg);
            SimVar.SetSimVarValue('GPS WP NEXT ID', SimVarValueType.String, (_a = leg.name) !== null && _a !== void 0 ? _a : '');
            //SimVar.SetSimVarValue('GPS FLIGHT PLAN WP INDEX', SimVarValueType.Number, plan.activeLateralLeg);
        }
    }
    /**
     * Handles when the number of active plan legs changes.
     * @param numLegs The number of active plan legs.
     */
    onNumLegsChanged(numLegs) {
        SimVar.SetSimVarValue('GPS IS ACTIVE FLIGHT PLAN', SimVarValueType.Bool, numLegs > 0);
        SimVar.SetSimVarValue('GPS IS ACTIVE WAY POINT', SimVarValueType.Bool, numLegs > 1);
        //SimVar.SetSimVarValue('GPS FLIGHT PLAN WP COUNT', SimVarValueType.Number, numLegs);
        if (this.flightPlanner.hasActiveFlightPlan()) {
            const plan = this.flightPlanner.getActiveFlightPlan();
            this.onIsPrevLegChanged(plan);
        }
    }
    /**
     * Handles when the previous leg changes.
     * @param plan The Active Flight Plan
     */
    onIsPrevLegChanged(plan) {
        const numLegs = this.numPlanLegs.get();
        if (numLegs > 1 && plan.activeLateralLeg > 0 && plan.activeLateralLeg < plan.length) {
            SimVar.SetSimVarValue('GPS WP PREV VALID', SimVarValueType.Bool, true);
            const prevLeg = plan.getLeg(plan.activeLateralLeg - 1);
            if (prevLeg.calculated) {
                SimVar.SetSimVarValue('GPS WP PREV LAT', SimVarValueType.Degree, prevLeg.calculated.endLat);
                SimVar.SetSimVarValue('GPS WP PREV LON', SimVarValueType.Degree, prevLeg.calculated.endLon);
            }
        }
    }
    /**
     * Handles when the LNAV Distance to Destination Changes.
     * @param dis The new distance to destination.
     */
    onLnavDistanceToDestinationChanged(dis) {
        const eteSeconds = 3600 * dis / this.groundSpeed;
        SimVar.SetSimVarValue('GPS ETE', SimVarValueType.Seconds, eteSeconds);
        SimVar.SetSimVarValue('GPS ETA', SimVarValueType.Seconds, eteSeconds + this.zuluTime);
    }
    /**
     * Handles when the LNAV DTK changes.
     * @param dtk The new DTK.
     */
    onDtkChanged(dtk) {
        SimVar.SetSimVarValue('GPS WP DESIRED TRACK', SimVarValueType.Radians, UnitType.DEGREE.convertTo(dtk, UnitType.RADIAN));
    }
    /**
     * Handles when the LNAV XTK changes.
     * @param xtk The new XTK.
     */
    onXtkChanged(xtk) {
        SimVar.SetSimVarValue('GPS WP CROSS TRK', SimVarValueType.Meters, UnitType.NMILE.convertTo(xtk, UnitType.METER) * -1);
    }
    /**
     * Handles when the LNAV DIS to WP changes.
     * @param dis The distance.
     */
    onLnavDistanceChanged(dis) {
        if (this.isDestinationLegActive.get() && dis < 1000) {
            this.hasReachedDestination.set(true);
        }
        SimVar.SetSimVarValue('GPS WP DISTANCE', SimVarValueType.Meters, dis);
        const distanceNM = UnitType.METER.convertTo(dis, UnitType.NMILE);
        const eteSeconds = 3600 * distanceNM / this.groundSpeed;
        SimVar.SetSimVarValue('GPS WP ETE', SimVarValueType.Seconds, eteSeconds);
        SimVar.SetSimVarValue('GPS WP ETA', SimVarValueType.Seconds, eteSeconds + this.zuluTime);
    }
    /**
     * Handles when the LNAV Bearing to WP changes.
     * @param brg The bearing.
     */
    onLnavBearingChanged(brg) {
        SimVar.SetSimVarValue('GPS WP BEARING', SimVarValueType.Radians, UnitType.DEGREE.convertTo(brg, UnitType.RADIAN));
    }
    /**
     * Handles when the True Ground Track Changes.
     * @param trk The true track.
     */
    onTrackTrueChanged(trk) {
        SimVar.SetSimVarValue('GPS GROUND TRUE TRACK', SimVarValueType.Radians, UnitType.DEGREE.convertTo(trk, UnitType.RADIAN));
    }
    /**
     * Handles when the Ground Speed changes.
     * @param gs The current ground speed.
     */
    onGroundSpeedChanged(gs) {
        this.groundSpeed = gs;
        SimVar.SetSimVarValue('GPS GROUND SPEED', SimVarValueType.Knots, gs);
    }
    /**
     * Handles when the true heading changes.
     * @param hdg The true heading.
     */
    onTrueHeadingChanged(hdg) {
        SimVar.SetSimVarValue('GPS GROUND TRUE HEADING', SimVarValueType.Radians, UnitType.DEGREE.convertTo(hdg, UnitType.RADIAN));
    }
    /**
     * Handles when the magvar changes.
     * @param magvar The new magvar.
     */
    onMagvarChanged(magvar) {
        this.magvar = magvar;
        SimVar.SetSimVarValue('GPS MAGVAR', SimVarValueType.Radians, UnitType.DEGREE.convertTo(magvar, UnitType.RADIAN));
    }
    /**
     * Handles when the VNAV required VS changes.
     * @param vs The required vertical speed.
     */
    requiredVsChanged(vs) {
        SimVar.SetSimVarValue('GPS WP VERTICAL SPEED', SimVarValueType.FPM, vs);
    }
    /**
     * Handles when the plane position changes.
     * @param pos The new plane position.
     */
    onPositionChanged(pos) {
        SimVar.SetSimVarValue('GPS POSITION LAT', SimVarValueType.Degree, pos.lat);
        SimVar.SetSimVarValue('GPS POSITION LON', SimVarValueType.Degree, pos.long);
        SimVar.SetSimVarValue('GPS POSITION ALT', SimVarValueType.Feet, pos.alt);
    }
    /**
     * Handles checking the approach type and timezone.
     * @param plan The active flight plan.
     * @param approachIndex The approach index in the active plan.
     */
    async checkApproachTypeAndTimezone(plan, approachIndex) {
        let approachType = 0;
        if (approachIndex > -1 && plan.destinationAirport) {
            const facility = await this.facLoader.getFacility(FacilityType.Airport, plan.destinationAirport);
            const approachName = facility.approaches[approachIndex].name.split(' ');
            switch (approachName[0]) {
                case 'RNAV':
                    approachType = 10;
                    break;
                case 'LOC':
                    approachType = 5;
                    break;
                case 'ILS':
                    approachType = 4;
                    break;
                case 'LDA':
                    approachType = 7;
                    break;
                case 'VOR':
                    approachType = 2;
                    break;
                case 'VDM':
                    approachType = 8;
                    break;
                case 'NDB':
                    approachType = 3;
                    break;
                case 'NDM':
                    approachType = 9;
                    break;
                case 'BC':
                    approachType = 11;
                    break;
            }
            // TODO: Find a way to get the timezone from the facility or by lat/lon?
        }
        SimVar.SetSimVarValue('GPS APPROACH APPROACH TYPE', SimVarValueType.Number, approachType);
    }
    /**
     * Handles checking the approach waypoint type.
     * @param leg The active lateral leg.
     */
    checkApproachWaypointType(leg) {
        let legType = 0;
        let segmentType = 0;
        if (leg) {
            switch (leg.leg.type) {
                case LegType.AF:
                    legType = leg.leg.turnDirection === LegTurnDirection.Left ? 4 : 5;
                    segmentType = leg.leg.turnDirection === LegTurnDirection.Left ? 2 : 1;
                    break;
                case LegType.RF:
                    legType = 1;
                    segmentType = leg.leg.turnDirection === LegTurnDirection.Left ? 2 : 1;
                    break;
                case LegType.CA:
                case LegType.FA:
                case LegType.VA:
                    legType = 9;
                    break;
                case LegType.FM:
                case LegType.VM:
                    legType = 10;
                    break;
                case LegType.CD:
                case LegType.FD:
                case LegType.VD:
                    legType = 8;
                    break;
                case LegType.PI:
                    legType = leg.leg.turnDirection === LegTurnDirection.Left ? 2 : 3;
                    break;
                case LegType.HA:
                case LegType.HM:
                case LegType.HF:
                    legType = leg.leg.turnDirection === LegTurnDirection.Left ? 6 : 7;
                    break;
                default:
                    legType = 1;
            }
        }
        SimVar.SetSimVarValue('GPS APPROACH WP TYPE', SimVarValueType.Number, legType);
        SimVar.SetSimVarValue('GPS APPROACH SEGMENT TYPE', SimVarValueType.Number, segmentType);
        SimVar.SetSimVarValue('GPS APPROACH IS WP RUNWAY', SimVarValueType.Bool, (leg === null || leg === void 0 ? void 0 : leg.leg.fixIcao[0]) === 'R');
    }
}

/* eslint-disable max-len */
/**
 * The base G1000 MFD instrument class.
 */
class WTG1000_MFD extends BaseInstrument {
    /**
     * Creates an instance of the WTG1000_MFD.
     */
    constructor() {
        super();
        this.airspaceSearcher = new AirspaceSearcher();
        this.lastCalculate = 0;
        WaypointIconImageCache.init();
        this.bus = new EventBus();
        this.gnss = new GNSSPublisher(this.bus);
        this.adc = new ADCPublisher(this.bus);
        this.controlPublisher = new ControlPublisher(this.bus);
        this.adc.subscribe('hdg_deg');
        this.adc.subscribe('hdg_deg_true');
        this.adc.subscribe('magvar');
        this.adc.subscribe('tas');
        this.adc.subscribe('ambient_wind_direction');
        this.adc.subscribe('ambient_wind_velocity');
        this.adc.subscribe('alt');
        this.adc.subscribe('on_ground');
        this.adc.subscribe('vs');
        this.adc.subscribe('pitch_deg');
        this.adc.subscribe('ias');
        this.adc.subscribe('roll_deg');
        this.eis = new EISPublisher(this.bus);
        this.eis.subscribe('rpm_1');
        this.eis.subscribe('recip_ff_1');
        this.eis.subscribe('oil_press_1');
        this.eis.subscribe('oil_temp_1');
        this.eis.subscribe('egt_1');
        this.eis.subscribe('vac');
        this.eis.subscribe('fuel_left');
        this.eis.subscribe('fuel_right');
        this.eis.subscribe('eng_hours_1');
        this.eis.subscribe('elec_bus_main_v');
        this.eis.subscribe('elec_bus_main_a');
        this.eis.subscribe('elec_bus_avionics_v');
        this.eis.subscribe('elec_bus_avionics_a');
        this.eis.subscribe('elec_bus_genalt_1_v');
        this.eis.subscribe('elec_bus_genalt_1_a');
        this.eis.subscribe('elec_bat_v');
        this.eis.subscribe('elec_bat_a');
        this.lNavPublisher = new LNavSimVarPublisher(this.bus);
        this.lNavPublisher.subscribe('lnavBrgMag');
        this.lNavPublisher.subscribe('lnavDis');
        this.lNavPublisher.subscribe('lnavDtkMag');
        this.lNavPublisher.subscribe('lnavXtk');
        this.lNavPublisher.subscribe('lnavCurrentVector');
        this.vNavPublisher = new VNavSimVarPublisher(this.bus);
        this.vNavPublisher.subscribe('vnavTodLegIndex');
        this.vNavPublisher.subscribe('vnavTodLegDistance');
        this.vNavPublisher.subscribe('vnavBodLegIndex');
        this.vNavPublisher.subscribe('vnavPathMode');
        this.vNavPublisher.subscribe('vnavFpa');
        this.vNavPublisher.subscribe('vnavTodDistance');
        this.vNavPublisher.subscribe('vnavTargetAlt');
        this.vNavPublisher.subscribe('vnavVDev');
        this.vNavPublisher.subscribe('vnavAltCaptureType');
        this.vNavPublisher.subscribe('vnavBodDistance');
        this.vNavPublisher.subscribe('vnavConstraintAltitude');
        this.vNavPublisher.subscribe('vnavConstraintLegIndex');
        this.vNavPublisher.subscribe('vnavRequiredVs');
        this.vNavPublisher.subscribe('vnavNextConstraintAltitude');
        this.apRadioNav = new APRadioNavInstrument(this.bus);
        this.hEventPublisher = new HEventPublisher(this.bus);
        this.g1000ControlPublisher = new G1000ControlPublisher(this.bus);
        this.controlPublisher = new ControlPublisher(this.bus);
        this.apInstrument = new AutopilotInstrument(this.bus);
        this.trafficInstrument = new TrafficInstrument(this.bus, { realTimeUpdateFreq: 2, simTimeUpdateFreq: 1, contactDeprecateTime: 10 });
        this.clock = new Clock(this.bus);
        this.fuelComputer = new FuelComputer(this.bus);
        this.backplane = new InstrumentBackplane();
        this.backplane.addPublisher('adc', this.adc);
        this.backplane.addPublisher('hEvents', this.hEventPublisher);
        this.backplane.addPublisher('gnss', this.gnss);
        this.backplane.addPublisher('eis', this.eis);
        this.backplane.addPublisher('control', this.controlPublisher);
        this.backplane.addPublisher('g1000', this.g1000ControlPublisher);
        this.backplane.addPublisher('lnav', this.lNavPublisher);
        this.backplane.addPublisher('vnav', this.vNavPublisher);
        this.backplane.addInstrument('ap', this.apInstrument);
        this.backplane.addInstrument('apRadioNav', this.apRadioNav);
        this.backplane.addInstrument('fuelComputer', this.fuelComputer);
        this.backplane.addInstrument('traffic', this.trafficInstrument);
        this.viewService = new MFDViewService(this.bus);
        this.loader = new FacilityLoader(FacilityRespository.getRepository(this.bus));
        this.calculator = new FlightPathCalculator(this.loader, { defaultClimbRate: 300, defaultSpeed: 85, bankAngle: 17.5 });
        this.planner = FlightPlanner.getPlanner(this.bus, this.calculator);
        this.gpsSynchronizer = new GpsSynchronizer(this.bus, this.planner, this.loader);
        window['planner'] = this.planner;
        window['calculator'] = this.calculator;
        this.heventSub = this.bus.getSubscriber();
        this.xmlLogicHost = new CompositeLogicXMLHost();
        this.gaugeFactory = new XMLGaugeConfigFactory(this, this.bus);
        this.navdataComputer = new NavdataComputer(this.bus, this.planner, this.loader);
        this.tas = new TrafficAdvisorySystem(this.bus, this.trafficInstrument, 30, 2, 1);
        this.backlightManager = new BacklightManager('mfd', this.bus);
        // TODO: Support pilot profiles.
        this.settingSaveManager = new G1000SettingSaveManager(this.bus);
        const saveKey = `${SimVar.GetSimVarValue('ATC MODEL', 'string')}.profile_1`;
        this.settingSaveManager.load(saveKey);
        this.settingSaveManager.startAutoSave(saveKey);
    }
    /**
     * The instrument template ID.
     * @returns The instrument template ID.
     */
    get templateID() {
        return 'AS1000_MFD';
    }
    /**
     * Whether or not the instrument is interactive (a touchscreen instrument).
     * @returns True
     */
    get isInteractive() {
        return true;
    }
    /**
     * A callback called when the element has connection to the DOM.
     */
    connectedCallback() {
        super.connectedCallback();
        this.autopilot = new G1000Autopilot(this.bus, this.planner, new G1000APConfig(this.bus, this.planner), new G1000APStateManager(this.bus));
        this.fms = new Fms(this.bus, this.planner, this.viewService, this.g1000ControlPublisher, this.autopilot);
        const menuSystem = new MenuSystem(this.bus, 'AS1000_MFD_SOFTKEYS_');
        //// BEGIN CURRENT
        let gaugeConfig = this.gaugeFactory.parseConfig(this.xmlConfig);
        // TODO Undo this when new panels are in the base game.
        if (!gaugeConfig.override) {
            const loader = new PanelLoader(this.gaugeFactory);
            const extPanel = loader.loadConfigForModel(SimVar.GetSimVarValue('ATC MODEL', 'string'));
            if (extPanel) {
                gaugeConfig = extPanel;
            }
        }
        menuSystem.addMenu('empty', new SoftKeyMenu(menuSystem));
        menuSystem.addMenu('navmap-root', new MFDNavMapRootMenu(menuSystem));
        menuSystem.addMenu('map-opt', new MapOptMenu(menuSystem, this.controlPublisher));
        menuSystem.addMenu('traffic-root', new MFDTrafficMapRootMenu(menuSystem));
        menuSystem.addMenu('traffic-motion', new MFDTrafficMapMotionMenu(menuSystem));
        menuSystem.addMenu('traffic-motion-duration', new MFDTrafficMapMotionDurationMenu(menuSystem));
        menuSystem.addMenu('traffic-alt', new MFDTrafficMapAltitudeMenu(menuSystem));
        menuSystem.addMenu('engine-menu', new EngineMenu(menuSystem, gaugeConfig, this.g1000ControlPublisher));
        menuSystem.addMenu('lean-menu', new LeanMenu(menuSystem, gaugeConfig, this.g1000ControlPublisher));
        menuSystem.addMenu('system-menu', new SystemMenu(menuSystem, gaugeConfig, this.g1000ControlPublisher));
        menuSystem.addMenu('fuel-rem-menu', new FuelRemMenu(menuSystem, gaugeConfig, this.g1000ControlPublisher));
        menuSystem.addMenu('inset-menu', new InsetMenu(menuSystem, this.controlPublisher));
        // menuSystem.addMenu('fpln-opt', new FlightPlanPopoutMenu(menuSystem, this.controlPublisher));
        // menuSystem.addMenu('view-opt', new ViewMenu(menuSystem, this.controlPublisher));
        menuSystem.pushMenu('navmap-root');
        FSComponent.render(FSComponent.buildComponent(EIS, { bus: this.bus, logicHandler: this.xmlLogicHost, gaugeConfig: gaugeConfig }), document.getElementsByClassName('eis')[0]);
        FSComponent.render(FSComponent.buildComponent(NavDataBar, { bus: this.bus, openPage: this.viewService.openPage }), document.getElementById('NavComBox'));
        FSComponent.render(FSComponent.buildComponent(NavComRadio, { bus: this.bus, title: 'NAV', position: 'left' }), document.querySelector('#NavComBox #Left'));
        FSComponent.render(FSComponent.buildComponent(NavComRadio, { bus: this.bus, title: 'COM', position: 'right' }), document.querySelector('#NavComBox #Right'));
        FSComponent.render(FSComponent.buildComponent(SoftKeyBar, { menuSystem: menuSystem }), document.getElementById('Electricity'));
        this.backplane.init();
        this.controlPublisher.publishEvent('publish_radio_states', true);
        this.viewService.registerView('NavMapPage', () => FSComponent.buildComponent(MFDNavMapPage, { viewService: this.viewService, bus: this.bus, menuSystem: menuSystem, flightPlanner: this.planner, airspaceSearcher: this.airspaceSearcher, tas: this.tas }));
        this.viewService.registerView('FPLPage', () => FSComponent.buildComponent(MFDFPLPage, { viewService: this.viewService, fms: this.fms, bus: this.bus, menuSystem: menuSystem, airspaceSearcher: this.airspaceSearcher, tas: this.tas }));
        this.viewService.registerView('TrafficPage', () => FSComponent.buildComponent(MFDTrafficMapPage, { viewService: this.viewService, bus: this.bus, menuSystem: menuSystem, flightPlanner: this.planner, tas: this.tas }));
        this.viewService.registerView('PageSelect', () => FSComponent.buildComponent(MFDPageSelect, { viewService: this.viewService, title: "Page Select", showTitle: false }));
        this.viewService.registerView(ContextMenuDialog.name, () => FSComponent.buildComponent(ContextMenuDialog, { viewService: this.viewService, title: "", showTitle: false, upperKnobCanScroll: true }));
        this.viewService.registerView('PROC', () => FSComponent.buildComponent(MFDProc, { viewService: this.viewService, title: "Procedures", showTitle: true, fms: this.fms }));
        this.viewService.registerView('DirectTo', () => FSComponent.buildComponent(MFDDirectTo, { viewService: this.viewService, bus: this.bus, fms: this.fms, title: "Direct To", showTitle: true }));
        this.viewService.registerView('SelectApproach', () => FSComponent.buildComponent(MFDSelectApproach, { viewService: this.viewService, title: "", showTitle: false, fms: this.fms, bus: this.bus }));
        this.viewService.registerView('SelectDeparture', () => FSComponent.buildComponent(MFDSelectDeparture, { viewService: this.viewService, bus: this.bus, title: "", showTitle: false, fms: this.fms }));
        this.viewService.registerView('SelectArrival', () => FSComponent.buildComponent(MFDSelectArrival, { viewService: this.viewService, bus: this.bus, title: "", showTitle: false, fms: this.fms }));
        this.viewService.registerView('MapSettings', () => FSComponent.buildComponent(MFDMapSettings, { viewService: this.viewService, title: 'Map Settings', showTitle: true, bus: this.bus, menuSystem: menuSystem }));
        this.viewService.registerView('WptInfo', () => FSComponent.buildComponent(MFDWptInfo, { viewService: this.viewService, title: "Waypoint Information", showTitle: true, bus: this.bus }));
        this.viewService.registerView('SetRunway', () => FSComponent.buildComponent(MFDSetRunway, { viewService: this.viewService, title: "Set Runway", showTitle: true }));
        this.viewService.registerView('MessageDialog', () => FSComponent.buildComponent(MessageDialog, { viewService: this.viewService, title: "", showTitle: false }));
        this.viewService.registerView('PageMenuDialog', () => FSComponent.buildComponent(MFDPageMenuDialog, { viewService: this.viewService, title: "Page Menu", showTitle: true }));
        this.viewService.registerView('SelectAirway', () => FSComponent.buildComponent(MFDSelectAirway, { viewService: this.viewService, title: "Select Airway", showTitle: true, fms: this.fms }));
        this.viewService.registerView('HoldAt', () => FSComponent.buildComponent(MFDHold, { viewService: this.viewService, title: "Hold at", showTitle: true, fms: this.fms, bus: this.bus }));
        this.viewService.registerView(MFDWptDupDialog.name, () => FSComponent.buildComponent(MFDWptDupDialog, { viewService: this.viewService, title: 'Duplicate Waypoints', showTitle: true, bus: this.bus }));
        this.viewService.open('NavMapPage');
        // force enable animations
        document.documentElement.classList.add('animationsEnabled');
        this.controlPublisher.publishEvent('init_cdi', true);
    }
    /**
     * A callback called when the instrument is initialized.
     */
    Init() {
        super.Init();
        this.initPrimaryFlightPlan();
        this.clock.init();
        this.tas.setOperatingMode(TCASOperatingMode.TA_RA); // TODO: putting this here until we get user control set up
        this.tas.init();
        this.backlightManager.init();
    }
    /**
     * Initializes the primary flight plan.
     */
    initPrimaryFlightPlan() {
        // Do not create a new flight plan ourselves; instead we will sync it from the PFD.
        this.fms.flightPlanner.requestSync();
    }
    /**
     * A callback called when the instrument gets a frame update.
     */
    Update() {
        var _a;
        super.Update();
        const now = Date.now();
        if (now - this.lastCalculate > 3000) {
            this.lastCalculate = now;
        }
        this.clock.onUpdate();
        this.backplane.onUpdate();
        (_a = this.autopilot) === null || _a === void 0 ? void 0 : _a.update();
        this.xmlLogicHost.update();
        this.gpsSynchronizer.update();
    }
    /**
     * Callback called when the flight starts.
     */
    onFlightStart() {
        super.onFlightStart();
        this.autopilot.stateManager.initialize();
    }
    /**
     * A callback called when the instrument received a H event.
     * @param args The H event and associated arguments, if any.
     */
    onInteractionEvent(args) {
        this.hEventPublisher.dispatchHEvent(args[0]);
    }
}
registerInstrument('wtg1000-mfd', WTG1000_MFD);
