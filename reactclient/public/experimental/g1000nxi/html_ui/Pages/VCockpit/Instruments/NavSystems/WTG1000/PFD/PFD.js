/**
 * A class for a Subject to observe.
 * @class Subject
 * @template T
 */
class Subject {
    /**
     * Constructs an observable Subject.
     * @param value The initial value.
     * @param equalityFunc The function to use to check for equality.
     * @param mutateFunc The function to use to mutate the subject's value.
     */
    constructor(value, equalityFunc, mutateFunc) {
        this.value = value;
        this.equalityFunc = equalityFunc;
        this.mutateFunc = mutateFunc;
        this._subs = [];
    }
    /**
     * Creates and returns a new Subject.
     * @param v The initial value of the subject.
     * @param equalityFunc The function to use to check for equality.
     * @param mutateFunc The function to use to mutate the subject's value. If not supplied, new values will replace
     * old values by variable assignment.
     * @returns A Subject instance.
     */
    static create(v, equalityFunc, mutateFunc) {
        return new Subject(v, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : Subject.DEFAULT_EQUALITY_FUNC, mutateFunc);
    }
    /**
     * Sets the new value and notifies the subscribers when value changed.
     * @param value The new value.
     */
    set(value) {
        if (!this.equalityFunc(value, this.value)) {
            if (this.mutateFunc) {
                this.mutateFunc(this.value, value);
            }
            else {
                this.value = value;
            }
            this.notify();
        }
    }
    /**
     * Applies a change to a value.
     * @param value The partial value to apply as a change.
     */
    apply(value) {
        Object.assign(this.value, value);
        this.notify();
    }
    /**
     * Notifies subscribers that the subject value has changed.
     */
    notify() {
        const subLen = this._subs.length;
        for (let i = 0; i < subLen; i++) {
            try {
                this._subs[i](this.value);
            }
            catch (error) {
                console.error(`Error in Subject handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
    }
    /**
     * Gets the value of the Subject.
     * @returns The value.
     */
    get() {
        return this.value;
    }
    /**
     * Subscribes to the subject with a callback function. The function will be called whenever the value of this Subject
     * changes.
     * @param fn A callback function.
     * @param initialNotify Whether to immediately notify the callback function with the current value of this Subject
     * after it is subscribed. False by default.
     */
    sub(fn, initialNotify) {
        this._subs.push(fn);
        if (initialNotify) {
            fn(this.value);
        }
    }
    /**
     * Unsubscribes a callback function from this Subject.
     * @param fn The callback function to unsubscribe.
     */
    unsub(fn) {
        const index = this._subs.indexOf(fn);
        if (index >= 0) {
            this._subs.splice(index, 1);
        }
    }
    /**
     * Maps a subject to a new subject.
     * @param fn The function to use to map to the new subject.
     * @returns A new mapped subject.
     */
    map(fn) {
        return new MappedSubject(this, fn);
    }
}
/**
 * Checks if two values are equal using the strict equality operator.
 * @param a The first value.
 * @param b The second value.
 * @returns whether a and b are equal.
 */
Subject.DEFAULT_EQUALITY_FUNC = (a, b) => a === b;
/**
 * A subject that is a mapped stream from another parent subscribable.
 */
class MappedSubject {
    /**
     * Creates a new MappedSubject.
     * @param parent The parent subscribable instance.
     * @param mapFunc The function to map to the new stream.
     */
    constructor(parent, mapFunc) {
        this.parent = parent;
        this.mapFunc = mapFunc;
        this._subs = [];
        /**
         * Maps the parent value to the subject value.
         * @param val The parent value to map.
         */
        this.mapValue = (val) => {
            for (let i = 0; i < this._subs.length; i++) {
                this._subs[i](this.mapFunc(val));
            }
        };
        parent.sub(this.mapValue, true);
    }
    /**
     * Gets the current value of the subject.
     * @returns The current value.
     */
    get() {
        return this.mapFunc(this.parent.get());
    }
    /**
     * Subscribes to the subject with a callback function. The function will be called whenever the value of this Subject
     * changes.
     * @param fn A callback function.
     * @param initialNotify Whether to immediately notify the callback function with the current value of this Subject
     * after it is subscribed. False by default.
     */
    sub(fn, initialNotify) {
        this._subs.push(fn);
        if (initialNotify) {
            fn(this.mapFunc(this.parent.get()));
        }
    }
    /**
     * Unsubscribes a callback function from this Subject.
     * @param fn The callback function to unsubscribe.
     */
    unsub(fn) {
        const index = this._subs.indexOf(fn);
        if (index >= 0) {
            this._subs.splice(index, 1);
        }
    }
    /**
     * Destroys the subscription to the parent subscribable.
     */
    destroy() {
        this.parent.unsub(this.mapValue);
    }
    /**
     * Maps a subject to a new subject.
     * @param fn The function to use to map to the new subject.
     * @returns A new mapped subject.
     */
    map(fn) {
        return new MappedSubject(this, fn);
    }
}

/**
 * A class for subjects that return a computed value.
 * @class ComputedSubject
 * @template T The type of the input value.
 * @template C The type of the computed output value.
 */
class ComputedSubject {
    /**
     * Creates an instance of ComputedSubject.
     * @param value The initial value.
     * @param computeFn The computation function.
     */
    constructor(value, computeFn) {
        this.computeFn = computeFn;
        this._subs = [];
        this._value = value;
        this._computedValue = computeFn(value);
    }
    /**
     * Creates and returns a new ComputedSubject.
     * @param v The initial value of the Subject.
     * @param fn A function which transforms raw values to computed values.
     * @returns A ComputedSubject instance.
     */
    static create(v, fn) {
        return new ComputedSubject(v, fn);
    }
    /**
     * Sets the new value and notifies the subscribers when value changed.
     * @param value The new value.
     */
    set(value) {
        this._value = value;
        const compValue = this.computeFn(value);
        if (compValue !== this._computedValue) {
            this._computedValue = compValue;
            const subLen = this._subs.length;
            for (let i = 0; i < subLen; i++) {
                this._subs[i](this._computedValue, this._value);
            }
        }
    }
    /**
     * Gets the computed value of the Subject.
     * @returns The computed value.
     */
    get() {
        return this._computedValue;
    }
    /**
     * Gets the raw value of the Subject.
     * @returns The raw value.
     */
    getRaw() {
        return this._value;
    }
    /**
     * Subscribes to the subject with a callback function. The function will be called whenever the computed value of
     * this Subject changes.
     * @param fn A callback function.
     * @param initialNotify Whether to immediately notify the callback function with the current compured and raw values
     * of this Subject after it is subscribed. False by default.
     */
    sub(fn, initialNotify) {
        this._subs.push(fn);
        if (initialNotify) {
            fn(this._computedValue, this._value);
        }
    }
    /**
     * Unsubscribes a callback function from this Subject.
     * @param fn The callback function to unsubscribe.
     */
    unsub(fn) {
        const index = this._subs.indexOf(fn);
        if (index >= 0) {
            this._subs.splice(index, 1);
        }
    }
    /**
     * Maps this subject to a new subject.
     * @param fn The function to use to map to the new subject.
     * @returns The mapped subject.
     */
    map(fn) {
        return new MappedSubject(this, fn);
    }
}

/* eslint-disable no-inner-declarations */
/** A releative render position. */
var RenderPosition;
(function (RenderPosition) {
    RenderPosition[RenderPosition["Before"] = 0] = "Before";
    RenderPosition[RenderPosition["After"] = 1] = "After";
    RenderPosition[RenderPosition["In"] = 2] = "In";
})(RenderPosition || (RenderPosition = {}));
/**
 * A display component in the component framework.
 */
class DisplayComponent {
    /**
     * Creates an instance of a DisplayComponent.
     * @param props The propertis of the component.
     */
    constructor(props) {
        this.props = props;
    }
    /**
     * A callback that is called before the component is rendered.
     */
    onBeforeRender() { return; }
    /**
     * A callback that is called after the component is rendered.
     */
    onAfterRender() { return; }
    /**
     * Destroys this component.
     */
    destroy() { return; }
}
/**
 * A reference to a component or element node.
 */
class NodeReference {
    constructor() {
        /** The internal reference instance. */
        this._instance = null;
    }
    /**
     * The instance of the element or component.
     * @returns The instance of the element or component.
     */
    get instance() {
        if (this._instance !== null) {
            return this._instance;
        }
        throw new Error('Instance was null.');
    }
    /**
     * Sets the value of the instance.
     */
    set instance(val) {
        this._instance = val;
    }
    /**
     * Gets the instance, or null if the instance is not populated.
     * @returns The component or element instance.
     */
    getOrDefault() {
        return this._instance;
    }
}
/**
 * The FS component namespace.
 */
// eslint-disable-next-line @typescript-eslint/no-namespace
var FSComponent;
(function (FSComponent) {
    /**
     * Valid SVG element tags.
     */
    const svgTags = {
        'circle': true,
        'clipPath': true,
        'color-profile': true,
        'cursor': true,
        'defs': true,
        'desc': true,
        'ellipse': true,
        'g': true,
        'image': true,
        'line': true,
        'linearGradient': true,
        'marker': true,
        'mask': true,
        'path': true,
        'pattern': true,
        'polygon': true,
        'polyline': true,
        'radialGradient': true,
        'rect': true,
        'stop': true,
        'svg': true,
        'text': true
    };
    /**
     * Builds a JSX based FSComponent.
     * @param type The DOM element tag that will be built.
     * @param props The properties to apply to the DOM element.
     * @param children Any children of this DOM element.
     * @returns The JSX VNode for the component or element.
     */
    // eslint-disable-next-line no-inner-declarations
    function buildComponent(type, props, ...children) {
        let vnode = null;
        if (typeof type === 'string') {
            let element;
            if (svgTags[type] !== undefined) {
                element = document.createElementNS('http://www.w3.org/2000/svg', type);
            }
            else {
                element = document.createElement(type);
            }
            if (props !== null) {
                for (const key in props) {
                    if (key === 'ref' && props.ref !== undefined) {
                        props.ref.instance = element;
                    }
                    else {
                        const prop = props[key];
                        if (prop instanceof Subject || prop instanceof MappedSubject || prop instanceof ComputedSubject) {
                            element.setAttribute(key, prop.get());
                            prop.sub((v) => {
                                element.setAttribute(key, v);
                            });
                        }
                        else {
                            element.setAttribute(key, prop);
                        }
                    }
                }
            }
            vnode = {
                instance: element,
                props: props,
                children: null
            };
            vnode.children = createChildNodes(vnode, children);
        }
        else if (typeof type === 'function') {
            if (children !== null && props === null) {
                props = {
                    children: children
                };
            }
            else if (props !== null) {
                props.children = children;
            }
            const instance = new type(props);
            if (props !== null && props.ref !== null && props.ref !== undefined) {
                props.ref.instance = instance;
            }
            vnode = {
                instance,
                props,
                children: [instance.render()]
            };
        }
        return vnode;
    }
    FSComponent.buildComponent = buildComponent;
    /**
     * Creates the collection of child VNodes.
     * @param parent The parent VNode.
     * @param children The JSX children to convert to nodes.
     * @returns A collection of child VNodes.
     */
    function createChildNodes(parent, children) {
        let vnodes = null;
        if (children !== null && children !== undefined && children.length > 0) {
            vnodes = [];
            for (const child of children) {
                if (child !== null) {
                    if (child instanceof Subject || child instanceof MappedSubject || child instanceof ComputedSubject) {
                        const subjectValue = child.get().toString();
                        const node = {
                            instance: subjectValue === '' ? ' ' : subjectValue,
                            children: null,
                            props: null,
                            root: undefined,
                        };
                        child.sub((v) => {
                            if (node.root !== undefined) {
                                // TODO workaround. gotta find a solution for the text node vanishing when text is empty
                                node.root.nodeValue = v === '' ? ' ' : v.toString();
                            }
                            else {
                                // for debugging
                                console.warn('Subject has no node!');
                            }
                        });
                        vnodes.push(node);
                    }
                    else if (child instanceof Array) {
                        const arrayNodes = createChildNodes(parent, child);
                        if (arrayNodes !== null) {
                            vnodes.push(...arrayNodes);
                        }
                    }
                    else if (typeof child === 'string' || typeof child === 'number') {
                        vnodes.push(createStaticContentNode(child));
                    }
                    else if (typeof child === 'object') {
                        vnodes.push(child);
                    }
                }
            }
        }
        return vnodes;
    }
    FSComponent.createChildNodes = createChildNodes;
    /**
     * Creates a static content VNode.
     * @param content The content to create a node for.
     * @returns A static content VNode.
     */
    function createStaticContentNode(content) {
        return {
            instance: content,
            children: null,
            props: null
        };
    }
    FSComponent.createStaticContentNode = createStaticContentNode;
    /**
     * Renders a VNode to a DOM element.
     * @param node The node to render.
     * @param element The DOM element to render to.
     * @param position The RenderPosition to put the item in.
     */
    function render(node, element, position = RenderPosition.In) {
        if (node.children && node.children.length > 0 && element !== null) {
            const componentInstance = node.instance;
            if (componentInstance.onBeforeRender !== undefined) {
                componentInstance.onBeforeRender();
            }
            if (node.instance instanceof HTMLElement || node.instance instanceof SVGElement) {
                insertNode(node, position, element);
            }
            else {
                for (const child of node.children) {
                    insertNode(child, position, element);
                }
            }
            if (componentInstance.onAfterRender !== undefined) {
                componentInstance.onAfterRender();
            }
        }
    }
    FSComponent.render = render;
    /**
     * Inserts a node into the DOM.
     * @param node The node to insert.
     * @param position The position to insert the node in.
     * @param element The element to insert relative to.
     */
    function insertNode(node, position, element) {
        var _a, _b, _c, _d, _e, _f;
        if (node.instance instanceof HTMLElement || node.instance instanceof SVGElement) {
            switch (position) {
                case RenderPosition.In:
                    element.appendChild(node.instance);
                    node.root = (_a = element.lastChild) !== null && _a !== void 0 ? _a : undefined;
                    break;
                case RenderPosition.Before:
                    element.insertAdjacentElement('beforebegin', node.instance);
                    node.root = (_b = element.previousSibling) !== null && _b !== void 0 ? _b : undefined;
                    break;
                case RenderPosition.After:
                    element.insertAdjacentElement('afterend', node.instance);
                    node.root = (_c = element.nextSibling) !== null && _c !== void 0 ? _c : undefined;
                    break;
            }
            if (node.children !== null) {
                for (const child of node.children) {
                    insertNode(child, RenderPosition.In, node.instance);
                }
            }
        }
        else if (typeof node.instance === 'string') {
            switch (position) {
                case RenderPosition.In:
                    element.insertAdjacentHTML('beforeend', node.instance);
                    node.root = (_d = element.lastChild) !== null && _d !== void 0 ? _d : undefined;
                    break;
                case RenderPosition.Before:
                    element.insertAdjacentHTML('beforebegin', node.instance);
                    node.root = (_e = element.previousSibling) !== null && _e !== void 0 ? _e : undefined;
                    break;
                case RenderPosition.After:
                    element.insertAdjacentHTML('afterend', node.instance);
                    node.root = (_f = element.nextSibling) !== null && _f !== void 0 ? _f : undefined;
                    break;
            }
        }
        else {
            render(node, element);
        }
    }
    /**
     * Render a node before a DOM element.
     * @param node The node to render.
     * @param element The element to render boeore.
     */
    function renderBefore(node, element) {
        render(node, element, RenderPosition.Before);
    }
    FSComponent.renderBefore = renderBefore;
    /**
     * Render a node after a DOM element.
     * @param node The node to render.
     * @param element The element to render after.
     */
    function renderAfter(node, element) {
        render(node, element, RenderPosition.After);
    }
    FSComponent.renderAfter = renderAfter;
    /**
     * Remove a previously rendered element.  Currently, this is just a simple
     * wrapper so that all of our high-level "component maniuplation" state is kept
     * in the FSComponent API, but it's not doing anything other than a simple
     * remove() on the element.   This can probably be enhanced.
     * @param element The element to remove.
     */
    function remove(element) {
        if (element !== null) {
            element.remove();
        }
    }
    FSComponent.remove = remove;
    /**
     * Creates a component or element node reference.
     * @returns A new component or element node reference.
     */
    function createRef() {
        return new NodeReference();
    }
    FSComponent.createRef = createRef;
    /**
     * An empty callback handler.
     */
    FSComponent.EmptyHandler = () => { return; };
})(FSComponent || (FSComponent = {}));

new Image();

/**
 * A number with an associated unit. Each NumberUnit is created with a reference unit type,
 * which cannot be changed after instantiation. The reference unit type determines how the
 * value of the NumberUnit is internally represented. Each NumberUnit also maintains an
 * active unit type, which can be dynamically changed at any time.
 */
class NumberUnit {
    /**
     * Constructor.
     * @param number - the initial numeric value of the new NumberUnit.
     * @param unit - the unit type of the new NumberUnit.
     */
    constructor(number, unit) {
        this._number = number;
        this._unit = unit;
        this.readonly = new NumberUnitReadOnly(this);
    }
    /**
     * Gets this NumberUnit's numeric value.
     * @returns this NumberUnit's numeric value.
     */
    get number() {
        return this._number;
    }
    /**
     * Gets this NumberUnit's unit type.
     * @returns this NumberUnit's unit type.
     */
    get unit() {
        return this._unit;
    }
    /**
     * Converts a value to a numeric value with this NumberUnit's unit type.
     * @param value - the value.
     * @param unit - the unit type of the new value. Defaults to this NumberUnit's unit type. This argument is ignored if
     * value is a NumberUnit.
     * @returns the numeric of the value with this NumberUnit's unit type.
     */
    toNumberOfThisUnit(value, unit) {
        if ((typeof value !== 'number') && this.unit.family === value.unit.family) {
            return this.unit.convertFrom(value.number, value.unit);
        }
        if (typeof value === 'number') {
            return unit ? this.unit.convertFrom(value, unit) : value;
        }
        return undefined;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        const converted = this.toNumberOfThisUnit(arg1, arg2);
        if (converted !== undefined) {
            this._number = converted;
            return this;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    add(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const converted = this.toNumberOfThisUnit(arg1, isArg2NumberUnit ? undefined : arg2);
        if (converted !== undefined) {
            let out = isArg2NumberUnit ? arg2 : arg3;
            if (out) {
                out.set(this.number + converted, this.unit);
            }
            else {
                out = this;
                this._number += converted;
            }
            return out;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    subtract(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const converted = this.toNumberOfThisUnit(arg1, isArg2NumberUnit ? undefined : arg2);
        if (converted !== undefined) {
            let out = isArg2NumberUnit ? arg2 : arg3;
            if (out) {
                out.set(this.number - converted, this.unit);
            }
            else {
                out = this;
                this._number -= converted;
            }
            return out;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    /**
     * Scales this NumberUnit by a unit-less factor and returns the result.
     * @param factor - the factor by which to scale.
     * @param out - the NumberUnit to which to write the result. Defaults to this NumberUnit.
     * @returns the scaled NumberUnit, or undefined if the operation could not be carried out.
     */
    scale(factor, out) {
        if (out) {
            return out.set(this.number * factor, this.unit);
        }
        else {
            this._number *= factor;
            return this;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    ratio(value, unit) {
        const converted = this.toNumberOfThisUnit(value, unit);
        if (converted) {
            return this.number / converted;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    /**
     * Calculates the absolute value of this NumberUnit and returns the result.
     * @param out - the NumberUnit to which to write the result. Defaults to this NumberUnit.
     * @returns the absolute value, or undefined if the operation could not be carried out.
     */
    abs(out) {
        if (out) {
            out.set(Math.abs(this.number), this.unit);
            return this;
        }
        else {
            this._number = Math.abs(this._number);
            return this;
        }
    }
    /**
     * Returns the numeric value of this NumberUnit after conversion to a specified unit.
     * @param unit - the unit to which to convert.
     * @returns the converted numeric value.
     * @throws Error if this NumberUnit's unit type cannot be converted to the specified unit.
     */
    asUnit(unit) {
        return this.unit.convertTo(this.number, unit);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    compare(value, unit) {
        const converted = this.toNumberOfThisUnit(value, unit);
        if (converted === undefined) {
            throw new Error('Invalid unit conversion attempted.');
        }
        const diff = this.number - converted;
        if (Math.abs(diff) < 1e-14) {
            return 0;
        }
        return Math.sign(diff);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(value, unit) {
        const converted = this.toNumberOfThisUnit(value, unit);
        if (converted === undefined) {
            return false;
        }
        const diff = this.number - converted;
        return Math.abs(diff) < 1e-14;
    }
    /**
     * Checks whether this NumberUnit has a numeric value of NaN.
     * @returns whether this NumberUnit has a numeric value of NaN.
     */
    isNaN() {
        return isNaN(this.number);
    }
    /**
     * Copies this NumberUnit.
     * @returns a copy of this NumberUnit.
     */
    copy() {
        return new NumberUnit(this.number, this.unit);
    }
}
/**
 * A read-only interface for a WT_NumberUnit.
 */
class NumberUnitReadOnly {
    /**
     * Constructor.
     * @param source - the source of the new read-only NumberUnit.
     */
    constructor(source) {
        this.source = source;
    }
    /**
     * Gets this NumberUnit's numeric value.
     * @returns this NumberUnit's numeric value.
     */
    get number() {
        return this.source.number;
    }
    /**
     * Gets this NumberUnit's unit type.
     * @returns this NumberUnit's unit type.
     */
    get unit() {
        return this.source.unit;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    add(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const out = isArg2NumberUnit ? arg2 : arg3;
        if (!out) {
            throw new Error('Cannot mutate a read-only NumberUnit.');
        }
        if (typeof arg1 === 'number') {
            return this.source.add(arg1, arg2, arg3);
        }
        else {
            return this.source.add(arg1, arg2);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    subtract(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const out = isArg2NumberUnit ? arg2 : arg3;
        if (!out) {
            throw new Error('Cannot mutate a read-only NumberUnit.');
        }
        if (typeof arg1 === 'number') {
            return this.source.subtract(arg1, arg2, arg3);
        }
        else {
            return this.source.subtract(arg1, arg2);
        }
    }
    /**
     * Scales this NumberUnit by a unit-less factor and returns the result.
     * @param factor - the factor by which to scale.
     * @param out - the NumberUnit to which to write the result.
     * @returns the scaled NumberUnit.
     * @throws Error if argument out is not specified.
     */
    scale(factor, out) {
        if (!out) {
            throw new Error('Cannot mutate a read-only NumberUnit.');
        }
        return this.source.scale(factor, out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    ratio(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.ratio(arg1, arg2);
        }
        else {
            return this.source.ratio(arg1);
        }
    }
    /**
     * Calculates the absolute value of this NumberUnit and returns the result.
     * @param out - the NumberUnit to which to write the result.
     * @returns the absolute value.
     * @throws Error if argument out is not specified.
     */
    abs(out) {
        if (!out) {
            throw new Error('Cannot mutate a read-only NumberUnit.');
        }
        return this.source.abs(out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    asUnit(unit) {
        return this.source.asUnit(unit);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    compare(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.compare(arg1, arg2);
        }
        else {
            return this.source.compare(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.equals(arg1, arg2);
        }
        else {
            return this.source.equals(arg1);
        }
    }
    /**
     * Checks whether this NumberUnit has a numeric value of NaN.
     * @returns whether this NumberUnit has a numeric value of NaN.
     */
    isNaN() {
        return this.source.isNaN();
    }
    /**
     * Copies this NumberUnit.
     * @returns a copy of this NumberUnit.
     */
    copy() {
        return this.source.copy();
    }
}
/**
 * A unit of measurement.
 */
class AbstractUnit {
    /**
     * Constructor.
     * @param name The name of this unit.
     */
    constructor(name) {
        this.name = name;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
        return this.family === otherUnit.family;
    }
    /** @inheritdoc */
    createNumber(value) {
        return new NumberUnit(value, this);
    }
    /** @inheritdoc */
    equals(other) {
        return this.family === other.family && this.name === other.name;
    }
}
/**
 * A unit that can be converted to another unit of the same type via a fixed linear transformation.
 */
class SimpleUnit extends AbstractUnit {
    /**
     * Constructor.
     * @param family The family to which this unit belongs.
     * @param name The name of this unit.
     * @param scaleFactor The relative linear scale of the new unit compared to the standard unit of the same family.
     * @param zeroOffset The zero offset of the new unit compared to the standard unit of the same family.
     */
    constructor(family, name, scaleFactor, zeroOffset = 0) {
        super(name);
        this.family = family;
        this.scaleFactor = scaleFactor;
        this.zeroOffset = zeroOffset;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
        return otherUnit instanceof SimpleUnit && super.canConvert(otherUnit);
    }
    /** @inheritdoc */
    convertTo(value, toUnit) {
        if (!this.canConvert(toUnit)) {
            throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
        }
        return (value + this.zeroOffset) * (this.scaleFactor / toUnit.scaleFactor) - toUnit.zeroOffset;
    }
    /** @inheritdoc */
    convertFrom(value, fromUnit) {
        if (!this.canConvert(fromUnit)) {
            throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
        }
        return (value + fromUnit.zeroOffset) * (fromUnit.scaleFactor / this.scaleFactor) - this.zeroOffset;
    }
}
/**
 * A unit of measure composed of the multiplicative combination of multiple elementary units.
 */
class CompoundUnit extends AbstractUnit {
    /**
     * Constructor.
     * @param numerator An array of CompoundableUnits containing all the units in the numerator of the compound unit.
     * @param denominator An array of CompoundableUnits containing all the units in the denominator of the compound unit.
     * @param name The name of this unit. If not defined, one will be automatically generated.
     */
    constructor(numerator, denominator, name) {
        // if not specified, build name from component units.
        if (name === undefined) {
            name = '';
            let i = 0;
            while (i < numerator.length - 1) {
                name += `${numerator[i].name}-`;
            }
            name += `${numerator[i].name}`;
            if (denominator.length > 0) {
                name += ' per ';
                i = 0;
                while (i < denominator.length - 1) {
                    name += `${denominator[i].name}-`;
                }
                name += `${denominator[i].name}`;
            }
        }
        super(name);
        this.numerator = Array.from(numerator);
        this.denominator = Array.from(denominator);
        this.numerator.sort((a, b) => a.family.localeCompare(b.family));
        this.denominator.sort((a, b) => a.family.localeCompare(b.family));
        this.family = this.getFamily();
        this.scaleFactor = this.getScaleFactor();
    }
    /**
     * Gets the family string for this unit.
     * @returns the family string for this unit.
     */
    getFamily() {
        let family = this.numerator.map(e => e.family) + '';
        family += (this.denominator.length > 0) ? ('/' + this.denominator.map(e => e.family) + '') : '';
        return family;
    }
    /**
     * Gets the scale factor for this unit.
     * @returns the scale factor for this unit.
     */
    getScaleFactor() {
        let factor = 1;
        factor = this.numerator.reduce((prev, curr) => prev * curr.scaleFactor, factor);
        factor = this.denominator.reduce((prev, curr) => prev / curr.scaleFactor, factor);
        return factor;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
        return otherUnit instanceof CompoundUnit && super.canConvert(otherUnit);
    }
    /** @inheritdoc */
    convertTo(value, toUnit) {
        if (!this.canConvert(toUnit)) {
            throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
        }
        return value * (this.scaleFactor / toUnit.scaleFactor);
    }
    /** @inheritdoc */
    convertFrom(value, fromUnit) {
        if (!this.canConvert(fromUnit)) {
            throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
        }
        return value * (fromUnit.scaleFactor / this.scaleFactor);
    }
}
var UnitFamily;
(function (UnitFamily) {
    UnitFamily["DISTANCE"] = "distance";
    UnitFamily["ANGLE"] = "angle";
    UnitFamily["DURATION"] = "duration";
    UnitFamily["WEIGHT"] = "weight";
    UnitFamily["VOLUME"] = "volume";
    UnitFamily["PRESSURE"] = "pressure";
    UnitFamily["TEMP"] = "temperature";
})(UnitFamily || (UnitFamily = {}));
/**
 * Predefined unit types.
 */
class UnitType {
}
UnitType.METER = new SimpleUnit(UnitFamily.DISTANCE, 'meter', 1);
UnitType.FOOT = new SimpleUnit(UnitFamily.DISTANCE, 'foot', 0.3048);
UnitType.KILOMETER = new SimpleUnit(UnitFamily.DISTANCE, 'kilometer', 1000);
UnitType.MILE = new SimpleUnit(UnitFamily.DISTANCE, 'mile', 1609.34);
UnitType.NMILE = new SimpleUnit(UnitFamily.DISTANCE, 'nautical mile', 1852);
UnitType.GA_RADIAN = new SimpleUnit(UnitFamily.DISTANCE, 'great arc radian', 6378100);
UnitType.RADIAN = new SimpleUnit(UnitFamily.ANGLE, 'radian', 1);
UnitType.DEGREE = new SimpleUnit(UnitFamily.ANGLE, 'degree', Math.PI / 180);
UnitType.ARC_MIN = new SimpleUnit(UnitFamily.ANGLE, 'minute', Math.PI / 180 / 60);
UnitType.ARC_SEC = new SimpleUnit(UnitFamily.ANGLE, 'second', Math.PI / 180 / 3600);
UnitType.MILLISECOND = new SimpleUnit(UnitFamily.DURATION, 'millisecond', 0.001);
UnitType.SECOND = new SimpleUnit(UnitFamily.DURATION, 'second', 1);
UnitType.MINUTE = new SimpleUnit(UnitFamily.DURATION, 'minute', 60);
UnitType.HOUR = new SimpleUnit(UnitFamily.DURATION, 'hour', 3600);
UnitType.KILOGRAM = new SimpleUnit(UnitFamily.WEIGHT, 'kilogram', 1);
UnitType.POUND = new SimpleUnit(UnitFamily.WEIGHT, 'pound', 0.453592);
UnitType.TON = new SimpleUnit(UnitFamily.WEIGHT, 'ton', 907.185);
UnitType.TONNE = new SimpleUnit(UnitFamily.WEIGHT, 'tonne', 1000);
// the following fuel units use the generic conversion factor of 1 gal = 6.7 lbs
UnitType.LITER_FUEL = new SimpleUnit(UnitFamily.WEIGHT, 'liter', 0.80283679);
UnitType.GALLON_FUEL = new SimpleUnit(UnitFamily.WEIGHT, 'gallon', 3.0390664);
UnitType.LITER = new SimpleUnit(UnitFamily.VOLUME, 'liter', 1);
UnitType.GALLON = new SimpleUnit(UnitFamily.VOLUME, 'gallon', 3.78541);
UnitType.HPA = new SimpleUnit(UnitFamily.PRESSURE, 'hectopascal', 1);
UnitType.ATM = new SimpleUnit(UnitFamily.PRESSURE, 'atmosphere', 1013.25);
UnitType.IN_HG = new SimpleUnit(UnitFamily.PRESSURE, 'inch of mercury', 33.8639);
UnitType.MM_HG = new SimpleUnit(UnitFamily.PRESSURE, 'millimeter of mercury', 1.33322);
UnitType.CELSIUS = new SimpleUnit(UnitFamily.TEMP, '° Celsius', 1, 273.15);
UnitType.FAHRENHEIT = new SimpleUnit(UnitFamily.TEMP, '° Fahrenheit', 5 / 9, 459.67);
UnitType.KNOT = new CompoundUnit([UnitType.NMILE], [UnitType.HOUR], 'knot');
UnitType.KPH = new CompoundUnit([UnitType.KILOMETER], [UnitType.HOUR]);
UnitType.MPM = new CompoundUnit([UnitType.METER], [UnitType.MINUTE]);
UnitType.MPS = new CompoundUnit([UnitType.METER], [UnitType.SECOND]);
UnitType.FPM = new CompoundUnit([UnitType.FOOT], [UnitType.MINUTE]);
UnitType.FPS = new CompoundUnit([UnitType.FOOT], [UnitType.SECOND]);
UnitType.KGH = new CompoundUnit([UnitType.KILOGRAM], [UnitType.HOUR]);
UnitType.PPH = new CompoundUnit([UnitType.POUND], [UnitType.HOUR]);
UnitType.LPH_FUEL = new CompoundUnit([UnitType.LITER_FUEL], [UnitType.HOUR]);
UnitType.GPH_FUEL = new CompoundUnit([UnitType.GALLON_FUEL], [UnitType.HOUR]);

/**
 * A class for conversions of degree units.
 */
class Degrees {
    constructor() {
        /**
         * Converts degrees to radians.
         * @param degrees The degrees to convert.
         * @returns The result as radians.
         */
        this.toRadians = (degrees) => degrees * (Math.PI / 180);
    }
}
/**
 * A class for conversions of foot units.
 */
class Feet {
    constructor() {
        /**
         * Converts feet to meters.
         * @param feet The feet to convert.
         * @returns The result as meters.
         */
        this.toMeters = (feet) => feet * 0.3048;
        /**
         * Converts feet to nautical miles.
         * @param feet The feet to convert.
         * @returns The result as nautical miles.
         */
        this.toNauticalMiles = (feet) => feet / 6076.11549;
    }
}
/**
 * A class for conversions of meter units.
 */
class Meters {
    constructor() {
        /**
         * Converts meters to feet.
         * @param meters The meters to convert.
         * @returns The result as feet.
         */
        this.toFeet = (meters) => meters / 0.3048;
        /**
         * Converts meters to nautical miles.
         * @param meters The meters to convert.
         * @returns The result as nautical miles.
         */
        this.toNauticalMiles = (meters) => meters / 1852;
    }
}
/**
 * A class for conversions of nautical mile units.
 */
class NauticalMiles {
    constructor() {
        /**
         * Converts nautical miles to feet.
         * @param nm The nautical miles to convert.
         * @returns The result as feet.
         */
        this.toFeet = (nm) => nm * 6076.11549;
        /**
         * Converts nautical miles to meters.
         * @param nm The nautical miles to convert.
         * @returns The result as meters.
         */
        this.toMeters = (nm) => nm * 1852;
    }
}
/**
 * A class for conversions of radian units.
 */
class Radians {
    constructor() {
        /**
         * Converts radians to degrees.
         * @param radians The radians to convert.
         * @returns The result as degrees.
         */
        this.toDegrees = (radians) => radians * 180 / Math.PI;
    }
}
/**
 * A class for unit conversions.
 */
class Units {
}
/** The degrees unit. */
Units.Degrees = new Degrees();
/** The radians unit. */
Units.Radians = new Radians();
/** The feet unit. */
Units.Feet = new Feet();
/** The meters unit. */
Units.Meters = new Meters();
/** The nautical miles unit. */
Units.NauticalMiles = new NauticalMiles();

/**
 * 2D vector mathematical opertaions.
 */
class Vec2Math {
    /**
     * Gets the polar angle theta of a vector in radians.
     * @param vec - a vector.
     * @returns the polar angle theta of the vector.
     */
    static theta(vec) {
        return Math.atan2(vec[1], vec[0]);
    }
    /**
     * Sets the components of a vector.
     * @param x - the new x-component.
     * @param y - the new y-component.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static set(x, y, vec) {
        vec[0] = x;
        vec[1] = y;
        return vec;
    }
    /**
     * Sets the polar components of a vector.
     * @param r - the new length (magnitude).
     * @param theta - the new polar angle theta, in radians.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static setFromPolar(r, theta, vec) {
        vec[0] = r * Math.cos(theta);
        vec[1] = r * Math.sin(theta);
        return vec;
    }
    /**
     * Add one vector to another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector sum.
     */
    static add(v1, v2, out) {
        out[0] = v1[0] + v2[0];
        out[1] = v1[1] + v2[1];
        return out;
    }
    /**
     * Subtracts one vector from another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector difference.
     */
    static sub(v1, v2, out) {
        out[0] = v1[0] - v2[0];
        out[1] = v1[1] - v2[1];
        return out;
    }
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     */
    static dot(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1];
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v1 The vector to multiply.
     * @param scalar The scalar to apply.
     * @param out The vector to write the results to.
     * @returns The scaled vector.
     */
    static multScalar(v1, scalar, out) {
        out[0] = v1[0] * scalar;
        out[1] = v1[1] * scalar;
        return out;
    }
    /**
     * Gets the magnitude of a vector.
     * @param v1 The vector to get the magnitude for.
     * @returns the vector's magnitude.
     */
    static abs(v1) {
        return Math.hypot(v1[0], v1[1]);
    }
    /**
     * Normalizes the vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns the normalized vector.
     */
    static normalize(v1, out) {
        const mag = Vec2Math.abs(v1);
        out[0] = v1[0] / mag;
        out[1] = v1[1] / mag;
        return out;
    }
    /**
     * Gets the normal of the supplied vector.
     * @param v1 The vector to get the normal for.
     * @param out The vector to write the results to.
     * @param counterClockwise Whether or not to get the counterclockwise normal.
     * @returns the normal vector.
     */
    static normal(v1, out, counterClockwise = false) {
        const x = v1[0];
        const y = v1[1];
        if (!counterClockwise) {
            out[0] = y;
            out[1] = -x;
        }
        else {
            out[0] = -y;
            out[1] = x;
        }
        return out;
    }
    /**
     * Gets the Euclidean distance between two vectors.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns the Euclidean distance between the two vectors.
     */
    static distance(vec1, vec2) {
        return Math.hypot(vec2[0] - vec1[0], vec2[1] - vec1[0]);
    }
    /**
     * Checks if two vectors are equal.
     * @param vec1 - the first vector.
     * @param vec2 - the second vector.
     * @returns whether the two vectors are equal.
     */
    static equals(vec1, vec2) {
        return vec1.length === vec2.length && vec1.every((element, index) => element === vec2[index]);
    }
    /**
     * Copies one vector to another.
     * @param from - the vector from which to copy.
     * @param to - the vector to which to copy.
     * @returns the changed vector.
     */
    static copy(from, to) {
        return Vec2Math.set(from[0], from[1], to);
    }
}
/**
 * 3D vector mathematical opertaions.
 */
class Vec3Math {
    /**
     * Gets the spherical angle theta of a vector in radians.
     * @param vec - a vector.
     * @returns the spherical angle theta of the vector.
     */
    static theta(vec) {
        return Math.atan2(Math.hypot(vec[0], vec[1]), vec[2]);
    }
    /**
     * Gets the spherical angle phi of a vector in radians.
     * @param vec - a vector.
     * @returns the spherical angle phi of the vector.
     */
    static phi(vec) {
        return Math.atan2(vec[1], vec[0]);
    }
    /**
     * Sets the components of a vector.
     * @param x - the new x-component.
     * @param y - the new y-component.
     * @param z - the new z-component.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static set(x, y, z, vec) {
        vec[0] = x;
        vec[1] = y;
        vec[2] = z;
        return vec;
    }
    /**
     * Sets the spherical components of a vector.
     * @param r - the new length (magnitude).
     * @param theta - the new spherical angle theta, in radians.
     * @param phi - the new spherical angle phi, in radians.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static setFromSpherical(r, theta, phi, vec) {
        const sinTheta = Math.sin(theta);
        vec[0] = sinTheta * Math.cos(phi);
        vec[1] = sinTheta * Math.sin(phi);
        vec[2] = Math.cos(theta);
        return vec;
    }
    /**
     * Add one vector to another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector sum.
     */
    static add(v1, v2, out) {
        out[0] = v1[0] + v2[0];
        out[1] = v1[1] + v2[1];
        out[2] = v1[2] + v2[2];
        return out;
    }
    /**
     * Subtracts one vector from another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector difference.
     */
    static sub(v1, v2, out) {
        out[0] = v1[0] - v2[0];
        out[1] = v1[1] - v2[1];
        out[2] = v1[2] - v2[2];
        return out;
    }
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     */
    static dot(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
    }
    /**
     * Gets the cross product of two vectors.
     * @param v1 - the first vector.
     * @param v2 - the second vector.
     * @param out - the vector to which to write the result.
     * @returns the cross product.
     */
    static cross(v1, v2, out) {
        const x1 = v1[0];
        const y1 = v1[1];
        const z1 = v1[2];
        const x2 = v2[0];
        const y2 = v2[1];
        const z2 = v2[2];
        out[0] = y1 * z2 - z1 * y2;
        out[1] = z1 * x2 - x1 * z2;
        out[2] = x1 * y2 - y1 * x2;
        return out;
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v1 The vector to multiply.
     * @param scalar The scalar to apply.
     * @param out The vector to write the results to.
     * @returns The scaled vector.
     */
    static multScalar(v1, scalar, out) {
        out[0] = v1[0] * scalar;
        out[1] = v1[1] * scalar;
        out[2] = v1[2] * scalar;
        return out;
    }
    /**
     * Gets the magnitude of a vector.
     * @param v1 The vector to get the magnitude for.
     * @returns the vector's magnitude.
     */
    static abs(v1) {
        return Math.hypot(v1[0], v1[1], v1[2]);
    }
    /**
     * Normalizes the vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns the normalized vector.
     */
    static normalize(v1, out) {
        const mag = Vec3Math.abs(v1);
        out[0] = v1[0] / mag;
        out[1] = v1[1] / mag;
        out[2] = v1[2] / mag;
        return out;
    }
    /**
     * Gets the Euclidean distance between two vectors.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns the Euclidean distance between the two vectors.
     */
    static distance(vec1, vec2) {
        return Math.hypot(vec2[0] - vec1[0], vec2[1] - vec1[0], vec2[2] - vec1[2]);
    }
    /**
     * Checks if two vectors are equal.
     * @param vec1 - the first vector.
     * @param vec2 - the second vector.
     * @returns whether the two vectors are equal.
     */
    static equals(vec1, vec2) {
        return vec1.length === vec2.length && vec1.every((element, index) => element === vec2[index]);
    }
    /**
     * Copies one vector to another.
     * @param from - the vector from which to copy.
     * @param to - the vector to which to copy.
     * @returns the changed vector.
     */
    static copy(from, to) {
        return Vec3Math.set(from[0], from[1], from[2], to);
    }
}

/**
 * A read-only wrapper for a GeoPoint.
 */
class GeoPointReadOnly {
    /**
     * Constructor.
     * @param source - the source of the new read-only point.
     */
    constructor(source) {
        this.source = source;
    }
    /**
     * The latitude of this point, in degrees.
     * @returns the latitude of this point.
     */
    get lat() {
        return this.source.lat;
    }
    /**
     * The longitude of this point, in degrees.
     * @returns the longitude of this point.
     */
    get lon() {
        return this.source.lon;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distance(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.distance(arg1, arg2);
        }
        else {
            return this.source.distance(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distanceRhumb(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.distanceRhumb(arg1, arg2);
        }
        else {
            return this.source.distanceRhumb(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingTo(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.bearingTo(arg1, arg2);
        }
        else {
            return this.source.bearingTo(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingFrom(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.bearingFrom(arg1, arg2);
        }
        else {
            return this.source.bearingFrom(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingRhumb(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.bearingRhumb(arg1, arg2);
        }
        else {
            return this.source.bearingRhumb(arg1);
        }
    }
    /**
     * Offsets this point by an initial bearing and distance along a great circle.
     * @param bearing - the initial bearing (forward azimuth) by which to offset.
     * @param distance - the distance, in great-arc radians, by which to offset.
     * @param out - the GeoPoint to which to write the results. If not supplied, a new GeoPoint object is created.
     * @returns the offset point.
     * @throws {Error} argument out cannot be undefined.
     */
    offset(bearing, distance, out) {
        if (!out) {
            throw new Error('Cannot mutate a read-only GeoPoint.');
        }
        return this.source.offset(bearing, distance, out);
    }
    /**
     * Offsets this point by a constant bearing and distance along a rhumb line.
     * @param bearing - the bearing by which to offset.
     * @param distance - the distance, in great-arc radians, by which to offset.
     * @param out - the GeoPoint to which to write the results. If not supplied, a new GeoPoint object is created.
     * @returns the offset point.
     * @throws {Error} argument out cannot be undefined.
     */
    offsetRhumb(bearing, distance, out) {
        if (!out) {
            throw new Error('Cannot mutate a read-only GeoPoint.');
        }
        return this.source.offsetRhumb(bearing, distance, out);
    }
    /**
     * Calculates the cartesian (x, y, z) representation of this point, in units of great-arc radians. By convention,
     * in the cartesian coordinate system the origin is at the center of the Earth, the positive x-axis passes through
     * 0 degrees N, 0 degrees E, and the positive z-axis passes through the north pole.
     * @param out - the vector array to which to write the result.
     * @returns the cartesian representation of this point.
     */
    toCartesian(out) {
        return this.source.toCartesian(out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2, arg3) {
        if (typeof arg1 === 'number') {
            return this.source.equals(arg1, arg2, arg3);
        }
        else {
            return this.source.equals(arg1, arg2);
        }
    }
    /**
     * Copies this point.
     * @param to - an optional point to which to copy this point. If this argument is not supplied, a new GeoPoint object
     * will be created.
     * @returns a copy of this point.
     */
    copy(to) {
        return this.source.copy(to);
    }
}
/**
 * A point on Earth's surface. This class uses a spherical Earth model.
 */
class GeoPoint {
    /**
     * Constructor.
     * @param lat - the latitude, in degrees.
     * @param lon - the longitude, in degrees.
     */
    constructor(lat, lon) {
        this._lat = 0;
        this._lon = 0;
        this.set(lat, lon);
        this.readonly = new GeoPointReadOnly(this);
    }
    /**
     * The latitude of this point, in degrees.
     * @returns the latitude of this point.
     */
    get lat() {
        return this._lat;
    }
    /**
     * The longitude of this point, in degrees.
     * @returns the longitude of this point.
     */
    get lon() {
        return this._lon;
    }
    /**
     * Converts an argument list consisting of either a LatLonInterface or lat/lon coordinates into an equivalent
     * LatLonInterface.
     * @param arg1 Argument 1.
     * @param arg2 Argument 2.
     * @returns a LatLonInterface.
     */
    static asLatLonInterface(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return GeoPoint.tempGeoPoint.set(arg1, arg2);
        }
        else {
            return arg1;
        }
    }
    /**
     * Converts an argument list consisting of either a 3D vector or x, y, z components into an equivalent 3D vector.
     * @param arg1 Argument 1.
     * @param arg2 Argument 2.
     * @param arg3 Argument 3.
     * @returns a 3D vector.
     */
    static asVec3(arg1, arg2, arg3) {
        if (typeof arg1 === 'number') {
            return Vec3Math.set(arg1, arg2, arg3, GeoPoint.tempVec3);
        }
        else {
            return arg1;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        let lat, lon;
        if (typeof arg1 === 'number') {
            lat = arg1;
            lon = arg2;
        }
        else {
            lat = arg1.lat;
            lon = arg1.lon;
        }
        lat = GeoPoint.toPlusMinus180(lat);
        lon = GeoPoint.toPlusMinus180(lon);
        if (Math.abs(lat) > 90) {
            lat = 180 - lat;
            lat = GeoPoint.toPlusMinus180(lat);
            lon += 180;
            lon = GeoPoint.toPlusMinus180(lon);
        }
        this._lat = lat;
        this._lon = lon;
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setFromCartesian(arg1, arg2, arg3) {
        const vec = GeoPoint.asVec3(arg1, arg2, arg3);
        const theta = Vec3Math.theta(vec);
        const phi = Vec3Math.phi(vec);
        return this.set(90 - theta * Avionics.Utils.RAD2DEG, phi * Avionics.Utils.RAD2DEG);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distance(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        const lat1 = this.lat * Avionics.Utils.DEG2RAD;
        const lat2 = other.lat * Avionics.Utils.DEG2RAD;
        const lon1 = this.lon * Avionics.Utils.DEG2RAD;
        const lon2 = other.lon * Avionics.Utils.DEG2RAD;
        // haversine formula
        const sinHalfDeltaLat = Math.sin((lat2 - lat1) / 2);
        const sinHalfDeltaLon = Math.sin((lon2 - lon1) / 2);
        const a = sinHalfDeltaLat * sinHalfDeltaLat + Math.cos(lat1) * Math.cos(lat2) * sinHalfDeltaLon * sinHalfDeltaLon;
        return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distanceRhumb(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        const lat1 = this.lat * Avionics.Utils.DEG2RAD;
        const lat2 = other.lat * Avionics.Utils.DEG2RAD;
        const lon1 = this.lon * Avionics.Utils.DEG2RAD;
        const lon2 = other.lon * Avionics.Utils.DEG2RAD;
        const deltaLat = lat2 - lat1;
        let deltaLon = lon2 - lon1;
        const deltaPsi = GeoPoint.deltaPsi(lat1, lat2);
        const correction = GeoPoint.rhumbCorrection(deltaPsi, lat1, lat2);
        if (Math.abs(deltaLon) > Math.PI) {
            deltaLon += -Math.sign(deltaLon) * 2 * Math.PI;
        }
        return Math.sqrt(deltaLat * deltaLat + correction * correction * deltaLon * deltaLon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingTo(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.calculateInitialBearing(this, other);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingFrom(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return (GeoPoint.calculateInitialBearing(this, other) + 180) % 360;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingRhumb(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        const lat1 = this.lat * Avionics.Utils.DEG2RAD;
        const lon1 = this.lon * Avionics.Utils.DEG2RAD;
        const lat2 = other.lat * Avionics.Utils.DEG2RAD;
        const lon2 = other.lon * Avionics.Utils.DEG2RAD;
        let deltaLon = lon2 - lon1;
        const deltaPsi = GeoPoint.deltaPsi(lat1, lat2);
        if (Math.abs(deltaLon) > Math.PI) {
            deltaLon += -Math.sign(deltaLon) * 2 * Math.PI;
        }
        return Math.atan2(deltaLon, deltaPsi) * Avionics.Utils.RAD2DEG;
    }
    /**
     * Offsets this point by an initial bearing and distance along a great circle.
     * @param bearing - the initial bearing (forward azimuth) by which to offset.
     * @param distance - the distance, in great-arc radians, by which to offset.
     * @param out - the GeoPoint to which to write the results. By default this point.
     * @returns the offset point.
     */
    offset(bearing, distance, out) {
        const latRad = this.lat * Avionics.Utils.DEG2RAD;
        const lonRad = this.lon * Avionics.Utils.DEG2RAD;
        const sinLat = Math.sin(latRad);
        const cosLat = Math.cos(latRad);
        const sinBearing = Math.sin(bearing * Avionics.Utils.DEG2RAD);
        const cosBearing = Math.cos(bearing * Avionics.Utils.DEG2RAD);
        const angularDistance = distance;
        const sinAngularDistance = Math.sin(angularDistance);
        const cosAngularDistance = Math.cos(angularDistance);
        const offsetLatRad = Math.asin(sinLat * cosAngularDistance + cosLat * sinAngularDistance * cosBearing);
        const offsetLonDeltaRad = Math.atan2(sinBearing * sinAngularDistance * cosLat, cosAngularDistance - sinLat * Math.sin(offsetLatRad));
        const offsetLat = offsetLatRad * Avionics.Utils.RAD2DEG;
        const offsetLon = (lonRad + offsetLonDeltaRad) * Avionics.Utils.RAD2DEG;
        return (out !== null && out !== void 0 ? out : this).set(offsetLat, offsetLon);
    }
    /**
     * Offsets this point by a constant bearing and distance along a rhumb line.
     * @param bearing - the bearing by which to offset.
     * @param distance - the distance, in great-arc radians, by which to offset.
     * @param out - the GeoPoint to which to write the results. By default this point.
     * @returns the offset point.
     */
    offsetRhumb(bearing, distance, out) {
        const latRad = this.lat * Avionics.Utils.DEG2RAD;
        const lonRad = this.lon * Avionics.Utils.DEG2RAD;
        const bearingRad = bearing * Avionics.Utils.DEG2RAD;
        const deltaLat = distance * Math.cos(bearingRad);
        let offsetLat = latRad + deltaLat;
        let offsetLon;
        if (Math.abs(offsetLat) >= Math.PI / 2) {
            // you can't technically go past the poles along a rhumb line, so we will simply terminate the path at the pole
            offsetLat = Math.sign(offsetLat) * 90;
            offsetLon = 0; // since longitude is meaningless at the poles, we'll arbitrarily pick a longitude of 0 degrees.
        }
        else {
            const deltaPsi = GeoPoint.deltaPsi(latRad, offsetLat);
            const correction = GeoPoint.rhumbCorrection(deltaPsi, latRad, offsetLat);
            const deltaLon = distance * Math.sin(bearingRad) / correction;
            offsetLon = lonRad + deltaLon;
            offsetLat *= Avionics.Utils.RAD2DEG;
            offsetLon *= Avionics.Utils.RAD2DEG;
        }
        return (out !== null && out !== void 0 ? out : this).set(offsetLat, offsetLon);
    }
    /**
     * Calculates the cartesian (x, y, z) representation of this point, in units of great-arc radians. By convention,
     * in the cartesian coordinate system the origin is at the center of the Earth, the positive x-axis passes through
     * 0 degrees N, 0 degrees E, and the positive z-axis passes through the north pole.
     * @param out - the vector array to which to write the result.
     * @returns the cartesian representation of this point.
     */
    toCartesian(out) {
        return GeoPoint.sphericalToCartesian(this, out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2, arg3) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        const tolerance = typeof arg1 === 'number' ? arg3 : arg2;
        if (other) {
            return this.distance(other) <= (tolerance !== null && tolerance !== void 0 ? tolerance : GeoPoint.EQUALITY_TOLERANCE);
        }
        else {
            return false;
        }
    }
    /**
     * Copies this point.
     * @param to - an optional point to which to copy this point. If this argument is not supplied, a new GeoPoint object
     * will be created.
     * @returns a copy of this point.
     */
    copy(to) {
        return to ? to.set(this.lat, this.lon) : new GeoPoint(this.lat, this.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static sphericalToCartesian(arg1, arg2, arg3) {
        const point = GeoPoint.asLatLonInterface(arg1, arg2);
        const theta = (90 - point.lat) * Avionics.Utils.DEG2RAD;
        const phi = point.lon * Avionics.Utils.DEG2RAD;
        return Vec3Math.setFromSpherical(1, theta, phi, arg3 !== null && arg3 !== void 0 ? arg3 : arg2);
    }
    /**
     * Converts an angle, in degrees, to an equivalent value in the range [-180, 180).
     * @param angle - an angle in degrees.
     * @returns the angle's equivalent in the range [-180, 180).
     */
    static toPlusMinus180(angle) {
        return ((angle % 360) + 540) % 360 - 180;
    }
    /**
     * Calculates the initial bearing (forward azimuth) from an origin point to a destination point.
     * @param origin - the origin point.
     * @param destination - the destination point.
     * @returns the initial bearing from the origin to destination.
     */
    static calculateInitialBearing(origin, destination) {
        const lat1 = origin.lat * Avionics.Utils.DEG2RAD;
        const lat2 = destination.lat * Avionics.Utils.DEG2RAD;
        const lon1 = origin.lon * Avionics.Utils.DEG2RAD;
        const lon2 = destination.lon * Avionics.Utils.DEG2RAD;
        const cosLat2 = Math.cos(lat2);
        const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * cosLat2 * Math.cos(lon2 - lon1);
        const y = Math.sin(lon2 - lon1) * cosLat2;
        const bearing = Math.atan2(y, x) * Avionics.Utils.RAD2DEG;
        return (bearing + 360) % 360; // enforce range [0, 360)
    }
    /**
     * Calculates the difference in isometric latitude from a pair of geodetic (geocentric) latitudes.
     * @param latRad1 - geodetic latitude 1, in radians.
     * @param latRad2 - geodetic latitude 2, in radians.
     * @returns the difference in isometric latitude from latitude 1 to latitude 2, in radians.
     */
    static deltaPsi(latRad1, latRad2) {
        return Math.log(Math.tan(latRad2 / 2 + Math.PI / 4) / Math.tan(latRad1 / 2 + Math.PI / 4));
    }
    /**
     * Calculates the rhumb correction factor between two latitudes.
     * @param deltaPsi - the difference in isometric latitude beween the two latitudes.
     * @param latRad1 - geodetic latitude 1, in radians.
     * @param latRad2 - geodetic latitude 2, in radians.
     * @returns the rhumb correction factor between the two latitudes.
     */
    static rhumbCorrection(deltaPsi, latRad1, latRad2) {
        return Math.abs(deltaPsi) > 1e-12 ? ((latRad2 - latRad1) / deltaPsi) : Math.cos(latRad1);
    }
}
/**
 * The default equality tolerance, defined as the maximum allowed distance between two equal points in great-arc
 * radians.
 */
GeoPoint.EQUALITY_TOLERANCE = 1e-7; // ~61 cm
GeoPoint.tempVec3 = new Float64Array(3);
GeoPoint.tempGeoPoint = new GeoPoint(0, 0);

/**
 * A circle on Earth's surface, defined as the set of points on the Earth's surface equidistant (as measured
 * geodetically) from a central point.
 */
class GeoCircle {
    /**
     * Constructor.
     * @param center The center of the new small circle, represented as a position vector in the standard geographic
     * cartesian reference system.
     * @param radius The radius of the new small circle in great-arc radians.
     */
    constructor(center, radius) {
        this._center = new Float64Array(3);
        this._radius = 0;
        this.set(center, radius);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The center of this circle.
     */
    get center() {
        return this._center;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The radius of this circle, in great-arc radians.
     */
    get radius() {
        return this._radius;
    }
    /**
     * Checks whether this circle is a great circle, or equivalently, whether its radius is equal to pi / 2 great-arc
     * radians.
     * @returns Whether this circle is a great circle.
     */
    isGreatCircle() {
        return this._radius === Math.PI / 2;
    }
    /**
     * Calculates the length of an arc along this circle subtended by a central angle.
     * @param angle A central angle, in radians.
     * @returns the length of the arc subtended by the angle, in great-arc radians.
     */
    arcLength(angle) {
        return Math.sin(this._radius) * angle;
    }
    /**
     * Sets the center and radius of this circle.
     * @param center The new center.
     * @param radius The new radius in great-arc radians.
     * @returns this circle, after it has been changed.
     */
    set(center, radius) {
        if (center instanceof Float64Array) {
            if (Vec3Math.abs(center) === 0) {
                // if center has no direction, arbitrarily set the center to 0 N, 0 E.
                Vec3Math.set(1, 0, 0, this._center);
            }
            else {
                Vec3Math.normalize(center, this._center);
            }
        }
        else {
            GeoPoint.sphericalToCartesian(center, this._center);
        }
        this._radius = Math.abs(radius) % Math.PI;
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setAsGreatCircle(arg1, arg2) {
        this.set(GeoCircle._getGreatCircleNormal(arg1, arg2, GeoCircle.vec3Cache[0]), Math.PI / 2);
        return this;
    }
    /**
     * Gets the distance from a point to the center of this circle, in great-arc radians.
     * @param point The point to which to measure the distance.
     * @returns the distance from the point to the center of this circle.
     */
    distanceToCenter(point) {
        if (point instanceof Float64Array) {
            point = Vec3Math.normalize(point, GeoCircle.vec3Cache[0]);
        }
        else {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]);
        }
        const dot = Vec3Math.dot(point, this._center);
        return Math.acos(Utils.Clamp(dot, -1, 1));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    closest(point, out) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]);
        }
        const offset = Vec3Math.multScalar(this._center, Math.cos(this._radius), GeoCircle.vec3Cache[1]);
        const dot = Vec3Math.dot(Vec3Math.sub(point, offset, GeoCircle.vec3Cache[2]), this._center);
        const planeProjected = Vec3Math.sub(point, Vec3Math.multScalar(this._center, dot, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]);
        if (Vec3Math.dot(planeProjected, planeProjected) === 0 || Math.abs(Vec3Math.dot(planeProjected, this._center)) === 1) {
            // the point is equidistant from all points on this circle
            return out instanceof GeoPoint ? out.set(NaN, NaN) : Vec3Math.set(NaN, NaN, NaN, out);
        }
        const displacement = Vec3Math.multScalar(Vec3Math.normalize(Vec3Math.sub(planeProjected, offset, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]), Math.sin(this._radius), GeoCircle.vec3Cache[2]);
        const closest = Vec3Math.add(offset, displacement, GeoCircle.vec3Cache[2]);
        return out instanceof Float64Array ? Vec3Math.normalize(closest, out) : out.setFromCartesian(closest);
    }
    /**
     * Calculates and returns the great-circle distance from a specified point to the closest point that lies on this
     * circle. In other words, calculates the shortest distance from a point to this circle. The distance is signed, with
     * positive distances representing deviation away from the center of the circle, and negative distances representing
     * deviation toward the center of the circle.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @returns the great circle distance, in great-arc radians, from the point to the closest point on this circle.
     */
    distance(point) {
        const distanceToCenter = this.distanceToCenter(point);
        return distanceToCenter - this._radius;
    }
    /**
     * Checks whether a point lies on this circle.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param tolerance - the error tolerance, in great-arc radians, of this operation. Defaults to 1e-8 (roughly 6 cm)
     * if not specified.
     * @returns whether the point lies on this circle.
     */
    includes(point, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const distance = this.distance(point);
        return Math.abs(distance) < tolerance;
    }
    /**
     * Checks whether a point lies within the boundary defined by this circle. This is equivalent to checking whether
     * the distance of the point from the center of this circle is less than or equal to this circle's radius.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param inclusive Whether points that lie on this circle should pass the check. True by default.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to 1e-8 (roughly 6 cm)
     * if not specified.
     * @returns whether the point lies within the boundary defined by this circle.
     */
    encircles(point, inclusive = true, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const distance = this.distance(point);
        return inclusive
            ? distance <= tolerance
            : distance < -tolerance;
    }
    /**
     * Gets the angular distance along an arc between two points that lie on this circle. The arc extends from the first
     * point to the second in a counterclockwise direction when viewed from above the center of the circle.
     * @param start A point on this circle which marks the beginning of an arc.
     * @param end A point on this circle which marks the end of an arc.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `end` lie on this circle.
     * Defaults to 1e-8 (roughly 6 cm) if not specified.
     * @returns the angular width of the arc between the two points, in radians.
     * @throws Error if either point does not lie on this circle.
     */
    angleAlong(start, end, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, GeoCircle.vec3Cache[1]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, GeoCircle.vec3Cache[2]);
        }
        if (!this.includes(start, tolerance) || !this.includes(end, tolerance)) {
            throw new Error(`GeoCircle: at least one of the two specified arc end points does not lie on this circle (start point distance of ${this.distance(start)}, end point distance of ${this.distance(end)}, vs tolerance of ${tolerance}).`);
        }
        if (this._radius <= GeoCircle.ANGULAR_TOLERANCE) {
            return 0;
        }
        const startRadialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, start, GeoCircle.vec3Cache[3]), GeoCircle.vec3Cache[3]);
        const endRadialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, end, GeoCircle.vec3Cache[4]), GeoCircle.vec3Cache[4]);
        const angularDistance = Math.acos(Utils.Clamp(Vec3Math.dot(startRadialNormal, endRadialNormal), -1, 1));
        const isArcGreaterThanSemi = Vec3Math.dot(startRadialNormal, end) < 0;
        return isArcGreaterThanSemi ? 2 * Math.PI - angularDistance : angularDistance;
    }
    /**
     * Gets the distance along an arc between two points that lie on this circle. The arc extends from the first point
     * to the second in a counterclockwise direction when viewed from above the center of the circle.
     * @param start A point on this circle which marks the beginning of an arc.
     * @param end A point on this circle which marks the end of an arc.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `end` lie on this circle.
     * Defaults to 1e-8 (roughly 6 cm) if not specified.
     * @returns the length of the arc between the two points, in great-arc radians.
     * @throws Error if either point does not lie on this circle.
     */
    distanceAlong(start, end, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        return this.arcLength(this.angleAlong(start, end, tolerance));
    }
    /**
     * Calculates the true bearing along this circle at a point on the circle.
     * @param point A point on this circle.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to 1e-8 (roughly 6 cm) if not specified.
     * @returns the bearing along this circle at the point.
     * @throws Error if the point does not lie on this circle.
     */
    bearingAt(point, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[1]);
        }
        if (!this.includes(point, tolerance)) {
            throw new Error(`GeoCircle: the specified point does not lie on this circle (distance of ${Math.abs(this.distance(point))} vs tolerance of ${tolerance}).`);
        }
        if (this._radius <= GeoCircle.ANGULAR_TOLERANCE || 1 - Math.abs(Vec3Math.dot(point, GeoCircle.NORTH_POLE)) <= GeoCircle.ANGULAR_TOLERANCE) {
            // Meaningful bearings cannot be defined along a circle with 0 radius (effectively a point) and at the north and south poles.
            return NaN;
        }
        const radialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, point, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]);
        const northNormal = Vec3Math.normalize(Vec3Math.cross(point, GeoCircle.NORTH_POLE, GeoCircle.vec3Cache[3]), GeoCircle.vec3Cache[3]);
        return (Math.acos(Utils.Clamp(Vec3Math.dot(radialNormal, northNormal), -1, 1)) * (radialNormal[2] >= 0 ? 1 : -1) * Avionics.Utils.RAD2DEG - 90 + 360) % 360;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    offsetDistanceAlong(point, distance, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const angle = distance / Math.sin(this.radius);
        return this._offsetAngleAlong(point, angle, out, tolerance);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    offsetAngleAlong(point, angle, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        return this._offsetAngleAlong(point, angle, out, tolerance);
    }
    /**
     * Offsets a point on this circle by a specified angular distance. The direction of the offset for positive distances
     * is counterclockwise when viewed from above the center of this circle.
     * @param point The point to offset.
     * @param angle The angular distance by which to offset, in radians.
     * @param out A Float64Array or GeoPoint object to which to write the result.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to 1e-8 (roughly 6 cm) if not specified.
     * @returns The offset point.
     * @throws Error if the point does not lie on this circle.
     */
    _offsetAngleAlong(point, angle, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[3]);
        }
        if (!this.includes(point, tolerance)) {
            throw new Error(`GeoCircle: the specified point does not lie on this circle (distance of ${Math.abs(this.distance(point))} vs tolerance of ${tolerance}).`);
        }
        if (this.radius === 0) {
            return out instanceof GeoPoint ? out.setFromCartesian(point) : Vec3Math.copy(point, out);
        }
        // Since point may not lie exactly on this circle due to error tolerance, project point onto this circle to ensure
        // the offset point lies exactly on this circle.
        point = this.closest(point, GeoCircle.vec3Cache[3]);
        const sin = Math.sin(angle / 2);
        const q0 = Math.cos(angle / 2);
        const q1 = sin * this._center[0];
        const q2 = sin * this._center[1];
        const q3 = sin * this._center[2];
        const q0Sq = q0 * q0;
        const q1Sq = q1 * q1;
        const q2Sq = q2 * q2;
        const q3Sq = q3 * q3;
        const q01 = q0 * q1;
        const q02 = q0 * q2;
        const q03 = q0 * q3;
        const q12 = q1 * q2;
        const q13 = q1 * q3;
        const q23 = q2 * q3;
        const rot_11 = q0Sq + q1Sq - q2Sq - q3Sq;
        const rot_12 = 2 * (q12 - q03);
        const rot_13 = 2 * (q13 + q02);
        const rot_21 = 2 * (q12 + q03);
        const rot_22 = q0Sq - q1Sq + q2Sq - q3Sq;
        const rot_23 = 2 * (q23 - q01);
        const rot_31 = 2 * (q13 - q02);
        const rot_32 = 2 * (q23 + q01);
        const rot_33 = (q0Sq - q1Sq - q2Sq + q3Sq);
        const x = point[0];
        const y = point[1];
        const z = point[2];
        const rotX = rot_11 * x + rot_12 * y + rot_13 * z;
        const rotY = rot_21 * x + rot_22 * y + rot_23 * z;
        const rotZ = rot_31 * x + rot_32 * y + rot_33 * z;
        return out instanceof Float64Array
            ? Vec3Math.set(rotX, rotY, rotZ, out)
            : out.setFromCartesian(Vec3Math.set(rotX, rotY, rotZ, GeoCircle.vec3Cache[2]));
    }
    /**
     * Calculates and returns the set of intersection points between this circle and another one, and writes the results
     * to an array of position vectors.
     * @param other The other circle to test for intersections.
     * @param out An array in which to store the results. The results will be stored at indexes 0 and 1. If these indexes
     * are empty, then new Float64Array objects will be created and inserted into the array.
     * @returns The number of solutions written to the out array. Either 0, 1, or 2.
     */
    intersection(other, out) {
        const center1 = this._center;
        const center2 = other._center;
        const radius1 = this._radius;
        const radius2 = other._radius;
        /**
         * Theory: We can model geo circles as the intersection between a sphere and the unit sphere (Earth's surface).
         * Therefore, the intersection of two geo circles is the intersection between two spheres AND the unit sphere.
         * First, we find the intersection of the two non-Earth spheres (which can either be a sphere, a circle, or a
         * point), then we find the intersection of that geometry with the unit sphere.
         */
        const dot = Vec3Math.dot(center1, center2);
        const dotSquared = dot * dot;
        if (dotSquared === 1) {
            // the two circles are concentric; either there are zero solutions or infinite solutions; either way we don't
            // write any solutions to the array.
            return 0;
        }
        // find the position vector to the center of the circle which defines the intersection of the two geo circle
        // spheres.
        const a = (Math.cos(radius1) - dot * Math.cos(radius2)) / (1 - dotSquared);
        const b = (Math.cos(radius2) - dot * Math.cos(radius1)) / (1 - dotSquared);
        const intersection = Vec3Math.add(Vec3Math.multScalar(center1, a, GeoCircle.vec3Cache[0]), Vec3Math.multScalar(center2, b, GeoCircle.vec3Cache[1]), GeoCircle.vec3Cache[0]);
        const intersectionLengthSquared = Vec3Math.dot(intersection, intersection);
        if (intersectionLengthSquared > 1) {
            // the two geo circle spheres do not intersect.
            return 0;
        }
        const cross = Vec3Math.cross(center1, center2, GeoCircle.vec3Cache[1]);
        const crossLengthSquared = Vec3Math.dot(cross, cross);
        if (crossLengthSquared === 0) {
            // this technically can't happen (since we already check if center1 dot center2 === +/-1 above, but just in
            // case...)
            return 0;
        }
        const offset = Math.sqrt((1 - intersectionLengthSquared) / crossLengthSquared);
        let solutionCount = 1;
        if (!out[0]) {
            out[0] = new Float64Array(3);
        }
        out[0].set(cross);
        Vec3Math.multScalar(out[0], offset, out[0]);
        Vec3Math.add(out[0], intersection, out[0]);
        if (offset > 0) {
            if (!out[1]) {
                out[1] = new Float64Array(3);
            }
            out[1].set(cross);
            Vec3Math.multScalar(out[1], -offset, out[1]);
            Vec3Math.add(out[1], intersection, out[1]);
            solutionCount++;
        }
        return solutionCount;
    }
    /**
     * Calculates and returns the set of intersection points between this circle and another one, and writes the results
     * to an array of GeoPoint objects.
     * @param other The other circle to test for intersections.
     * @param out An array in which to store the results. The results will be stored at indexes 0 and 1. If these indexes
     * are empty, then new GeoPoint objects will be created and inserted into the array.
     * @returns The number of solutions written to the out array. Either 0, 1, or 2.
     */
    intersectionGeoPoint(other, out) {
        const solutionCount = this.intersection(other, GeoCircle.intersectionCache);
        for (let i = 0; i < solutionCount; i++) {
            if (!out[i]) {
                out[i] = new GeoPoint(0, 0);
            }
            out[i].setFromCartesian(GeoCircle.intersectionCache[i]);
        }
        return solutionCount;
    }
    /**
     * Calculates and returns the number of intersection points between this circle and another one. Returns NaN if there
     * are an infinite number of intersection points.
     * @param other The other circle to test for intersections.
     * @param tolerance - the error tolerance, in great-arc radians, of this operation. Defaults to 1e-8 (roughly 6 cm)
     * if not specified.
     * @returns the number of intersection points between this circle and the other one.
     */
    numIntersectionPoints(other, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const center1 = this.center;
        const center2 = other.center;
        const radius1 = this.radius;
        const radius2 = other.radius;
        const dot = Vec3Math.dot(center1, center2);
        const dotSquared = dot * dot;
        if (dotSquared === 1) {
            // the two circles are concentric; if they are the same circle there are an infinite number of intersections,
            // otherwise there are none.
            if (dot === 1) {
                // centers are the same
                return (Math.abs(this.radius - other.radius) <= tolerance) ? NaN : 0;
            }
            else {
                // centers are antipodal
                return (Math.abs(Math.PI - this.radius - other.radius) <= tolerance) ? NaN : 0;
            }
        }
        const a = (Math.cos(radius1) - dot * Math.cos(radius2)) / (1 - dotSquared);
        const b = (Math.cos(radius2) - dot * Math.cos(radius1)) / (1 - dotSquared);
        const intersection = Vec3Math.add(Vec3Math.multScalar(center1, a, GeoCircle.vec3Cache[0]), Vec3Math.multScalar(center2, b, GeoCircle.vec3Cache[1]), GeoCircle.vec3Cache[1]);
        const intersectionLengthSquared = Vec3Math.dot(intersection, intersection);
        if (intersectionLengthSquared > 1) {
            return 0;
        }
        const cross = Vec3Math.cross(center1, center2, GeoCircle.vec3Cache[1]);
        const crossLengthSquared = Vec3Math.dot(cross, cross);
        if (crossLengthSquared === 0) {
            return 0;
        }
        const sinTol = Math.sin(tolerance);
        return ((1 - intersectionLengthSquared) / crossLengthSquared > sinTol * sinTol) ? 2 : 1;
    }
    /**
     * Creates a new small circle from a lat/long coordinate pair and radius.
     * @param point The center of the new small circle.
     * @param radius The radius of the new small circle, in great-arc radians.
     * @returns a small circle.
     */
    static createFromPoint(point, radius) {
        return new GeoCircle(GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]), radius);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static createGreatCircle(arg1, arg2) {
        return new GeoCircle(GeoCircle._getGreatCircleNormal(arg1, arg2, GeoCircle.vec3Cache[0]), Math.PI / 2);
    }
    /**
     * Creates a new great circle defined by one point and a bearing offset. The new great circle will be equivalent to
     * the path projected from the point with the specified initial bearing (forward azimuth).
     * @param point A point that lies on the new great circle.
     * @param bearing The initial bearing from the point.
     * @returns a great circle.
     */
    static createGreatCircleFromPointBearing(point, bearing) {
        return new GeoCircle(GeoCircle.getGreatCircleNormalFromPointBearing(point, bearing, GeoCircle.vec3Cache[0]), Math.PI / 2);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static getGreatCircleNormal(arg1, arg2, out) {
        return GeoCircle._getGreatCircleNormal(arg1, arg2, out);
    }
    /**
     * Calculates a normal vector for a great circle given two points which lie on the circle, or a point and initial bearing.
     * @param arg1 A point that lies on the great circle.
     * @param arg2 A second point that lies on the great circle, or an initial bearing from the first point.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static _getGreatCircleNormal(arg1, arg2, out) {
        if (typeof arg2 === 'number') {
            return GeoCircle.getGreatCircleNormalFromPointBearing(arg1, arg2, out);
        }
        else {
            return GeoCircle.getGreatCircleNormalFromPoints(arg1, arg2, out);
        }
    }
    /**
     * Calculates a normal vector for a great circle given two points which lie on the cirlce.
     * @param point1 The first point that lies on the great circle.
     * @param point2 The second point that lies on the great circle.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static getGreatCircleNormalFromPoints(point1, point2, out) {
        if (!(point1 instanceof Float64Array)) {
            point1 = GeoPoint.sphericalToCartesian(point1, GeoCircle.vec3Cache[0]);
        }
        if (!(point2 instanceof Float64Array)) {
            point2 = GeoPoint.sphericalToCartesian(point2, GeoCircle.vec3Cache[1]);
        }
        return Vec3Math.normalize(Vec3Math.cross(point1, point2, out), out);
    }
    /**
     * Calculates a normal vector for a great circle given a point and initial bearing.
     * @param point A point that lies on the great circle.
     * @param bearing The initial bearing from the point.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static getGreatCircleNormalFromPointBearing(point, bearing, out) {
        if (point instanceof Float64Array) {
            point = GeoCircle.tempGeoPoint.setFromCartesian(point);
        }
        const lat = point.lat * Avionics.Utils.DEG2RAD;
        const long = point.lon * Avionics.Utils.DEG2RAD;
        bearing *= Avionics.Utils.DEG2RAD;
        const sinLat = Math.sin(lat);
        const sinLon = Math.sin(long);
        const cosLon = Math.cos(long);
        const sinBearing = Math.sin(bearing);
        const cosBearing = Math.cos(bearing);
        const x = sinLon * cosBearing - sinLat * cosLon * sinBearing;
        const y = -cosLon * cosBearing - sinLat * sinLon * sinBearing;
        const z = Math.cos(lat) * sinBearing;
        return Vec3Math.set(x, y, z, out);
    }
}
GeoCircle.ANGULAR_TOLERANCE = 1e-7; // ~61cm
GeoCircle.NORTH_POLE = new Float64Array([0, 0, 1]);
GeoCircle.tempGeoPoint = new GeoPoint(0, 0);
GeoCircle.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
GeoCircle.intersectionCache = [new Float64Array(3), new Float64Array(3)];

/**
 * Navigational mathematics functions.
 */
class NavMath {
    /**
     * Clamps a value to a min and max.
     * @param val The value to clamp.
     * @param min The minimum value to clamp to.
     * @param max The maximum value to clamp to.
     * @returns The clamped value.
     */
    static clamp(val, min, max) {
        return Math.min(Math.max(val, min), max);
    }
    /**
     * Normalizes a heading to a 0-360 range.
     * @param heading The heading to normalize.
     * @returns The normalized heading.
     */
    static normalizeHeading(heading) {
        if (isFinite(heading)) {
            return (heading % 360 + 360) % 360;
        }
        else {
            console.error(`normalizeHeading: Invalid heading: ${heading}`);
            return NaN;
        }
    }
    /**
     * Gets the turn radius for a given true airspeed.
     * @param airspeedTrue The true airspeed of the plane.
     * @param bankAngle The bank angle of the plane, in degrees.
     * @returns The airplane turn radius.
     */
    static turnRadius(airspeedTrue, bankAngle) {
        return (Math.pow(airspeedTrue, 2) / (11.26 * Math.tan(bankAngle * NavMath.DEG2RAD)))
            / 3.2808399;
    }
    /**
     * Gets the required bank angle for a given true airspeed and turn radius.
     * @param airspeedTrue The true airspeed of the plane.
     * @param radius The airplane turn radius.
     * @returns The required bank angle, in degrees.
     */
    static bankAngle(airspeedTrue, radius) {
        const airspeedMS = airspeedTrue * 0.51444444;
        return Units.Radians.toDegrees(Math.atan(Math.pow(airspeedMS, 2) / (radius * 9.80665)));
    }
    /**
     * Get the turn direction for a given course change.
     * @param startCourse The start course.
     * @param endCourse The end course.
     * @returns The turn direction for the course change.
     */
    static getTurnDirection(startCourse, endCourse) {
        return NavMath.normalizeHeading(endCourse - startCourse) > 180 ? 'left' : 'right';
    }
    /**
     * Converts polar radians to degrees north.
     * @param radians The radians to convert.
     * @returns The angle, in degrees north.
     */
    static polarToDegreesNorth(radians) {
        return NavMath.normalizeHeading((180 / Math.PI) * (Math.PI / 2 - radians));
    }
    /**
     * Converts degrees north to polar radians.
     * @param degrees The degrees to convert.
     * @returns The angle radians, in polar.
     */
    static degreesNorthToPolar(degrees) {
        return NavMath.normalizeHeading(degrees - 90) / (180 / Math.PI);
    }
    /**
     * Calculates the distance along an arc on Earth's surface. The arc begins at the intersection of the great circle
     * passing through the center of a circle of radius `radius` meters in the direction of 'startBearing', and ends at
     * the intersection of the great circle passing through the center of the circle in the direction of 'endBearing',
     * proceeding clockwise (as viewed from above).
     * @param startBearing The degrees of the start of the arc.
     * @param endBearing The degrees of the end of the arc.
     * @param radius The radius of the arc, in meters.
     * @returns The arc distance.
     */
    static calculateArcDistance(startBearing, endBearing, radius) {
        const angularWidth = ((endBearing - startBearing + 360) % 360) * Avionics.Utils.DEG2RAD;
        const conversion = UnitType.GA_RADIAN.convertTo(1, UnitType.METER);
        return angularWidth * Math.sin(radius / conversion) * conversion;
    }
    /**
     * Calculates the intersection of a line and a circle.
     * @param x1 The start x of the line.
     * @param y1 The start y of the line.
     * @param x2 The end x of the line.
     * @param y2 The end y of the line.
     * @param cx The circle center x.
     * @param cy The circle center y.
     * @param r The radius of the circle.
     * @param sRef The reference to the solution object to write the solution to.
     * @returns The number of solutions (0, 1 or 2).
     */
    static circleIntersection(x1, y1, x2, y2, cx, cy, r, sRef) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const a = dx * dx + dy * dy;
        const b = 2 * (dx * (x1 - cx) + dy * (y1 - cy));
        const c = (x1 - cx) * (x1 - cx) + (y1 - cy) * (y1 - cy) - r * r;
        const det = b * b - 4 * a * c;
        if (a < 0.0000001 || det < 0) {
            sRef.x1 = NaN;
            sRef.x2 = NaN;
            sRef.y1 = NaN;
            sRef.y2 = NaN;
            return 0;
        }
        else if (det == 0) {
            const t = -b / (2 * a);
            sRef.x1 = x1 + t * dx;
            sRef.y1 = y1 + t * dy;
            sRef.x2 = NaN;
            sRef.y2 = NaN;
            return 1;
        }
        else {
            const t1 = ((-b + Math.sqrt(det)) / (2 * a));
            sRef.x1 = x1 + t1 * dx;
            sRef.y1 = y1 + t1 * dy;
            const t2 = ((-b - Math.sqrt(det)) / (2 * a));
            sRef.x2 = x1 + t2 * dx;
            sRef.y2 = y1 + t2 * dy;
            return 2;
        }
    }
    /**
     * Gets the degrees north that a point lies on a circle.
     * @param cx The x point of the center of the circle.
     * @param cy The y point of the center of the circle.
     * @param x The x point to get the bearing for.
     * @param y The y point to get the bearing for.
     * @returns The angle in degrees north that the point is relative to the center.
     */
    static northAngle(cx, cy, x, y) {
        return NavMath.polarToDegreesNorth(Math.atan2(y - cy, x - cx));
    }
    /**
     * Checks if a degrees north bearing is between two other degrees north bearings.
     * @param bearing The bearing in degrees north to check.
     * @param start The start bearing in degrees north.
     * @param end The end bearing, in degrees north.
     * @returns True if the bearing is between the two provided bearings, false otherwise.
     */
    static bearingIsBetween(bearing, start, end) {
        const range = this.normalizeHeading(end - start);
        const relativeBearing = this.normalizeHeading(bearing - start);
        return relativeBearing >= 0 && relativeBearing <= range;
    }
    /**
     * Converts a degrees north heading to a degrees north turn circle angle.
     * @param heading The heading to convert.
     * @param turnDirection The direction of the turn.
     * @returns A degrees north turn circle angle.
     */
    static headingToAngle(heading, turnDirection) {
        return NavMath.normalizeHeading(heading + (turnDirection === 'left' ? 90 : -90));
    }
    /**
     * Converts a degrees north turn circle angle to a degrees north heading.
     * @param angle The turn circle angle to convert.
     * @param turnDirection The direction of the turn.
     * @returns A degrees north heading.
     */
    static angleToHeading(angle, turnDirection) {
        return NavMath.normalizeHeading(angle + (turnDirection === 'left' ? -90 : 90));
    }
    /**
     * Calculates the wind correction angle.
     * @param course The current plane true course.
     * @param airspeedTrue The current plane true airspeed.
     * @param windDirection The direction of the wind, in degrees true.
     * @param windSpeed The current speed of the wind.
     * @returns The calculated wind correction angle.
     */
    static windCorrectionAngle(course, airspeedTrue, windDirection, windSpeed) {
        const currCrosswind = windSpeed * (Math.sin((course * Math.PI / 180) - (windDirection * Math.PI / 180)));
        const windCorrection = 180 * Math.asin(currCrosswind / airspeedTrue) / Math.PI;
        return windCorrection;
    }
    /**
     * Calculates the cross track deviation from the provided leg fixes.
     * @param start The location of the starting fix of the leg.
     * @param end The location of the ending fix of the leg.
     * @param pos The current plane location coordinates.
     * @returns The amount of cross track deviation, in nautical miles.
     */
    static crossTrack(start, end, pos) {
        const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
        if (isNaN(path.center[0])) {
            return NaN;
        }
        return UnitType.GA_RADIAN.convertTo(path.distance(pos), UnitType.NMILE);
    }
    /**
     * Calculates the along-track distance from a starting point to another point along a great-circle track running
     * through the starting point.
     * @param start The start of the great-circle track.
     * @param end The end of the great-circle track.
     * @param pos The point for which to calculate the along-track distance.
     * @returns The along-track distance, in nautical miles.
     */
    static alongTrack(start, end, pos) {
        const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
        if (isNaN(path.center[0])) {
            return NaN;
        }
        const distance = path.distanceAlong(start, path.closest(pos, NavMath.vec3Cache[0]));
        return UnitType.GA_RADIAN.convertTo((distance + Math.PI) % (2 * Math.PI) - Math.PI, UnitType.NMILE);
    }
    /**
     * Calculates the desired track from the provided leg fixes.
     * @param start The location of the starting fix of the leg.
     * @param end The location of the ending fix of the leg.
     * @param pos The current plane location coordinates.
     * @returns The desired track, in degrees true.
     */
    static desiredTrack(start, end, pos) {
        const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
        if (isNaN(path.center[0])) {
            return NaN;
        }
        return path.bearingAt(path.closest(pos, NavMath.vec3Cache[0]));
    }
    /**
     * Gets the desired track for a given arc.
     * @param center The center of the arc.
     * @param turnDirection The direction of the turn.
     * @param pos The current plane position.
     * @returns The desired track.
     */
    static desiredTrackArc(center, turnDirection, pos) {
        const northAngle = NavMath.geoPointCache[0].set(pos).bearingFrom(center);
        //TODO: Clamp the arc angle to the start and end angles
        return NavMath.angleToHeading(northAngle, turnDirection);
    }
    /**
     * Gets the percentage along the arc path that the plane currently is.
     * @param start The start of the arc, in degrees north.
     * @param end The end of the arc, in degrees north.
     * @param center The center location of the arc.
     * @param turnDirection The direction of the turn.
     * @param pos The current plane position.
     * @returns The percentage along the arc the plane is.
     */
    static percentAlongTrackArc(start, end, center, turnDirection, pos) {
        const bearingFromCenter = NavMath.geoPointCache[0].set(center).bearingTo(pos);
        const sign = turnDirection === 'right' ? 1 : -1;
        const alpha = ((end - start) * sign + 360) % 360;
        const mid = (start + alpha / 2 * sign + 360) % 360;
        const rotBearing = ((bearingFromCenter - mid) + 540) % 360 - 180;
        const frac = rotBearing * sign / alpha + 0.5;
        return frac;
    }
    /**
     * Gets a position given an arc and a distance from the arc start.
     * @param start The start bearing of the arc.
     * @param center The center of the arc.
     * @param radius The radius of the arc.
     * @param turnDirection The turn direction for the arc.
     * @param distance The distance along the arc to get the position for.
     * @param out The position to write to.
     * @returns The position along the arc that was written to.
     */
    static positionAlongArc(start, center, radius, turnDirection, distance, out) {
        const convertedRadius = UnitType.GA_RADIAN.convertTo(Math.sin(UnitType.METER.convertTo(radius, UnitType.GA_RADIAN)), UnitType.METER);
        const theta = UnitType.RADIAN.convertTo(distance / convertedRadius, UnitType.DEGREE);
        const bearing = turnDirection === 'right' ? start + theta : start - theta;
        center.offset(NavMath.normalizeHeading(bearing), UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), out);
        return out;
    }
    /**
     * Gets the cross track distance for a given arc.
     * @param center The center of the arc.
     * @param radius The radius of the arc, in meters.
     * @param pos The current plane position.
     * @returns The cross track distance, in NM.
     */
    static crossTrackArc(center, radius, pos) {
        return UnitType.METER.convertTo(radius, UnitType.NMILE) - UnitType.GA_RADIAN.convertTo(NavMath.geoPointCache[0].set(pos).distance(center), UnitType.NMILE);
    }
    /**
     * Gets the total difference in degrees between two angles.
     * @param a The first angle.
     * @param b The second angle.
     * @returns The difference between the two angles, in degrees.
     */
    static diffAngle(a, b) {
        let diff = b - a;
        while (diff > 180) {
            diff -= 360;
        }
        while (diff <= -180) {
            diff += 360;
        }
        return diff;
    }
    /**
     * Finds side a given sides b, c, and angles beta, gamma.
     * @param b The length of side b, as a trigonometric ratio.
     * @param c The length of side c, as a trigonometric ratio.
     * @param beta The angle, in radians, of the opposite of side b.
     * @param gamma The angle, in radians, of the opposite of side c
     * @returns The length of side a, as a trigonometric ratio.
     */
    static napierSide(b, c, beta, gamma) {
        return 2 * Math.atan(Math.tan(0.5 * (b - c))
            * (Math.sin(0.5 * (beta + gamma)) / Math.sin(0.5 * (beta - gamma))));
    }
    /**
     * Calculates a normal vector to a provided course in degrees north.
     * @param course The course in degrees north.
     * @param turnDirection The direction of the turn to orient the normal.
     * @param outVector The normal vector for the provided course.
     */
    static normal(course, turnDirection, outVector) {
        const normalCourse = NavMath.headingToAngle(course, turnDirection);
        const polarCourse = NavMath.degreesNorthToPolar(normalCourse);
        outVector[0] = Math.cos(polarCourse);
        outVector[1] = Math.sin(polarCourse);
    }
}
NavMath.DEG2RAD = Math.PI / 180;
NavMath.RAD2DEG = 180 / Math.PI;
NavMath.vec3Cache = [new Float64Array(3)];
NavMath.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
NavMath.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/// <reference types="msfstypes/Coherent/Facilities" />
/**
 * A utility class for working with magnetic variation (magnetic declination).
 */
class MagVar {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static get(arg1, arg2) {
        return MagVar.getMagVar(arg1, arg2);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static magneticToTrue(bearing, arg1, arg2) {
        return NavMath.normalizeHeading(bearing + MagVar.getMagVar(arg1, arg2));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static trueToMagnetic(bearing, arg1, arg2) {
        return NavMath.normalizeHeading(bearing - MagVar.getMagVar(arg1, arg2));
    }
    /**
     * Gets the magnetic variation (magnetic declination) at a specific point on Earth.
     * @param arg1 The query point, or the latitude of the query point.
     * @param arg2 The longitude of the query point.
     * @returns The magnetic variation (magnetic declination) at the point.
     */
    static getMagVar(arg1, arg2) {
        if (typeof Facilities === 'undefined') {
            // In case this code is executed before the Facilities class is created.
            return 0;
        }
        let lat, lon;
        if (typeof arg1 === 'number') {
            lat = arg1;
            lon = arg2;
        }
        else {
            lat = arg1.lat;
            lon = arg1.lon;
        }
        return Facilities.getMagVar(lat, lon);
    }
}

/**
 * A Subject which provides a GeoPointInterface value.
 */
class GeoPointSubject extends Subject {
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        const isArg1Number = typeof arg1 === 'number';
        const equals = isArg1Number ? this.value.equals(arg1, arg2) : this.value.equals(arg1);
        if (!equals) {
            isArg1Number ? this.value.set(arg1, arg2) : this.value.set(arg1);
            this.notify();
        }
    }
    /**
     * Creates a GeoPointSubject.
     * @param initialVal The initial value.
     * @returns a GeoPointSubject.
     */
    static createFromGeoPoint(initialVal) {
        return new GeoPointSubject(initialVal, Subject.DEFAULT_EQUALITY_FUNC);
    }
}

/**
 * A partial implementation of a MutableGeoProjection. Subclasses should use the projectRaw() and invertRaw() methods
 * to define the type of projection to be implemented.
 */
class AbstractGeoProjection {
    constructor() {
        this.center = new GeoPoint(0, 0);
        this.centerTranslation = new Float64Array(2);
        this.scaleFactor = UnitType.GA_RADIAN.convertTo(1, UnitType.NMILE); // 1 pixel = 1 nautical mile
        this.preRotation = new Float64Array(2);
        this.translation = new Float64Array(2);
        this.postRotation = 0;
        this.rotationSin = 0;
        this.rotationCos = 1;
        this.reflectY = 1;
    }
    /**
     * Gets the geographic center of this projection.
     * @returns the geographic center of this projection.
     */
    getCenter() {
        return this.center.readonly;
    }
    /**
     * Gets the nominal scale factor of this projection. At a scale factor of 1, a distance of one great-arc radian will
     * be projected to a distance of one pixel.
     * @returns the nominal scale factor of this projection.
     */
    getScaleFactor() {
        return this.scaleFactor;
    }
    /**
     * Gets the pre-projection rotation of this projection as a vector ([lambda, phi]). The rotation angles are
     * expressed in radians.
     * @returns the pre-projection rotation of this projection.
     */
    getPreRotation() {
        return this.preRotation;
    }
    /**
     * Gets the post-projection (planar) translation of this projection, in pixels.
     * @returns the post-projection translation of this projection.
     */
    getTranslation() {
        return this.translation;
    }
    /**
     * Gets the post-projection (planar) rotation angle of this projection in radians.
     * @returns the post-projection rotation angle of this projection.
     */
    getPostRotation() {
        return this.postRotation;
    }
    /**
     * Checks whether this projection reflects the projected coordinate system across the x-axis.
     * @returns whether this projection reflects the projected coordinate system across the x-axis.
     */
    getReflectY() {
        return this.reflectY === -1;
    }
    /**
     * Sets the geographic center of this projection. The center point of the projection is projected to the origin,
     * before any post-projection transformations are applied.
     * @param point - the new center point.
     * @returns this projection, after it has been changed.
     */
    setCenter(point) {
        this.center.set(point);
        this.updateCenterTranslation();
        return this;
    }
    /**
     * Sets the nominal scale factor of this projection. At a scale factor of 1, a distance of one great-arc radian will
     * be projected to a distance of one pixel.
     * @param factor - the new nominal scale factor.
     * @returns this projection, after it has been changed.
     */
    setScaleFactor(factor) {
        this.scaleFactor = factor;
        return this;
    }
    /**
     * Sets the pre-projection (spherical) rotation of this projection.
     * @param vec - the pre-projection rotation, as a vector ([lambda, phi]). The rotation angles should be expressed in
     * radians.
     * @returns this projection, after it has been changed.
     */
    setPreRotation(vec) {
        this.preRotation.set(vec);
        this.updateCenterTranslation();
        return this;
    }
    /**
     * Sets the post-projection (planar) translation of this projection.
     * @param vec - the new post-projection translation, in pixels.
     * @returns this projection, after it has been changed.
     */
    setTranslation(vec) {
        this.translation.set(vec);
        return this;
    }
    /**
     * Sets the post-projection (planar) rotation of this projection.
     * @param rotation - the new post-projection rotation angle, in radians.
     * @returns this projection, after it has been changed.
     */
    setPostRotation(rotation) {
        this.postRotation = rotation;
        this.rotationCos = Math.cos(rotation);
        this.rotationSin = Math.sin(rotation);
        return this;
    }
    /**
     * Sets whether this reflection should reflect the projected coordinate system across the x-axis. Setting this value
     * to true is useful in the situation where the projected coordinate system should use a positive-y-axis-down
     * convention.
     * @param val True if reflection is desired, false otherwise.
     * @returns this projection, after it has been changed.
     */
    setReflectY(val) {
        this.reflectY = val ? -1 : 1;
        return this;
    }
    /**
     * Copies all projection parameters from another projection. The parameters copied are: center, pre-projection
     * rotation angles, scale factor, post-projection translation, and post-projection rotation angle.
     * @param other the projection from which to copy parameters.
     * @returns this projection, after it has been changed.
     */
    copyParametersFrom(other) {
        return this.setCenter(other.getCenter())
            .setPreRotation(other.getPreRotation())
            .setScaleFactor(other.getScaleFactor())
            .setTranslation(other.getTranslation())
            .setPostRotation(other.getPostRotation())
            .setReflectY(other.getReflectY());
    }
    /**
     * Updates the translation vector to move the center of this projection to the origin.
     */
    updateCenterTranslation() {
        const centerArray = AbstractGeoProjection.tempVec2;
        centerArray[0] = this.center.lon;
        centerArray[1] = this.center.lat;
        this.preRotateForward(centerArray, centerArray);
        this.projectRaw(centerArray, this.centerTranslation);
    }
    /**
     * Applies a forward rotation to a set of lat/lon coordinates using this projection's pre-projection rotation angles.
     * @param vec - the lat/lon coordinates to rotate, as a vector ([long, lat]).
     * @param out - the vector to which to write the result.
     * @returns the rotated lat/lon coordinates.
     */
    preRotateForward(vec, out) {
        const phi = this.preRotation[1];
        const lambda = this.preRotation[0];
        if (phi === 0 && lambda === 0) {
            out.set(vec);
            return out;
        }
        const lat = vec[1];
        const lon = vec[0];
        const rotatedLon = ((lon + lambda * Avionics.Utils.RAD2DEG) % 360 + 540) % 360 - 180; // enforce [-180, 180)
        if (phi === 0) {
            return Vec2Math.set(rotatedLon, lat, out);
        }
        const latRad = lat * Avionics.Utils.DEG2RAD;
        const rotatedLonRad = rotatedLon * Avionics.Utils.DEG2RAD;
        const cosPhi = Math.cos(phi);
        const sinPhi = Math.sin(phi);
        const cosLat = Math.cos(latRad);
        const x = Math.cos(rotatedLonRad) * cosLat;
        const y = Math.sin(rotatedLonRad) * cosLat;
        const z = Math.sin(latRad);
        return Vec2Math.set(Math.atan2(y, x * cosPhi - z * sinPhi) * Avionics.Utils.RAD2DEG, Math.asin(z * cosPhi + x * sinPhi) * Avionics.Utils.RAD2DEG, out);
    }
    /**
     * Applies a reverse rotation to a set of lat/lon coordinates using this projection's pre-projection rotation angles.
     * @param vec - the lat/lon coordinates to rotate, as a vector ([long, lat]).
     * @param out - the vector to which to write the result.
     * @returns the rotated lat/lon coordinates.
     */
    preRotateReverse(vec, out) {
        const phi = this.preRotation[1];
        const lambda = this.preRotation[0];
        if (phi === 0 && lambda === 0) {
            out.set(vec);
            return out;
        }
        const lat = vec[1];
        const lon = vec[0];
        let rotatedLat = lat;
        let rotatedLon = lon;
        if (phi !== 0) {
            const latRad = lat * Avionics.Utils.DEG2RAD;
            const lonRad = lon * Avionics.Utils.DEG2RAD;
            const cosPhi = Math.cos(phi);
            const sinPhi = Math.sin(phi);
            const cosLat = Math.cos(latRad);
            const x = Math.cos(lonRad) * cosLat;
            const y = Math.sin(lonRad) * cosLat;
            const z = Math.sin(latRad);
            rotatedLat = Math.asin(z * cosPhi - x * sinPhi) * Avionics.Utils.RAD2DEG;
            rotatedLon = Math.atan2(y, x * cosPhi + z * sinPhi) * Avionics.Utils.RAD2DEG;
        }
        rotatedLon = ((rotatedLon - lambda * Avionics.Utils.RAD2DEG) % 360 + 540) % 360 - 180; // enforce [-180, 180)
        return Vec2Math.set(rotatedLon, rotatedLat, out);
    }
    /**
     * Projects a set of lat/lon coordinates.
     * @param point - the point to project.
     * @param out - the vector to which to write the result.
     * @returns the projected point, as a vector.
     */
    project(point, out) {
        if (point instanceof Float64Array) {
            out.set(point);
        }
        else {
            out[0] = point.lon;
            out[1] = point.lat;
        }
        this.preRotateForward(out, out);
        this.projectRaw(out, out);
        // translate projected center point to origin
        out[0] -= this.centerTranslation[0];
        out[1] -= this.centerTranslation[1];
        // apply y-reflection
        out[1] *= this.reflectY;
        // apply scale factor
        out[0] *= this.scaleFactor;
        out[1] *= this.scaleFactor;
        // apply post-projection rotation
        const x = out[0];
        const y = out[1];
        out[0] = x * this.rotationCos - y * this.rotationSin;
        out[1] = x * this.rotationSin + y * this.rotationCos;
        // apply post-projection translation
        out[0] += this.translation[0];
        out[1] += this.translation[1];
        return out;
    }
    /**
     * Inverts a set of projected coordinates. This method will determine the geographic point whose projected location
     * is the equal to that described by a 2D position vector.
     * @param vec - the 2D position vector describing the location of the projected coordinates.
     * @param out - the point to which to write the result.
     * @returns the inverted point.
     */
    invert(vec, out) {
        const projected = AbstractGeoProjection.tempVec2;
        projected.set(vec);
        // invert post-projection translation
        projected[0] -= this.translation[0];
        projected[1] -= this.translation[1];
        // invert post-projection rotation
        const x = projected[0];
        const y = projected[1];
        projected[0] = x * this.rotationCos + y * this.rotationSin;
        projected[1] = -x * this.rotationSin + y * this.rotationCos;
        // invert scale factor
        projected[0] /= this.scaleFactor;
        projected[1] /= this.scaleFactor;
        // invert y-reflection
        projected[1] *= this.reflectY;
        // translate projected center point to default projected position
        projected[0] += this.centerTranslation[0];
        projected[1] += this.centerTranslation[1];
        const inverted = this.invertRaw(projected, projected);
        this.preRotateReverse(inverted, inverted);
        if (out instanceof Float64Array) {
            out.set(inverted);
            return out;
        }
        else {
            return out.set(inverted[1], inverted[0]);
        }
    }
}
AbstractGeoProjection.tempVec2 = new Float64Array(2);
/**
 * A Mercator projection.
 */
class MercatorProjection extends AbstractGeoProjection {
    /**
     * Applies a raw projection.
     * @param vec - a [lon, lat] vector describing the geographic point to project.
     * @param out - a 2D vector to which to write the result.
     * @returns the projected point.
     */
    projectRaw(vec, out) {
        out[0] = vec[0] * Avionics.Utils.DEG2RAD;
        out[1] = Math.log(Math.tan((90 + vec[1]) * Avionics.Utils.DEG2RAD / 2));
        return out;
    }
    /**
     * Inverts a raw projection.
     * @param vec - a 2D vector describing the projected point to invert.
     * @param out - a 2D vector to which to write the result.
     * @returns the inverted point.
     */
    invertRaw(vec, out) {
        out[0] = vec[0] * Avionics.Utils.RAD2DEG;
        out[1] = 2 * Math.atan(Math.exp(vec[1])) * Avionics.Utils.RAD2DEG - 90;
        return out;
    }
}

/**
 * Resamples projected geodesic (great-circle) paths between defined endpoints into series of straight line segments.
 */
class GeodesicResampler {
    /**
     * Constructor.
     * @param minDistance The minimum geodesic distance this resampler enforces between two adjacent resampled points, in
     * great-arc radians.
     * @param dpTolerance The Douglas-Peucker tolerance this resampler uses when deciding whether to discard a resampled
     * point during the line simplification process.
     * @param maxDepth The maximum depth of the resampling algorithm used by this resampler. The number of resampled
     * points is bounded from above by 2^[maxDepth] - 1.
     */
    constructor(minDistance, dpTolerance, maxDepth) {
        this.minDistance = minDistance;
        this.dpTolerance = dpTolerance;
        this.maxDepth = maxDepth;
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2)];
        this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3)];
        this.cosMinDistance = Math.cos(minDistance);
        this.dpTolSq = dpTolerance * dpTolerance;
    }
    /**
     * Resamples a projected geodesic (great-circle) path.
     * @param projection The projection to use.
     * @param start The start of the path.
     * @param end The end of the path.
     * @param handler A function to handle the resampled points. The function is called once for each resampled point,
     * in order.
     * @throws Error when the start and end of the path are antipodal.
     */
    resample(projection, start, end, handler) {
        const startVec = GeoPoint.sphericalToCartesian(start, this.vec3Cache[0]);
        const endVec = GeoPoint.sphericalToCartesian(end, this.vec3Cache[1]);
        const startProjected = projection.project(start, this.vec2Cache[0]);
        const endProjected = projection.project(end, this.vec2Cache[1]);
        handler(this.geoPointCache[0].set(start), startProjected, 0);
        const index = this.resampleHelper(projection, start.lat, start.lon, startVec[0], startVec[1], startVec[2], startProjected[0], startProjected[1], end.lat, end.lon, endVec[0], endVec[1], endVec[2], endProjected[0], endProjected[1], handler, 0, 1);
        handler(this.geoPointCache[0].set(end), endProjected, index);
    }
    /**
     * Resamples a projected geodesic (great-circle) path. This method will recursively split the path into two halves
     * and resample the midpoint. Recursion continues as long as the maximum depth has not been reached and at least one
     * of the following conditions is met:
     * * The distance from the midpoint to the endpoints is greater than or equal to the minimum resampling distance.
     * * The Douglas-Peucker metric of the projected midpoint is greater than or equal to the set tolerance.
     * @param projection The projection to use.
     * @param lat1 The latitude of the start of the path.
     * @param lon1 The longitude of the start of the path.
     * @param x1 The x-component of the Cartesian position vector of the start of the path.
     * @param y1 The y-component of the Cartesian position vector of the start of the path.
     * @param z1 The z-component of the Cartesian position vector of the start of the path.
     * @param projX1 The x-component of the projected location of the start of the path.
     * @param projY1 The y-component of the projected location of the start of the path.
     * @param lat2 The latitude of the end of the path.
     * @param lon2 The longitude of the end of the path.
     * @param x2 The x-component of the Cartesian position vector of the end of the path.
     * @param y2 The y-component of the Cartesian position vector of the end of the path.
     * @param z2 The z-component of the Cartesian position vector of the end of the path.
     * @param projX2 The x-component of the projected location of the end of the path.
     * @param projY2 The y-component of the projected location of the end of the path.
     * @param handler A function to handle the resampled points.
     * @param depth The current depth of the resampling algorithm.
     * @param index The index of the next resampled point.
     * @returns The index of the next resampled point.
     * @throws Error when the start and end of the path are antipodal.
     */
    resampleHelper(projection, lat1, lon1, x1, y1, z1, projX1, projY1, lat2, lon2, x2, y2, z2, projX2, projY2, handler, depth, index) {
        if (depth >= this.maxDepth) {
            return index;
        }
        const startVec = Vec3Math.set(x1, y1, z1, this.vec3Cache[0]);
        const endVec = Vec3Math.set(x2, y2, z2, this.vec3Cache[1]);
        const sumVec = Vec3Math.add(startVec, endVec, this.vec3Cache[2]);
        if (Vec3Math.dot(sumVec, sumVec) === 0) {
            throw new Error('Cannot resample from antipodal endpoints.');
        }
        const midVec = Vec3Math.normalize(sumVec, sumVec);
        const startProjected = Vec2Math.set(projX1, projY1, this.vec2Cache[0]);
        const endProjected = Vec2Math.set(projX2, projY2, this.vec2Cache[1]);
        const deltaProjected = Vec2Math.sub(endProjected, startProjected, this.vec2Cache[2]);
        const deltaProjectedDot = Vec2Math.dot(deltaProjected, deltaProjected);
        const midPoint = this.geoPointCache[0].setFromCartesian(midVec);
        const midProjected = projection.project(midPoint, this.vec2Cache[2]);
        const lat0 = midPoint.lat;
        const lon0 = midPoint.lon;
        const x0 = midVec[0];
        const y0 = midVec[1];
        const z0 = midVec[2];
        const projX0 = midProjected[0];
        const projY0 = midProjected[1];
        const cosDistance = Vec3Math.dot(startVec, midVec);
        // cosine of distance increases with decreasing distance, so the check needs to be greater than.
        if (cosDistance > this.cosMinDistance) {
            // calculate Douglas-Peucker metric.
            const area = (projX2 - projX1) * (projY1 - projY0) - (projX1 - projX0) * (projY2 - projY1);
            const dpDisSq = area * area / deltaProjectedDot;
            if (dpDisSq < this.dpTolSq) {
                return index;
            }
        }
        index = this.resampleHelper(projection, lat1, lon1, x1, y1, z1, projX1, projY1, lat0, lon0, x0, y0, z0, projX0, projY0, handler, depth + 1, index);
        handler(this.geoPointCache[0].set(lat0, lon0), Vec2Math.set(projX0, projY0, this.vec2Cache[0]), index);
        return this.resampleHelper(projection, lat0, lon0, x0, y0, z0, projX0, projY0, lat2, lon2, x2, y2, z2, projX2, projY2, handler, depth + 1, index + 1);
    }
}

var DmsDirection;
(function (DmsDirection) {
    DmsDirection["NORTH"] = "N";
    DmsDirection["SOUTH"] = "S";
    DmsDirection["WEST"] = "W";
    DmsDirection["EAST"] = "E";
})(DmsDirection || (DmsDirection = {}));
/**
 * A class to format latitude/longitude to DMS.
 * @class DmsFormatter
 */
class DmsFormatter {
    constructor() {
        this.coordsParts = {
            direction: DmsDirection.NORTH,
            degrees: 0,
            minutes: 0,
            seconds: 0
        };
    }
    /**
     * Builds a DMS string out of the given latitude.
     * @param value The latitude.
     * @returns The DMS string.
     */
    getLatDmsStr(value) {
        const parts = this.parseLat(value);
        if (parts.minutes >= 59.5) {
            parts.minutes = 0;
            parts.degrees++;
        }
        return `${parts.direction} ${parts.degrees.toString().padStart(2, '0')}°${parts.minutes.toFixed(2).padStart(5, '0')}'`;
    }
    /**
     * Builds a DMS string out of the given longitude.
     * @param value The longitude.
     * @returns The DMS string.
     */
    getLonDmsStr(value) {
        const parts = this.parseLon(value);
        if (parts.minutes >= 59.5) {
            parts.minutes = 0;
            parts.degrees++;
        }
        return `${parts.direction}${parts.degrees.toString().padStart(3, '0')}°${parts.minutes.toFixed(2).padStart(5, '0')}'`;
    }
    /**
     * Parses a latitude in to the dms parts.
     * @param value The latitude in degrees.
     * @returns The DMS parts.
     */
    parseLat(value) {
        this.coordsParts.direction = value < 0 ? DmsDirection.SOUTH : DmsDirection.NORTH;
        return this.parse(value);
    }
    /**
     * Parses a longitude in to the dms parts.
     * @param value The longitude in degrees.
     * @returns The DMS parts.
     */
    parseLon(value) {
        this.coordsParts.direction = value < 0 ? DmsDirection.WEST : DmsDirection.EAST;
        return this.parse(value);
    }
    /**
     * Parses the latitude/longitude.
     * @private
     * @param value The value to parse.
     * @returns The DMS parts.
     */
    parse(value) {
        value = Math.abs(value);
        this.coordsParts.degrees = Math.trunc(value);
        value = (value - this.coordsParts.degrees) * 60;
        this.coordsParts.minutes = value;
        this.coordsParts.seconds = (value - this.coordsParts.minutes) * 60;
        return this.coordsParts;
    }
}

/**
 * A Subject which provides a NumberUnitInterface value.
 */
class NumberUnitSubject extends Subject {
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        const isArg1Number = typeof arg1 === 'number';
        const equals = isArg1Number ? this.value.equals(arg1, arg2) : this.value.equals(arg1);
        if (!equals) {
            isArg1Number ? this.value.set(arg1, arg2) : this.value.set(arg1);
            this.notify();
        }
    }
    /**
     * Creates a NumberUnitSubject.
     * @param initialVal The initial value.
     * @returns a NumberUnitSubject.
     */
    static createFromNumberUnit(initialVal) {
        return new NumberUnitSubject(initialVal, Subject.DEFAULT_EQUALITY_FUNC);
    }
}

/**
 * A Subject which allows a 2D vector to be observed.
 */
class Vec2Subject extends Subject {
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        let x, y;
        if (typeof arg1 === 'number') {
            x = arg1;
            y = arg2;
        }
        else {
            x = arg1[0];
            y = arg1[1];
        }
        const equals = x === this.value[0] && y === this.value[1];
        if (!equals) {
            Vec2Math.set(x, y, this.value);
            this.notify();
        }
    }
    /**
     * Creates a Vec2Subject.
     * @param initialVal The initial value.
     * @returns A Vec2Subject.
     */
    static createFromVector(initialVal) {
        return new Vec2Subject(initialVal, Subject.DEFAULT_EQUALITY_FUNC);
    }
}
/**
 * A Subject which allows a N-D vector to be observed.
 */
class VecNSubject extends Subject {
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, ...args) {
        let array;
        if (typeof arg1 === 'number') {
            array = args;
            args.unshift(arg1);
        }
        else {
            array = arg1;
        }
        if (array.length > this.value.length) {
            throw new RangeError(`VecNSubject: Cannot set ${array.length} components on a vector of length ${this.value.length}`);
        }
        let equals = true;
        const len = array.length;
        for (let i = 0; i < len; i++) {
            if (array[i] !== this.value[i]) {
                equals = false;
                break;
            }
        }
        if (!equals) {
            this.value.set(array);
            this.notify();
        }
    }
    /**
     * Creates a VecNSubject.
     * @param initialVal The initial value.
     * @returns A VecNSubject.
     */
    static createFromVector(initialVal) {
        return new VecNSubject(initialVal, Subject.DEFAULT_EQUALITY_FUNC);
    }
}

/**
 * A utitlity class for calculating a numerical average of a selected number of samples.
 */
class SimpleMovingAverage {
    /**
     * Class to return a numerical average from a specified number of inputs.
     * @param samples is the number of samples.
     */
    constructor(samples) {
        this.samples = samples;
        this._values = [];
    }
    /**
     * Returns a numerical average of the inputs.
     * @param input is the input number.
     * @returns The numerical average.
     */
    getAverage(input) {
        let samples = this.samples;
        if (this._values.length === samples) {
            this._values.splice(0, 1);
        }
        else {
            samples = this._values.length;
        }
        this._values.push(input);
        let sum = 0;
        this._values.forEach((v) => {
            sum += v;
        });
        return sum / samples;
    }
    /**
     * Resets the average.
     */
    reset() {
        this._values = [];
    }
}

/**
 * A utitlity class for basic math.
 */
class MathUtils {
    /**
     * Clamps a numerical value to the min/max range.
     * @param value The value to be clamped.
     * @param min The minimum.
     * @param max The maximum.
     *
     * @returns The clamped numerical value..
     */
    static clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }
}

/**
 * Applies time-weighted exponential smoothing (i.e. an exponential moving average) to a sequence of raw values. When
 * a new raw value is added to the sequence, it and the last smoothed value are weighted according to the time elapsed
 * since the last smoothed value was calculated (i.e. since the last raw value was added) and averaged. The calculation
 * of the weighting is such that the weight of each raw value in the sequence decays exponentially with the "age"
 * (i.e. time elapsed between when that value was added to the sequence and when the latest value was added to the
 * sequence) of the value.
 */
class ExpSmoother {
    /**
     * Constructor.
     * @param tau This smoother's time constant. The larger the constant, the greater the smoothing effect.
     * @param initial The initial smoothed value of this smoother. Defaults to null.
     * @param dtThreshold The elapsed time threshold, in seconds, above which this smoother will not smooth a new raw
     * value. Defaults to infinity.
     */
    constructor(tau, initial = null, dtThreshold = Infinity) {
        this.tau = tau;
        this.dtThreshold = dtThreshold;
        this.lastValue = initial;
    }
    /**
     * Gets the last smoothed value.
     * @returns the last smoothed value, or null if none exists.
     */
    last() {
        return this.lastValue;
    }
    /**
     * Adds a new raw value and gets the next smoothed value. If the new raw value is the first to be added since this
     * smoother was created or reset with no initial smoothed value, the returned smoothed value will be equal to the
     * raw value.
     * @param raw The new raw value.
     * @param dt The elapsed time, in seconds, since the last raw value was added.
     * @returns The next smoothed value.
     */
    next(raw, dt) {
        let next;
        if (this.lastValue !== null) {
            const factor = this.calculateFactor(dt);
            next = ExpSmoother.smooth(raw, this.lastValue, factor);
        }
        else {
            next = raw;
        }
        this.lastValue = next;
        return next;
    }
    /**
     * Calculates the smoothing factor for a given time interval.
     * @param dt A time interval, in seconds.
     * @returns the smoothing factor for the given time interval.
     */
    calculateFactor(dt) {
        if (dt > this.dtThreshold) {
            return 0;
        }
        else {
            return Math.exp(-dt / this.tau);
        }
    }
    /**
     * Resets the "history" of this smoother and optionally sets the initial smoothed value.
     * @param value The new initial smoothed value. Defaults to null.
     * @returns The reset smoothed value.
     */
    reset(value) {
        return this.lastValue = (value !== null && value !== void 0 ? value : null);
    }
    /**
     * Applies exponential smoothing.
     * @param value The value to smooth.
     * @param last The last smoothed value.
     * @param factor The smoothing factor.
     * @returns A smoothed value.
     */
    static smooth(value, last, factor) {
        return value * (1 - factor) + last * factor;
    }
}

// eslint-disable-next-line @typescript-eslint/no-namespace
var Wait;
(function (Wait) {
    /**
     * Waits for a set amount of time.
     * @param delay The amount of time to wait in milliseconds.
     * @returns a Promise which is fulfilled after the delay.
     */
    // eslint-disable-next-line no-inner-declarations
    function awaitDelay(delay) {
        return new Promise(resolve => setTimeout(() => resolve(), delay));
    }
    Wait.awaitDelay = awaitDelay;
    /**
     * Waits for a condition to be satisfied.
     * @param predicate A function which evaluates whether the condition is satisfied.
     * @param interval The interval, in milliseconds, at which to evaluate the condition. A zero or negative value
     * causes the condition to be evaluated every frame. Defaults to 0.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected and the condition to be
     * continually evaluated until it is satisfied. Defaults to 0.
     * @returns a Promise which is fulfilled when the condition is satisfied.
     */
    // eslint-disable-next-line no-inner-declarations
    function awaitCondition(predicate, interval = 0, timeout = 0) {
        const t0 = Date.now();
        if (interval <= 0) {
            const loopFunc = (resolve, reject) => {
                if (timeout > 0 && Date.now() - t0 >= timeout) {
                    reject('Await condition timed out.');
                }
                else {
                    predicate() ? resolve() : requestAnimationFrame(loopFunc.bind(undefined, resolve, reject));
                }
            };
            return new Promise((resolve, reject) => { loopFunc(resolve, reject); });
        }
        else {
            return new Promise((resolve, reject) => {
                const timer = setInterval(() => {
                    if (timeout > 0 && Date.now() - t0 > timeout) {
                        clearInterval(timer);
                        reject('Await condition timed out.');
                    }
                    else if (predicate()) {
                        clearInterval(timer);
                        resolve();
                    }
                }, interval);
            });
        }
    }
    Wait.awaitCondition = awaitCondition;
})(Wait || (Wait = {}));

/**
 * Types of subscribable array change event.
 */
var SubscribableArrayEventType;
(function (SubscribableArrayEventType) {
    /** An element was added. */
    SubscribableArrayEventType["Added"] = "Added";
    /** An element was removed. */
    SubscribableArrayEventType["Removed"] = "Removed";
    /** The array was cleared. */
    SubscribableArrayEventType["Cleared"] = "Cleared";
})(SubscribableArrayEventType || (SubscribableArrayEventType = {}));

/**
 * An array-like class to observe changes in a list of objects.
 * @class ArraySubject
 * @template T
 */
class ArraySubject {
    /**
     * Constructs an observable array.
     * @param arr The initial array elements.
     */
    constructor(arr) {
        this._subs = [];
        this.notifyPaused = false;
        this._array = arr;
    }
    /**
     * Gets the length of the array.
     * @readonly
     * @type {number}
     */
    get length() {
        return this._array.length;
    }
    /**
     * Creates and returns a new observable array.
     * @static
     * @template AT The type of the array items.
     * @param arr The initial array elements.
     * @returns A new instance of SubjectArray.
     */
    static create(arr = []) {
        return new ArraySubject(arr);
    }
    /**
     * Inserts a new item at the end or the specified index.
     * @param item The item to insert.
     * @param index The optional index to insert the item to. Will add the item at then end if index not given.
     */
    insert(item, index = -1) {
        if (index === -1 || index > this._array.length - 1) {
            this._array.push(item);
        }
        else {
            this._array.splice(index, 0, item);
        }
        this.notifySubs(index, SubscribableArrayEventType.Added, item);
    }
    /**
     * Inserts items of an array beginning at the specified index.
     * @param [index] The index to begin inserting the array items.
     * @param arr The array to insert.
     */
    insertRange(index = 0, arr) {
        this._array.splice(index, 0, ...arr);
        this.notifySubs(index, SubscribableArrayEventType.Added, arr);
    }
    /**
     * Removes the item at the specified index.
     * @param index The index of the item to remove.
     */
    removeAt(index) {
        const removedItem = this._array.splice(index, 1);
        this.notifySubs(index, SubscribableArrayEventType.Removed, removedItem[0]);
    }
    /**
     * Removes the given item from the array.
     * @param item The item to remove.
     * @returns Returns a boolean indicating if the item was found and removed.
     */
    removeItem(item) {
        const index = this._array.indexOf(item);
        if (index > -1) {
            this.removeAt(index);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Replaces all items in the array with the new array.
     * @param arr The array.
     */
    set(arr) {
        this.clear();
        this.insertRange(0, arr);
    }
    /**
     * Clears all data in the array.
     */
    clear() {
        this._array.length = 0;
        this.notifySubs(0, SubscribableArrayEventType.Cleared);
    }
    /**
     * Subscribes to the subject with a callback function. The function will be called whenever this Subject's array
     * changes.
     * @param fn A callback function.
     * @param initialNotify Whether to immediately notify the callback function after it is subscribed. False by default.
     */
    sub(fn, initialNotify) {
        this._subs.push(fn);
        if (initialNotify) {
            fn(0, SubscribableArrayEventType.Added, this._array, this._array);
        }
    }
    /**
     * Unsubscribes a callback function from this Subject.
     * @param fn The callback function to unsubscribe.
     */
    unsub(fn) {
        const index = this._subs.indexOf(fn);
        if (index >= 0) {
            this._subs.splice(index, 1);
        }
    }
    /**
     * Gets the array.
     * @returns The array.
     */
    getArray() {
        return this._array;
    }
    /**
     * Gets an item from the array.
     * @param index Thex index of the item to get.
     * @returns An item.
     * @throws
     */
    get(index) {
        if (index > this._array.length - 1) {
            throw new Error('Index out of range');
        }
        return this._array[index];
    }
    /**
     * Tries to get the value from the array.
     * @param index The index of the item to get.
     * @returns The value or undefined if not found.
     */
    tryGet(index) {
        return this._array[index];
    }
    /**
     * Notifies the subscribers of a change in the array.
     * @param index The index that was changed.
     * @param type The type of subject event.
     * @param modifiedItem The item modified by the operation.
     * @private
     */
    notifySubs(index, type, modifiedItem) {
        if (!this.notifyPaused) {
            const subLen = this._subs.length;
            for (let i = 0; i < subLen; i++) {
                try {
                    this._subs[i](index, type, modifiedItem, this._array);
                }
                catch (error) {
                    console.error(`Error in ArraySubject handler: ${error}`);
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
        }
    }
}

/**
 * A sorted array.
 */
class SortedArray {
    /**
     * Constructor.
     * @param comparatorFunc A function which defines the relative sorting priority of two elements. The function should
     * return 0 if its arguments are to be sorted identically, a negative number if the first argument is to be sorted
     * before the second argument, and a positive number if the first argument is to be sorted after the second argument.
     * @param equalityFunc A function which checks if two elements are equal. Defaults to the strict equality comparison
     * (`===`) if not defined.
     */
    constructor(comparatorFunc, equalityFunc = SortedArray.DEFAULT_EQUALITY_FUNC) {
        this.comparatorFunc = comparatorFunc;
        this.equalityFunc = equalityFunc;
        this._array = [];
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** A read-only version of the array object backing this sorted array. */
    get array() {
        return this._array;
    }
    /**
     * The number of elements in this array.
     */
    get length() {
        return this._array.length;
    }
    /**
     * Finds the index of the first or last element in this array whose sorting priority is equal to a query element. If
     * no such element in this array exists, `-(index + 1)` is returned, where `index` is the index at which the query
     * element would be found if it were contained in the array.
     * @param element The query element.
     * @param first Whether to find the first index.
     * @returns The index of the first or last element in this array with the same sorting priority as the query, or
     * `-(index + 1)` if no such element exists, where `index` is the index at which the query element would be found if
     * it were contained in the array.
     */
    findIndex(element, first = true) {
        let min = 0;
        let max = this._array.length;
        let index = Math.floor((min + max) / 2);
        while (min < max) {
            const compare = this.comparatorFunc(element, this._array[index]);
            if (compare < 0) {
                max = index;
            }
            else if (compare > 0) {
                min = index + 1;
            }
            else {
                const delta = first ? -1 : 1;
                while (index + delta >= 0 && index + delta < this._array.length && this.comparatorFunc(element, this._array[index + delta]) === 0) {
                    index += delta;
                }
                return index;
            }
            index = Math.floor((min + max) / 2);
        }
        return -(index + 1);
    }
    /**
     * Finds the index of the first element in this array which equals a query element, starting at a specified index.
     * The search proceeds toward the end of the array, ending at the first index containing an element whose sorting
     * priority does not equal the query, or the end of the array, whichever comes first. If no such element in this
     * array exists, -1 is returned instead.
     * @param element The query element.
     * @param startIndex The index at which to start the search.
     * @returns The index of the first element in this array which equals the query element, or -1 if no such element
     * exists.
     */
    searchEquals(element, startIndex) {
        let index = startIndex;
        while (index >= 0 && index < this._array.length && this.comparatorFunc(element, this._array[index]) === 0) {
            if (this.equalityFunc(element, this._array[index])) {
                return index;
            }
            index++;
        }
        return -1;
    }
    /**
     * Gets the element at a specified index, if it exists.
     * @param index An index.
     * @returns The element at the specified index, or undefined if the index is out of bounds.
     */
    get(index) {
        return this._array[index];
    }
    /**
     * Gets the first element in this array, if it exists.
     * @returns The first element in this array, or undefined if this array is empty.
     */
    first() {
        return this._array[0];
    }
    /**
     * Gets the last element in this array, if it exists.
     * @returns The last element in this array, or undefined if this array is empty.
     */
    last() {
        return this._array[this._array.length - 1];
    }
    /**
     * Checks whether this array contains an element. Returns true if and only if there is at least one element in this
     * array which is equal to the specified element according to this array's equality function.
     * @param element The element to check.
     * @returns Whether this array contains the element.
     */
    has(element) {
        return this.searchEquals(element, this.findIndex(element)) >= 0;
    }
    /**
     * Inserts an element into this array. The element will be inserted at the greatest index such that it is located
     * before all the existing elements in the array sorted after it according to this array's sorting function. All
     * existing elements located at indexes greater than or equal to the index at which the element was inserted are
     * shifted to the right.
     * @param element The element to insert.
     * @returns The index at which the element was placed.
     */
    insert(element) {
        let index = this.findIndex(element, false);
        if (index < 0) {
            index = -index - 1;
        }
        this._array.splice(index, 0, element);
        return index;
    }
    /**
     * Inserts all elements in an Iterable into this array. Each element is inserted according to the same behavior used
     * by the `insert()` method. If an element appears more than once in the iterable, one instance of that element will
     * be inserted into this array for each time the element appears in the iterable.
     * @param elements An iterable of elements to insert.
     * @returns The number of elements inserted.
     */
    insertAll(elements) {
        const sorted = Array.from(elements).sort(this.comparatorFunc);
        let toInsertIndex = 0;
        let toInsert = sorted[toInsertIndex];
        const len = this._array.length;
        const insertLen = sorted.length;
        for (let i = 0; i < len && toInsertIndex < insertLen; i++) {
            if (this.comparatorFunc(toInsert, this._array[i]) > 0) {
                this._array.splice(i, 0, toInsert);
                toInsert = sorted[++toInsertIndex];
            }
        }
        for (; toInsertIndex < insertLen; toInsertIndex++) {
            this._array.push(sorted[toInsertIndex]);
        }
        return sorted.length;
    }
    /**
     * Removes the first occurrence of an element from this array. This array is searched for the first element which
     * is equal to the specified element according to this array's equality function, the matching element is removed,
     * and all elements after it are shifted to the left.
     * @param element The element to remove.
     * @returns The (former) index of the removed element, or -1 if no element was removed.
     */
    remove(element) {
        const index = this.searchEquals(element, this.findIndex(element));
        if (index >= 0) {
            this._array.splice(index, 1);
        }
        return index;
    }
    /**
     * Removes all elements in an Iterable from this array. Each element is removed according to the behavior used by the
     * `remove()` method. If an element appears more than once in the iterable, one instance of that element will be
     * removed from this array for each time the element appears in the iterable.
     * @param elements An iterable of elements to remove.
     * @returns The number of elements removed.
     */
    removeAll(elements) {
        const sorted = Array.from(elements).sort(this.comparatorFunc);
        let numRemoved = 0;
        let toRemoveIndex = 0;
        let toRemove = sorted[toRemoveIndex];
        const len = this._array.length;
        const removeLen = sorted.length;
        for (let i = 0; i < len && toRemoveIndex < removeLen; i++) {
            if (this.equalityFunc(toRemove, this._array[i])) {
                this._array.splice(i--, 1);
                toRemove = sorted[++toRemoveIndex];
                numRemoved++;
            }
        }
        return numRemoved;
    }
    /**
     * Finds the index of the first occurrence of an element in this array. This array is searched for the first element
     * which is equal to the specified element according to this array's equality function, and its index is returned.
     * @param element The element for which to search.
     * @returns The index of the first occurrence of the specified element, or -1 if no such element was found.
     */
    indexOf(element) {
        return this.searchEquals(element, this.findIndex(element));
    }
    /**
     * Searches this array for the first element whose sorting priority is equal to a query element. If no such element
     * is found, then undefined is returned instead.
     * @param query The query element.
     * @returns The first element in the array with the same sorting priority as the query, or undefined if no such
     * element exists.
     */
    match(query) {
        const index = this.matchIndex(query);
        return this._array[index];
    }
    /**
     * Searches this array for the index of the first element whose sorting priority is equal to a query element. If no
     * such element is found, then `-(index + 1)` is returned instead, where `index` is the index at which the query
     * element would be found if it were contained in the array.
     * @param query The query element.
     * @returns The index of the first element in this array with the same sorting priority as the query, or
     * `-(index + 1)` if no such element exists, where `index` is the index at which the query element would be found if
     * it were contained in the array.
     */
    matchIndex(query) {
        return this.findIndex(query);
    }
    /**
     * Removes all elements from this array.
     */
    clear() {
        this._array.length = 0;
    }
    /**
     * Gets an IterableIterator over all elements in this array.
     * @returns An IterableIterator over all elements in this array.
     */
    values() {
        return this._array.values();
    }
    /** @inheritdoc */
    [Symbol.iterator]() {
        return this._array.values();
    }
}
SortedArray.DEFAULT_EQUALITY_FUNC = (a, b) => a === b;

/**
 * A subscribable which provides a sorted version of a source SubscribableArray.
 */
class SortedMappedSubscribableArray {
    /**
     * Constructor.
     * @param source The source array subject for this subscribable.
     * @param comparatorFunc A function which defines the relative sorting priority of two elements. The function should
     * return 0 if its arguments are to be sorted identically, a negative number if the first argument is to be sorted
     * before the second argument, and a positive number if the first argument is to be sorted after the second argument.
     * @param equalityFunc A function which checks if two elements are equal. Defaults to the strict equality comparison
     * (`===`) if not defined.
     */
    constructor(source, comparatorFunc, equalityFunc) {
        this.source = source;
        this.comparatorFunc = comparatorFunc;
        this.equalityFunc = equalityFunc;
        this.subs = [];
        this.sorted = new SortedArray(this.comparatorFunc, this.equalityFunc);
        this.sourceHandler = this.onSourceChanged.bind(this);
        source.sub(this.sourceHandler, true);
    }
    /** @inheritdoc */
    get length() {
        return this.sorted.length;
    }
    /**
     * Responds to changes in this subscribable's source array.
     * @param index The index of the change.
     * @param type The type of change.
     * @param item The item(s) involved in the change, if any.
     */
    onSourceChanged(index, type, item) {
        switch (type) {
            case SubscribableArrayEventType.Cleared:
                if (this.sorted.length !== 0) {
                    this.sorted.clear();
                    this.notifySubs(0, SubscribableArrayEventType.Cleared);
                }
                break;
            case SubscribableArrayEventType.Added:
                if (item) {
                    this.insert(item);
                }
                break;
            case SubscribableArrayEventType.Removed:
                if (item) {
                    this.remove(item);
                }
                break;
        }
    }
    /**
     * Inserts elements into this array.
     * @param elements An element or array of elements to insert.
     */
    insert(elements) {
        if (this.sorted.length === 0) {
            // since we know all elements will be added to one contiguous index range, we can do a small optimization here
            // with notifications
            elements instanceof Array ? this.sorted.insertAll(elements) : this.sorted.insert(elements);
            this.notifySubs(0, SubscribableArrayEventType.Added, elements instanceof Array ? this.sorted.array : elements);
        }
        else {
            const sorted = elements instanceof Array ? Array.from(elements).sort(this.comparatorFunc) : [elements];
            const len = sorted.length;
            for (let i = 0; i < len; i++) {
                const toInsert = sorted[i];
                this.notifySubs(this.sorted.insert(toInsert), SubscribableArrayEventType.Added, toInsert);
            }
        }
    }
    /**
     * Removes elements from this array.
     * @param elements An element or array of elements to remove.
     */
    remove(elements) {
        const sorted = elements instanceof Array ? Array.from(elements).sort(this.comparatorFunc) : [elements];
        const len = sorted.length;
        for (let i = 0; i < len; i++) {
            const toRemove = sorted[i];
            const removedIndex = this.sorted.remove(toRemove);
            if (removedIndex >= 0) {
                this.notifySubs(removedIndex, SubscribableArrayEventType.Removed, toRemove);
            }
        }
    }
    /**
     * Notifies subscribers of a change in this array.
     * @param index The index that was changed.
     * @param type The type of subject event.
     * @param modifiedItem The item modified by the operation.
     * @private
     */
    notifySubs(index, type, modifiedItem) {
        const len = this.subs.length;
        for (let i = 0; i < len; i++) {
            try {
                this.subs[i](index, type, modifiedItem, this.sorted.array);
            }
            catch (error) {
                console.error(`SortedMappedSubscribableArray: Error in subscriber handler ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
    }
    /** @inheritdoc */
    getArray() {
        return this.sorted.array;
    }
    /** @inheritdoc */
    get(index) {
        if (index < 0 || index >= this.sorted.length) {
            throw new RangeError(`SortedMappedSubscribableArray: index ${index} out of range`);
        }
        return this.sorted.get(index);
    }
    /** @inheritdoc */
    tryGet(index) {
        return this.sorted.get(index);
    }
    /** @inheritdoc */
    sub(fn, initialNotify) {
        this.subs.push(fn);
        initialNotify && fn(0, SubscribableArrayEventType.Added, this.sorted.array, this.sorted.array);
    }
    /** @inheritdoc */
    unsub(fn) {
        const index = this.subs.indexOf(fn);
        if (index >= 0) {
            this.subs.splice(index, 1);
        }
    }
    /**
     * Destroys this subscribable. After destruction, this subscribable will no longer update in response to changes
     * made to its source.
     */
    destroy() {
        this.source.unsub(this.sourceHandler);
    }
    /**
     * Creates a new SortedMappedSubscribableArray.
     * @param source The source array subject for the new mapped sorted array.
     * @param comparatorFunc A function which defines the relative sorting priority of two elements. The function should
     * return 0 if its arguments are to be sorted identically, a negative number if the first argument is to be sorted
     * before the second argument, and a positive number if the first argument is to be sorted after the second argument.
     * @param equalityFunc A function which checks if two elements are equal. Defaults to the strict equality comparison
     * (`===`) if not defined.
     * @returns A new SortedMappedSubscribableArray.
     */
    static create(source, comparatorFunc, equalityFunc) {
        return new SortedMappedSubscribableArray(source, comparatorFunc, equalityFunc);
    }
}

/**
 * A task queue backed by an array.
 */
class ArrayTaskQueue {
    /**
     * Constructor.
     * @param tasks The array of tasks in this queue.
     */
    constructor(tasks) {
        this.tasks = tasks;
        this.head = 0;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    hasNext() {
        return this.head < this.tasks.length;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    next() {
        return this.tasks[this.head++];
    }
}

/**
 * A process which dispatches tasks in a task queue potentially over multiple frames.
 */
class ThrottledTaskQueueProcess {
    /**
     * Constructor.
     * @param queue The queue to process.
     * @param handler A handler which defines the behavior of this process.
     */
    constructor(queue, handler) {
        this.queue = queue;
        this.handler = handler;
        this._hasStarted = false;
        this._hasEnded = false;
        this._shouldAbort = false;
    }
    /**
     * Checks whether this process has been started.
     * @returns whether this process has been started.
     */
    hasStarted() {
        return this._hasStarted;
    }
    /**
     * Checks whether this process has ended.
     * @returns whether this process has ended.
     */
    hasEnded() {
        return this._hasEnded;
    }
    /**
     * Starts this process.
     */
    start() {
        this._hasStarted = true;
        this.processQueue(0);
    }
    /**
     * Processes the queue.
     * @param elapsedFrameCount The number of frames elapsed since queue processing started.
     */
    processQueue(elapsedFrameCount) {
        let dispatchCount = 0;
        const t0 = performance.now();
        while (!this._shouldAbort && this.queue.hasNext()) {
            if (this.handler.canContinue(elapsedFrameCount, dispatchCount, performance.now() - t0)) {
                const task = this.queue.next();
                task();
                dispatchCount++;
            }
            else {
                break;
            }
        }
        if (this._shouldAbort) {
            return;
        }
        if (!this.queue.hasNext()) {
            this.handler.onFinished(elapsedFrameCount);
            this._hasEnded = true;
        }
        else {
            this.handler.onPaused(elapsedFrameCount);
            requestAnimationFrame(this.processQueue.bind(this, elapsedFrameCount + 1));
        }
    }
    /**
     * Aborts this process. Has no effect if the process has not been started or if it has already ended.
     */
    abort() {
        if (this._hasStarted && !this._hasEnded) {
            this.handler.onAborted();
            this._shouldAbort = true;
            this._hasEnded = true;
        }
    }
}

/**
 * Can be used in classes to provide support for custom events.
 * @class SubEvent
 */
class SubEvent {
    constructor() {
        this.handlers = [];
    }
    /**
     * Subscribe to this event.
     * @param handler The handler to be called when the event is emitted.
     */
    on(handler) {
        this.handlers.push(handler);
    }
    /**
     * Unsubscribe from this event.
     * @param handler The handler to be called when the event is emitted.
     */
    off(handler) {
        this.handlers = this.handlers.filter(h => h !== handler);
    }
    /**
     * Clears all subscriptions to this event.
     */
    clear() {
        this.handlers.length = 0;
    }
    /**
     * Emit event to subscribers.
     * @param sender The object emitting the event.
     * @param [data] The event arguments.
     */
    notify(sender, data) {
        const handlers = [...this.handlers];
        for (let i = 0; i < handlers.length; i++) {
            handlers[i](sender, data);
        }
    }
}

/**
 * A class for caching images.
 * Do your own instrument specific implementation with an init() method
 * that will add images to cache on instrument load to prefill the cache.
 * @class ImageCache
 */
class ImageCache {
    /**
     * Loads the image from the url and adds it to the cache.
     * @static
     * @param key The image key to access it later.
     * @param url The url to load the image from.
     */
    static addToCache(key, url) {
        if (this.cache[key] === undefined) {
            const img = new Image();
            img.src = url;
            this.cache[key] = img;
        }
    }
    /**
     * Gets a cached image element.
     * @static
     * @param key The key of the cached image.
     * @returns The cached image element.
     */
    static get(key) {
        return this.cache[key];
    }
}
ImageCache.cache = {};

/**
 * Utility class for manipulating bit flags.
 */
class BitFlags {
    /**
     * Generates a bit flag with a boolean value of true at a specified index.
     * @param index The index of the flag. Must be between 0 and 32, inclusive.
     * @returns a bit flag.
     * @throws Error if index is out of bounds.
     */
    static createFlag(index) {
        if (index < 0 || index > 32) {
            throw new Error(`Invalid index ${index} for bit flag. Index must be between 0 and 32.`);
        }
        return 1 << index;
    }
    /**
     * Gets the inverse of some bit flags.
     * @param flags The bit flag group containing the flags to invert.
     * @param mask An optional bit mask to use when applying the inverse operation. The operation will only be performed
     * at the indexes where the mask has a value of 1 (true). If a mask is not specified, the operation will be performed
     * at all indexes.
     * @returns the inverse
     */
    static not(flags, mask = ~0) {
        return flags ^ mask;
    }
    /**
     * Gets the union of zero or more bit flags.
     * @param flags A list of bit flags.
     * @returns the union of the bit flags.
     */
    static union(...flags) {
        let result = 0;
        const len = flags.length;
        for (let i = 0; i < len; i++) {
            result |= flags[i];
        }
        return result;
    }
    /**
     * Gets the intersection of zero or more bit flags.
     * @param flags A list of bit flags.
     * @returns the intersection of the bit flags.
     */
    static intersection(...flags) {
        const len = flags.length;
        if (len === 0) {
            return 0;
        }
        let result = flags[0];
        for (let i = 1; i < len; i++) {
            result &= flags[i];
        }
        return result;
    }
    /**
     * Checks if a bit flag group meets at least one condition from a list of conditions.
     * @param flags A bit flag group.
     * @param conditions The conditions to meet, as a bit flag group.
     * @returns whether the bit flag group meets at least one condition.
     */
    static isAny(flags, conditions) {
        return (flags & conditions) !== 0;
    }
    /**
     * Checks if a bit flag group meets all the conditions from a list of conditions.
     * @param flags A bit flag group.
     * @param conditions The conditions to meet, as a bit flag group.
     * @returns whether the bit flag group meets all the conditions.
     */
    static isAll(flags, conditions) {
        return (flags & conditions) === conditions;
    }
    /**
     * Iterates through a bit flag group and executes a callback function once for each flag.
     * @param flags A bit flag group.
     * @param callback A function which will be called once for each flag.
     * @param valueFilter The value on which to filter. If defined, only flags with values equal to the filter will be
     * iterated, otherwise all flags will be iterated regardless of their values.
     * @param startIndex The index of the flag at which to start (inclusive). Defaults to 0.
     * @param endIndex The index of the flag at which to end (exclusive). Defaults to 32.
     */
    static forEach(flags, callback, valueFilter, startIndex, endIndex) {
        startIndex = Utils.Clamp(startIndex !== null && startIndex !== void 0 ? startIndex : (startIndex = 0), 0, 32);
        endIndex = Utils.Clamp(endIndex !== null && endIndex !== void 0 ? endIndex : (endIndex = 32), 0, 32);
        for (let i = startIndex; i < endIndex; i++) {
            const value = (flags & (1 << i)) !== 0;
            if (valueFilter === undefined || valueFilter === value) {
                callback(value, i, flags);
            }
        }
    }
}

/**
 * A utility class for creating number formatters.
 */
class NumberFormatter {
    /**
     * Formats a number to a string.
     * @param precision The precision to which to round the number. A value of 0 denotes no rounding.
     * @param roundFunc The rounding function to use.
     * @param maxDigits The maximum number of digits to enforce.
     * @param forceDecimalZeroes Whether to force trailing zeroes after the decimal point.
     * @param pad The number of digits to which to pad with zeroes in front of the decimal point.
     * @param showCommas Whether to show commas.
     * @param forceSign Whether to force the display of a positive sign.
     * @param nanString The string to use for NaN.
     * @param number The number to format.
     * @returns A formatted string.
     */
    static formatNumber(precision, roundFunc, maxDigits, forceDecimalZeroes, pad, showCommas, forceSign, nanString, number) {
        if (isNaN(number)) {
            return nanString;
        }
        const sign = number < 0 ? '-' : '+';
        const abs = Math.abs(number);
        let formatted;
        if (precision != 0) {
            const rounded = roundFunc(abs / precision) * precision;
            const precisionString = `${precision}`;
            const decimalIndex = precisionString.indexOf('.');
            if (decimalIndex >= 0) {
                formatted = rounded.toFixed(precisionString.length - decimalIndex - 1);
            }
            else {
                formatted = `${rounded}`;
            }
        }
        else {
            formatted = `${abs}`;
        }
        let decimalIndex = formatted.indexOf('.');
        if (!forceDecimalZeroes && decimalIndex >= 0) {
            formatted = formatted.replace(/0+$/, '');
            if (formatted.indexOf('.') == formatted.length - 1) {
                formatted = formatted.substring(0, formatted.length - 1);
            }
        }
        decimalIndex = formatted.indexOf('.');
        if (decimalIndex >= 0 && formatted.length - 1 > maxDigits) {
            const shift = Math.max(maxDigits - decimalIndex, 0);
            const shiftPrecision = Math.pow(0.1, shift);
            formatted = (roundFunc(abs / shiftPrecision) * shiftPrecision).toFixed(shift);
        }
        if (pad === 0) {
            formatted = formatted.replace(/^0\./, '.');
        }
        else if (pad > 1) {
            decimalIndex = formatted.indexOf('.');
            if (decimalIndex < 0) {
                decimalIndex = formatted.length;
            }
            formatted = formatted.padStart(pad + formatted.length - decimalIndex, '0');
        }
        if (showCommas) {
            const parts = formatted.split('.');
            parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            formatted = parts.join('.');
        }
        return ((forceSign || sign === '-') ? sign : '') + formatted;
    }
    /**
     * Creates a number formatter.
     * @param options Options to customize the formatter.
     * @returns A number formatter.
     */
    static create(options) {
        const optsToUse = Object.assign({}, NumberFormatter.DEFAULT_OPTIONS);
        Object.assign(optsToUse, options);
        return NumberFormatter.formatNumber.bind(undefined, optsToUse.precision, NumberFormatter.roundFuncs[optsToUse.round], optsToUse.maxDigits, optsToUse.forceDecimalZeroes, optsToUse.pad, optsToUse.showCommas, optsToUse.forceSign, optsToUse.nanString);
    }
}
NumberFormatter.DEFAULT_OPTIONS = {
    precision: 0,
    round: 0,
    maxDigits: Infinity,
    forceDecimalZeroes: true,
    pad: 1,
    showCommas: false,
    forceSign: false,
    nanString: 'NaN'
};
NumberFormatter.roundFuncs = {
    [-1]: Math.floor,
    [0]: Math.round,
    [1]: Math.ceil
};

/** A class that linearly drives a SimVar value towards a given set point. */
class LinearServo {
    /**
     * Creates an instance of a LinearServo.
     * @param rate The rate, in units per second, to drive the servo.
     */
    constructor(rate) {
        this.rate = rate;
    }
    /**
     * Drives the servo towards the set point.
     * @param currentValue The current value.
     * @param setValue The value to drive towards.
     * @returns The output value.
     */
    drive(currentValue, setValue) {
        if (this.currentTime === undefined) {
            this.currentTime = new Date().appTime();
            return currentValue;
        }
        const currentTime = new Date().appTime();
        const deltaTime = currentTime - this.currentTime;
        this.currentTime = currentTime;
        const deltaValue = setValue - currentValue;
        const maximumDrive = this.rate * (deltaTime / 1000);
        const output = Math.abs(deltaValue) > maximumDrive
            ? currentValue + (Math.sign(deltaValue) * maximumDrive)
            : setValue;
        return output;
    }
}

/**
 * A basic event-bus publisher.
 */
class BasePublisher {
    /**
     * Creates an instance of BasePublisher.
     * @param bus The common event bus.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(bus, pacer = undefined) {
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.publishActive = false;
        this.pacer = pacer;
    }
    /**
     * Start publishing.
     */
    startPublish() {
        this.publishActive = true;
    }
    /**
     * Stop publishing.
     */
    stopPublish() {
        this.publishActive = false;
    }
    /**
     * Tells whether or not the publisher is currently active.
     * @returns True if the publisher is active, false otherwise.
     */
    isPublishing() {
        return this.publishActive;
    }
    /**
     * A callback called when the publisher receives an update cycle.
     */
    onUpdate() {
        return;
    }
    /**
     * Publish a message if publishing is acpive
     * @param topic The topic key to publish to.
     * @param data The data type for chosen topic.
     * @param sync Whether or not the event should be synced via local storage.
     */
    publish(topic, data, sync = false) {
        if (this.publishActive && (!this.pacer || this.pacer.canPublish(topic, data))) {
            this.publisher.pub(topic, data, sync);
        }
    }
}
/**
 * A base class for publishers that need to handle simvars with built-in
 * support for pacing callbacks.
 */
class SimVarPublisher extends BasePublisher {
    /**
     * Create a SimVarPublisher
     * @param simVarMap A map of simvar event type keys to a SimVarDefinition.
     * @param bus The EventBus to use for publishing.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(simVarMap, bus, pacer = undefined) {
        super(bus, pacer);
        this.simvars = simVarMap;
        this.subscribed = new Set();
    }
    /**
     * Subscribe to an event type to begin publishing.
     * @param data Key of the event type in the simVarMap
     */
    subscribe(data) {
        this.subscribed.add(data);
    }
    /**
     * Unsubscribe to an event to stop publishing.
     * @param data Key of the event type in the simVarMap
     */
    unsubscribe(data) {
        // TODO If we have multiple subscribers we may want to add reference counting here.
        this.subscribed.delete(data);
    }
    /**
     * Read the value of a given simvar by its key.
     * @param key The key of the simvar in simVarMap
     * @returns The value returned by SimVar.GetSimVarValue()
     */
    getValue(key) {
        const simvar = this.simvars.get(key);
        if (simvar === undefined) {
            return undefined;
        }
        return SimVar.GetSimVarValue(simvar.name, simvar.type);
    }
    /**
     * Publish all subscribed data points to the bus.
     */
    onUpdate() {
        for (const data of this.subscribed.values()) {
            const value = this.getValue(data);
            if (value !== undefined) {
                this.publish(data, value);
            }
        }
    }
    /**
     * Change the simvar read for a given key.
     * @param key The key of the simvar in simVarMap
     * @param value The new value to set the simvar to.
     */
    updateSimVarSource(key, value) {
        this.simvars.set(key, value);
    }
}

/** A publisher for sound events. */
class SoundPublisher extends BasePublisher {
    /**
     * Create a SoundPublisher.
     * @param bus An event bus.
     * @param pacer An optional pacer to controle the rate of publishing.
     */
    constructor(bus, pacer) {
        super(bus, pacer);
    }
    /**
     * Request that a sound be played.
     * @param soundId The id of the sound to play.
     */
    playSound(soundId) {
        this.publish('play_sound', soundId, true);
    }
    /**
     * Request that a continuous sound be started.
     * @param soundId The id of the sound to play.
     */
    startSound(soundId) {
        this.publish('start_sound', soundId, true);
    }
    /**
     * Request that a continuous sound be stopped.
     * @param soundId The id of the sound to play.
     */
    stopSound(soundId) {
        this.publish('stop_sound', soundId, true);
    }
    /**
     * Send a notification that play has been requested.
     * @param soundId The id of the sound requested.
     */
    soundQueued(soundId) {
        this.publish('sound_queued', soundId, true);
    }
    /**
     * Send a notification that play has completed.
     * @param soundId The id of the sound played.
     */
    soundPlayed(soundId) {
        this.publish('sound_played', soundId, true);
    }
}
/**
 * A event-drive sound server that manages both one-shot and continuous sound playback.
 */
class SoundServer {
    /**
     * Create a sound server.
     * @param bus An event bus.
     * @param publisher A sound publisher.
     * @param instrument The hosting instance of BaseInstrument.
     */
    constructor(bus, publisher, instrument) {
        this.instrument = instrument;
        this.playing = new Map();
        this.subscriber = bus.getSubscriber();
        this.publisher = publisher;
        this.subscriber.on('play_sound').handle((soundId) => { this.playSound(soundId, false); });
        this.subscriber.on('start_sound').handle((soundId) => { this.playSound(soundId, true); });
        this.subscriber.on('stop_sound').handle((soundId) => { this.stopSound(soundId); });
    }
    /**
     * Play a requested sound once or continuously.
     * @param soundId The id of the sound to play.
     * @param continuous Whether to play it continuously.
     */
    playSound(soundId, continuous = false) {
        if (!this.playing.has(soundId)) {
            this.instrument.playInstrumentSound(soundId);
            this.playing.set(soundId, { soundEventId: new Name_Z(soundId), continuous: continuous });
            this.publisher.soundQueued(soundId);
        }
    }
    /**
     * Stop a continuously played sound.
     * @param soundId The id of the sound to stop.
     */
    stopSound(soundId) {
        const record = this.playing.get(soundId);
        if (record) {
            // Setting continuous to false means it won't be retriggered next time it ends.
            record.continuous = false;
            this.playing.set(soundId, record);
        }
    }
    /**
     * Handle a sound end event.  This needs to be called by the parent device,
     * and it takes a Name_Z, as sent from VCockpit.js in the master onSoundEnd call.
     * @param soundEventId The id of the sound event.
     */
    onSoundEnd(soundEventId) {
        for (const entry of this.playing.entries()) {
            // Name_Z can't be compared with ==, you need to use the in-built function.
            if (Name_Z.compare(entry[1].soundEventId, soundEventId)) {
                if (entry[1].continuous) {
                    this.instrument.playInstrumentSound(entry[0]);
                    return;
                }
                else {
                    this.publisher.soundPlayed(entry[0]);
                    this.playing.delete(entry[0]);
                    return;
                }
            }
        }
    }
}

/**
 * An event bus consumer for a specific topic.
 */
class Consumer {
    /**
     * Creates an instance of a Consumer.
     * @param bus The event bus to subscribe to.
     * @param topic The topic of the subscription.
     * @param state The state for the consumer to track.
     * @param currentHandler The current build filter handler stack, if any.
     */
    constructor(bus, topic, state = {}, currentHandler) {
        this.bus = bus;
        this.topic = topic;
        this.state = state;
        this.currentHandler = currentHandler;
    }
    /**
     * Handles an event using the provided event handler.
     * @param handler The event handler for the event.
     */
    handle(handler) {
        if (this.currentHandler !== undefined) {
            /**
             * The handler reference to store.
             * @param data The input data to the handler.
             */
            this.handlerReference = (data) => {
                if (this.currentHandler !== undefined) {
                    this.currentHandler(data, this.state, handler);
                }
            };
            this.bus.on(this.topic, this.handlerReference);
        }
        else {
            this.bus.on(this.topic, handler);
        }
    }
    /**
     * Disables handling of the event.
     * @param handler The handler to disable.
     */
    off(handler) {
        if (this.handlerReference !== undefined) {
            this.bus.off(this.topic, this.handlerReference);
        }
        else {
            this.bus.off(this.topic, handler);
        }
    }
    /**
     * Caps the event subscription to a specified frequency, in Hz.
     * @param frequency The frequency, in Hz, to cap to.
     * @returns A new consumer with the applied frequency filter.
     */
    atFrequency(frequency) {
        const deltaTimeTrigger = 1000 / frequency;
        return new Consumer(this.bus, this.topic, { previousTime: Date.now() }, (data, state, next) => {
            const currentTime = Date.now();
            const deltaTime = currentTime - state.previousTime;
            if (deltaTimeTrigger <= deltaTime) {
                while ((state.previousTime + deltaTimeTrigger) < currentTime) {
                    state.previousTime += deltaTimeTrigger;
                }
                this.with(data, next);
            }
        });
    }
    /**
     * Quantizes the numerical event data to consume only at the specified decimal precision.
     * @param precision The decimal precision to snap to.
     * @returns A new consumer with the applied precision filter.
     */
    withPrecision(precision) {
        return new Consumer(this.bus, this.topic, { lastValue: 0 }, (data, state, next) => {
            const dataValue = data;
            const multiplier = Math.pow(10, precision);
            const currentValueAtPrecision = Math.round(dataValue * multiplier) / multiplier;
            if (currentValueAtPrecision !== state.lastValue) {
                state.lastValue = currentValueAtPrecision;
                this.with(currentValueAtPrecision, next);
            }
        });
    }
    /**
     * Filter the subscription to consume only when the value has changed by a minimum amount.
     * @param amount The minimum amount threshold below which the consumer will not consume.
     * @returns A new consumer with the applied change threshold filter.
     */
    whenChangedBy(amount) {
        return new Consumer(this.bus, this.topic, { lastValue: 0 }, (data, state, next) => {
            const dataValue = data;
            const diff = Math.abs(dataValue - state.lastValue);
            if (diff >= amount) {
                state.lastValue = dataValue;
                this.with(data, next);
            }
        });
    }
    /**
     * Filter the subscription to consume only if the value has changed. At all.  Really only
     * useful for strings or other events that don't change much.
     * @returns A new consumer with the applied change threshold filter.
     */
    whenChanged() {
        return new Consumer(this.bus, this.topic, { lastValue: '' }, (data, state, next) => {
            if (state.lastValue !== data) {
                state.lastValue = data;
                this.with(data, next);
            }
        });
    }
    /**
     * Filters events by time such that events will not be consumed until a minimum duration
     * has passed since the previous event.
     * @param deltaTime The minimum delta time between events.
     * @returns A new consumer with the applied change threshold filter.
     */
    onlyAfter(deltaTime) {
        return new Consumer(this.bus, this.topic, { previousTime: Date.now() }, (data, state, next) => {
            const currentTime = Date.now();
            const timeDiff = currentTime - state.previousTime;
            if (timeDiff > deltaTime) {
                state.previousTime += deltaTime;
                this.with(data, next);
            }
        });
    }
    /**
     * Builds a handler stack from the current handler.
     * @param data The data to send in to the handler.
     * @param handler The handler to use for processing.
     */
    with(data, handler) {
        if (this.currentHandler !== undefined) {
            this.currentHandler(data, this.state, handler);
        }
        else {
            handler(data);
        }
    }
}

/**
 * A typed container for subscribers interacting with the Event Bus.
 */
class EventSubscriber {
    /**
     * Creates an instance of an EventSubscriber.
     * @param bus The EventBus that is the parent of this instance.
     */
    constructor(bus) {
        this.bus = bus;
    }
    /**
     * Subscribes to a topic on the bus.
     * @param topic The topic to subscribe to.
     * @returns A consumer to bind the event handler to.
     */
    on(topic) {
        return new Consumer(this.bus, topic);
    }
}

/// <reference types="msfstypes/JS/common" />
/**
 * An event bus that can be used to publish data from backend
 * components and devices to consumers.
 */
class EventBus {
    /**
     * Creates an instance of an EventBus.
     * @param useStorageSync Whether or not to use storage sync (optional, default false)
     */
    constructor(useStorageSync) {
        this._topicHandlersMap = new Map();
        this._wildcardHandlers = new Array();
        this._eventCache = new Map();
        this._busId = Math.floor(Math.random() * 2147483647);
        const syncFunc = useStorageSync ? EventBusStorageSync : EventBusCoherentSync;
        this._busSync = new syncFunc(this.pub.bind(this), this._busId);
        console.log('sending resync request');
        this.syncEvent('event_bus', 'resync_request', false);
        this.on('event_bus', (data) => {
            if (data == 'resync_request') {
                console.log('got resync request');
                this.resyncEvents();
            }
        });
    }
    /**
     * Subscribes to a topic on the bus.
     * @param topic The topic to subscribe to.
     * @param handler The handler to be called when an event happens.
     */
    on(topic, handler) {
        var _a;
        const handlers = this._topicHandlersMap.get(topic);
        const isNew = !(handlers && handlers.push(handler));
        if (isNew) {
            this._topicHandlersMap.set(topic, [handler]);
        }
        const lastState = (_a = this._eventCache.get(topic)) === null || _a === void 0 ? void 0 : _a.data;
        if (this._eventCache.get(topic) !== undefined) {
            handler(lastState);
        }
    }
    /**
     * Unsubscribes a handler from the topic's events.
     * @param topic The topic to unsubscribe from.
     * @param handler The handler to unsubscribe from topic.
     */
    off(topic, handler) {
        const handlers = this._topicHandlersMap.get(topic);
        if (handlers) {
            handlers.splice(handlers.indexOf(handler) >>> 0, 1);
        }
    }
    /**
     * Subscribe to the handler as * to all topics.
     * @param handler The handler to subscribe to all events.
     */
    onAll(handler) {
        this._wildcardHandlers.push(handler);
    }
    /**
     * Unsubscribe the handler from all topics.
     * @param handler The handler to unsubscribe from all events.
     */
    offAll(handler) {
        const handlerIndex = this._wildcardHandlers.indexOf(handler);
        if (handlerIndex > -1) {
            this._wildcardHandlers.splice(handlerIndex >>> 0, 1);
        }
    }
    /**
     * Publishes an event to the topic on the bus.
     * @param topic The topic to publish to.
     * @param data The data portion of the event.
     * @param sync Whether or not this message needs to be synced on local stoage.
     * @param isCached Whether or not this message will be resync'd across the bus on load.
     */
    pub(topic, data, sync = false, isCached = true) {
        if (isCached) {
            this._eventCache.set(topic, { data: data, synced: sync });
        }
        const handlers = this._topicHandlersMap.get(topic);
        if (handlers !== undefined) {
            const len = handlers.length;
            for (let i = 0; i < len; i++) {
                try {
                    handlers[i](data);
                }
                catch (error) {
                    console.error(`Error in EventBus Handler: ${error}`);
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
        }
        // We don't know if anything is subscribed on busses in other instruments,
        // so we'll unconditionally sync if sync is true and trust that the
        // publisher knows what it's doing.
        if (sync) {
            this.syncEvent(topic, data, isCached);
        }
        // always push to wildcard handlers
        const wcLen = this._wildcardHandlers.length;
        for (let i = 0; i < wcLen; i++) {
            this._wildcardHandlers[i](topic, data);
        }
    }
    /**
     * Re-sync all synced events
     */
    resyncEvents() {
        for (const [topic, event] of this._eventCache) {
            if (event.synced) {
                this.syncEvent(topic, event.data, true);
            }
        }
    }
    /**
     * Publish an event to the sync bus.
     * @param topic The topic to publish to.
     * @param data The data to publish.
     * @param isCached Whether or not this message will be resync'd across the bus on load.
     */
    syncEvent(topic, data, isCached) {
        // console.log(`sending synced event to ${topic}:`);
        // console.log(data);
        this._busSync.sendEvent(topic, data, isCached);
    }
    /**
     * Gets a typed publisher from the event bus..
     * @returns The typed publisher.
     */
    getPublisher() {
        return this;
    }
    /**
     * Gets a typed subscriber from the event bus.
     * @returns The typed subscriber.
     */
    getSubscriber() {
        return new EventSubscriber(this);
    }
}
/**
 * A class that manages event bus synchronization via data storage.
 */
class EventBusStorageSync {
    /**
     * Creates an instance of EventBusStorageSync.
     * @param recvEventCb A callback to execute when an event is received on the bus.
     * @param busId The ID of the bus.  Derp.
     */
    constructor(recvEventCb, busId) {
        this.recvEventCb = recvEventCb;
        this.busId = busId;
        window.addEventListener('storage', this.receiveEvent.bind(this));
    }
    /**
     * Sends an event via storage events.
     * @param topic The topic to send data on.
     * @param data The data to send.
     */
    sendEvent(topic, data) {
        // TODO can we do the stringing more gc friendly?
        // TODO we could not stringify on simple types, but the receiver wouldn't know I guess
        // TODO add handling for busIds to avoid message loops
        //console.log('send' + topic.toString());
        localStorage.setItem(EventBusStorageSync.EB_KEY, `${topic.toString()},${data !== undefined ? JSON.stringify(data) : EventBusStorageSync.EMPTY_DATA}`);
        // TODO move removeItem to a function called at intervals instead of every time?
        localStorage.removeItem(EventBusStorageSync.EB_KEY);
    }
    /**
     * Receives an event from storage and syncs onto the bus.
     * @param e The storage event that was received.
     */
    receiveEvent(e) {
        // TODO only react on topics that have subscribers
        //console.log('recv' + e.key);
        if (e.key === EventBusStorageSync.EB_KEY && e.newValue) {
            const val = e.newValue.split(',');
            this.recvEventCb(val[0], val.length > 1 ? JSON.parse(val[1]) : undefined, true);
        }
    }
}
EventBusStorageSync.EMPTY_DATA = '{}';
EventBusStorageSync.EB_KEY = 'eb.evt';
/**
 * A class that manages event bus synchronization via Coherent notifications.
 */
class EventBusCoherentSync {
    /**
     * Creates an instance of EventBusCoherentSync.
     * @param recvEventCb A callback to execute when an event is received on the bus.
     * @param busId The ID of the bus.  Derp.
     */
    constructor(recvEventCb, busId) {
        this.evtNum = 0;
        this.lastEventSynced = -1;
        this.recvEventCb = recvEventCb;
        this.busId = busId;
        this.listener = RegisterViewListener(EventBusCoherentSync.EB_LISTENER_KEY);
        this.listener.on(EventBusCoherentSync.EB_KEY, this.receiveEvent.bind(this));
    }
    /**
     * Sends an event via Coherent events.
     * @param topic The topic to send data on.
     * @param data The data to send.
     * @param isCached Whether or not this event is cached.
     */
    sendEvent(topic, data, isCached) {
        // console.log('send ' + topic.toString());
        this.listener.triggerToAllSubscribers(EventBusCoherentSync.EB_KEY, { topic, data, isCached, busId: this.busId, evtNum: this.evtNum++ });
    }
    /**
     * Receives an event via Coherent and syncs onto the bus.
     * @param e The storage event that was received.
     */
    receiveEvent(e) {
        // If we've sent this event, don't act on it.
        if (e.busId == this.busId) {
            return;
        }
        if (this.lastEventSynced !== e.evtNum) {
            // TODO only react on topics that have subscribers
            // console.log(`coherent recv ${e['topic']}`);
            this.lastEventSynced = e.evtNum;
            this.recvEventCb(e['topic'], e['data'], undefined, e['isCached']);
        }
    }
}
EventBusCoherentSync.EMPTY_DATA = '{}';
EventBusCoherentSync.EB_KEY = 'eb.evt';
EventBusCoherentSync.EB_LISTENER_KEY = 'JS_LISTENER_SIMVARS';

/**
 * A publisher for publishing H:Events on the bus.
 */
class HEventPublisher extends BasePublisher {
    /**
     * Dispatches an H:Event to the event bus.
     * @param hEvent The H:Event to dispatch.
     * @param sync Whether this event should be synced (optional, default false)
     */
    dispatchHEvent(hEvent, sync = false) {
        //console.log(`dispaching hevent:  ${hEvent}`);
        this.publish('hEvent', hEvent, sync);
    }
}

/**
 * Valid type arguments for Set/GetSimVarValue
 */
var SimVarValueType;
(function (SimVarValueType) {
    SimVarValueType["Number"] = "number";
    SimVarValueType["Degree"] = "degrees";
    SimVarValueType["Knots"] = "knots";
    SimVarValueType["Feet"] = "feet";
    SimVarValueType["Meters"] = "meters";
    SimVarValueType["FPM"] = "feet per minute";
    SimVarValueType["Radians"] = "radians";
    SimVarValueType["InHG"] = "inches of mercury";
    SimVarValueType["MB"] = "Millibars";
    SimVarValueType["Bool"] = "Bool";
    SimVarValueType["Celsius"] = "celsius";
    SimVarValueType["MHz"] = "MHz";
    SimVarValueType["KHz"] = "KHz";
    SimVarValueType["NM"] = "nautical mile";
    SimVarValueType["String"] = "string";
    SimVarValueType["RPM"] = "Rpm";
    SimVarValueType["PPH"] = "Pounds per hour";
    SimVarValueType["GPH"] = "gph";
    SimVarValueType["Farenheit"] = "farenheit";
    SimVarValueType["PSI"] = "psi";
    SimVarValueType["GAL"] = "gallons";
    SimVarValueType["Hours"] = "Hours";
    SimVarValueType["Volts"] = "Volts";
    SimVarValueType["Amps"] = "Amperes";
    SimVarValueType["Seconds"] = "seconds";
    SimVarValueType["Enum"] = "Enum";
    SimVarValueType["LLA"] = "latlonalt";
})(SimVarValueType || (SimVarValueType = {}));

/**
 * A publisher for control interactions.
 * This is meant to handle the events for which there aren't existing HEvents
 * in the sim to allow us to maintain a decoupled, event-driven architecture.
 */
class ControlPublisher extends BasePublisher {
    /**
     * Create a ControlPublisher.
     * @param bus The EventBus to publish to.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer = undefined) {
        super(bus, pacer);
    }
    /**
     * Publish a control event.
     * @param event The event from ControlEvents.
     * @param value The value of the event.
     */
    publishEvent(event, value) {
        this.publish(event, value, true);
    }
    /** debug logger */
    startPublish() {
        super.startPublish();
        console.log('control publisher started.');
    }
}

/// <reference types="msfstypes/Pages/VCockpit/Instruments/Shared/utils/XMLLogic" />
/** The kind of data to return. */
var CompositeLogicXMLValueType;
(function (CompositeLogicXMLValueType) {
    CompositeLogicXMLValueType[CompositeLogicXMLValueType["Any"] = 0] = "Any";
    CompositeLogicXMLValueType[CompositeLogicXMLValueType["Number"] = 1] = "Number";
    CompositeLogicXMLValueType[CompositeLogicXMLValueType["String"] = 2] = "String";
})(CompositeLogicXMLValueType || (CompositeLogicXMLValueType = {}));
/**
 *
 */
class CompositeLogicXMLHost {
    constructor() {
        this.anyHandlers = new Array();
        this.stringHandlers = new Array();
        this.numberHandlers = new Array();
        this.anyResultCache = new Array();
        this.stringResultCache = new Array();
        this.numberResultCache = new Array();
        this.context = new LogicXMLContext();
    }
    /**
     * Add a new logic element to calcluate a number or a string.
     * @param logic A CompositeLogicXMLElement.
     * @param handler A callback hander to take new values of either type.
     * @returns The current value of the logic.
     */
    addLogic(logic, handler) {
        this.anyHandlers.push({ logic: logic, handler: handler });
        return logic.getValue(this.context);
    }
    /**
     * Add a new logic element to calcluate a number.
     * @param logic A CompositeLogicXMLElement.
     * @param handler A callback hander to take new values as numbers.
     * @param precision An optional precision to require for updates to be sent.
     * @returns The current value of the logic.
     */
    addLogicAsNumber(logic, handler, precision) {
        this.numberHandlers.push({ logic: logic, handler: handler, precision: precision });
        return logic.getValueAsNumber(this.context);
    }
    /**
     * Add a new logic element to calcluate a string.
     * @param logic A CompositeLogicXMLElement.
     * @param handler A callback hander to take new values as strings.
     * @returns The current value of the logic.
     */
    addLogicAsString(logic, handler) {
        this.stringHandlers.push({ logic: logic, handler: handler });
        return logic.getValueAsString(this.context);
    }
    /**
     * Add a function to the logic context.
     * @param funcSpec The XMLFunction configuration.
     * @returns The function's current value.
     */
    addFunction(funcSpec) {
        const func = new LogicXMLFunction();
        func.name = funcSpec.name;
        func.callback = funcSpec.logic;
        this.context.addFunction(func);
        return funcSpec.logic.getValue(this.context);
    }
    /**
     * Update every logic element and publish updates.
     */
    update() {
        for (let i = 0; i < this.anyHandlers.length; i++) {
            const newVal = this.anyHandlers[i].logic.getValue(this.context);
            if (newVal !== this.anyResultCache[i]) {
                this.anyResultCache[i] = newVal;
                this.anyHandlers[i].handler(newVal);
            }
        }
        for (let i = 0; i < this.stringHandlers.length; i++) {
            const newVal = this.stringHandlers[i].logic.getValueAsString(this.context);
            if (newVal !== this.stringResultCache[i]) {
                this.stringResultCache[i] = newVal;
                this.stringHandlers[i].handler(newVal);
            }
        }
        for (let i = 0; i < this.numberHandlers.length; i++) {
            let newVal = this.numberHandlers[i].logic.getValueAsNumber(this.context);
            let precision = this.numberHandlers[i].precision;
            if (precision !== undefined) {
                precision = Math.pow(10, precision);
                newVal = Math.round(newVal * precision) / precision;
            }
            if (newVal !== this.numberResultCache[i]) {
                this.numberResultCache[i] = newVal;
                this.numberHandlers[i].handler(newVal);
            }
        }
        this.context.update();
    }
}

/// <reference types="msfstypes/JS/dataStorage" />
/* eslint-disable no-inner-declarations */
// eslint-disable-next-line @typescript-eslint/no-namespace
var DataStore;
(function (DataStore) {
    /**
     * Writes a keyed value to the data store.
     * @param key A key.
     * @param value The value to set.
     */
    function set(key, value) {
        SetStoredData(key, JSON.stringify(value));
    }
    DataStore.set = set;
    /**
     * Retrieves a keyed value from the data store.
     * @param key A key.
     * @returns the value stored under the key, or undefined if one could not be retrieved.
     */
    function get(key) {
        try {
            const string = GetStoredData(key);
            return JSON.parse(string);
        }
        catch (e) {
            return undefined;
        }
    }
    DataStore.get = get;
    /**
     * Removes a key from the data store.
     * @param key The key to remove.
     */
    function remove(key) {
        DeleteStoredData(key);
    }
    DataStore.remove = remove;
})(DataStore || (DataStore = {}));

/**
 * Types of airspaces.
 */
var AirspaceType;
(function (AirspaceType) {
    AirspaceType[AirspaceType["None"] = 0] = "None";
    AirspaceType[AirspaceType["Center"] = 1] = "Center";
    AirspaceType[AirspaceType["ClassA"] = 2] = "ClassA";
    AirspaceType[AirspaceType["ClassB"] = 3] = "ClassB";
    AirspaceType[AirspaceType["ClassC"] = 4] = "ClassC";
    AirspaceType[AirspaceType["ClassD"] = 5] = "ClassD";
    AirspaceType[AirspaceType["ClassE"] = 6] = "ClassE";
    AirspaceType[AirspaceType["ClassF"] = 7] = "ClassF";
    AirspaceType[AirspaceType["ClassG"] = 8] = "ClassG";
    AirspaceType[AirspaceType["Tower"] = 9] = "Tower";
    AirspaceType[AirspaceType["Clearance"] = 10] = "Clearance";
    AirspaceType[AirspaceType["Ground"] = 11] = "Ground";
    AirspaceType[AirspaceType["Departure"] = 12] = "Departure";
    AirspaceType[AirspaceType["Approach"] = 13] = "Approach";
    AirspaceType[AirspaceType["MOA"] = 14] = "MOA";
    AirspaceType[AirspaceType["Restricted"] = 15] = "Restricted";
    AirspaceType[AirspaceType["Prohibited"] = 16] = "Prohibited";
    AirspaceType[AirspaceType["Warning"] = 17] = "Warning";
    AirspaceType[AirspaceType["Alert"] = 18] = "Alert";
    AirspaceType[AirspaceType["Danger"] = 19] = "Danger";
    AirspaceType[AirspaceType["Nationalpark"] = 20] = "Nationalpark";
    AirspaceType[AirspaceType["ModeC"] = 21] = "ModeC";
    AirspaceType[AirspaceType["Radar"] = 22] = "Radar";
    AirspaceType[AirspaceType["Training"] = 23] = "Training";
    AirspaceType[AirspaceType["Max"] = 24] = "Max";
})(AirspaceType || (AirspaceType = {}));

/**
 *
 */
class CoherentAirspace {
    /**
     * Constructor.
     * @param def The airspace definition to use for the new airspace.
     * @param uid A unique string ID for the new airspace.
     */
    constructor(def, uid) {
        /** @inheritdoc */
        this.name = '';
        this._segments = [];
        this.type = def.type;
        this.uid = uid;
        const segments = def.segments;
        const len = segments.length;
        for (let i = 0; i < len; i++) {
            const point = segments[i];
            this._segments[i] = new GeoPoint(point.lat, point.long);
        }
    }
    /** @inheritdoc */
    get segments() {
        return this._segments;
    }
    /** @inheritdoc */
    equals(other) {
        if (other instanceof CoherentAirspace) {
            return this.uid === other.uid;
        }
        return this.type === other.type
            && this.segments.length === other.segments.length
            && this.segments.every((point, index) => point.equals(other.segments[index]));
    }
}
/**
 * A searcher for airspaces.
 */
class AirspaceSearcher {
    /**
     * Constructor.
     * @param cacheSize The maximum size of the Airspace cache.
     */
    constructor(cacheSize = AirspaceSearcher.DEFAULT_CACHE_SIZE) {
        this.cacheSize = cacheSize;
        this.cache = new Map();
        this._isBusy = false;
        this.queue = [];
    }
    /**
     * Checks whether this searcher is currently busy with a search.
     * @returns whether this searcher is currently busy with a search.
     */
    isBusy() {
        return this._isBusy;
    }
    /**
     * Searches for airspaces around a geographic point. If the searcher is not busy, the search will execute
     * immediately. If the search is busy, the search will be queued. Queued searches will be executed one at a time in
     * FIFO order as searches are finished.
     * @param center The center of the search area.
     * @returns a Promise which is fulfilled with an array of airspaces when the search finishes.
     */
    search(center) {
        return new Promise(resolve => {
            if (this._isBusy || this.queue.length > 0) {
                this.enqueueSearch(center, resolve);
            }
            else {
                this.doSearch(center, resolve);
            }
        });
    }
    /**
     * Enqueues a search operation.
     * @param center The center of the search area.
     * @param resolve The Promise resolve function to call with the search results.
     */
    enqueueSearch(center, resolve) {
        this.queue.push(this.doSearch.bind(this, center, resolve));
    }
    /**
     * Executes the next search operation in the queue, if one exists.
     */
    processQueue() {
        const next = this.queue.shift();
        if (next) {
            next();
        }
    }
    /**
     * Executes an airspace search.
     * @param center The center of the search area.
     * @param resolve The Promise resolve function to call with the search results.
     */
    async doSearch(center, resolve) {
        this._isBusy = true;
        try {
            const coherentDefs = await Promise.race([
                this.executeCoherentSearch(center),
                new Promise((timeoutResolve, reject) => setTimeout(() => reject('Airspace search timed out.'), AirspaceSearcher.SEARCH_TIMEOUT))
            ]);
            const airspaces = this.processCoherentDefs(coherentDefs);
            resolve(airspaces);
        }
        catch (e) {
            console.log(e);
            resolve([]);
        }
        this._isBusy = false;
        this.processQueue();
    }
    /**
     * Executes a Coherent airspace search.
     * @param center The center of the search area.
     * @returns a Promise which is fulfilled with an array of Coherent airspace definitions when the search finishes.
     */
    async executeCoherentSearch(center) {
        await Coherent.call('SET_LOAD_LATLON', center.lat, center.lon);
        return await Coherent.call('GET_NEAREST_AIRSPACES');
    }
    /**
     * Processes an array of Coherent airspace definitions into an array of Airspaces.
     * @param defs An array fo Coherent airspace definitions.
     * @returns an array of Airspaces corresponding to the supplied definitions.
     */
    processCoherentDefs(defs) {
        const result = [];
        const len = defs.length;
        for (let i = 0; i < len; i++) {
            const def = defs[i];
            if (def.type === AirspaceType.None) {
                continue;
            }
            const uid = AirspaceSearcher.generateUID(def);
            let airspace = this.cache.get(uid);
            if (!airspace) {
                airspace = new CoherentAirspace(def, uid);
                this.cacheAirspace(airspace);
            }
            result.push(airspace);
        }
        return result;
    }
    /**
     * Adds an airspace to the cache. If the cache size exceeds the maximum after the operation, airspaces will be
     * removed from the cache in FIFO order to maintain the maximum cache size.
     * @param airspace The airspace to cache.
     */
    cacheAirspace(airspace) {
        this.cache.set(airspace.uid, airspace);
        if (this.cache.size > this.cacheSize) {
            this.cache.delete(this.cache.keys().next().value);
        }
    }
    /**
     * Generates a unique string ID for a Coherent airspace definition.
     * @param def The airspace definition.
     * @returns a unique string ID.
     */
    static generateUID(def) {
        const segments = def.segments;
        let uid = `${def.type}[${segments.length}]:`;
        // skip last vertex since it is always a repeat of the first; cap length to 10 to avoid creating super long strings
        const len = Math.min(segments.length - 1, 10);
        for (let i = 0; i < len; i++) {
            const point = segments[i];
            uid += `(${point.lat},${point.long})`;
        }
        // if vertices were skipped, grab the last (unique) vertex to decrease chance of uid collision.
        if (len < segments.length - 1) {
            const point = segments[segments.length - 2];
            uid += `(${point.lat},${point.long})`;
        }
        return uid;
    }
}
/** The amount of time to wait for a search to finish before it times out, in milliseconds. */
AirspaceSearcher.SEARCH_TIMEOUT = 5000;
AirspaceSearcher.DEFAULT_CACHE_SIZE = 1000;

/**
 * A viewlistener that gets autopilot mode information.
 */
var MSFSAPStates;
(function (MSFSAPStates) {
    MSFSAPStates[MSFSAPStates["LogicOn"] = 1] = "LogicOn";
    MSFSAPStates[MSFSAPStates["APOn"] = 2] = "APOn";
    MSFSAPStates[MSFSAPStates["FDOn"] = 4] = "FDOn";
    MSFSAPStates[MSFSAPStates["FLC"] = 8] = "FLC";
    MSFSAPStates[MSFSAPStates["Alt"] = 16] = "Alt";
    MSFSAPStates[MSFSAPStates["AltArm"] = 32] = "AltArm";
    MSFSAPStates[MSFSAPStates["GS"] = 64] = "GS";
    MSFSAPStates[MSFSAPStates["GSArm"] = 128] = "GSArm";
    MSFSAPStates[MSFSAPStates["Pitch"] = 256] = "Pitch";
    MSFSAPStates[MSFSAPStates["VS"] = 512] = "VS";
    MSFSAPStates[MSFSAPStates["Heading"] = 1024] = "Heading";
    MSFSAPStates[MSFSAPStates["Nav"] = 2048] = "Nav";
    MSFSAPStates[MSFSAPStates["NavArm"] = 4096] = "NavArm";
    MSFSAPStates[MSFSAPStates["WingLevel"] = 8192] = "WingLevel";
    MSFSAPStates[MSFSAPStates["Attitude"] = 16384] = "Attitude";
    MSFSAPStates[MSFSAPStates["ThrottleSpd"] = 32768] = "ThrottleSpd";
    MSFSAPStates[MSFSAPStates["ThrottleMach"] = 65536] = "ThrottleMach";
    MSFSAPStates[MSFSAPStates["ATArm"] = 131072] = "ATArm";
    MSFSAPStates[MSFSAPStates["YD"] = 262144] = "YD";
    MSFSAPStates[MSFSAPStates["EngineRPM"] = 524288] = "EngineRPM";
    MSFSAPStates[MSFSAPStates["TOGAPower"] = 1048576] = "TOGAPower";
    MSFSAPStates[MSFSAPStates["Autoland"] = 2097152] = "Autoland";
    MSFSAPStates[MSFSAPStates["TOGAPitch"] = 4194304] = "TOGAPitch";
    MSFSAPStates[MSFSAPStates["Bank"] = 8388608] = "Bank";
    MSFSAPStates[MSFSAPStates["FBW"] = 16777216] = "FBW";
    MSFSAPStates[MSFSAPStates["AvionicsManaged"] = 33554432] = "AvionicsManaged";
    MSFSAPStates[MSFSAPStates["None"] = -2147483648] = "None";
})(MSFSAPStates || (MSFSAPStates = {}));

/// <reference types="msfstypes/JS/Simplane" />
/**
 * The available facility frequency types.
 */
var FacilityFrequencyType;
(function (FacilityFrequencyType) {
    FacilityFrequencyType[FacilityFrequencyType["None"] = 0] = "None";
    FacilityFrequencyType[FacilityFrequencyType["ATIS"] = 1] = "ATIS";
    FacilityFrequencyType[FacilityFrequencyType["Multicom"] = 2] = "Multicom";
    FacilityFrequencyType[FacilityFrequencyType["Unicom"] = 3] = "Unicom";
    FacilityFrequencyType[FacilityFrequencyType["CTAF"] = 4] = "CTAF";
    FacilityFrequencyType[FacilityFrequencyType["Ground"] = 5] = "Ground";
    FacilityFrequencyType[FacilityFrequencyType["Tower"] = 6] = "Tower";
    FacilityFrequencyType[FacilityFrequencyType["Clearance"] = 7] = "Clearance";
    FacilityFrequencyType[FacilityFrequencyType["Approach"] = 8] = "Approach";
    FacilityFrequencyType[FacilityFrequencyType["Departure"] = 9] = "Departure";
    FacilityFrequencyType[FacilityFrequencyType["Center"] = 10] = "Center";
    FacilityFrequencyType[FacilityFrequencyType["FSS"] = 11] = "FSS";
    FacilityFrequencyType[FacilityFrequencyType["AWOS"] = 12] = "AWOS";
    FacilityFrequencyType[FacilityFrequencyType["ASOS"] = 13] = "ASOS";
    /** Clearance Pre-Taxi*/
    FacilityFrequencyType[FacilityFrequencyType["CPT"] = 14] = "CPT";
    /** Remote Clearance Delivery */
    FacilityFrequencyType[FacilityFrequencyType["GCO"] = 15] = "GCO";
})(FacilityFrequencyType || (FacilityFrequencyType = {}));
/** Additional Approach Types (additive to those defined in simplane). */
var AdditionalApproachType;
(function (AdditionalApproachType) {
    AdditionalApproachType[AdditionalApproachType["APPROACH_TYPE_VISUAL"] = 99] = "APPROACH_TYPE_VISUAL";
})(AdditionalApproachType || (AdditionalApproachType = {}));
/**
 * Flags indicating the approach fix type.
 */
var FixTypeFlags;
(function (FixTypeFlags) {
    FixTypeFlags[FixTypeFlags["None"] = 0] = "None";
    FixTypeFlags[FixTypeFlags["IAF"] = 1] = "IAF";
    FixTypeFlags[FixTypeFlags["IF"] = 2] = "IF";
    FixTypeFlags[FixTypeFlags["MAP"] = 4] = "MAP";
    FixTypeFlags[FixTypeFlags["FAF"] = 8] = "FAF";
    FixTypeFlags[FixTypeFlags["MAHP"] = 16] = "MAHP";
})(FixTypeFlags || (FixTypeFlags = {}));
/**
 * Flags indicating the rnav approach type.
 */
var RnavTypeFlags;
(function (RnavTypeFlags) {
    RnavTypeFlags[RnavTypeFlags["None"] = 0] = "None";
    RnavTypeFlags[RnavTypeFlags["LNAV"] = 1] = "LNAV";
    RnavTypeFlags[RnavTypeFlags["LNAVVNAV"] = 2] = "LNAVVNAV";
    RnavTypeFlags[RnavTypeFlags["LP"] = 4] = "LP";
    RnavTypeFlags[RnavTypeFlags["LPV"] = 8] = "LPV";
})(RnavTypeFlags || (RnavTypeFlags = {}));
var UserFacilityType;
(function (UserFacilityType) {
    UserFacilityType[UserFacilityType["RADIAL_RADIAL"] = 0] = "RADIAL_RADIAL";
    UserFacilityType[UserFacilityType["RADIAL_DISTANCE"] = 1] = "RADIAL_DISTANCE";
    UserFacilityType[UserFacilityType["LAT_LONG"] = 2] = "LAT_LONG";
})(UserFacilityType || (UserFacilityType = {}));
/**
 * ARINC 424 Leg Types
 */
var LegType;
(function (LegType) {
    /** An unknown leg type. */
    LegType[LegType["Unknown"] = 0] = "Unknown";
    /** An arc-to-fix leg. This indicates a DME arc leg to a specified fix.*/
    LegType[LegType["AF"] = 1] = "AF";
    /** A course-to-altitude leg. */
    LegType[LegType["CA"] = 2] = "CA";
    /**
     * A course-to-DME-distance leg. This leg is flown on a wind corrected course
     * to a specific DME distance from another fix.
     */
    LegType[LegType["CD"] = 3] = "CD";
    /** A course-to-fix leg.*/
    LegType[LegType["CF"] = 4] = "CF";
    /** A course-to-intercept leg. */
    LegType[LegType["CI"] = 5] = "CI";
    /** A course-to-radial intercept leg. */
    LegType[LegType["CR"] = 6] = "CR";
    /** A direct-to-fix leg, from an unspecified starting position. */
    LegType[LegType["DF"] = 7] = "DF";
    /**
     * A fix-to-altitude leg. A FA leg is flown on a track from a fix to a
     * specified altitude.
     */
    LegType[LegType["FA"] = 8] = "FA";
    /**
     * A fix-to-distance leg. This leg is flown on a track from a fix to a
     * specific distance from the fix.
     */
    LegType[LegType["FC"] = 9] = "FC";
    /**
     * A fix to DME distance leg. This leg is flown on a track from a fix to
     * a specific DME distance from another fix.
     */
    LegType[LegType["FD"] = 10] = "FD";
    /** A course-to-manual-termination leg. */
    LegType[LegType["FM"] = 11] = "FM";
    /** A hold-to-altitude leg. The hold is flown until a specified altitude is reached. */
    LegType[LegType["HA"] = 12] = "HA";
    /**
     * A hold-to-fix leg. This indicates one time around the hold circuit and
     * then an exit.
     */
    LegType[LegType["HF"] = 13] = "HF";
    /** A hold-to-manual-termination leg. */
    LegType[LegType["HM"] = 14] = "HM";
    /** Initial procedure fix. */
    LegType[LegType["IF"] = 15] = "IF";
    /** A procedure turn leg. */
    LegType[LegType["PI"] = 16] = "PI";
    /** A radius-to-fix leg, with endpoint fixes, a center fix, and a radius. */
    LegType[LegType["RF"] = 17] = "RF";
    /** A track-to-fix leg, from the previous fix to the terminator. */
    LegType[LegType["TF"] = 18] = "TF";
    /** A heading-to-altitude leg. */
    LegType[LegType["VA"] = 19] = "VA";
    /** A heading-to-DME-distance leg. */
    LegType[LegType["VD"] = 20] = "VD";
    /** A heading-to-intercept leg. */
    LegType[LegType["VI"] = 21] = "VI";
    /** A heading-to-manual-termination leg. */
    LegType[LegType["VM"] = 22] = "VM";
    /** A heading-to-radial intercept leg. */
    LegType[LegType["VR"] = 23] = "VR";
    /** A leg representing a discontinuity in the flight plan. */
    LegType[LegType["Discontinuity"] = 99] = "Discontinuity";
})(LegType || (LegType = {}));
/**
 * Types of altitude restrictions on procedure legs.
 */
var AltitudeRestrictionType;
(function (AltitudeRestrictionType) {
    AltitudeRestrictionType[AltitudeRestrictionType["Unused"] = 0] = "Unused";
    AltitudeRestrictionType[AltitudeRestrictionType["At"] = 1] = "At";
    AltitudeRestrictionType[AltitudeRestrictionType["AtOrAbove"] = 2] = "AtOrAbove";
    AltitudeRestrictionType[AltitudeRestrictionType["AtOrBelow"] = 3] = "AtOrBelow";
    AltitudeRestrictionType[AltitudeRestrictionType["Between"] = 4] = "Between";
})(AltitudeRestrictionType || (AltitudeRestrictionType = {}));
var LegTurnDirection;
(function (LegTurnDirection) {
    LegTurnDirection[LegTurnDirection["None"] = 0] = "None";
    LegTurnDirection[LegTurnDirection["Left"] = 1] = "Left";
    LegTurnDirection[LegTurnDirection["Right"] = 2] = "Right";
    LegTurnDirection[LegTurnDirection["Either"] = 3] = "Either";
})(LegTurnDirection || (LegTurnDirection = {}));
var AirwayType;
(function (AirwayType) {
    AirwayType[AirwayType["None"] = 0] = "None";
    AirwayType[AirwayType["Victor"] = 1] = "Victor";
    AirwayType[AirwayType["Jet"] = 2] = "Jet";
    AirwayType[AirwayType["Both"] = 3] = "Both";
})(AirwayType || (AirwayType = {}));
var NdbType;
(function (NdbType) {
    NdbType[NdbType["CompassPoint"] = 0] = "CompassPoint";
    NdbType[NdbType["MH"] = 1] = "MH";
    NdbType[NdbType["H"] = 2] = "H";
    NdbType[NdbType["HH"] = 3] = "HH";
})(NdbType || (NdbType = {}));
var VorType;
(function (VorType) {
    VorType[VorType["Unknown"] = 0] = "Unknown";
    VorType[VorType["VOR"] = 1] = "VOR";
    VorType[VorType["VORDME"] = 2] = "VORDME";
    VorType[VorType["DME"] = 3] = "DME";
    VorType[VorType["TACAN"] = 4] = "TACAN";
    VorType[VorType["VORTAC"] = 5] = "VORTAC";
    VorType[VorType["ILS"] = 6] = "ILS";
    VorType[VorType["VOT"] = 7] = "VOT";
})(VorType || (VorType = {}));
var RunwaySurfaceType;
(function (RunwaySurfaceType) {
    RunwaySurfaceType[RunwaySurfaceType["Concrete"] = 0] = "Concrete";
    RunwaySurfaceType[RunwaySurfaceType["Grass"] = 1] = "Grass";
    RunwaySurfaceType[RunwaySurfaceType["WaterFSX"] = 2] = "WaterFSX";
    RunwaySurfaceType[RunwaySurfaceType["GrassBumpy"] = 3] = "GrassBumpy";
    RunwaySurfaceType[RunwaySurfaceType["Asphalt"] = 4] = "Asphalt";
    RunwaySurfaceType[RunwaySurfaceType["ShortGrass"] = 5] = "ShortGrass";
    RunwaySurfaceType[RunwaySurfaceType["LongGrass"] = 6] = "LongGrass";
    RunwaySurfaceType[RunwaySurfaceType["HardTurf"] = 7] = "HardTurf";
    RunwaySurfaceType[RunwaySurfaceType["Snow"] = 8] = "Snow";
    RunwaySurfaceType[RunwaySurfaceType["Ice"] = 9] = "Ice";
    RunwaySurfaceType[RunwaySurfaceType["Urban"] = 10] = "Urban";
    RunwaySurfaceType[RunwaySurfaceType["Forest"] = 11] = "Forest";
    RunwaySurfaceType[RunwaySurfaceType["Dirt"] = 12] = "Dirt";
    RunwaySurfaceType[RunwaySurfaceType["Coral"] = 13] = "Coral";
    RunwaySurfaceType[RunwaySurfaceType["Gravel"] = 14] = "Gravel";
    RunwaySurfaceType[RunwaySurfaceType["OilTreated"] = 15] = "OilTreated";
    RunwaySurfaceType[RunwaySurfaceType["SteelMats"] = 16] = "SteelMats";
    RunwaySurfaceType[RunwaySurfaceType["Bituminous"] = 17] = "Bituminous";
    RunwaySurfaceType[RunwaySurfaceType["Brick"] = 18] = "Brick";
    RunwaySurfaceType[RunwaySurfaceType["Macadam"] = 19] = "Macadam";
    RunwaySurfaceType[RunwaySurfaceType["Planks"] = 20] = "Planks";
    RunwaySurfaceType[RunwaySurfaceType["Sand"] = 21] = "Sand";
    RunwaySurfaceType[RunwaySurfaceType["Shale"] = 22] = "Shale";
    RunwaySurfaceType[RunwaySurfaceType["Tarmac"] = 23] = "Tarmac";
    RunwaySurfaceType[RunwaySurfaceType["WrightFlyerTrack"] = 24] = "WrightFlyerTrack";
    //SURFACE_TYPE_LAST_FSX
    RunwaySurfaceType[RunwaySurfaceType["Ocean"] = 26] = "Ocean";
    RunwaySurfaceType[RunwaySurfaceType["Water"] = 27] = "Water";
    RunwaySurfaceType[RunwaySurfaceType["Pond"] = 28] = "Pond";
    RunwaySurfaceType[RunwaySurfaceType["Lake"] = 29] = "Lake";
    RunwaySurfaceType[RunwaySurfaceType["River"] = 30] = "River";
    RunwaySurfaceType[RunwaySurfaceType["WasteWater"] = 31] = "WasteWater";
    RunwaySurfaceType[RunwaySurfaceType["Paint"] = 32] = "Paint";
    // UNUSED
    // SURFACE_TYPE_ERASE_GRASS
})(RunwaySurfaceType || (RunwaySurfaceType = {}));
var RunwayLightingType;
(function (RunwayLightingType) {
    RunwayLightingType[RunwayLightingType["Unknown"] = 0] = "Unknown";
    RunwayLightingType[RunwayLightingType["None"] = 1] = "None";
    RunwayLightingType[RunwayLightingType["PartTime"] = 2] = "PartTime";
    RunwayLightingType[RunwayLightingType["FullTime"] = 3] = "FullTime";
    RunwayLightingType[RunwayLightingType["Frequency"] = 4] = "Frequency";
})(RunwayLightingType || (RunwayLightingType = {}));
var AirportPrivateType;
(function (AirportPrivateType) {
    AirportPrivateType[AirportPrivateType["Uknown"] = 0] = "Uknown";
    AirportPrivateType[AirportPrivateType["Public"] = 1] = "Public";
    AirportPrivateType[AirportPrivateType["Military"] = 2] = "Military";
    AirportPrivateType[AirportPrivateType["Private"] = 3] = "Private";
})(AirportPrivateType || (AirportPrivateType = {}));
var GpsBoolean;
(function (GpsBoolean) {
    GpsBoolean[GpsBoolean["Unknown"] = 0] = "Unknown";
    GpsBoolean[GpsBoolean["No"] = 1] = "No";
    GpsBoolean[GpsBoolean["Yes"] = 2] = "Yes";
})(GpsBoolean || (GpsBoolean = {}));
var VorClass;
(function (VorClass) {
    VorClass[VorClass["Unknown"] = 0] = "Unknown";
    VorClass[VorClass["Terminal"] = 1] = "Terminal";
    VorClass[VorClass["LowAlt"] = 2] = "LowAlt";
    VorClass[VorClass["HighAlt"] = 3] = "HighAlt";
    VorClass[VorClass["ILS"] = 4] = "ILS";
    VorClass[VorClass["VOT"] = 5] = "VOT";
})(VorClass || (VorClass = {}));
var FacilityType;
(function (FacilityType) {
    FacilityType["Airport"] = "LOAD_AIRPORT";
    FacilityType["Intersection"] = "LOAD_INTERSECTION";
    FacilityType["VOR"] = "LOAD_VOR";
    FacilityType["NDB"] = "LOAD_NDB";
    FacilityType["USR"] = "USR";
    FacilityType["RWY"] = "RWY";
    FacilityType["VIS"] = "VIS";
})(FacilityType || (FacilityType = {}));
var FacilitySearchType;
(function (FacilitySearchType) {
    FacilitySearchType[FacilitySearchType["None"] = 0] = "None";
    FacilitySearchType[FacilitySearchType["Airport"] = 1] = "Airport";
    FacilitySearchType[FacilitySearchType["Intersection"] = 2] = "Intersection";
    FacilitySearchType[FacilitySearchType["Vor"] = 3] = "Vor";
    FacilitySearchType[FacilitySearchType["Ndb"] = 4] = "Ndb";
    FacilitySearchType[FacilitySearchType["Boundary"] = 5] = "Boundary";
    FacilitySearchType[FacilitySearchType["User"] = 6] = "User";
})(FacilitySearchType || (FacilitySearchType = {}));
/**
 * A type of airspace boundary.
 */
var BoundaryType;
(function (BoundaryType) {
    BoundaryType[BoundaryType["None"] = 0] = "None";
    BoundaryType[BoundaryType["Center"] = 1] = "Center";
    BoundaryType[BoundaryType["ClassA"] = 2] = "ClassA";
    BoundaryType[BoundaryType["ClassB"] = 3] = "ClassB";
    BoundaryType[BoundaryType["ClassC"] = 4] = "ClassC";
    BoundaryType[BoundaryType["ClassD"] = 5] = "ClassD";
    BoundaryType[BoundaryType["ClassE"] = 6] = "ClassE";
    BoundaryType[BoundaryType["ClassF"] = 7] = "ClassF";
    BoundaryType[BoundaryType["ClassG"] = 8] = "ClassG";
    BoundaryType[BoundaryType["Tower"] = 9] = "Tower";
    BoundaryType[BoundaryType["Clearance"] = 10] = "Clearance";
    BoundaryType[BoundaryType["Ground"] = 11] = "Ground";
    BoundaryType[BoundaryType["Departure"] = 12] = "Departure";
    BoundaryType[BoundaryType["Approach"] = 13] = "Approach";
    BoundaryType[BoundaryType["MOA"] = 14] = "MOA";
    BoundaryType[BoundaryType["Restricted"] = 15] = "Restricted";
    BoundaryType[BoundaryType["Prohibited"] = 16] = "Prohibited";
    BoundaryType[BoundaryType["Warning"] = 17] = "Warning";
    BoundaryType[BoundaryType["Alert"] = 18] = "Alert";
    BoundaryType[BoundaryType["Danger"] = 19] = "Danger";
    BoundaryType[BoundaryType["NationalPark"] = 20] = "NationalPark";
    BoundaryType[BoundaryType["ModeC"] = 21] = "ModeC";
    BoundaryType[BoundaryType["Radar"] = 22] = "Radar";
    BoundaryType[BoundaryType["Training"] = 23] = "Training";
})(BoundaryType || (BoundaryType = {}));
/**
 * A type of airspace boundary altitude maxima.
 */
var BoundaryAltitudeType;
(function (BoundaryAltitudeType) {
    BoundaryAltitudeType[BoundaryAltitudeType["Unknown"] = 0] = "Unknown";
    BoundaryAltitudeType[BoundaryAltitudeType["MSL"] = 1] = "MSL";
    BoundaryAltitudeType[BoundaryAltitudeType["AGL"] = 2] = "AGL";
    BoundaryAltitudeType[BoundaryAltitudeType["Unlimited"] = 3] = "Unlimited";
})(BoundaryAltitudeType || (BoundaryAltitudeType = {}));
/**
 * A type of boundary geometry vector.
 */
var BoundaryVectorType;
(function (BoundaryVectorType) {
    BoundaryVectorType[BoundaryVectorType["None"] = 0] = "None";
    BoundaryVectorType[BoundaryVectorType["Start"] = 1] = "Start";
    BoundaryVectorType[BoundaryVectorType["Line"] = 2] = "Line";
    BoundaryVectorType[BoundaryVectorType["Origin"] = 3] = "Origin";
    BoundaryVectorType[BoundaryVectorType["ArcCW"] = 4] = "ArcCW";
    BoundaryVectorType[BoundaryVectorType["ArcCCW"] = 5] = "ArcCCW";
    BoundaryVectorType[BoundaryVectorType["Circle"] = 6] = "Circle";
})(BoundaryVectorType || (BoundaryVectorType = {}));
/**
 * Wind speed units used by METAR.
 */
var MetarWindSpeedUnits;
(function (MetarWindSpeedUnits) {
    MetarWindSpeedUnits[MetarWindSpeedUnits["Knot"] = 0] = "Knot";
    MetarWindSpeedUnits[MetarWindSpeedUnits["MeterPerSecond"] = 1] = "MeterPerSecond";
    MetarWindSpeedUnits[MetarWindSpeedUnits["KilometerPerHour"] = 2] = "KilometerPerHour";
})(MetarWindSpeedUnits || (MetarWindSpeedUnits = {}));
/** Visibility distance units used by METAR. */
var MetarVisibilityUnits;
(function (MetarVisibilityUnits) {
    MetarVisibilityUnits[MetarVisibilityUnits["Meter"] = 0] = "Meter";
    MetarVisibilityUnits[MetarVisibilityUnits["StatuteMile"] = 1] = "StatuteMile";
})(MetarVisibilityUnits || (MetarVisibilityUnits = {}));
/**
 * METAR cloud layer coverage/sky condition.
 */
var MetarCloudLayerCoverage;
(function (MetarCloudLayerCoverage) {
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["SkyClear"] = 0] = "SkyClear";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Clear"] = 1] = "Clear";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["NoSignificant"] = 2] = "NoSignificant";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Few"] = 3] = "Few";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Scattered"] = 4] = "Scattered";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Broken"] = 5] = "Broken";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Overcast"] = 6] = "Overcast";
})(MetarCloudLayerCoverage || (MetarCloudLayerCoverage = {}));
/**
 * METAR significant cloud types.
 */
var MetarCloudLayerType;
(function (MetarCloudLayerType) {
    MetarCloudLayerType[MetarCloudLayerType["Unspecified"] = -1] = "Unspecified";
    MetarCloudLayerType[MetarCloudLayerType["ToweringCumulus"] = 0] = "ToweringCumulus";
    MetarCloudLayerType[MetarCloudLayerType["Cumulonimbus"] = 1] = "Cumulonimbus";
    MetarCloudLayerType[MetarCloudLayerType["AltocumulusCastellanus"] = 2] = "AltocumulusCastellanus";
})(MetarCloudLayerType || (MetarCloudLayerType = {}));
/** METAR phenomenon types. */
var MetarPhenomenonType;
(function (MetarPhenomenonType) {
    MetarPhenomenonType[MetarPhenomenonType["None"] = 0] = "None";
    MetarPhenomenonType[MetarPhenomenonType["Mist"] = 1] = "Mist";
    MetarPhenomenonType[MetarPhenomenonType["Duststorm"] = 2] = "Duststorm";
    MetarPhenomenonType[MetarPhenomenonType["Dust"] = 3] = "Dust";
    MetarPhenomenonType[MetarPhenomenonType["Drizzle"] = 4] = "Drizzle";
    MetarPhenomenonType[MetarPhenomenonType["FunnelCloud"] = 5] = "FunnelCloud";
    MetarPhenomenonType[MetarPhenomenonType["Fog"] = 6] = "Fog";
    MetarPhenomenonType[MetarPhenomenonType["Smoke"] = 7] = "Smoke";
    MetarPhenomenonType[MetarPhenomenonType["Hail"] = 8] = "Hail";
    MetarPhenomenonType[MetarPhenomenonType["SmallHail"] = 9] = "SmallHail";
    MetarPhenomenonType[MetarPhenomenonType["Haze"] = 10] = "Haze";
    MetarPhenomenonType[MetarPhenomenonType["IceCrystals"] = 11] = "IceCrystals";
    MetarPhenomenonType[MetarPhenomenonType["IcePellets"] = 12] = "IcePellets";
    MetarPhenomenonType[MetarPhenomenonType["DustSandWhorls"] = 13] = "DustSandWhorls";
    MetarPhenomenonType[MetarPhenomenonType["Spray"] = 14] = "Spray";
    MetarPhenomenonType[MetarPhenomenonType["Rain"] = 15] = "Rain";
    MetarPhenomenonType[MetarPhenomenonType["Sand"] = 16] = "Sand";
    MetarPhenomenonType[MetarPhenomenonType["SnowGrains"] = 17] = "SnowGrains";
    MetarPhenomenonType[MetarPhenomenonType["Shower"] = 18] = "Shower";
    MetarPhenomenonType[MetarPhenomenonType["Snow"] = 19] = "Snow";
    MetarPhenomenonType[MetarPhenomenonType["Squalls"] = 20] = "Squalls";
    MetarPhenomenonType[MetarPhenomenonType["Sandstorm"] = 21] = "Sandstorm";
    MetarPhenomenonType[MetarPhenomenonType["UnknownPrecip"] = 22] = "UnknownPrecip";
    MetarPhenomenonType[MetarPhenomenonType["VolcanicAsh"] = 23] = "VolcanicAsh";
})(MetarPhenomenonType || (MetarPhenomenonType = {}));
/** METAR phenomenon intensities. */
var MetarPhenomenonIntensity;
(function (MetarPhenomenonIntensity) {
    MetarPhenomenonIntensity[MetarPhenomenonIntensity["Light"] = -1] = "Light";
    MetarPhenomenonIntensity[MetarPhenomenonIntensity["Normal"] = 0] = "Normal";
    MetarPhenomenonIntensity[MetarPhenomenonIntensity["Heavy"] = 1] = "Heavy";
})(MetarPhenomenonIntensity || (MetarPhenomenonIntensity = {}));
/**
 * Methods for working with FS ICAO strings.
 */
class ICAO {
    /**
     * Gets the facility type from an ICAO.
     * @param icao The icao to get the facility type for.
     * @returns The ICAO facility type.
     * @throws An error if the facility type cannot be determined.
     */
    static getFacilityType(icao) {
        switch (icao[0]) {
            case 'A':
                return FacilityType.Airport;
            case 'W':
                return FacilityType.Intersection;
            case 'V':
                return FacilityType.VOR;
            case 'N':
                return FacilityType.NDB;
            case 'U':
                return FacilityType.USR;
            case 'R':
                return FacilityType.RWY;
            case 'S':
                return FacilityType.VIS;
            default:
                throw new Error(`ICAO ${icao} has unknown type: ${icao[0]}`);
        }
    }
    /**
     * Gets whether an icao is a facility type.
     * @param icao The icao to get the facility type for.
     * @returns a bool whether or not this icao is a facility type.
     */
    static isFacility(icao) {
        switch (icao[0]) {
            case 'A':
            case 'W':
            case 'V':
            case 'N':
            case 'U':
            case 'R':
            case 'S':
                return true;
        }
        return false;
    }
    /**
     * Gets the ident for a given ICAO string.
     * @param icao The FS ICAO to get the ident for.
     * @returns The ICAO ident.
     */
    static getIdent(icao) {
        return icao.substr(7).trim();
    }
}
/**
 * An empty ICAO.
 */
ICAO.emptyIcao = '            ';
/**
 * Utility functions for working with user facilities.
 */
class UserFacilityUtils {
    /**
     * Creates a user facility from latitude/longitude coordinates.
     * @param icao The ICAO string of the new facility.
     * @param lat The latitude of the new facility.
     * @param lon The longitude of the new facility.
     * @param isTemporary Whether the new facility is temporary.
     * @param name The name of the new facility.
     * @returns A new user facility.
     */
    static createFromLatLon(icao, lat, lon, isTemporary = false, name) {
        const fac = {
            icao,
            name: name !== null && name !== void 0 ? name : '',
            lat,
            lon,
            userFacilityType: UserFacilityType.LAT_LONG,
            isTemporary,
            region: '',
            city: '',
            magvar: MagVar.get(lat, lon)
        };
        return fac;
    }
}

/**
 * Methods for working with Runways and Runway Designations.
 */
class RunwayUtils {
    /**
     * Creates an empty one-way runway.
     * @returns an empty one-way runway.
     */
    static createEmptyOneWayRunway() {
        return {
            parentRunwayIndex: -1,
            designation: '',
            direction: 36,
            runwayDesignator: RunwayDesignator.RUNWAY_DESIGNATOR_NONE,
            course: 0,
            elevation: 0,
            latitude: 0,
            longitude: 0
        };
    }
    /**
     * Utility method to return two one-way runways from a single runway facility
     * @param runway is the AirportRunway object to evaluate
     * @param index is the index of the AirportRunway in the Facility
     * @returns splitRunways array of OneWayRunway objects
     */
    static getOneWayRunways(runway, index) {
        const splitRunways = [];
        const designations = runway.designation.split('-');
        for (let i = 0; i < designations.length; i++) {
            const runwayNumber = parseInt(designations[i]);
            let designator = RunwayDesignator.RUNWAY_DESIGNATOR_NONE;
            let course = 0;
            let thresholdDistanceFromCenter = 0;
            let thresholdElevation = 0;
            let ilsFrequency;
            if (i === 0) {
                designator = runway.designatorCharPrimary;
                course = runway.direction;
                thresholdDistanceFromCenter = (runway.length / 2) - runway.primaryThresholdLength;
                thresholdElevation = runway.primaryElevation;
                ilsFrequency = runway.primaryILSFrequency.freqMHz === 0 ? undefined : runway.primaryILSFrequency;
            }
            else if (i === 1) {
                designator = runway.designatorCharSecondary;
                course = NavMath.normalizeHeading(runway.direction + 180);
                thresholdDistanceFromCenter = (runway.length / 2) - runway.secondaryThresholdLength;
                thresholdElevation = runway.secondaryElevation;
                ilsFrequency = runway.secondaryILSFrequency.freqMHz === 0 ? undefined : runway.secondaryILSFrequency;
            }
            const designation = RunwayUtils.getRunwayNameString(runwayNumber, designator);
            const coordinates = RunwayUtils.tempGeoPoint
                .set(runway.latitude, runway.longitude)
                .offset(course - 180, UnitType.METER.convertTo(thresholdDistanceFromCenter, UnitType.GA_RADIAN));
            splitRunways.push({
                parentRunwayIndex: index,
                designation,
                direction: runwayNumber,
                runwayDesignator: designator,
                course,
                elevation: thresholdElevation,
                latitude: coordinates.lat,
                longitude: coordinates.lon,
                ilsFrequency
            });
        }
        return splitRunways;
    }
    /**
     * Utility method to return the runway name from the number and designator (L/R/C/W)
     * @param runwayNumber is the integer part of a runway name (18, 26, 27, etc)
     * @param designator is the RunwayDesignator enum for the runway
     * @param padded Whether single-char runways should be 0-padded.
     * @param prefix A prefix to put before the runway name.
     * @returns the runway name string
     */
    static getRunwayNameString(runwayNumber, designator, padded = true, prefix = '') {
        let numberText = `${runwayNumber}`;
        if (padded) {
            numberText = numberText.padStart(2, '0');
        }
        let string = prefix + numberText;
        switch (designator) {
            case RunwayDesignator.RUNWAY_DESIGNATOR_NONE:
                return string;
            case RunwayDesignator.RUNWAY_DESIGNATOR_LEFT:
                return string += 'L';
            case RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT:
                return string += 'R';
            case RunwayDesignator.RUNWAY_DESIGNATOR_CENTER:
                return string += 'C';
            case RunwayDesignator.RUNWAY_DESIGNATOR_WATER:
                return string += 'W';
            case RunwayDesignator.RUNWAY_DESIGNATOR_A:
                return string += 'A';
            case RunwayDesignator.RUNWAY_DESIGNATOR_B:
                return string += 'B';
        }
    }
    /**
     * Gets a one-way runway from an airport that matches a runway designation by number and designator.
     * @param airport The airport facility in which to search for the match.
     * @param runwayNumber A runway number to match.
     * @param runwayDesignator A runway designator to match.
     * @returns The one-way runway which matches the designation, or undefined if no match could be found.
     */
    static matchOneWayRunway(airport, runwayNumber, runwayDesignator) {
        const length = airport.runways.length;
        for (let r = 0; r < length; r++) {
            const runway = airport.runways[r];
            const designation = runway.designation;
            const primaryRunwayNumber = parseInt(designation.split('-')[0]);
            const secondaryRunwayNumber = parseInt(designation.split('-')[1]);
            if (primaryRunwayNumber === runwayNumber && runway.designatorCharPrimary === runwayDesignator) {
                const oneWayRunways = RunwayUtils.getOneWayRunways(runway, r);
                return oneWayRunways[0];
            }
            else if (secondaryRunwayNumber === runwayNumber && runway.designatorCharSecondary === runwayDesignator) {
                const oneWayRunways = RunwayUtils.getOneWayRunways(runway, r);
                return oneWayRunways[1];
            }
        }
        return undefined;
    }
    /**
     * Gets a one-way runway from an airport that matches a runway designation string.
     * @param airport The airport facility in which to search for the match.
     * @param designation A runway designation.
     * @returns The one-way runway which matches the designation, or undefined if no match could be found.
     */
    static matchOneWayRunwayFromDesignation(airport, designation) {
        const length = airport.runways.length;
        for (let i = 0; i < length; i++) {
            const match = RunwayUtils.getOneWayRunways(airport.runways[i], i).find((r) => {
                return (r.designation === designation);
            });
            if (match) {
                return match;
            }
        }
        return undefined;
    }
    /**
     * Gets a one-way runway from an airport that matches a runway ident.
     * @param airport The airport facility in which to search for the match.
     * @param ident A runway ident.
     * @returns The one-way runway which matches the ident, or undefined if no match could be found.
     */
    static matchOneWayRunwayFromIdent(airport, ident) {
        return RunwayUtils.matchOneWayRunwayFromDesignation(airport, ident.substr(2).trim());
    }
    /**
     * Utility method to return the procedures for a given runway.
     * @param procedures The procedures for the airport.
     * @param runway The given runway to find procedures for.
     * @returns A list of approach procedures for the given runway.
     */
    static getProceduresForRunway(procedures, runway) {
        const oneways = new Array();
        // TODO Make the designation splitting logic a common routine too.
        const designations = runway.designation.split('-');
        for (let i = 0; i < designations.length; i++) {
            const runwayNumber = parseInt(designations[i]);
            let runwayName;
            if (i === 0) {
                runwayName = RunwayUtils.getRunwayNameString(runwayNumber, runway.designatorCharPrimary, false, '');
            }
            else {
                runwayName = RunwayUtils.getRunwayNameString(runwayNumber, runway.designatorCharSecondary, false, '');
            }
            oneways.push(runwayName);
        }
        const found = new Array();
        for (const procedure of procedures) {
            if (oneways.includes(procedure.runway.trim())) {
                found.push(procedure);
            }
            else if (procedure.runwayNumber === 0) {
                found.push(procedure);
            }
        }
        return found;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static getLocFrequency(airport, arg) {
        let runway, runwayDesignation;
        if (typeof arg === 'string') {
            const matchedRunway = RunwayUtils.matchOneWayRunwayFromDesignation(airport, arg);
            if (!matchedRunway) {
                return undefined;
            }
            runway = matchedRunway;
            runwayDesignation = arg;
        }
        else {
            runway = arg;
            runwayDesignation = arg.designation;
        }
        if (runway.ilsFrequency) {
            return runway.ilsFrequency;
        }
        for (let i = 0; i < airport.frequencies.length; i++) {
            const match = airport.frequencies[i].name.search(runwayDesignation);
            if (match > -1) {
                return airport.frequencies[i];
            }
        }
        return undefined;
    }
    /**
     * A comparer for sorting runways by number, and then by L, C, and R.
     * @param r1 The first runway to compare.
     * @param r2 The second runway to compare.
     * @returns -1 if the first is before, 0 if equal, 1 if the first is after.
     */
    static sortRunways(r1, r2) {
        if (r1.direction === r2.direction) {
            let v1 = 0;
            if (r1.designation.indexOf('L') != -1) {
                v1 = 1;
            }
            else if (r1.designation.indexOf('C') != -1) {
                v1 = 2;
            }
            else if (r1.designation.indexOf('R') != -1) {
                v1 = 3;
            }
            let v2 = 0;
            if (r2.designation.indexOf('L') != -1) {
                v2 = 1;
            }
            else if (r2.designation.indexOf('C') != -1) {
                v2 = 2;
            }
            else if (r2.designation.indexOf('R') != -1) {
                v2 = 3;
            }
            return v1 - v2;
        }
        return r1.direction - r2.direction;
    }
    /**
     * Gets the ICAO string for the runway facility associated with a one-way runway.
     * @param airport The runway's parent airport.
     * @param runway A one-way runway.
     * @returns the ICAO string for the runway facility associated with the one-way runway.
     */
    static getRunwayFacilityIcao(airport, runway) {
        return `R  ${airport.icao.substr(7, 4)}RW${runway.designation.padEnd(3, ' ')}`;
    }
    /**
     * Creates a runway waypoint facility from a runway.
     * @param airport The runway's parent airport.
     * @param runway A one-way runway.
     * @returns A runway waypoint facility corresponding to the runway.
     */
    static createRunwayFacility(airport, runway) {
        return {
            icao: RunwayUtils.getRunwayFacilityIcao(airport, runway),
            name: `Runway ${runway.designation}`,
            region: airport.region,
            city: airport.city,
            lat: runway.latitude,
            lon: runway.longitude,
            magvar: airport.magvar,
            runway
        };
    }
    /**
     * Gets an alpha code from a runway number.
     * @param number is the runway number.
     * @returns a letter.
     */
    static getRunwayCode(number) {
        const n = Math.round(number);
        return String.fromCharCode(48 + n + (n > 9 ? 7 : 0));
    }
}
RunwayUtils.tempGeoPoint = new GeoPoint(0, 0);

/// <reference types="msfstypes/JS/common" />
/**
 * A class that handles loading facility data from the simulator.
 */
class FacilityLoader {
    /**
     * Creates an instance of the FacilityLoader.
     * @param facilityRepo A local facility repository.
     * @param onInitialized A callback to call when the facility loader has completed initialization.
     */
    constructor(facilityRepo, onInitialized = () => { }) {
        this.facilityRepo = facilityRepo;
        this.onInitialized = onInitialized;
        if (FacilityLoader.facilityListener === undefined) {
            FacilityLoader.facilityListener = RegisterViewListener('JS_LISTENER_FACILITY', () => {
                FacilityLoader.facilityListener.on('SendAirport', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('SendIntersection', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('SendVor', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('SendNdb', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('NearestSearchCompleted', FacilityLoader.onNearestSearchCompleted);
                setTimeout(() => this.onInitialized(), 2000);
            }, true);
        }
        else {
            setTimeout(() => this.onInitialized(), 2000);
        }
    }
    /**
     * Retrieves a facility.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    getFacility(type, icao) {
        switch (type) {
            case FacilityType.USR:
            case FacilityType.RWY:
            case FacilityType.VIS:
                return this.getFacilityFromRepo(type, icao);
            default:
                return this.getFacilityFromCoherent(type, icao);
        }
    }
    // eslint-disable-next-line jsdoc/require-throws
    /**
     * Retrieves a facility from the local facility repository.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    async getFacilityFromRepo(type, icao) {
        const fac = this.facilityRepo.get(icao);
        if (fac) {
            return fac;
        }
        else if (type === FacilityType.RWY) {
            try {
                const airport = await this.getFacility(FacilityType.Airport, `A      ${icao.substr(3, 4)} `);
                const runway = RunwayUtils.matchOneWayRunwayFromIdent(airport, ICAO.getIdent(icao));
                if (runway) {
                    const runwayFac = RunwayUtils.createRunwayFacility(airport, runway);
                    this.facilityRepo.add(runwayFac);
                    return runwayFac;
                }
            }
            catch (e) {
                // noop
            }
        }
        throw `Facility ${icao} could not be found.`;
    }
    /**
     * Retrieves a facility from Coherent.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    getFacilityFromCoherent(type, icao) {
        const isMismatch = ICAO.getFacilityType(icao) !== type;
        const currentTime = Date.now();
        let queue = FacilityLoader.requestQueue;
        let cache = FacilityLoader.facCache;
        if (isMismatch) {
            queue = FacilityLoader.mismatchRequestQueue;
            cache = FacilityLoader.typeMismatchFacCache;
        }
        let request = queue.get(icao);
        if (request === undefined || currentTime - request.timeStamp > 10000) {
            let resolve = undefined;
            let reject = undefined;
            const promise = new Promise((resolution, rejection) => {
                resolve = resolution;
                reject = rejection;
                const cachedFac = cache.get(icao);
                if (cachedFac === undefined) {
                    Coherent.call(type, icao).then((isValid) => {
                        if (!isValid) {
                            rejection(`Facility ${icao} could not be found.`);
                            FacilityLoader.requestQueue.delete(icao);
                        }
                    });
                }
                else {
                    resolve(cachedFac);
                }
            });
            if (request) {
                request.reject(`Facility request for ${icao} has timed out.`);
            }
            request = { promise, timeStamp: currentTime, resolve: resolve, reject: reject };
            FacilityLoader.requestQueue.set(icao, request);
        }
        return request.promise;
    }
    /**
     * Gets airway data from the sim.
     * @param airwayName The airway name.
     * @param airwayType The airway type.
     * @param icao The 12 character FS ICAO of at least one intersection in the airway.
     * @returns The retrieved airway.
     * @throws an error if no airway is returned
     */
    async getAirway(airwayName, airwayType, icao) {
        if (FacilityLoader.airwayCache.has(airwayName)) {
            const cachedAirway = FacilityLoader.airwayCache.get(airwayName);
            const match = cachedAirway === null || cachedAirway === void 0 ? void 0 : cachedAirway.waypoints.find((w) => {
                w.icao === icao;
            });
            if (match !== undefined && cachedAirway !== undefined) {
                return cachedAirway;
            }
        }
        const fac = await this.getFacility(FacilityType.Intersection, icao);
        const route = fac.routes.find((r) => r.name === airwayName);
        if (route !== undefined) {
            const airwayBuilder = new AirwayBuilder(fac, route, this);
            const status = await airwayBuilder.startBuild();
            if (status === AirwayStatus.COMPLETE) {
                const waypoints = airwayBuilder.waypoints;
                if (waypoints !== null) {
                    const airway = new AirwayObject(airwayName, airwayType);
                    airway.waypoints = [...waypoints];
                    FacilityLoader.addToAirwayCache(airway);
                    return airway;
                }
            }
        }
        throw new Error('Airway could not be found.');
    }
    /**
     * Starts a nearest facilities search session.
     * @param type The type of facilities to search for.
     * @returns The new nearest search session.
     */
    async startNearestSearchSession(type) {
        const sessionId = await Coherent.call('START_NEAREST_SEARCH_SESSION', type);
        let session;
        switch (type) {
            case FacilitySearchType.Airport:
                session = new NearestAirportSearchSession(sessionId);
                break;
            case FacilitySearchType.Intersection:
                session = new NearestIntersectionSearchSession(sessionId);
                break;
            case FacilitySearchType.Vor:
                session = new NearestIntersectionSearchSession(sessionId);
                break;
            default:
                session = new NearestSearchSession(sessionId);
                break;
        }
        FacilityLoader.searchSessions.set(sessionId, session);
        return session;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    async getMetar(arg) {
        const ident = typeof arg === 'string' ? arg : ICAO.getIdent(arg.icao);
        const metar = await Coherent.call('GET_METAR_BY_IDENT', ident);
        return FacilityLoader.cleanMetar(metar);
    }
    /**
     * Searches for the METAR issued for the closest airport to a given location.
     * @param lat The latitude of the center of the search, in degrees.
     * @param lon The longitude of the center of the search, in degrees.
     * @returns The METAR issued for the closest airport to the given location, or undefined if none could be found.
     */
    async searchMetar(lat, lon) {
        const metar = await Coherent.call('GET_METAR_BY_LATLON', lat, lon);
        return FacilityLoader.cleanMetar(metar);
    }
    /**
     * Cleans up a raw METAR object.
     * @param raw A raw METAR object.
     * @returns A cleaned version of the raw METAR object, or undefined if the raw METAR is empty.
     */
    static cleanMetar(raw) {
        if (raw.icao === '') {
            return undefined;
        }
        raw.gust < 0 && delete raw.gust;
        raw.vertVis < 0 && delete raw.vertVis;
        isNaN(raw.altimeterA) && delete raw.altimeterA;
        raw.altimeterQ < 0 && delete raw.altimeterQ;
        isNaN(raw.slp) && delete raw.slp;
        return raw;
    }
    /**
     * Searches for ICAOs by their ident portion only.
     * @param filter The type of facility to filter by. Selecting NONE will search all facility type ICAOs.
     * @param ident The partial or complete ident to search for.
     * @param maxItems The max number of matches to return.
     * @returns A collection of matched ICAOs.
     */
    async searchByIdent(filter, ident, maxItems = 40) {
        const results = await Coherent.call('SEARCH_BY_IDENT', ident, filter, maxItems);
        if (filter === FacilitySearchType.User || filter === FacilitySearchType.None) {
            this.facilityRepo.forEach(fac => {
                const facIdent = ICAO.getIdent(fac.icao);
                if (facIdent === ident) {
                    results.unshift(fac.icao);
                }
                else if (facIdent.startsWith(ident)) {
                    results.push(fac.icao);
                }
            }, FacilityLoader.facRepositorySearchTypes);
        }
        return results;
    }
    /**
     * A callback called when a facility is received from the simulator.
     * @param facility The received facility.
     */
    static onFacilityReceived(facility) {
        const request = FacilityLoader.requestQueue.get(facility.icao);
        if (request !== undefined) {
            request.resolve(facility);
            FacilityLoader.addToFacilityCache(facility, facility['__Type'] === 'JS_FacilityIntersection' && facility.icao[0] !== 'W');
            FacilityLoader.requestQueue.delete(facility.icao);
        }
    }
    /**
     * A callback called when a search completes.
     * @param results The results of the search.
     */
    static onNearestSearchCompleted(results) {
        const session = FacilityLoader.searchSessions.get(results.sessionId);
        if (session !== undefined) {
            session.onSearchCompleted(results);
        }
    }
    /**
     * Adds a facility to the cache.
     * @param fac The facility to add.
     * @param isTypeMismatch Whether to add the facility to the type mismatch cache.
     */
    static addToFacilityCache(fac, isTypeMismatch) {
        const cache = isTypeMismatch ? FacilityLoader.typeMismatchFacCache : FacilityLoader.facCache;
        cache.set(fac.icao, fac);
        if (cache.size > FacilityLoader.MAX_FACILITY_CACHE_ITEMS) {
            cache.delete(cache.keys().next().value);
        }
    }
    /**
     * Adds an airway to the airway cache.
     * @param airway The airway to add.
     */
    static addToAirwayCache(airway) {
        FacilityLoader.airwayCache.set(airway.name, airway);
        if (FacilityLoader.airwayCache.size > FacilityLoader.MAX_AIRWAY_CACHE_ITEMS) {
            FacilityLoader.airwayCache.delete(FacilityLoader.airwayCache.keys().next().value);
        }
    }
}
FacilityLoader.MAX_FACILITY_CACHE_ITEMS = 1000;
FacilityLoader.MAX_AIRWAY_CACHE_ITEMS = 1000;
FacilityLoader.requestQueue = new Map();
FacilityLoader.mismatchRequestQueue = new Map();
FacilityLoader.facCache = new Map();
FacilityLoader.typeMismatchFacCache = new Map();
FacilityLoader.airwayCache = new Map();
FacilityLoader.searchSessions = new Map();
FacilityLoader.facRepositorySearchTypes = [FacilityType.USR];
/**
 * A session for searching for nearest facilities.
 */
class NearestSearchSession {
    /**
     * Creates an instance of a NearestSearchSession.
     * @param sessionId The ID of the session.
     */
    constructor(sessionId) {
        this.sessionId = sessionId;
        this.searchQueue = new Map();
    }
    /**
     * Searches for nearest facilities from the specified point.
     * @param lat The latitude, in degrees.
     * @param lon The longitude, in degrees.
     * @param radius The radius around the point to search, in meters.
     * @param maxItems The maximum number of items.
     * @returns The nearest search results.
     */
    searchNearest(lat, lon, radius, maxItems) {
        const promise = new Promise((resolve) => {
            Coherent.call('SEARCH_NEAREST', this.sessionId, lat, lon, radius, maxItems)
                .then((searchId) => {
                this.searchQueue.set(searchId, { promise, resolve });
            });
        });
        return promise;
    }
    /**
     * A callback called by the facility loader when a nearest search has completed.
     * @param results The search results.
     */
    onSearchCompleted(results) {
        const request = this.searchQueue.get(results.searchId);
        if (request !== undefined) {
            request.resolve(results);
            this.searchQueue.delete(results.searchId);
        }
    }
}
/**
 * A session for searching for nearest airports.
 */
class NearestAirportSearchSession extends NearestSearchSession {
    /**
     * Sets the filter for the airport nearest search.
     * @param showClosed Whether or not to show closed airports.
     * @param classMask A bitmask to determine which JS airport classes to show.
     */
    setAirportFilter(showClosed, classMask) {
        Coherent.call('SET_NEAREST_AIRPORT_FILTER', this.sessionId, showClosed ? 1 : 0, classMask);
    }
}
/**
 * A session for searching for nearest intersections.
 */
class NearestIntersectionSearchSession extends NearestSearchSession {
    /**
     * Sets the filter for the intersection nearest search.
     * @param typeMask A bitmask to determine which JS intersection types to show.
     */
    setIntersectionFilter(typeMask) {
        Coherent.call('SET_NEAREST_INTERSECTION_FILTER', this.sessionId, typeMask);
    }
}
/**
 * An airway.
 */
class AirwayObject {
    /** Builds a Airway
     * @param name - the name of the new airway.
     * @param type - the type of the new airway.
     */
    constructor(name, type) {
        this._waypoints = [];
        this._name = name;
        this._type = type;
    }
    /**
     * Gets the name of the airway
     * @returns the airway name
     */
    get name() {
        return this._name;
    }
    /**
     * Gets the type of the airway
     * @returns the airway type
     */
    get type() {
        return this._type;
    }
    /**
     * Gets the waypoints of this airway.
     * @returns the waypoints of this airway.
     */
    get waypoints() {
        return this._waypoints;
    }
    /**
     * Sets the waypoints of this airway.
     * @param waypoints is the array of waypoints.
     */
    set waypoints(waypoints) {
        this._waypoints = waypoints;
    }
}
/**
 * WT Airway Status Enum
 */
var AirwayStatus;
(function (AirwayStatus) {
    /**
     * @readonly
     * @property {number} INCOMPLETE - indicates waypoints have not been loaded yet.
     */
    AirwayStatus[AirwayStatus["INCOMPLETE"] = 0] = "INCOMPLETE";
    /**
     * @readonly
     * @property {number} COMPLETE - indicates all waypoints have been successfully loaded.
     */
    AirwayStatus[AirwayStatus["COMPLETE"] = 1] = "COMPLETE";
    /**
     * @readonly
     * @property {number} PARTIAL - indicates some, but not all, waypoints have been successfully loaded.
     */
    AirwayStatus[AirwayStatus["PARTIAL"] = 2] = "PARTIAL";
})(AirwayStatus || (AirwayStatus = {}));
/**
 * The Airway Builder.
 */
class AirwayBuilder {
    /** Creates an instance of the AirwayBuilder
     * @param _initialWaypoint is the initial intersection facility
     * @param _initialData is the intersection route to build from
     * @param facilityLoader is an instance of the facility loader
     */
    constructor(_initialWaypoint, _initialData, facilityLoader) {
        this._initialWaypoint = _initialWaypoint;
        this._initialData = _initialData;
        this.facilityLoader = facilityLoader;
        this._waypointsArray = [];
        this._hasStarted = false;
        this._isDone = false;
    }
    // constructor(private _initialWaypoint: IntersectionFacility, private _requestEntry: (entry: string) => Promise<IntersectionFacility>) {
    // }
    /**
     * Get whether this builder has started loading waypoints
     * @returns whether this builder has started
     */
    get hasStarted() {
        return this._hasStarted;
    }
    /**
     * Get whether this builder is done loading waypoints
     * @returns whether this builder is done loading waypoints
     */
    get isDone() {
        return this._isDone;
    }
    /**
     * Get the airway waypoints
     * @returns the airway waypoints, or null
     */
    get waypoints() {
        return this._waypointsArray;
    }
    /** Steps through the airway waypoints
     * @param stepForward is the direction to step; true = forward, false = backward
     * @param arrayInsertFunc is the arrayInsertFunc
     */
    async _step(stepForward, arrayInsertFunc) {
        let isDone = false;
        let current = this._initialData;
        while (!isDone && current) {
            const nextICAO = stepForward ? current.nextIcao : current.prevIcao;
            if (nextICAO && nextICAO.length > 0 && nextICAO[0] != ' ' && this._waypointsArray !== null
                && !this._waypointsArray.find(waypoint => waypoint.icao === nextICAO)) {
                const fac = await this.facilityLoader.getFacility(FacilityType.Intersection, nextICAO);
                arrayInsertFunc(fac);
                const next = fac.routes.find((route) => route.name === current.name);
                if (next !== undefined) {
                    current = next;
                }
                else {
                    isDone = true;
                }
            }
            else {
                isDone = true;
            }
        }
    }
    /** Steps Forward through the airway waypoints
     * @returns the step forward function
     */
    async _stepForward() {
        if (this._waypointsArray !== null) {
            return this._step(true, this._waypointsArray.push.bind(this._waypointsArray));
        }
    }
    /** Steps Backward through the airway waypoints
     * @returns the step backward function
     */
    async _stepBackward() {
        if (this._waypointsArray !== null) {
            return this._step(false, this._waypointsArray.unshift.bind(this._waypointsArray));
        }
    }
    /**
     * Sets the array into which this builder will load waypoints.
     * @param array is the array into which the builder will load waypoints
     */
    setWaypointsArray(array) {
        this._waypointsArray = array;
    }
    /**
     * Begins loading waypoints for this builder's parent airway.
     * @returns a Promise to return a status code corresponding to Airway.Status when this builder has
     * finished loading waypoints.
     */
    startBuild() {
        if (this.hasStarted) {
            return Promise.reject(new Error('Airway builder has already started building.'));
        }
        return new Promise(resolve => {
            this._hasStarted = true;
            if (this._waypointsArray !== null) {
                this._waypointsArray.push(this._initialWaypoint);
                Promise.all([
                    this._stepForward(),
                    this._stepBackward()
                ]).then(() => {
                    this._isDone = true;
                    resolve(AirwayStatus.COMPLETE);
                }).catch(() => {
                    this._isDone = true;
                    resolve(AirwayStatus.PARTIAL);
                });
            }
        });
    }
}

var FacilityRepositorySyncType;
(function (FacilityRepositorySyncType) {
    FacilityRepositorySyncType[FacilityRepositorySyncType["Add"] = 0] = "Add";
    FacilityRepositorySyncType[FacilityRepositorySyncType["Remove"] = 1] = "Remove";
    FacilityRepositorySyncType[FacilityRepositorySyncType["DumpRequest"] = 2] = "DumpRequest";
    FacilityRepositorySyncType[FacilityRepositorySyncType["DumpResponse"] = 3] = "DumpResponse";
})(FacilityRepositorySyncType || (FacilityRepositorySyncType = {}));
/**
 * A repository of facilities.
 */
class FacilityRespository {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.repos = {};
        this.ignoreSync = false;
        bus.getSubscriber().on(FacilityRespository.SYNC_TOPIC).handle(this.onSyncEvent.bind(this));
        this.pubSyncEvent(FacilityRepositorySyncType.DumpRequest);
    }
    /**
     * Retrieves a facility from this repository.
     * @param icao The ICAO of the facility to retrieve.
     * @returns The requested user facility, or undefined if it was not found in this repository.
     */
    get(icao) {
        var _a;
        if (!ICAO.isFacility(icao)) {
            return undefined;
        }
        return (_a = this.repos[ICAO.getFacilityType(icao)]) === null || _a === void 0 ? void 0 : _a.get(icao);
    }
    /**
     * Adds a facility to this repository and all other repositories synced with this one.
     * @param fac The facility to add.
     */
    add(fac) {
        if (!ICAO.isFacility(fac.icao)) {
            return;
        }
        this.addToRepo(fac);
        this.pubSyncEvent(FacilityRepositorySyncType.Add, [fac]);
    }
    /**
     * Removes a facility from this repository and all other repositories synced with this one.
     * @param fac The facility to remove.
     */
    remove(fac) {
        if (!ICAO.isFacility(fac.icao)) {
            return;
        }
        this.removeFromRepo(fac);
        this.pubSyncEvent(FacilityRepositorySyncType.Remove, [fac]);
    }
    /**
     * Iterates over every facility in this respository with a visitor function.
     * @param fn A visitor function.
     * @param types The types of facilities over which to iterate. Defaults to all facility types.
     */
    forEach(fn, types) {
        var _a;
        const keys = types !== null && types !== void 0 ? types : Object.keys(this.repos);
        const len = keys.length;
        for (let i = 0; i < len; i++) {
            (_a = this.repos[keys[i]]) === null || _a === void 0 ? void 0 : _a.forEach(fn);
        }
    }
    /**
     * Adds a facility to this repository.
     * @param fac The facility to add.
     */
    addToRepo(fac) {
        var _a;
        var _b, _c;
        ((_a = (_b = this.repos)[_c = ICAO.getFacilityType(fac.icao)]) !== null && _a !== void 0 ? _a : (_b[_c] = new Map())).set(fac.icao, fac);
    }
    /**
     * Removes a facility from this repository.
     * @param fac The facility to remove.
     */
    removeFromRepo(fac) {
        var _a;
        (_a = this.repos[ICAO.getFacilityType(fac.icao)]) === null || _a === void 0 ? void 0 : _a.delete(fac.icao);
    }
    /**
     * Publishes a sync event over the event bus.
     * @param type The type of sync event.
     * @param facs The event's user facilities.
     */
    pubSyncEvent(type, facs) {
        this.ignoreSync = true;
        this.bus.pub(FacilityRespository.SYNC_TOPIC, { type, facs }, true, false);
        this.ignoreSync = false;
    }
    /**
     * A callback which is called when a sync event occurs.
     * @param data The event data.
     */
    onSyncEvent(data) {
        if (this.ignoreSync) {
            return;
        }
        switch (data.type) {
            case FacilityRepositorySyncType.Add:
            case FacilityRepositorySyncType.DumpResponse:
                data.facs.forEach(fac => this.addToRepo(fac));
                break;
            case FacilityRepositorySyncType.Remove:
                data.facs.forEach(fac => this.removeFromRepo(fac));
                break;
            case FacilityRepositorySyncType.DumpRequest:
                {
                    const facs = [];
                    this.forEach(fac => facs.push(fac));
                    this.pubSyncEvent(FacilityRepositorySyncType.DumpResponse, facs);
                }
                break;
        }
    }
    /**
     * Gets an instance of FacilityRespository.
     * @param bus The event bus.
     * @returns an instance of FacilityRespository.
     */
    static getRepository(bus) {
        var _a;
        return (_a = FacilityRespository.INSTANCE) !== null && _a !== void 0 ? _a : (FacilityRespository.INSTANCE = new FacilityRespository(bus));
    }
}
FacilityRespository.SYNC_TOPIC = 'facilityrepo_sync';

var IcaoSearchFilter;
(function (IcaoSearchFilter) {
    IcaoSearchFilter[IcaoSearchFilter["ALL"] = 0] = "ALL";
    IcaoSearchFilter[IcaoSearchFilter["AIRPORT"] = 1] = "AIRPORT";
    IcaoSearchFilter[IcaoSearchFilter["VOR"] = 2] = "VOR";
    IcaoSearchFilter[IcaoSearchFilter["NDB"] = 3] = "NDB";
    IcaoSearchFilter[IcaoSearchFilter["INTERSECTION"] = 4] = "INTERSECTION";
    IcaoSearchFilter[IcaoSearchFilter["USR"] = 5] = "USR";
})(IcaoSearchFilter || (IcaoSearchFilter = {}));

/// <reference types="msfstypes/JS/simvar" />
/**
 * A publisher for basic ADC/AHRS information.
 */
class ADCPublisher extends SimVarPublisher {
    /**
     * Create an ADCPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        super(ADCPublisher.simvars, bus, pacer);
    }
    /**
     * Updates the ADC publisher.
     */
    onUpdate() {
        super.onUpdate();
    }
}
ADCPublisher.simvars = new Map([
    ['ias', { name: 'AIRSPEED INDICATED', type: SimVarValueType.Knots }],
    ['tas', { name: 'AIRSPEED TRUE', type: SimVarValueType.Knots }],
    ['alt', { name: 'INDICATED ALTITUDE', type: SimVarValueType.Feet }],
    ['vs', { name: 'VERTICAL SPEED', type: SimVarValueType.FPM }],
    ['hdg_deg', { name: 'PLANE HEADING DEGREES MAGNETIC', type: SimVarValueType.Degree }],
    ['pitch_deg', { name: 'PLANE PITCH DEGREES', type: SimVarValueType.Degree }],
    ['roll_deg', { name: 'PLANE BANK DEGREES', type: SimVarValueType.Degree }],
    ['hdg_deg_true', { name: 'PLANE HEADING DEGREES TRUE', type: SimVarValueType.Degree }],
    ['magvar', { name: 'MAGVAR', type: SimVarValueType.Degree }],
    ['kohlsman_setting_hg_1', { name: 'KOHLSMAN SETTING HG', type: SimVarValueType.InHG }],
    ['turn_coordinator_ball', { name: 'TURN COORDINATOR BALL', type: SimVarValueType.Number }],
    ['delta_heading_rate', { name: 'DELTA HEADING RATE', type: SimVarValueType.Degree }],
    ['ambient_temp_c', { name: 'AMBIENT TEMPERATURE', type: SimVarValueType.Celsius }],
    ['ambient_wind_velocity', { name: 'AMBIENT WIND VELOCITY', type: SimVarValueType.Knots }],
    ['ambient_wind_direction', { name: 'AMBIENT WIND DIRECTION', type: SimVarValueType.Degree }],
    ['kohlsman_setting_mb_1', { name: 'KOHLSMAN SETTING MB', type: SimVarValueType.MB }],
    ['baro_units_hpa_1', { name: 'L:XMLVAR_Baro_Selector_HPA_1', type: SimVarValueType.Bool }],
    ['on_ground', { name: 'SIM ON GROUND', type: SimVarValueType.Bool }],
    ['aoa', { name: 'INCIDENCE ALPHA', type: SimVarValueType.Degree }]
]);

/**
 * InstrumentBackplane provides a common control point for aggregating and
 * managing any number of publishers.  This can be used as an "update loop"
 * corral", amongst other things.
 */
class InstrumentBackplane {
    /**
     * Create an InstrumentBackplane
     */
    constructor() {
        this.publishers = new Map();
        this.instruments = new Map();
    }
    /**
     * Initialize all the things. This is initially just a proxy for the
     * private initPublishers() and initInstruments() methods.
     *
     * This should be simplified.
     */
    init() {
        this.initPublishers();
        this.initInstruments();
    }
    /**
     * Update all the things.  This is initially just a proxy for the private
     * updatePublishers() and updateInstruments() methods.
     *
     * This should be simplified.
     */
    onUpdate() {
        this.updatePublishers();
        this.updateInstruments();
    }
    /**
     * Add a publisher to the backplane.
     * @param name - a symbolic name for the publisher for reference
     * @param publisher - a publisher extending BasePublisher
     */
    addPublisher(name, publisher) {
        this.publishers.set(name, publisher);
    }
    /**
     * Add an instrument to the backplane.
     * @param name - a symbolic name for the publisher for reference
     * @param instrument - an instrument implementing Instrment
     */
    addInstrument(name, instrument) {
        this.instruments.set(name, instrument);
    }
    /**
     * Initialize all of the publishers that you hold.
     */
    initPublishers() {
        for (const publisher of this.publishers.values()) {
            publisher.startPublish();
        }
    }
    /**
     * Initialize all of the instruments that you hold.
     */
    initInstruments() {
        for (const instrument of this.instruments.values()) {
            instrument.init();
        }
    }
    /**
     * Update all of the publishers that you hold.
     */
    updatePublishers() {
        for (const publisher of this.publishers.values()) {
            publisher.onUpdate();
        }
    }
    /**
     * Update all of the instruments that you hold.
     */
    updateInstruments() {
        for (const instrument of this.instruments.values()) {
            instrument.onUpdate();
        }
    }
}

/// <reference types="msfstypes/JS/SimPlane" />
/**
 * A publisher for basic GNSS information.
 */
class GNSSPublisher extends BasePublisher {
    /**
     * Create an GNSSPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        super(bus, pacer);
    }
    /**
     * A callback called when the publisher updates.
     */
    onUpdate() {
        this.publishPosition();
        this.publishTime();
        this.publishTrack();
        this.publishGroundSpeed();
    }
    /**
     * Publishes the gps-position event.
     */
    publishPosition() {
        const lat = SimVar.GetSimVarValue('PLANE LATITUDE', SimVarValueType.Degree);
        const lon = SimVar.GetSimVarValue('PLANE LONGITUDE', SimVarValueType.Degree);
        const alt = SimVar.GetSimVarValue('PLANE ALTITUDE', SimVarValueType.Feet);
        this.publish('gps-position', new LatLongAlt(lat, lon, alt));
    }
    /**
     * Publishes the zulu_time and time_of_day events.
     */
    publishTime() {
        const zuluTime = SimVar.GetGlobalVarValue('ZULU TIME', 'seconds');
        const timeOfDay = SimVar.GetSimVarValue('E:TIME OF DAY', 'number');
        this.publish('zulu_time', zuluTime);
        this.publish('time_of_day', timeOfDay);
    }
    /**
     * Publishes the track_deg_true and track_deg_magnetic events.
     */
    publishTrack() {
        const headingTrue = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', SimVarValueType.Degree);
        const velocityEW = SimVar.GetSimVarValue('VELOCITY WORLD X', SimVarValueType.Knots);
        const velocityNS = SimVar.GetSimVarValue('VELOCITY WORLD Z', SimVarValueType.Knots);
        let track = headingTrue;
        if (velocityEW !== 0 || velocityNS !== 0) {
            track = NavMath.normalizeHeading(UnitType.RADIAN.convertTo(Math.atan2(velocityEW, velocityNS), UnitType.DEGREE));
        }
        const magvar = SimVar.GetSimVarValue('MAGVAR', SimVarValueType.Degree);
        const magneticTrack = NavMath.normalizeHeading(track - magvar);
        this.publish('track_deg_true', track);
        this.publish('track_deg_magnetic', magneticTrack);
    }
    /**
     * Publishes the ground_speed event.
     */
    publishGroundSpeed() {
        const gs = SimVar.GetSimVarValue('GROUND VELOCITY', SimVarValueType.Knots);
        this.publish('ground_speed', gs);
    }
}

// Common definitions relevant to all radio types.
/** The basic radio types. */
var RadioType;
(function (RadioType) {
    RadioType["Com"] = "COM";
    RadioType["Nav"] = "NAV";
    RadioType["Adf"] = "ADF";
})(RadioType || (RadioType = {}));
/** The two frequency "banks", active and standby. */
var FrequencyBank;
(function (FrequencyBank) {
    FrequencyBank[FrequencyBank["Active"] = 0] = "Active";
    FrequencyBank[FrequencyBank["Standby"] = 1] = "Standby";
})(FrequencyBank || (FrequencyBank = {}));

/// <reference types="msfstypes/JS/simvar" />
/** Publish simvars for ourselves */
class NavProcSimVarPublisher extends SimVarPublisher {
    /**
     * Create a NavProcSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(NavProcSimVarPublisher.simvars, bus, pacer);
    }
}
NavProcSimVarPublisher.simvars = new Map([
    ['nav1_obs', { name: 'NAV OBS:1', type: SimVarValueType.Degree }],
    ['nav1_cdi', { name: 'NAV CDI:1', type: SimVarValueType.Number }],
    ['nav1_dme', { name: 'NAV DME:1', type: SimVarValueType.NM }],
    ['nav1_has_dme', { name: 'NAV HAS DME:1', type: SimVarValueType.Bool }],
    ['nav1_has_nav', { name: 'NAV HAS NAV:1', type: SimVarValueType.Bool }],
    ['nav1_radial', { name: 'NAV RADIAL:1', type: SimVarValueType.Radians }],
    ['nav1_signal', { name: 'NAV SIGNAL:1', type: SimVarValueType.Number }],
    ['nav1_ident', { name: 'NAV IDENT:1', type: SimVarValueType.String }],
    ['nav1_to_from', { name: 'NAV TOFROM:1', type: SimVarValueType.Enum }],
    ['nav1_localizer', { name: 'NAV HAS LOCALIZER:1', type: SimVarValueType.Bool }],
    ['nav1_localizer_crs', { name: 'NAV LOCALIZER:1', type: SimVarValueType.Number }],
    ['nav1_glideslope', { name: 'NAV HAS GLIDE SLOPE:1', type: SimVarValueType.Bool }],
    ['nav1_gs_error', { name: 'NAV GLIDE SLOPE ERROR:1', type: SimVarValueType.Degree }],
    ['nav1_raw_gs', { name: 'NAV RAW GLIDE SLOPE:1', type: SimVarValueType.Degree }],
    ['nav1_gs_lla', { name: 'NAV GS LATLONALT:1', type: SimVarValueType.LLA }],
    ['nav1_lla', { name: 'NAV VOR LATLONALT:1', type: SimVarValueType.LLA }],
    ['nav1_magvar', { name: 'NAV MAGVAR:1', type: SimVarValueType.Number }],
    ['nav2_obs', { name: 'NAV OBS:2', type: SimVarValueType.Degree }],
    ['nav2_cdi', { name: 'NAV CDI:2', type: SimVarValueType.Number }],
    ['nav2_dme', { name: 'NAV DME:2', type: SimVarValueType.NM }],
    ['nav2_has_dme', { name: 'NAV HAS DME:2', type: SimVarValueType.Bool }],
    ['nav2_has_nav', { name: 'NAV HAS NAV:2', type: SimVarValueType.Bool }],
    ['nav2_radial', { name: 'NAV RADIAL:2', type: SimVarValueType.Radians }],
    ['nav2_signal', { name: 'NAV SIGNAL:2', type: SimVarValueType.Number }],
    ['nav2_ident', { name: 'NAV IDENT:2', type: SimVarValueType.String }],
    ['nav2_to_from', { name: 'NAV TOFROM:2', type: SimVarValueType.Enum }],
    ['nav2_localizer', { name: 'NAV HAS LOCALIZER:2', type: SimVarValueType.Bool }],
    ['nav2_localizer_crs', { name: 'NAV LOCALIZER:2', type: SimVarValueType.Number }],
    ['nav2_glideslope', { name: 'NAV HAS GLIDE SLOPE:2', type: SimVarValueType.Bool }],
    ['nav2_gs_error', { name: 'NAV GLIDE SLOPE ERROR:2', type: SimVarValueType.Degree }],
    ['nav2_raw_gs', { name: 'NAV RAW GLIDE SLOPE:2', type: SimVarValueType.Degree }],
    ['nav2_gs_lla', { name: 'NAV GS LATLONALT:2', type: SimVarValueType.LLA }],
    ['nav2_lla', { name: 'NAV VOR LATLONALT:2', type: SimVarValueType.LLA }],
    ['nav2_magvar', { name: 'NAV MAGVAR:2', type: SimVarValueType.Number }],
    ['gps_dtk', { name: 'GPS WP DESIRED TRACK', type: SimVarValueType.Degree }],
    ['gps_xtk', { name: 'GPS WP CROSS TRK', type: SimVarValueType.NM }],
    ['gps_wp', { name: 'GPS WP NEXT ID', type: SimVarValueType.NM }],
    ['gps_wp_bearing', { name: 'GPS WP BEARING', type: SimVarValueType.Degree }],
    ['gps_wp_distance', { name: 'GPS WP DISTANCE', type: SimVarValueType.NM }],
    ['adf1_bearing', { name: 'ADF RADIAL:1', type: SimVarValueType.Radians }],
    ['adf1_signal', { name: 'ADF SIGNAL:1', type: SimVarValueType.Number }],
    ['mkr_bcn_state_simvar', { name: 'MARKER BEACON STATE', type: SimVarValueType.Number }],
    ['gps_obs_active_simvar', { name: 'GPS OBS ACTIVE', type: SimVarValueType.Bool }],
    ['gps_obs_value_simvar', { name: 'GPS OBS VALUE', type: SimVarValueType.Degree }]
]);
//
// Navigation event configurations
//
var NavSourceType;
(function (NavSourceType) {
    NavSourceType[NavSourceType["Nav"] = 0] = "Nav";
    NavSourceType[NavSourceType["Gps"] = 1] = "Gps";
    NavSourceType[NavSourceType["Adf"] = 2] = "Adf";
})(NavSourceType || (NavSourceType = {}));
//* ENUM for VOR To/From Flag */
var VorToFrom;
(function (VorToFrom) {
    VorToFrom[VorToFrom["OFF"] = 0] = "OFF";
    VorToFrom[VorToFrom["TO"] = 1] = "TO";
    VorToFrom[VorToFrom["FROM"] = 2] = "FROM";
})(VorToFrom || (VorToFrom = {}));
/** Marker beacon signal state. */
var MarkerBeaconState;
(function (MarkerBeaconState) {
    MarkerBeaconState[MarkerBeaconState["Inactive"] = 0] = "Inactive";
    MarkerBeaconState[MarkerBeaconState["Outer"] = 1] = "Outer";
    MarkerBeaconState[MarkerBeaconState["Middle"] = 2] = "Middle";
    MarkerBeaconState[MarkerBeaconState["Inner"] = 3] = "Inner";
})(MarkerBeaconState || (MarkerBeaconState = {}));
/**
 * Encapsulation of the logic for a generic nav source.
 */
class NavSourceBase {
    /**
     * Create a bearing pointer
     * @param id The navsourceid.
     */
    constructor(id) {
        this._ident = null;
        this._bearing = null;
        this._distance = null;
        this._obs = 0;
        this._deviation = null;
        this._toFrom = VorToFrom.OFF;
        this._glideslopeDeviation = null;
        this._glideslopeAngle = null;
        this._localizerCourse = null;
        this._magneticVariation = null;
        this._isLocalizerFrequency = null;
        this.validHandler = undefined;
        this.identHandler = undefined;
        this.brgHandler = undefined;
        this.distHandler = undefined;
        this.obsHandler = undefined;
        this.deviationHandler = undefined;
        this.toFromHandler = undefined;
        this.glideslopeDeviationHandler = undefined;
        this.glideslopeAngleHandler = undefined;
        this.localizerCourseHandler = undefined;
        this.magvarHandler = undefined;
        this.isLocalizerFrequencyHandler = undefined;
        this._valid = false;
        this._activeBrg = false;
        this._activeCdi = false;
        this._hasCdi = false;
        this._hasDme = false;
        this._hasLocalizer = false;
        this._hasGlideslope = false;
        this._signal = 0;
        this._activeForCount = 0;
        if (id.type !== null && id.type in [NavSourceType.Nav, NavSourceType.Gps]) {
            this._hasCdi = true;
        }
        this.valid = false;
        this.srcId = id;
    }
    /**
     * Do we support CDI?
     * @returns A boolean with our CDI support state.
     */
    get hasCdi() {
        return this._hasCdi;
    }
    /**
     * Set a new ident.
     * @param ident The new ident string.
     */
    set ident(ident) {
        this._ident = ident;
        if (this.valid && this.activeBrg && this.identHandler !== undefined) {
            this.identHandler(ident, this.srcId);
        }
    }
    /**
     * Get an ident.
     * @returns A string identifying the nav source.
     */
    get ident() {
        if (this._signal > 0) {
            return this._ident;
        }
        else {
            return null;
        }
    }
    /**
     * Set a new bearing.
     * @param bearing The new bearing in degrees.
     */
    set bearing(bearing) {
        if (bearing !== null) {
            bearing *= 57.2958;
            bearing = (bearing + 180) % 360;
        }
        this._bearing = bearing;
        if (this.valid && this.activeBrg && this.brgHandler !== undefined) {
            this.brgHandler(bearing, this.srcId);
        }
    }
    /**
     * Get abearing.
     * @returns Bearing to the source in degrees.
     */
    get bearing() {
        return this._bearing;
    }
    /**
     * Set a new distance
     * @param distance The distance in NM.
     */
    set distance(distance) {
        this._distance = distance;
        if (this.valid && this.activeBrg && this.distHandler !== undefined) {
            this.distHandler(this.distance, this.srcId);
        }
    }
    /**
     * Get the distance to a source..
     * @returns Distance to the source in degrees.
     */
    get distance() {
        if (this.hasDme) {
            return this._distance;
        }
        else {
            return null;
        }
    }
    /**
     * Set a new OBS
     * @param obs the new bearing in degrees
     */
    set obs(obs) {
        this._obs = obs;
        if (this.activeCdi && this.obsHandler !== undefined) {
            this.obsHandler(obs, this.srcId);
        }
    }
    /**
     * Get the OBS setting.
     * @returns OBS in degrees.
     */
    get obs() {
        return this._obs;
    }
    /**
     * Set a new deviation
     * @param deviation The new deviation in points.
     */
    set deviation(deviation) {
        this._deviation = deviation;
        if (this.activeCdi && this.deviationHandler !== undefined) {
            this.deviationHandler(deviation, this.srcId);
        }
    }
    /**
     * Get the deviation.
     * @returns The deviation in points.
     */
    get deviation() {
        return this._deviation;
    }
    /**
     * Set a new VOR to/from value
     * @param toFrom The to/from value.
     */
    set toFrom(toFrom) {
        if (this.activeCdi && this.toFromHandler !== undefined) {
            this.toFromHandler(toFrom, this.srcId);
        }
        this._toFrom = toFrom;
    }
    /**
     * Get the VOR to/from value.
     * @returns The VOR to/from value.
     */
    get toFrom() {
        return this._toFrom;
    }
    /**
     * Set whether the nav radio has a loc signal
     * @param valid If the loc exists.
     */
    set hasLocalizer(valid) {
        this._hasLocalizer = valid;
        if (!this._hasLocalizer) {
            this.localizerCourse = -1;
        }
        else if (this._hasLocalizer && this.localizerCourseHandler && this.localizerCourseHandler !== null
            && this._localizerCourse !== null && this._localizerCourse >= 0) {
            this.localizerCourseHandler(this._localizerCourse, this.srcId);
        }
    }
    /**
     * Get if the radio has a loc.
     * @returns The loc bool.
     */
    get hasLocalizer() {
        return this._hasLocalizer;
    }
    /**
     * Set a new localizerCourse
     * @param course The new localizer course.
     */
    set localizerCourse(course) {
        this._localizerCourse = course !== null ? course * (180 / Math.PI) : -1;
        if (this._localizerCourse !== -1 && this.localizerCourseHandler !== undefined) {
            this.localizerCourseHandler(this._localizerCourse, this.srcId);
        }
    }
    /**
     * Get the localizerCourse.
     * @returns The glideslopeDeviation in degrees.
     */
    get localizerCourse() {
        return this._localizerCourse;
    }
    /**
     * Set whether the nav radio has a GS signal
     * @param valid If the GS exists.
     */
    set hasGlideslope(valid) {
        this._hasGlideslope = valid;
        if (this.glideslopeDeviationHandler !== undefined) {
            this.glideslopeDeviationHandler(this.glideslopeDeviation, this.srcId);
        }
    }
    /**
     * Get if the radio has a glideslope.
     * @returns The glideslope bool.
     */
    get hasGlideslope() {
        return this._hasGlideslope;
    }
    /**
     * Set a new _glideslopeDeviation
     * @param deviation The new deviation in points.
     */
    set glideslopeDeviation(deviation) {
        this._glideslopeDeviation = deviation;
        if (this.valid && this.activeCdi && this.hasGlideslope && this.glideslopeDeviationHandler !== undefined) {
            this.glideslopeDeviationHandler(deviation, this.srcId);
        }
    }
    /**
     * Get the glideslopeDeviation.
     * @returns The glideslopeDeviation in degrees.
     */
    get glideslopeDeviation() {
        return this._glideslopeDeviation;
    }
    /**
     * Set a new _glideslopeAngle
     * @param angle The new angle in degrees.
     */
    set glideslopeAngle(angle) {
        this._glideslopeAngle = angle;
        if (this.valid && this.activeCdi && this.hasGlideslope && this.glideslopeAngleHandler !== undefined) {
            this.glideslopeAngleHandler(angle, this.srcId);
        }
    }
    /**
     * Get the glideslopeAngle.
     * @returns The glideslopeAngle in degrees.
     */
    get glideslopeAngle() {
        return this._glideslopeAngle;
    }
    /**
     * Set whether there's a valid DME signal.
     * @param hasDme Whether a nav signal is present or not.
     */
    set hasDme(hasDme) {
        this._hasDme = hasDme;
        if (this.distHandler !== undefined) {
            // If hasDme state is changing, we need to publish a new distance event.
            // The getter for this.distance handles whether there's a DME signal or not.
            this.distHandler(this.distance, this.srcId);
        }
    }
    /**
     * Get whether there's a valid DME signal.
     * @returns A boolean indicatind presence of DME.
     */
    get hasDme() {
        return this._hasDme;
    }
    /**
     * Get the nav radio magvar.
     * @returns The magvar value.
     */
    get magneticVariation() {
        return this._magneticVariation;
    }
    /**
     * Set a new nav radio magvar
     * @param magvar The new nav radio magvar.
     */
    set magneticVariation(magvar) {
        this._magneticVariation = magvar;
        if (this.valid && this.activeCdi && this.magvarHandler !== undefined) {
            this.magvarHandler(magvar, this.srcId);
        }
    }
    /**
     * Get if the frequency is for a localizer.
     * @returns a bool of whether the freq is for a localizer.
     */
    get isLocalizerFrequency() {
        return this._isLocalizerFrequency;
    }
    /**
     * Sets if a frequency is for a localizer
     * @param isLocFreq whether the freq is a localizer freq.
     */
    set isLocalizerFrequency(isLocFreq) {
        if (this.isLocalizerFrequencyHandler !== undefined) {
            this.isLocalizerFrequencyHandler(isLocFreq, this.srcId);
        }
        this._isLocalizerFrequency = isLocFreq;
    }
    /**
     * Set the nav signal strength.
     * @param signal The signal strength as a number.
     */
    set signal(signal) {
        if ((this._signal == 0) != (signal == 0)) {
            // if we gain or lose signal, we need to update our ident.
            this._signal = signal;
            if (this.identHandler !== undefined) {
                // The getter for ident will handle whether we have signal or not.
                this.identHandler(this.ident, this.srcId);
            }
        }
        else {
            // repaet this from above to avoid a needless temporary assigment.
            this._signal = signal;
        }
    }
    /**
     * Set validity.
     * @param valid Whether we are valid or not.
     */
    set valid(valid) {
        // TODO Make sure this matches up with new activeBrg logic
        this._valid = valid;
        this.validHandler && this.validHandler(valid, this.srcId);
        if (valid && this.activeBrg) {
            if (this.identHandler !== undefined) {
                this.identHandler(this._ident, this.srcId);
            }
            if (this.brgHandler !== undefined) {
                this.brgHandler(this._bearing, this.srcId);
            }
            if (this.distHandler !== undefined) {
                this.distHandler(this._distance, this.srcId);
            }
            if (this.toFromHandler !== undefined) {
                this.toFromHandler(this._toFrom, this.srcId);
            }
            if (this.localizerCourseHandler !== undefined) {
                this.localizerCourseHandler(this._localizerCourse, this.srcId);
            }
            if (this.glideslopeDeviationHandler !== undefined) {
                this.glideslopeDeviationHandler(this._glideslopeDeviation, this.srcId);
            }
            if (this.magvarHandler !== undefined) {
                this.magvarHandler(this._magneticVariation, this.srcId);
            }
            if (this.isLocalizerFrequencyHandler !== undefined) {
                this.isLocalizerFrequencyHandler(this._isLocalizerFrequency, this.srcId);
            }
            if (this.obsHandler !== undefined) {
                this.obsHandler(this._obs, this.srcId);
            }
        }
        else if (this.activeBrg) {
            if (this.identHandler !== undefined) {
                this.identHandler(null, this.srcId);
            }
            if (this.brgHandler !== undefined) {
                this.brgHandler(null, this.srcId);
            }
            if (this.distHandler !== undefined) {
                this.distHandler(null, this.srcId);
            }
            if (this.toFromHandler !== undefined) {
                this.toFromHandler(this._toFrom, this.srcId);
            }
            if (this.localizerCourseHandler !== undefined) {
                this.localizerCourseHandler(null, this.srcId);
            }
            if (this.glideslopeDeviationHandler !== undefined) {
                this.glideslopeDeviationHandler(null, this.srcId);
            }
            if (this.magvarHandler !== undefined) {
                this.magvarHandler(null, this.srcId);
            }
            if (this.isLocalizerFrequencyHandler !== undefined) {
                this.isLocalizerFrequencyHandler(this._isLocalizerFrequency, this.srcId);
            }
            if (this.obsHandler !== undefined) {
                this.obsHandler(this._obs, this.srcId);
            }
        }
    }
    /**
     * Get validity
     * @returns A boolean indicating whether this is valid
     */
    get valid() {
        return this._valid;
    }
    /**
     * Set as active for bearing information
     * @param active Whether we are active for bearing info.
     */
    set activeBrg(active) {
        if (active) {
            this._activeForCount++;
        }
        else if (this._activeForCount > 0) {
            this._activeForCount--;
        }
        this.validHandler && this.validHandler(this.valid, this.srcId);
        if (!this.activeBrg || !this.valid) {
            if (this.identHandler !== undefined) {
                this.identHandler(null, this.srcId);
            }
            if (this.brgHandler !== undefined) {
                this.brgHandler(null, this.srcId);
            }
            if (this.distHandler !== undefined) {
                this.distHandler(null, this.srcId);
            }
            if (this.toFromHandler !== undefined) {
                this.toFromHandler(this._toFrom, this.srcId);
            }
            if (this.isLocalizerFrequencyHandler !== undefined) {
                this.isLocalizerFrequencyHandler(this._isLocalizerFrequency, this.srcId);
            }
        }
        else {
            if (this.identHandler !== undefined) {
                this.identHandler(this.ident, this.srcId);
            }
            if (this.brgHandler !== undefined) {
                this.brgHandler(this.bearing, this.srcId);
            }
            if (this.distHandler !== undefined) {
                this.distHandler(this.distance, this.srcId);
            }
            if (this.toFromHandler !== undefined) {
                this.toFromHandler(this._toFrom, this.srcId);
            }
            if (this.isLocalizerFrequencyHandler !== undefined) {
                this.isLocalizerFrequencyHandler(this._isLocalizerFrequency, this.srcId);
            }
        }
    }
    /**
     * Are we active for bearing information?
     * @returns Our active state
     */
    get activeBrg() {
        return this._activeForCount > 0;
    }
    /**
     * Set this at the active deviation source or not
     * @param active Whether we are active for publishing deviation info.
     */
    set activeCdi(active) {
        this._activeCdi = active;
        if (active && this.deviationHandler !== undefined) {
            this.deviationHandler(this._deviation, this.srcId);
        }
    }
    /**
     * Are we active for CDI data?
     * @returns Boolean of our CDI active state
     */
    get activeCdi() {
        return this._activeCdi;
    }
}
/**
 * A utility for controlling and optimizing simvar subscriptions for multiple pointers.
 */
class PooledSubscriber {
    /**
     * Create a pooled subscriber
     * @param publisher The simvar publisher to manage.
     */
    constructor(publisher) {
        this.publisher = publisher;
        this.subCount = new Map();
        for (const key of PooledSubscriber.simvarMap.keys()) {
            this.subCount.set(key, 0);
        }
    }
    /**
     * Add a subscriber to one of the tracked types
     * @param type the type to add
     */
    addSub(type) {
        const subCount = this.subCount.get(type);
        if (subCount == undefined) {
            return;
        }
        if (subCount == 0) {
            const simvars = PooledSubscriber.simvarMap.get(type);
            if (simvars) {
                for (const simvar of simvars) {
                    this.publisher.subscribe(simvar);
                }
            }
        }
        this.subCount.set(type, subCount + 1);
    }
    /**
     * Remove a subscriber of a tracked type
     * @param type The type to remove.
     */
    delSub(type) {
        const subCount = this.subCount.get(type);
        if (subCount == undefined) {
            return;
        }
        if (subCount == 1) {
            for (const simvar in PooledSubscriber.simvarMap.get(type)) {
                this.publisher.unsubscribe(simvar);
            }
        }
        this.subCount.set(type, subCount - 1);
    }
}
PooledSubscriber.simvarMap = new Map([
    ['nav1', [
            'nav1_cdi', 'nav1_dme', 'nav1_glideslope', 'nav1_gs_error', 'nav1_has_dme', 'nav1_has_nav',
            'nav1_ident', 'nav1_localizer', 'nav1_localizer_crs', 'nav1_magvar', 'nav1_obs', 'nav1_radial',
            'nav1_raw_gs', 'nav1_signal', 'nav1_to_from'
        ]],
    ['nav2', [
            'nav2_cdi', 'nav2_dme', 'nav2_glideslope', 'nav2_gs_error', 'nav2_has_dme', 'nav2_has_nav',
            'nav2_ident', 'nav2_localizer', 'nav2_localizer_crs', 'nav2_magvar', 'nav2_obs', 'nav2_radial',
            'nav2_raw_gs', 'nav2_signal', 'nav2_to_from'
        ]],
    ['gps', ['gps_wp', 'gps_wp_bearing', 'gps_wp_distance']],
    ['adf', ['adf1_bearing', 'adf1_signal']]
]);
/**
 * A convenience class for creating a navproc configuration set.
 *
 * Implementers should instantiate this and then populate the sets with the
 * HEvents that their radio sends for various actions.
 */
class NavProcessorConfig {
    constructor() {
        this.numNav = 2;
        this.numGps = 1;
        this.numAdf = 1;
        this.initialCdiIndex = 3;
        this.courseIncEvents = new Set();
        this.courseDecEvents = new Set();
        this.additionalSources = new Array();
    }
}
/**
 * A publisher for navigation processor events.
 */
class NavProcPublisher extends BasePublisher {
    /**
     * Creates a NavProcPublisher
     * @param bus The event bus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer) {
        super(bus, pacer);
    }
    /**
     * Publish a new CDI source selection.
     * @param source The selected NavSource.
     */
    publishCdiSelect(source) {
        this.publish('cdi_select', source, true);
    }
    /**
     * Publish a new CDI deviation
     * @param deviation The deviation
     * @param source the source for thes deviation
     */
    publishDeviation(deviation, source) {
        this.publish('cdi_deviation', { source: source, deviation: deviation });
    }
    /**
     * Publish a new OBS heading
     * @param heading The heading
     * @param source The source for this heading.
     */
    publishObsHeading(heading, source) {
        this.publish('obs_set', { source: source, heading: heading });
    }
    /**
     * Publish new validity information.
     * @param index The bearing index number to update.
     * @param valid The validity state of that berign source.
     */
    publishBrgValidity(index, valid) {
        this.publish('brg_validity', { index: index, valid: valid }, true);
    }
    /**
     * Publish a new bearing source
     * @param index The source number.
     * @param source The source name.
     */
    publishBrgSrc(index, source) {
        this.publish('brg_source', { index: index, source: source });
    }
    /**
     * Publish heading of a bearing source.
     * @param index The index number to update.
     * @param direction The direction.
     */
    publishBrgDir(index, direction) {
        this.publish('brg_direction', { index: index, direction: direction });
    }
    /**
     * Publish distance to a bearing source.
     * @param index The source number.
     * @param distance The distance in NMs.
     */
    publishBrgDist(index, distance) {
        this.publish('brg_distance', { index: index, distance: distance });
    }
    /**
     * Publish distance to a bearing source.
     * @param index The source number.
     * @param ident The ident as a string.
     * @param isLoc is this source a loc.
     */
    publishBrgIdent(index, ident, isLoc) {
        this.publish('brg_ident', { index: index, ident: ident, isLoc: isLoc });
    }
    // /**
    //  * Publish distance to a bearing source.
    //  * @param index The source number.
    //  * @param isLoc The ident as a string.
    //  */
    // public publishBrgIsLoc(index: number, isLoc: boolean | null): void {
    //     this.publish('brg_is_loc', { index: index, isLoc: isLoc });
    // }
    /**
     * Publish to/from value for a nav source.
     * @param toFrom The to/from enum value.
     * @param source The nav radio source.
     */
    publishToFrom(toFrom, source) {
        this.publish('vor_to_from', { toFrom: toFrom, source: source });
    }
    /**
     * Publish localizer value for a nav source.
     * @param localizer is the localizer data
     * @param source The nav radio source.
     */
    publishLocalizer(localizer, source) {
        this.publish('localizer', { isValid: localizer.isValid, course: localizer.course, source: source });
    }
    /**
     * Publish if the nav source is tuned to a localizer frequency.
     * @param isLoc is a bool whether or not the nav source is a loc frequency
     * @param source The nav radio source.
     */
    publishIsLocalizerFrequency(isLoc, source) {
        this.publish('is_localizer_frequency', { isLocalizer: isLoc.isLocalizer, source: source });
    }
    /**
     * Publish gliseslope value for a nav source.
     * @param glideslope is the localizer data
     * @param source The nav radio source.
     */
    publishGlideslope(glideslope, source) {
        this.publish('glideslope', { isValid: glideslope.isValid, deviation: glideslope.deviation, gsAngle: glideslope.gsAngle, source: source });
    }
    /**
     * Publish magvar value for a nav source.
     * @param variation is the magnetic variation
     * @param source The nav radio source.
     */
    publishMagvar(variation, source) {
        if (variation !== null) {
            this.publish('mag_variation', { variation: variation, source: source });
        }
    }
    /**
     * Publish marker beacon state value.
     * @param state is the marker beacon state value
     */
    publishMarkerBeacon(state) {
        this.publish('mkr_bcn_state', state);
    }
    /**
     * Publish DME state.
     * @param state is the has_dme state value
     * @param distance is the dme distance value.
     * @param source The nav radio source.
     */
    publishDmeState(state, distance, source) {
        this.publish('dme_state', { hasDme: state, dmeDistance: distance, source: source });
    }
    /**
     * Publish GPS OBS State.
     * @param state is the GPS OBS Active State
     */
    publishGpsObsState(state) {
        this.publish('gps_obs_active', state, true);
    }
    /**
     * Publish GPS OBS Value.
     * @param value is the GPS OBS heading value
     */
    publishGpsObsValue(value) {
        this.publish('gps_obs_value', value, true);
    }
}
/**
 * The core of tne nav processor
 */
class NavProcessor {
    /**
     * Create a NavProcessor.
     * @param bus The event bus to publish to.
     * @param config A config object defining our radio options.
     */
    constructor(bus, config) {
        /**
         * Handle HEvents
         * @param event The hEvent name
         */
        this.eventHandler = (event) => {
            if (this.config.courseIncEvents.has(event)) {
                this.handleCrsInc();
            }
            else if (this.config.courseDecEvents.has(event)) {
                this.handleCrsDec();
            }
        };
        /**
         * Toggles CDI between GPS and NAV1.
         */
        this.onCdiGpsToggle = () => {
            const src = this.navSources[this.cdiSourceIdx];
            if (src.srcId.type === NavSourceType.Gps) {
                this.switchCdiSrc();
            }
            else {
                this.switchCdiSrc(3);
            }
        };
        this.bus = bus;
        this.config = config;
        this.publisher = new NavProcPublisher(bus);
        this.simVarPublisher = config.simVarPublisher ? config.simVarPublisher : new NavProcSimVarPublisher(this.bus);
        this.subController = new PooledSubscriber(this.simVarPublisher);
        this.hEvents = bus.getSubscriber();
        this.controlSubscriber = bus.getSubscriber();
        this.simVarSubscriber = new EventSubscriber(bus);
        this.navComSubscriber = bus.getSubscriber();
        this.simVarPublisher.subscribe('mkr_bcn_state_simvar');
        this.simVarPublisher.subscribe('gps_obs_active_simvar');
        this.simVarPublisher.subscribe('gps_obs_value_simvar');
        this.navSources = new Array();
        this.bearingSourceIdxs = [-1, -1];
        this.cdiSourceIdx = 0;
    }
    /**
     * Initialize a nav processor
     */
    init() {
        this.publisher.startPublish();
        this.simVarPublisher.startPublish();
        this.hEvents.on('hEvent').handle(this.eventHandler);
        this.controlSubscriber.on('cdi_src_switch').handle(() => {
            this.switchCdiSrc();
        });
        this.controlSubscriber.on('cdi_src_set').handle((src) => {
            if (src.type === NavSourceType.Gps) {
                this.switchCdiSrc(3);
            }
            else if (src.type === NavSourceType.Nav) {
                this.switchCdiSrc(src.index - 1);
            }
        });
        this.controlSubscriber.on('cdi_src_gps_toggle').handle(this.onCdiGpsToggle);
        this.controlSubscriber.on('init_cdi').handle(this.initCdi.bind(this));
        this.controlSubscriber.on('brg_src_switch').handle(this.switchBrgSrc.bind(this));
        // TODO Determine why this throttle doesn't work but does on the client end.
        this.simVarSubscriber.on('mkr_bcn_state_simvar').whenChanged().handle((state) => {
            this.publisher.publishMarkerBeacon(state);
        });
        this.simVarSubscriber.on('gps_obs_active_simvar').whenChanged().handle((state) => {
            this.publisher.publishGpsObsState(state);
        });
        this.simVarSubscriber.on('gps_obs_value_simvar').whenChangedBy(1).handle((value) => {
            this.publisher.publishGpsObsValue(value);
        });
        for (let i = 1; i <= this.config.numNav; i++) {
            const src = new NavSourceBase({ type: NavSourceType.Nav, index: i });
            src.deviationHandler = this.publisher.publishDeviation.bind(this.publisher);
            src.obsHandler = this.publisher.publishObsHeading.bind(this.publisher);
            src.distHandler = this.onBrgDistance.bind(this);
            src.brgHandler = this.onBrgDirection.bind(this);
            src.identHandler = this.onBrgIdent.bind(this);
            src.toFromHandler = this.publisher.publishToFrom.bind(this.publisher);
            src.localizerCourseHandler = this.onLocalizerCourse.bind(this);
            src.glideslopeDeviationHandler = this.onGlideslopeDeviation.bind(this);
            src.magvarHandler = this.publisher.publishMagvar.bind(this.publisher);
            src.isLocalizerFrequencyHandler = this.onIsLocalizerFrequency.bind(this);
            src.glideslopeAngleHandler = this.onGlideslopeAngle.bind(this);
            src.validHandler = this.onBrgValidity.bind(this);
            this.simVarSubscriber.on(`nav${i}_cdi`).whenChangedBy(1).handle((deviation) => {
                src.deviation = deviation;
            });
            this.simVarSubscriber.on(`nav${i}_obs`).whenChangedBy(1).handle((obs) => {
                src.obs = obs;
            });
            this.simVarSubscriber.on(`nav${i}_dme`).whenChangedBy(0.1).handle((distance) => {
                src.distance = distance;
                // TODO Fold DME logic into the distance handler.
                this.onDme(src.hasDme, src.distance, src.srcId);
            });
            this.simVarSubscriber.on(`nav${i}_radial`).handle((bearing) => {
                src.bearing = bearing;
            });
            this.simVarSubscriber.on(`nav${i}_ident`).whenChanged().handle((ident) => {
                src.ident = ident;
            });
            this.simVarSubscriber.on(`nav${i}_signal`).withPrecision(0).handle((signal) => {
                src.signal = signal;
            });
            this.simVarSubscriber.on(`nav${i}_has_nav`).whenChanged().handle((valid) => {
                src.valid = valid == 0 ? false : true;
            });
            this.simVarSubscriber.on(`nav${i}_has_dme`).whenChanged().handle((dme) => {
                src.hasDme = dme == 0 ? false : true;
                // TODO Fold DME logic into the distance handler.
                this.onDme(src.hasDme, src.distance, src.srcId);
            });
            this.simVarSubscriber.on(`nav${i}_to_from`).whenChanged().handle((value) => {
                src.toFrom = value;
            });
            this.simVarSubscriber.on(`nav${i}_localizer`).whenChanged().handle((localizer) => {
                src.hasLocalizer = localizer;
            });
            this.simVarSubscriber.on(`nav${i}_localizer_crs`).whenChanged().handle((locCourse) => {
                src.localizerCourse = locCourse;
            });
            this.simVarSubscriber.on(`nav${i}_glideslope`).whenChanged().handle((gs) => {
                src.hasGlideslope = gs;
            });
            this.simVarSubscriber.on(`nav${i}_gs_error`).whenChanged().handle((gsDev) => {
                src.glideslopeDeviation = gsDev;
            });
            this.simVarSubscriber.on(`nav${i}_raw_gs`).whenChanged().handle((rawGs) => {
                src.glideslopeAngle = rawGs;
            });
            this.simVarSubscriber.on(`nav${i}_magvar`).whenChanged().handle((magvar) => {
                src.magneticVariation = magvar;
            });
            this.navComSubscriber.on('setRadioState').handle((radioState) => {
                if (radioState.radioType === RadioType.Nav && radioState.index == i && radioState.activeFrequency) {
                    src.isLocalizerFrequency = this.frequencyIsLocalizer(radioState.activeFrequency);
                }
            });
            this.navComSubscriber.on('setFrequency').handle((setFrequency) => {
                if (setFrequency.radio.radioType === RadioType.Nav && setFrequency.radio.index == i
                    && setFrequency.bank == FrequencyBank.Active) {
                    src.isLocalizerFrequency = this.frequencyIsLocalizer(setFrequency.frequency);
                }
            });
            this.navSources.push(src);
            this.subController.addSub(`nav${i}`);
        }
        // TODO Add support for multiple GPSes
        if (this.config.numGps > 0) {
            // Set the CDI source to the first GPS (which, since we're zero-indexed, is the
            // same as the number of nav radios.
            this.cdiSourceIdx = this.config.numNav;
            const src = new NavSourceBase({ type: NavSourceType.Gps, index: 1 });
            src.valid = true;
            src.deviationHandler = this.publisher.publishDeviation.bind(this.publisher);
            src.obsHandler = this.publisher.publishObsHeading.bind(this.publisher);
            src.distHandler = this.onBrgDistance.bind(this);
            src.brgHandler = this.onBrgDirection.bind(this);
            src.identHandler = this.onBrgIdent.bind(this);
            this.simVarSubscriber.on('gps_xtk').whenChangedBy(1).handle((deviation) => {
                src.deviation = deviation;
            });
            this.simVarSubscriber.on('gps_dtk').whenChangedBy(1).handle((obs) => {
                src.obs = obs;
            });
            this.simVarSubscriber.on('gps_wp_bearing').withPrecision(2).handle((brg) => {
                // The nav source bearing expects to be a radial, not the bearing to the
                // waypoint.  When we get the bearing from the GPS, we need to invert it
                // so the NavSource knows how to handle it correctly.
                // TODO Make bearing handling in NavSourceBase more consistent.
                brg = (brg + Math.PI) % (2 * Math.PI);
                src.bearing = brg;
            });
            this.navSources.push(src);
            this.subController.addSub('gps');
        }
        if (this.config.numAdf > 0) {
            const src = new NavSourceBase({ type: NavSourceType.Adf, index: 1 });
            src.valid = false;
            src.signal = 0;
            src.brgHandler = this.onBrgDirection.bind(this);
            src.identHandler = this.onBrgIdent.bind(this);
            src.validHandler = this.onBrgValidity.bind(this);
            this.simVarSubscriber.on('adf1_signal').withPrecision(0).handle((signal) => {
                src.signal = signal;
                if (signal > 0) {
                    if (!src.valid) {
                        src.valid = true;
                    }
                }
                else {
                    if (src.valid) {
                        src.valid = false;
                    }
                }
            });
            this.navComSubscriber.on('adf1ActiveFreq').handle((freq) => {
                if (src.ident !== freq.toFixed(1)) {
                    src.ident = freq.toFixed(1);
                }
            });
            this.simVarSubscriber.on('adf1_bearing').withPrecision(2).handle((brg) => {
                brg = (brg + Math.PI) % (2 * Math.PI);
                src.bearing = brg;
            });
            this.navSources.push(src);
            this.subController.addSub('adf');
        }
        for (const source of this.config.additionalSources) {
            this.addNavSource(source);
        }
        this.cdiSourceIdx = this.config.initialCdiIndex;
        SimVar.SetSimVarValue('GPS DRIVES NAV1', SimVarValueType.Bool, this.navSources[this.cdiSourceIdx].srcId.type === NavSourceType.Gps);
    }
    /**
     * Add a custom nav source to the processor.
     * @param source The implementation of NavSourceBase to add.
     */
    addNavSource(source) {
        // TODO Add remaining handlers here for other custom nav sources.
        if (source.validHandler) {
            source.validHandler = this.onBrgValidity.bind(this);
        }
        if (source.brgHandler) {
            source.brgHandler = this.onBrgDirection.bind(this);
        }
        if (source.distHandler) {
            source.distHandler = this.onBrgDistance.bind(this);
        }
        if (source.identHandler) {
            source.identHandler = this.onBrgIdent.bind(this);
        }
        this.navSources.push(source);
    }
    /**
     * Process a CDI source change event.
     * @param index is specified if a specific cdiSourceIdx is requested
     */
    switchCdiSrc(index) {
        let src = this.navSources[this.cdiSourceIdx];
        src.activeCdi = false;
        if (index !== undefined && index < this.navSources.length && this.navSources[index].hasCdi) {
            this.cdiSourceIdx = index;
        }
        else if (index === undefined) {
            do {
                this.cdiSourceIdx = this.cdiSourceIdx < this.navSources.length - 1 ? this.cdiSourceIdx + 1 : 0;
            } while (!this.navSources[this.cdiSourceIdx].hasCdi);
        }
        else {
            console.warn(`switchCdiSrc: Unable to set CDI Source index ${index}`);
            return;
        }
        src = this.navSources[this.cdiSourceIdx];
        src.activeCdi = true;
        this.publisher.publishCdiSelect(src.srcId);
        if (src.obs) {
            this.publisher.publishObsHeading(src.obs, src.srcId);
        }
        if (src.toFrom) {
            this.publisher.publishToFrom(src.toFrom, src.srcId);
        }
        this.publisher.publishDmeState(src.hasDme, src.distance, src.srcId);
        SimVar.SetSimVarValue('GPS DRIVES NAV1', SimVarValueType.Bool, src.srcId.type === NavSourceType.Gps);
        if (src.srcId.type === NavSourceType.Nav) {
            SimVar.SetSimVarValue('AUTOPILOT NAV SELECTED', SimVarValueType.Number, src.srcId.index);
        }
    }
    /**srcent.
     */
    initCdi() {
        const src = this.navSources[this.cdiSourceIdx];
        src.activeCdi = true;
        this.publisher.publishCdiSelect(src.srcId);
        if (src.obs) {
            this.publisher.publishObsHeading(src.obs, src.srcId);
        }
        if (src.toFrom) {
            this.publisher.publishToFrom(src.toFrom, src.srcId);
        }
        this.publisher.publishDmeState(src.hasDme, src.distance, src.srcId);
        SimVar.SetSimVarValue('GPS DRIVES NAV1', SimVarValueType.Bool, src.srcId.type === NavSourceType.Gps);
    }
    /**
     * Process a bearing source change event.
     * @param index The index of the source to change
     */
    switchBrgSrc(index) {
        index--;
        const oldSrc = this.navSources[this.bearingSourceIdxs[index]];
        if (oldSrc !== undefined) {
            oldSrc.activeBrg = false;
        }
        if (this.bearingSourceIdxs[index] == this.navSources.length - 1) {
            this.bearingSourceIdxs[index] = -1;
        }
        else {
            this.bearingSourceIdxs[index]++;
        }
        const newSrc = this.navSources[this.bearingSourceIdxs[index]];
        this.publisher.publishBrgSrc(index, newSrc !== undefined ? newSrc.srcId : null);
        if (newSrc !== undefined) {
            newSrc.activeBrg = true;
        }
        newSrc && this.publisher.publishBrgValidity(index, newSrc.valid);
        if (newSrc === undefined) {
            this.publisher.publishBrgIdent(index, null, false);
            this.publisher.publishBrgDir(index, null);
            this.publisher.publishBrgDist(index, null);
            //this.publisher.publishBrgIsLoc(index, false);
        }
    }
    /**
     * Handle a course inc event if we have a nav radio as our active CDI source.
     */
    handleCrsInc() {
        if (this.navSources[this.cdiSourceIdx].srcId.type != NavSourceType.Nav) {
            return;
        }
        switch (this.navSources[this.cdiSourceIdx].srcId.index) {
            case 1:
                SimVar.SetSimVarValue('K:VOR1_OBI_INC', 'number', 0);
                break;
            case 2:
                SimVar.SetSimVarValue('K:VOR2_OBI_INC', 'number', 0);
        }
    }
    /**
     * Handle a course dec event if we have a nav radio as our active CDI source.
     */
    handleCrsDec() {
        if (this.navSources[this.cdiSourceIdx].srcId.type != NavSourceType.Nav) {
            return;
        }
        switch (this.navSources[this.cdiSourceIdx].srcId.index) {
            case 1:
                SimVar.SetSimVarValue('K:VOR1_OBI_DEC', 'number', 0);
                break;
            case 2:
                SimVar.SetSimVarValue('K:VOR2_OBI_DEC', 'number', 0);
                break;
        }
    }
    /**
     * Handle a bearing validity change.
     * @param valid The new bearing validity
     * @param source The source of
     */
    onBrgValidity(valid, source) {
        if (this.bearingSourceIdxs) {
            for (let i = 0; i < this.bearingSourceIdxs.length; i++) {
                if (this.navSources[this.bearingSourceIdxs[i]] &&
                    this.navSources[this.bearingSourceIdxs[i]].srcId == source &&
                    !this.navSources[this.bearingSourceIdxs[i]].isLocalizerFrequency) {
                    this.publisher.publishBrgValidity(i, valid);
                }
            }
        }
    }
    // TODO Unify the next two functions
    /**
     * Handle a bearing distance change.
     * @param distance The distance to the source.
     * @param source The nav source ID.
     */
    onBrgDistance(distance, source) {
        for (let i = 0; i < this.bearingSourceIdxs.length; i++) {
            if (this.navSources[this.bearingSourceIdxs[i]] &&
                this.navSources[this.bearingSourceIdxs[i]].srcId == source &&
                !this.navSources[this.bearingSourceIdxs[i]].isLocalizerFrequency) {
                this.publisher.publishBrgDist(i, distance);
            }
        }
    }
    /**
     * Handle a bearing direction change.
     * @param direction The distance to the source.
     * @param source The nav source ID.
     */
    onBrgDirection(direction, source) {
        for (let i = 0; i < this.bearingSourceIdxs.length; i++) {
            if (this.navSources[this.bearingSourceIdxs[i]] &&
                this.navSources[this.bearingSourceIdxs[i]].srcId == source &&
                !this.navSources[this.bearingSourceIdxs[i]].isLocalizerFrequency) {
                this.publisher.publishBrgDir(i, direction);
            }
        }
    }
    /**
     * Handle a bearing ident change.
     * @param ident The ident of the source.
     * @param source The nav source ID.
     */
    onBrgIdent(ident, source) {
        for (let i = 0; i < this.bearingSourceIdxs.length; i++) {
            if (this.navSources[this.bearingSourceIdxs[i]] &&
                this.navSources[this.bearingSourceIdxs[i]].srcId == source) {
                this.publisher.publishBrgIdent(i, ident, this.navSources[this.bearingSourceIdxs[i]].isLocalizerFrequency);
                //this.publisher.publishBrgIsLoc(i, this.navSources[this.bearingSourceIdxs[i]].isLocalizerFrequency);
                if (this.navSources[this.bearingSourceIdxs[i]].isLocalizerFrequency) {
                    this.publisher.publishBrgDir(i, null);
                    this.publisher.publishBrgDist(i, null);
                }
                else {
                    this.publisher.publishBrgSrc(i, source);
                }
            }
        }
    }
    /**
     * Handle a localizer course change.
     * @param course The localizer course of the source.
     * @param source The nav source ID.
     */
    onLocalizerCourse(course, source) {
        for (let i = 0; i < this.navSources.length; i++) {
            if (this.navSources[i] && this.navSources[i].srcId == source && this.navSources[i].hasLocalizer && course !== null) {
                const localizer = { isValid: true, course: course, source: source };
                this.publisher.publishLocalizer(localizer, source);
            }
        }
    }
    /**
     * Handle a glideslope deviation change.
     * @param deviation The glideslope deviation of the source.
     * @param source The nav source ID.
     */
    onGlideslopeDeviation(deviation, source) {
        for (let i = 0; i < this.navSources.length; i++) {
            const navSource = this.navSources[i];
            if (navSource && navSource.srcId == source && deviation !== null && navSource.glideslopeAngle) {
                const glideslope = { isValid: this.navSources[i].hasGlideslope, deviation: deviation, gsAngle: navSource.glideslopeAngle, source: source };
                this.publisher.publishGlideslope(glideslope, source);
            }
        }
    }
    /**
     * Handle a glideslope angle change.
     * @param angle The glideslope angle of the source.
     * @param source The nav source ID.
     */
    onGlideslopeAngle(angle, source) {
        for (let i = 0; i < this.navSources.length; i++) {
            const navSource = this.navSources[i];
            if (navSource && navSource.srcId == source && navSource.deviation && angle !== null) {
                const glideslope = { isValid: this.navSources[i].hasGlideslope, deviation: navSource.deviation, gsAngle: angle, source: source };
                this.publisher.publishGlideslope(glideslope, source);
            }
        }
    }
    /**
     * Determine whether a set frequency is a localizer frequency.
     * @param frequency The frequency to evaluate.
     * @returns a bool true if the frequency is a loc freq.
     */
    frequencyIsLocalizer(frequency) {
        let isLoc = false;
        if (Math.floor(frequency) < 112) {
            const roundedFreq = Math.round(frequency * 100) / 100;
            const integer = Math.floor(roundedFreq);
            const remainder = roundedFreq - integer;
            const decimalValue = Math.round(remainder * 100);
            const tenthsDigit = Math.trunc(decimalValue / 10);
            if (tenthsDigit % 2 != 0) {
                isLoc = true;
            }
        }
        return isLoc;
    }
    /**
     * Publishers whether a set frequency is a localizer frequency.
     * @param isLoc whether the freq is a loc.
     * @param source the selected nav source.
     */
    onIsLocalizerFrequency(isLoc, source) {
        if (isLoc !== null) {
            const loc = { isLocalizer: isLoc, source: source };
            this.publisher.publishIsLocalizerFrequency(loc, source);
        }
    }
    /**
     * Publishers dme distance info.  This should be replaced by a generalization of
     * BearingDistance that provides the distance to any nav source if it has DME.
     * @param hasDme whether the radio has dme.
     * @param distance is the dme distance.
     * @param source the selected nav source.
     */
    onDme(hasDme, distance, source) {
        this.publisher.publishDmeState(hasDme ? hasDme : false, distance ? distance : -1, source);
    }
    /**
     * Perform events for the update loop.
     */
    onUpdate() {
        this.simVarPublisher.onUpdate();
    }
}

/** A publisher to poll and publish nav/com simvars. */
class NavComSimVarPublisher extends SimVarPublisher {
    /**
     * Create a NavComSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(NavComSimVarPublisher.simvars, bus, pacer);
    }
}
NavComSimVarPublisher.simvars = new Map([
    ['nav1ActiveFreq', { name: 'NAV ACTIVE FREQUENCY:1', type: SimVarValueType.MHz }],
    ['nav1StandbyFreq', { name: 'NAV STANDBY FREQUENCY:1', type: SimVarValueType.MHz }],
    ['nav1Ident', { name: 'NAV IDENT:1', type: SimVarValueType.String }],
    ['nav2ActiveFreq', { name: 'NAV ACTIVE FREQUENCY:2', type: SimVarValueType.MHz }],
    ['nav2StandbyFreq', { name: 'NAV STANDBY FREQUENCY:2', type: SimVarValueType.MHz }],
    ['nav2Ident', { name: 'NAV IDENT:2', type: SimVarValueType.String }],
    ['com1ActiveFreq', { name: 'COM ACTIVE FREQUENCY:1', type: SimVarValueType.MHz }],
    ['com1StandbyFreq', { name: 'COM STANDBY FREQUENCY:1', type: SimVarValueType.MHz }],
    ['com2ActiveFreq', { name: 'COM ACTIVE FREQUENCY:2', type: SimVarValueType.MHz }],
    ['com2StandbyFreq', { name: 'COM STANDBY FREQUENCY:2', type: SimVarValueType.MHz }],
    ['adf1StandbyFreq', { name: 'ADF STANDBY FREQUENCY:1', type: SimVarValueType.KHz }],
    ['adf1ActiveFreq', { name: 'ADF ACTIVE FREQUENCY:1', type: SimVarValueType.KHz }]
]);
/**
 * A convenience class for creating a radio configuration set.
 *
 * Implementers should instantiate this and then populate the various maps
 * with the H events that their radio sends and which displays they affect.
 */
class NavComConfig {
    constructor() {
        this.navSwitchEvents = new Map();
        this.navSelectorEvents = new Map();
        this.navWholeIncEvents = new Map();
        this.navWholeDecEvents = new Map();
        this.navFractionIncEvents = new Map();
        this.navFractionDecEvents = new Map();
        this.comSwitchEvents = new Map();
        this.comSelectorEvents = new Map();
        this.comWholeIncEvents = new Map();
        this.comWholeDecEvents = new Map();
        this.comFractionIncEvents = new Map();
        this.comFractionDecEvents = new Map();
    }
}
/**
 * Sends radio events from the nav/com controller to subscribers.
 */
class NavComPublisher extends BasePublisher {
    /**
     * Creates a NavComPublisher
     * @param bus The event bus to publish to.
     * @param pacer An optional pace to use to control the rate of publishing.
     * @param sync Whether to use synced events.
     */
    constructor(bus, pacer, sync = true) {
        super(bus, pacer);
        this.sync = sync;
    }
    /**
     * Publish a radio state event.
     *
     * This sets the complete state of a radio for initialzation or resync.
     * @param radio The Radio data to publish.
     */
    publishRadioState(radio) {
        if (radio !== undefined) {
            super.publish('setRadioState', radio, this.sync);
        }
    }
    /**
     * Publish a frequency change event.
     *
     * Unlike a radio state event, this just changes a specific frequency.
     * We provide this to avoid issues with potentially conflicting updates
     * if active and standby get updated quickly and we send a snapshot after
     * each.
     * @param radio The Radio to change.
     * @param bank The frequency bank to update.
     * @param frequency The new frequency to set.
     */
    publishFreqChange(radio, bank, frequency) {
        if (radio !== undefined) {
            super.publish('setFrequency', { radio: radio, bank: bank, frequency: frequency }, this.sync);
        }
    }
    /**
     * Publish the ident of the currently tuned station.
     * @param index The index number of the tuned radio.
     * @param ident The ident as a string.
     */
    publishIdent(index, ident) {
        super.publish('setIdent', { index: index, ident: ident }, this.sync);
    }
    /**
     * Publish the ADF1 Active Frequency in Khz.
     * @param freq The active frequency in Khz.
     */
    publishAdfActiveFrequencySet(freq) {
        super.publish('adf1ActiveFreq', freq, false);
    }
    /**
     * Publish the ADF1 Standby Frequency in Khz.
     * @param freq The standby frequency in Khz.
     */
    publishAdfStandbyFrequencySet(freq) {
        super.publish('adf1StandbyFreq', freq, false);
    }
}
/**
 * The core instrument that will drive all of a system's radios.
 */
class NavComInstrument {
    /**
     * Create a NavComController.
     * @param bus The event bus to publish to.
     * @param config A NavComConfig object defining the radio configuration.
     * @param numNavRadios The number of nav radios in the system.
     * @param numComRadios The number of com radios in the system.
     * @param sync Whether to sync events or not, default true.
     */
    constructor(bus, config, numNavRadios, numComRadios, sync = true) {
        this.navRadios = new Array();
        this.comRadios = new Array();
        /**
         * Handle an hEvent.
         * @param hEvent The event that needs to be handled.
         */
        this.eventHandler = (hEvent) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
            // We can't use a switch statement here because of the need to retrieve
            // the key from each map.  Sorry it's so ugly.
            if ((_a = this.config.navSwitchEvents) === null || _a === void 0 ? void 0 : _a.has(hEvent)) {
                this.swapFreqs(this.getSelectedRadio(this.navRadios));
            }
            else if ((_b = this.config.navSelectorEvents) === null || _b === void 0 ? void 0 : _b.has(hEvent)) {
                this.swapSelection(this.navRadios);
            }
            else if ((_c = this.config.navWholeIncEvents) === null || _c === void 0 ? void 0 : _c.has(hEvent)) {
                this.wholeInc(this.getSelectedRadio(this.navRadios));
            }
            else if ((_d = this.config.navWholeDecEvents) === null || _d === void 0 ? void 0 : _d.has(hEvent)) {
                this.wholeDec(this.getSelectedRadio(this.navRadios));
            }
            else if ((_e = this.config.navFractionIncEvents) === null || _e === void 0 ? void 0 : _e.has(hEvent)) {
                this.fractInc(this.getSelectedRadio(this.navRadios));
            }
            else if ((_f = this.config.navFractionDecEvents) === null || _f === void 0 ? void 0 : _f.has(hEvent)) {
                this.fractDec(this.getSelectedRadio(this.navRadios));
            }
            else if ((_g = this.config.comSwitchEvents) === null || _g === void 0 ? void 0 : _g.has(hEvent)) {
                this.swapFreqs(this.getSelectedRadio(this.comRadios));
            }
            else if ((_h = this.config.comSelectorEvents) === null || _h === void 0 ? void 0 : _h.has(hEvent)) {
                this.swapSelection(this.comRadios);
            }
            else if ((_j = this.config.comWholeIncEvents) === null || _j === void 0 ? void 0 : _j.has(hEvent)) {
                this.wholeInc(this.getSelectedRadio(this.comRadios));
            }
            else if ((_k = this.config.comWholeDecEvents) === null || _k === void 0 ? void 0 : _k.has(hEvent)) {
                this.wholeDec(this.getSelectedRadio(this.comRadios));
            }
            else if ((_l = this.config.comFractionIncEvents) === null || _l === void 0 ? void 0 : _l.has(hEvent)) {
                this.fractInc(this.getSelectedRadio(this.comRadios));
            }
            else if ((_m = this.config.comFractionDecEvents) === null || _m === void 0 ? void 0 : _m.has(hEvent)) {
                this.fractDec(this.getSelectedRadio(this.comRadios));
            }
        };
        this.bus = bus;
        this.config = config;
        // Populate our radio arrays.
        for (let i = 1; i <= numNavRadios; i++) {
            this.navRadios.push({
                index: i,
                activeFrequency: 0,
                ident: null,
                standbyFrequency: 0,
                radioType: RadioType.Nav,
                selected: false
            });
        }
        for (let i = 1; i <= numComRadios; i++) {
            this.comRadios.push({
                index: i,
                activeFrequency: 0,
                ident: null,
                standbyFrequency: 0,
                radioType: RadioType.Com,
                selected: false
            });
        }
        // Create our publishers and subscribers.
        this.hevents = this.bus.getSubscriber();
        this.publisher = new NavComPublisher(bus, undefined, sync);
        this.simVarPublisher = new NavComSimVarPublisher(this.bus);
        this.simVarSubscriber = new EventSubscriber(this.bus);
        this.controlSubscriber = bus.getSubscriber();
        // Subscribe to the simvars we need to monitor.
        this.simVarPublisher.subscribe('nav1ActiveFreq');
        this.simVarPublisher.subscribe('nav1StandbyFreq');
        this.simVarPublisher.subscribe('nav2ActiveFreq');
        this.simVarPublisher.subscribe('nav2StandbyFreq');
        this.simVarPublisher.subscribe('com1ActiveFreq');
        this.simVarPublisher.subscribe('com1StandbyFreq');
        this.simVarPublisher.subscribe('com2ActiveFreq');
        this.simVarPublisher.subscribe('com2StandbyFreq');
        this.simVarPublisher.subscribe('nav1Ident');
        this.simVarPublisher.subscribe('nav2Ident');
        this.simVarPublisher.subscribe('adf1ActiveFreq');
        this.simVarPublisher.subscribe('adf1StandbyFreq');
    }
    /**
     * Initialize the instrument.
     */
    init() {
        // Start our two publishers.
        this.publisher.startPublish();
        this.simVarPublisher.startPublish();
        // Set up our event handlers, for both H events and simvar updates.
        this.hevents.on('hEvent').handle(this.eventHandler);
        const navProcessorSubscriber = this.bus.getSubscriber();
        navProcessorSubscriber.on('cdi_select').handle(this.setActiveRadio.bind(this));
        this.controlSubscriber.on('publish_radio_states').handle(this.publishRadioStates.bind(this));
        this.controlSubscriber.on('standby_com_freq').handle(this.setStandbyFreq.bind(this, RadioType.Com));
        this.controlSubscriber.on('standby_nav_freq').handle(this.setStandbyFreq.bind(this, RadioType.Nav));
        this.simVarSubscriber.on('nav1ActiveFreq').whenChangedBy(0.01).handle((data) => {
            this.updateRadioFreqCb(RadioType.Nav, 0, FrequencyBank.Active, data);
        });
        this.simVarSubscriber.on('nav1StandbyFreq').whenChangedBy(0.01).handle((data) => {
            this.updateRadioFreqCb(RadioType.Nav, 0, FrequencyBank.Standby, data);
        });
        this.simVarSubscriber.on('nav2ActiveFreq').whenChangedBy(0.01).handle((data) => {
            this.updateRadioFreqCb(RadioType.Nav, 1, FrequencyBank.Active, data);
        });
        this.simVarSubscriber.on('nav2StandbyFreq').whenChangedBy(0.01).handle((data) => {
            this.updateRadioFreqCb(RadioType.Nav, 1, FrequencyBank.Standby, data);
        });
        this.simVarSubscriber.on('com1ActiveFreq').whenChangedBy(0.001).handle((data) => {
            this.updateRadioFreqCb(RadioType.Com, 0, FrequencyBank.Active, data);
        });
        this.simVarSubscriber.on('com1StandbyFreq').whenChangedBy(0.001).handle((data) => {
            this.updateRadioFreqCb(RadioType.Com, 0, FrequencyBank.Standby, data);
        });
        this.simVarSubscriber.on('com2ActiveFreq').whenChangedBy(0.001).handle((data) => {
            this.updateRadioFreqCb(RadioType.Com, 1, FrequencyBank.Active, data);
        });
        this.simVarSubscriber.on('com2StandbyFreq').whenChangedBy(0.001).handle((data) => {
            this.updateRadioFreqCb(RadioType.Com, 1, FrequencyBank.Standby, data);
        });
        this.simVarSubscriber.on('nav1Ident').whenChanged().handle((data) => {
            this.navRadios[0].ident = data;
            this.publisher.publishIdent(1, data);
        });
        this.simVarSubscriber.on('nav2Ident').whenChanged().handle((data) => {
            this.navRadios[1].ident = data;
            this.publisher.publishIdent(2, data);
        });
        this.simVarSubscriber.on('adf1ActiveFreq').whenChanged().handle((freq) => {
            this.publisher.publishAdfActiveFrequencySet(freq);
        });
        this.simVarSubscriber.on('adf1StandbyFreq').whenChanged().handle((freq) => {
            this.publisher.publishAdfStandbyFrequencySet(freq);
        });
        // Configure and publish the initial state of all our radios.
        this.navRadios[0].selected = true;
        this.comRadios[0].selected = true;
        for (let i = 0; i < this.navRadios.length; i++) {
            this.updateAndPublish(this.navRadios[i]);
        }
        for (let i = 0; i < this.comRadios.length; i++) {
            this.updateAndPublish(this.comRadios[i]);
        }
    }
    /**
     * Perform events for the update loop.
     */
    onUpdate() {
        // Currently, we just need to update our simvar publisher so it polls.
        this.simVarPublisher.onUpdate();
    }
    /**
     * Get the current frequency of a radio.
     * @param radioType The RadioType to query.
     * @param index The index number of the desired radio.
     * @param bank The FrequencyBank to query.
     * @returns The frequency in MHz.
     */
    getFrequency(radioType, index, bank) {
        return SimVar.GetSimVarValue(`${radioType == RadioType.Com ? 'COM' : 'NAV'} ${bank == FrequencyBank.Active ? 'ACTIVE' : 'STANDBY'} FREQUENCY:${index}`, 'MHz');
    }
    /**
     * React to a change on a radio frequency simvar.
     * @param type The RadioType to update.
     * @param index Index of the radio in the internal array.
     * @param bank The FrequencyBank in the selected radio to update.
     * @param freq The new frequency in MHz.
     */
    updateRadioFreqCb(type, index, bank, freq) {
        // Note: 'index' here is the index of the radio in our internal array,
        // not the device index.  This is confusing, and we should probably use
        // different words for each of the two data points.
        // TODO Disambigurate radio device number"index" from index in internal array.
        const radioArr = type == RadioType.Nav ? this.navRadios : this.comRadios;
        switch (bank) {
            case FrequencyBank.Active:
                radioArr[index].activeFrequency = freq;
                this.publisher.publishFreqChange(radioArr[index], FrequencyBank.Active, freq);
                break;
            case FrequencyBank.Standby:
                radioArr[index].standbyFrequency = freq;
                this.publisher.publishFreqChange(radioArr[index], FrequencyBank.Standby, freq);
                break;
        }
    }
    /**
     * Get the current selected radio in a collection of radios.
     * @param radios An array of Radios.
     * @returns The selected Radio in the array.
     */
    getSelectedRadio(radios) {
        for (const radio of radios) {
            if (radio.selected) {
                return radio;
            }
        }
        return undefined;
    }
    /**
     * Swap frequencies in a radio.
     * @param radio The radio whose frequencies we want to swap.
     */
    swapFreqs(radio) {
        if (radio !== undefined) {
            this.setKVar('SWAP', radio);
        }
    }
    /**
     * Update the frequencies in a radio from simvars.
     *
     * This is useful for snapshot updates as long as we're not worried
     * about one of the frequencies being updated while the snapshot is in
     * flight.
     * @param radio the radio to update
     */
    updateAndPublish(radio) {
        if (radio !== undefined) {
            radio.activeFrequency = this.getFrequency(radio.radioType, radio.index, FrequencyBank.Active);
            radio.standbyFrequency = this.getFrequency(radio.radioType, radio.index, FrequencyBank.Standby);
        }
        switch (radio === null || radio === void 0 ? void 0 : radio.radioType) {
            case RadioType.Com:
                this.comRadios[radio.index - 1] = radio;
                break;
            case RadioType.Nav:
                this.navRadios[radio.index - 1] = radio;
                break;
        }
        this.publisher.publishRadioState(radio);
    }
    /**
     * Explicitly set a new selected nav radio.
     * @param navSourceId An array of Radios to toggle.
     */
    setActiveRadio(navSourceId) {
        if (navSourceId.type === NavSourceType.Nav) {
            for (let i = 0; i < this.navRadios.length; i++) {
                const radio = this.navRadios[i];
                if (radio.index == navSourceId.index) {
                    radio.selected = true;
                }
                else {
                    radio.selected = false;
                }
                this.publisher.publishRadioState(radio);
            }
        }
    }
    /**
     * Set the standby frequency of the currently selected nav or com radio.
     * @param radioType The radio type we want to set standby for.
     * @param frequency The frequency in MHz as a string.
     */
    setStandbyFreq(radioType, frequency) {
        let radio;
        switch (radioType) {
            case RadioType.Com:
                radio = this.getSelectedRadio(this.comRadios);
                break;
            case RadioType.Nav:
                radio = this.getSelectedRadio(this.navRadios);
                break;
        }
        this.freqSet(radio, FrequencyBank.Standby, frequency);
    }
    /**
     * Toggle which of the radios is selected.
     * @param radios An array of Radios to toggle.
     */
    swapSelection(radios) {
        // TODO It would be nice to extend this to handle systems with more than 2 radios
        for (let i = 0; i < radios.length; i++) {
            radios[i].selected = !radios[i].selected;
            this.publisher.publishRadioState(radios[i]);
        }
    }
    /**
     * Increase the integer portion of a frequency.
     * @param radio The Radio to update.
     */
    wholeInc(radio) {
        this.setKVar('WHOLE_INC', radio);
    }
    /**
     * Decrease the integer portion of a frequency.
     * @param radio The Radio to update.
     */
    wholeDec(radio) {
        this.setKVar('WHOLE_DEC', radio);
    }
    /**
     * Increase the decimal portion of a frequency.
     * @param radio The Radio to update.
     */
    fractInc(radio) {
        this.setKVar('FRACT_INC', radio);
    }
    /**
     * Decrease the decimal portion of a frequency.
     * @param radio The Radio to update.
     */
    fractDec(radio) {
        this.setKVar('FRACT_DEC', radio);
    }
    /**
     * Set the full frequency of a radio.
     * @param radio The Radio to update.
     * @param bank The FrequencyBank to update.
     * @param freq The new frequency in MHz as a string.
     */
    freqSet(radio, bank, freq) {
        if (!radio) {
            return;
        }
        let radioId;
        if (radio.radioType == RadioType.Com) {
            const first = radio.index == 1 ? 'COM' : `COM${radio.index}`;
            const second = bank == FrequencyBank.Active ? 'RADIO' : 'STBY_RADIO';
            radioId = `${first}_${second}`;
        }
        else {
            radioId = `NAV${radio.index}_${bank == FrequencyBank.Active ? 'RADIO' : 'STBY'}`;
        }
        SimVar.SetSimVarValue(`K:${radioId}_SET`, 'Frequency BCD16', Avionics.Utils.make_bcd16(parseFloat(freq) * 1000000));
    }
    /**
     * Set the K var for a frequency event
     * @param action A string defining whole/fract and inc/dec.
     * @param radio The radio this frequency is for.
     */
    setKVar(action, radio) {
        if (radio == undefined) {
            return;
        }
        let device;
        switch (radio.radioType) {
            case RadioType.Nav:
                device = `NAV${radio.index}`;
                break;
            case RadioType.Com:
                if (action == 'SWAP') {
                    // Com radios break the naming pattern for swap events. :(
                    device = radio.index == 1 ? 'COM_STBY' : `COM${radio.index}`;
                }
                else {
                    device = radio.index == 1 ? 'COM' : `COM${radio.index}`;
                }
                break;
            default: // this should never happen
                return;
        }
        SimVar.SetSimVarValue(`K:${device}_RADIO_${action}`, 'number', 0);
    }
    /**
     * Send an update of all our radio states.
     * @param data True if we really want to do this.  (We need to support non-paramaterized commands.())
     */
    publishRadioStates(data) {
        if (!data) {
            return;
        }
        for (const radio of this.navRadios) {
            this.publisher.publishRadioState(radio);
        }
        for (const radio of this.comRadios) {
            this.publisher.publishRadioState(radio);
        }
    }
}

/// <reference types="msfstypes/JS/simvar" />
var APLockType;
(function (APLockType) {
    APLockType[APLockType["Heading"] = 0] = "Heading";
    APLockType[APLockType["Nav"] = 1] = "Nav";
    APLockType[APLockType["Alt"] = 2] = "Alt";
    APLockType[APLockType["Bank"] = 3] = "Bank";
    APLockType[APLockType["WingLevel"] = 4] = "WingLevel";
    APLockType[APLockType["Vs"] = 5] = "Vs";
    APLockType[APLockType["Flc"] = 6] = "Flc";
    APLockType[APLockType["Pitch"] = 7] = "Pitch";
    APLockType[APLockType["Approach"] = 8] = "Approach";
    APLockType[APLockType["Backcourse"] = 9] = "Backcourse";
    APLockType[APLockType["Glideslope"] = 10] = "Glideslope";
    APLockType[APLockType["VNav"] = 11] = "VNav";
})(APLockType || (APLockType = {}));
/** base publisher for simvars */
class APSimVarPublisher extends SimVarPublisher {
    /**
     * Create an APSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(APSimVarPublisher.simvars, bus, pacer);
    }
}
APSimVarPublisher.simvars = new Map([
    // TODO extend the next two to handle multiple APs?
    ['selected_heading', { name: 'AUTOPILOT HEADING LOCK DIR:1', type: SimVarValueType.Degree }],
    ['selected_altitude', { name: 'AUTOPILOT ALTITUDE LOCK VAR:1', type: SimVarValueType.Feet }],
    ['ap_master_status', { name: 'AUTOPILOT MASTER', type: SimVarValueType.Bool }],
    ['ap_heading_lock', { name: 'AUTOPILOT HEADING LOCK', type: SimVarValueType.Bool }],
    ['ap_nav_lock', { name: 'AUTOPILOT NAV1 LOCK', type: SimVarValueType.Bool }],
    ['ap_bank_hold', { name: 'AUTOPILOT BANK HOLD', type: SimVarValueType.Bool }],
    ['ap_wing_lvl', { name: 'AUTOPILOT WING LEVELER', type: SimVarValueType.Bool }],
    ['ap_approach_hold', { name: 'AUTOPILOT APPROACH HOLD', type: SimVarValueType.Bool }],
    ['ap_backcourse_hold', { name: 'AUTOPILOT BACKCOURSE HOLD', type: SimVarValueType.Bool }],
    ['ap_vs_hold', { name: 'AUTOPILOT VERTICAL HOLD', type: SimVarValueType.Bool }],
    ['ap_flc_hold', { name: 'AUTOPILOT FLIGHT LEVEL CHANGE', type: SimVarValueType.Bool }],
    ['ap_alt_lock', { name: 'AUTOPILOT ALTITUDE LOCK', type: SimVarValueType.Bool }],
    ['ap_glideslope_hold', { name: 'AUTOPILOT GLIDESLOPE HOLD', type: SimVarValueType.Bool }],
    ['ap_pitch_hold', { name: 'AUTOPILOT PITCH HOLD', type: SimVarValueType.Bool }],
    ['vs_hold_fpm', { name: 'AUTOPILOT VERTICAL HOLD VAR:1', type: SimVarValueType.FPM }],
    ['flc_hold_knots', { name: 'AUTOPILOT AIRSPEED HOLD VAR', type: SimVarValueType.Knots }],
    ['flight_director_bank', { name: 'AUTOPILOT FLIGHT DIRECTOR BANK', type: SimVarValueType.Degree }],
    ['flight_director_pitch', { name: 'AUTOPILOT FLIGHT DIRECTOR PITCH', type: SimVarValueType.Degree }],
    ['flight_director_lock', { name: 'AUTOPILOT FLIGHT DIRECTOR ACTIVE', type: SimVarValueType.Bool }],
    ['vnav_active', { name: 'L:XMLVAR_VNAVButtonValue', type: SimVarValueType.Bool }],
    ['alt_lock', { name: 'AUTOPILOT ALTITUDE LOCK', type: SimVarValueType.Bool }],
    ['pitch_ref', { name: 'AUTOPILOT PITCH HOLD REF', type: SimVarValueType.Degree }],
    ['kap_140_simvar', { name: 'L:WT1000_AP_KAP140_INSTALLED', type: SimVarValueType.Bool }]
]);
/**
 * Publishes autopilot data
 */
class AutopilotPublisher extends BasePublisher {
    /**
     * Creates an AutopilotPublisher
     * @param bus The event bus to publish to.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
        super(bus, pacer);
    }
    /**
     * Publish an AP master engage event
     */
    publishMasterEngage() {
        this.publish('ap_master_engage', true);
    }
    /**
     * Publish an AP master disengage event
     */
    publishMasterDisengage() {
        this.publish('ap_master_disengage', true);
    }
    /**
     * Publish a selected alt change
     * @param newAlt The new selected altitude.
     */
    publishAltChange(newAlt) {
        this.publish('alt_select', newAlt);
    }
    /**
     * Publish a selected hdg change
     * @param newHdg The new selected heading.
     */
    publishHdgChange(newHdg) {
        this.publish('heading_select', newHdg);
    }
    /**
     * Publish a selected vs change
     * @param newVs The new selected vs.
     */
    publishVsChange(newVs) {
        this.publish('vs_hold_fpm', newVs);
    }
    /**
     * Publish a selected flc ias change
     * @param newIas The new selected ias.
     */
    publishFlcIasChange(newIas) {
        this.publish('flc_hold_knots', newIas);
    }
    /**
     * Publish a lock set event
     * @param lock The lock/hold set
     */
    publishLockSet(lock) {
        this.publish('ap_lock_set', lock);
    }
    /**
     * Publish a lock release event
     * @param lock The lock/hold released
     */
    publishLockRelease(lock) {
        this.publish('ap_lock_release', lock);
    }
    /**
     * Publish a pitch ref value.
     * @param newPitch The new commanded pitch angle.
     */
    publishPitchRefChange(newPitch) {
        this.publish('pitch_ref', newPitch);
    }
    /**
     * Publish a flight director pitch value.
     * @param newPitch The new commanded pitch angle.
     */
    publishFlightDirectorPitchChange(newPitch) {
        this.publish('flight_director_pitch', newPitch);
    }
    /**
     * Publish a flight director bank value
     * @param newBank The new commanded bank angle.
     */
    publishFlightDirectorBankChange(newBank) {
        this.publish('flight_director_bank', newBank);
    }
    /**
     * Publish an FD lock event
     * @param state is the flight director state (true = on, false = off).
     */
    publishFlightDirectorState(state) {
        this.publish('flight_director_state', state);
    }
    /**
     * Publish alt lock
     * @param locked is if it is locked.
     */
    publishAltLock(locked) {
        this.publish('alt_lock', locked);
    }
    /**
     * Publish KAP140 Installed State
     * @param state is the state of the simvar.
     */
    publishKAP140State(state) {
        this.publish('kap_140_installed', state);
    }
}
/**
 * Manages an autopilot system
 */
class AutopilotInstrument {
    /**
     * Create an AutopilotInstrument
     * @param bus The event bus to publish to
     */
    constructor(bus) {
        this.bus = bus;
        // this.hEvents = this.bus.getSubscriber<HEvent>();
        this.publisher = new AutopilotPublisher(bus);
        this.simVarPublisher = new APSimVarPublisher(bus);
        this.simVarSubscriber = new EventSubscriber(bus);
        this.simVarPublisher.subscribe('ap_master_status');
        this.simVarPublisher.subscribe('selected_altitude');
        this.simVarPublisher.subscribe('selected_heading');
        this.simVarPublisher.subscribe('ap_alt_lock');
        this.simVarPublisher.subscribe('ap_bank_hold');
        this.simVarPublisher.subscribe('ap_wing_lvl');
        this.simVarPublisher.subscribe('ap_flc_hold');
        this.simVarPublisher.subscribe('ap_heading_lock');
        this.simVarPublisher.subscribe('ap_nav_lock');
        this.simVarPublisher.subscribe('ap_approach_hold');
        this.simVarPublisher.subscribe('ap_backcourse_hold');
        this.simVarPublisher.subscribe('ap_pitch_hold');
        this.simVarPublisher.subscribe('ap_glideslope_hold');
        this.simVarPublisher.subscribe('ap_vs_hold');
        this.simVarPublisher.subscribe('vs_hold_fpm');
        this.simVarPublisher.subscribe('flc_hold_knots');
        this.simVarPublisher.subscribe('flight_director_bank');
        this.simVarPublisher.subscribe('flight_director_pitch');
        this.simVarPublisher.subscribe('flight_director_lock');
        this.simVarPublisher.subscribe('vnav_active');
        this.simVarPublisher.subscribe('alt_lock');
        this.simVarPublisher.subscribe('pitch_ref');
        this.simVarPublisher.subscribe('kap_140_simvar');
    }
    /**
     * Initialize the instrument
     */
    init() {
        this.publisher.startPublish();
        this.simVarPublisher.startPublish();
        console.log('initting autopilot');
        this.simVarSubscriber.on('ap_master_status').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishMasterEngage();
            }
            else {
                this.publisher.publishMasterDisengage();
            }
        });
        this.simVarSubscriber.on('selected_altitude').whenChangedBy(1).handle((newAlt) => {
            this.publisher.publishAltChange(newAlt);
        });
        this.simVarSubscriber.on('selected_heading').whenChangedBy(1).handle((newHdg) => {
            this.publisher.publishHdgChange(newHdg);
        });
        this.simVarSubscriber.on('vs_hold_fpm').whenChangedBy(1).handle((newVs) => {
            this.publisher.publishVsChange(newVs);
        });
        this.simVarSubscriber.on('flc_hold_knots').whenChangedBy(1).handle((newIas) => {
            this.publisher.publishFlcIasChange(newIas);
        });
        this.simVarSubscriber.on('ap_alt_lock').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Alt);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Alt);
            }
        });
        this.simVarSubscriber.on('ap_pitch_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Pitch);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Pitch);
            }
        });
        this.simVarSubscriber.on('ap_heading_lock').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Heading);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Heading);
            }
        });
        this.simVarSubscriber.on('ap_nav_lock').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Nav);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Nav);
            }
        });
        this.simVarSubscriber.on('ap_approach_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Approach);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Approach);
            }
        });
        this.simVarSubscriber.on('ap_backcourse_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Backcourse);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Backcourse);
            }
        });
        this.simVarSubscriber.on('ap_bank_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Bank);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Bank);
            }
        });
        this.simVarSubscriber.on('ap_wing_lvl').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.WingLevel);
            }
            else {
                this.publisher.publishLockRelease(APLockType.WingLevel);
            }
        });
        this.simVarSubscriber.on('ap_flc_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Flc);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Flc);
            }
        });
        this.simVarSubscriber.on('ap_vs_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Vs);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Vs);
            }
        });
        this.simVarSubscriber.on('ap_glideslope_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Glideslope);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Glideslope);
            }
        });
        this.simVarSubscriber.on('flight_director_bank').whenChangedBy(.25).handle((newBank) => {
            this.publisher.publishFlightDirectorBankChange(newBank);
        });
        this.simVarSubscriber.on('flight_director_pitch').whenChangedBy(.25).handle((newPitch) => {
            this.publisher.publishFlightDirectorPitchChange(newPitch);
        });
        this.simVarSubscriber.on('flight_director_lock').whenChanged().handle((state) => {
            this.publisher.publishFlightDirectorState(state);
        });
        this.simVarSubscriber.on('vnav_active').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.VNav);
            }
            else {
                this.publisher.publishLockRelease(APLockType.VNav);
            }
        });
        this.simVarSubscriber.on('alt_lock').whenChanged().handle((lock) => {
            this.publisher.publishAltLock(lock);
        });
        this.simVarSubscriber.on('pitch_ref').whenChangedBy(0.1).handle((val) => {
            this.publisher.publishPitchRefChange(val);
        });
        this.simVarSubscriber.on('kap_140_simvar').whenChanged().handle((val) => {
            this.publisher.publishKAP140State(val);
        });
    }
    /** update our publishers */
    onUpdate() {
        this.simVarPublisher.onUpdate();
    }
}

/// <reference types="msfstypes/JS/simvar" />
/**
 * A publisher for Engine information.
 */
class EISPublisher extends SimVarPublisher {
    /**
     * Create an ADCPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        super(EISPublisher.simvars, bus, pacer);
    }
}
EISPublisher.simvars = new Map([
    ['rpm_1', { name: 'GENERAL ENG RPM:1', type: SimVarValueType.RPM }],
    ['recip_ff_1', { name: 'RECIP ENG FUEL FLOW:1', type: SimVarValueType.PPH }],
    ['oil_press_1', { name: 'ENG OIL PRESSURE:1', type: SimVarValueType.PSI }],
    ['oil_temp_1', { name: 'ENG OIL TEMPERATURE:1', type: SimVarValueType.Farenheit }],
    ['egt_1', { name: 'ENG EXHAUST GAS TEMPERATURE:1', type: SimVarValueType.Farenheit }],
    ['vac', { name: 'SUCTION PRESSURE', type: SimVarValueType.InHG }],
    ['fuel_left', { name: 'FUEL LEFT QUANTITY', type: SimVarValueType.GAL }],
    ['fuel_right', { name: 'FUEL RIGHT QUANTITY', type: SimVarValueType.GAL }],
    ['eng_hours_1', { name: 'GENERAL ENG ELAPSED TIME:1', type: SimVarValueType.Hours }],
    ['elec_bus_main_v', { name: 'ELECTRICAL MAIN BUS VOLTAGE', type: SimVarValueType.Volts }],
    ['elec_bus_main_a', { name: 'ELECTRICAL MAIN BUS AMPS', type: SimVarValueType.Amps }],
    ['elec_bus_avionics_v', { name: 'ELECTRICAL AVIONICS BUS VOLTAGE', type: SimVarValueType.Volts }],
    ['elec_bus_avionics_a', { name: 'ELECTRICAL AVIONICS BUS AMPS', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_1_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:1', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_1_a', { name: 'ELECTRICAL GENALT BUS AMPS:1', type: SimVarValueType.Amps }],
    ['elec_bat_a', { name: 'ELECTRICAL BATTERY LOAD', type: SimVarValueType.Amps }],
    ['elec_bat_v', { name: 'ELECTRICAL BATTERY VOLTAGE', type: SimVarValueType.Volts }]
]);

/**
 * A publisher of clock events.
 */
class ClockPublisher extends BasePublisher {
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdate() {
        this.publish('realTime', Date.now());
        this.publish('simTime', ClockPublisher.absoluteTimeToUNIXTime(SimVar.GetSimVarValue('E:ABSOLUTE TIME', 'seconds')));
    }
    /**
     * Converts the sim's absolute time to a UNIX timestamp. The sim's absolute time value is equivalent to a .NET
     * DateTime.Ticks value (epoch = 00:00:00 01 Jan 0001).
     * @param absoluteTime an absolute time value, in units of seconds.
     * @returns the UNIX timestamp corresponding to the absolute time value.
     */
    static absoluteTimeToUNIXTime(absoluteTime) {
        return (absoluteTime - 62135596800) * 1000;
    }
}
/**
 * A clock which keeps track of real-world and sim time.
 */
class Clock {
    /**
     * Constructor.
     * @param bus The event bus to use to publish events from this clock.
     */
    constructor(bus) {
        this.publisher = new ClockPublisher(bus);
    }
    /**
     * Initializes this clock.
     */
    init() {
        this.publisher.startPublish();
    }
    /**
     * Updates this clock.
     */
    onUpdate() {
        this.publisher.onUpdate();
    }
}

/** Transponder modes. */
var XPDRMode;
(function (XPDRMode) {
    XPDRMode[XPDRMode["OFF"] = 0] = "OFF";
    XPDRMode[XPDRMode["STBY"] = 1] = "STBY";
    XPDRMode[XPDRMode["TEST"] = 2] = "TEST";
    XPDRMode[XPDRMode["ON"] = 3] = "ON";
    XPDRMode[XPDRMode["ALT"] = 4] = "ALT";
    XPDRMode[XPDRMode["GROUND"] = 5] = "GROUND";
})(XPDRMode || (XPDRMode = {}));
/** A publiher to poll transponder simvars. */
class XPDRSimVarPublisher extends SimVarPublisher {
    /**
     * Create an XPDRSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(XPDRSimVarPublisher.simvars, bus, pacer);
    }
}
XPDRSimVarPublisher.simvars = new Map([
    ['xpdrMode1', { name: 'TRANSPONDER STATE:1', type: SimVarValueType.Number }],
    ['xpdrCode1', { name: 'TRANSPONDER CODE:1', type: SimVarValueType.Number }],
    ['xpdrIdent', { name: 'TRANSPONDER IDENT:1', type: SimVarValueType.Bool }]
]);
/** A transponder. */
class XPDRInstrument {
    /**
     * Create an XPDRInstrument.
     * @param bus The event bus to publish to.
     */
    constructor(bus) {
        this.bus = bus;
        this.isSendingIdent = false;
        this.bus = bus;
        this.simVarPublisher = new XPDRSimVarPublisher(bus);
        this.controlSubscriber = bus.getSubscriber();
        this.simVarPublisher.subscribe('xpdrCode1');
        this.simVarPublisher.subscribe('xpdrMode1');
        this.simVarPublisher.subscribe('xpdrIdent');
    }
    /** Initialize the instrument. */
    init() {
        this.simVarPublisher.startPublish();
        this.controlSubscriber.on('publish_xpdr_code').handle(this.setXpdrCode.bind(this));
        this.controlSubscriber.on('publish_xpdr_mode').handle(this.setXpdrMode.bind(this));
        this.controlSubscriber.on('xpdr_send_ident').handle(this.sendIdent.bind(this));
        // force standby on plane load when off
        if (this.getXpdrMode() === XPDRMode.OFF) {
            this.setXpdrMode(XPDRMode.STBY);
        }
    }
    /**
     * Perform events for the update loop.
     */
    onUpdate() {
        // Currently, we just need to update our simvar publisher so it polls.
        this.simVarPublisher.onUpdate();
    }
    /**
     * Set the XPDR code in the sim.
     * @param code The xpdr code.
     */
    setXpdrCode(code) {
        const bcdCode = Avionics.Utils.make_xpndr_bcd16(code);
        SimVar.SetSimVarValue('K:XPNDR_SET', 'Frequency BCD16', bcdCode);
    }
    /**
     * Set the xpdr mode in the sim.
     * @param mode The xpdr mode..
     */
    setXpdrMode(mode) {
        SimVar.SetSimVarValue('TRANSPONDER STATE:1', 'number', mode);
    }
    /**
     * Gets xpdr mode from the sim.
     * @returns the xpdr mode
     */
    getXpdrMode() {
        return SimVar.GetSimVarValue('TRANSPONDER STATE:1', 'number');
    }
    /**
     * Sends ident to ATC for 18 seconds.
     */
    sendIdent() {
        if (this.getXpdrMode() > XPDRMode.STBY) {
            this.isSendingIdent = true;
            SimVar.SetSimVarValue('K:XPNDR_IDENT_ON', 'number', 1);
            setTimeout(() => {
                this.isSendingIdent = false;
                SimVar.SetSimVarValue('K:XPNDR_IDENT_OFF', 'number', 0);
            }, 18000);
        }
    }
}

/**
 * Tracks aircraft traffic. Maintains a list of contacts, periodically updates their position, altitude, and reported
 * heading, and uses these data to compute ground speed, ground track, and vertical speed.
 */
class TrafficInstrument {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param options Options with which to initialize this instrument.
     */
    constructor(bus, options) {
        this.bus = bus;
        this.tracked = new Map();
        this.lastUpdateRealTime = 0;
        this.lastUpdateSimTime = 0;
        this.isBusy = false;
        this.options = Object.assign({}, options);
    }
    /**
     * Retrieves a traffic contact by its assigned ID number.
     * @param uid an ID number.
     * @returns the traffic contact with the assigned ID number, or undefined if no such contact exists.
     */
    getContact(uid) {
        return this.tracked.get(uid);
    }
    /**
     * Iterates through all tracked traffic contacts with a visitor function.
     * @param visitor A visitor function.
     */
    forEachContact(visitor) {
        this.tracked.forEach(visitor);
    }
    /**
     * Initializes this instrument. Once initialized, this instrument will automatically track and update traffic
     * contacts.
     */
    init() {
        this.bus.getSubscriber()
            .on('simTime')
            .whenChanged()
            .handle(this.onSimTimeChanged.bind(this));
    }
    /**
     * Updates this instrument's list of contacts.
     * @param data An array of the most recent traffic data entries.
     * @param simTime The sim time at which the traffic data was generated.
     */
    updateContacts(data, simTime) {
        const len = data.length;
        for (let i = 0; i < len; i++) {
            const entry = data[i];
            const contact = this.tracked.get(entry.uId);
            if (contact) {
                this.updateContact(contact, entry, simTime);
            }
            else {
                this.createContact(entry, simTime);
            }
        }
    }
    /**
     * Creates a contact.
     * @param entry The traffic data entry from which to create the new contact.
     * @param simTime The sim time at which the traffic data entry was generated.
     */
    createContact(entry, simTime) {
        const contact = new TrafficContactClass(entry.uId, 1000 / this.options.simTimeUpdateFreq * 5);
        this.tracked.set(contact.uid, contact);
        contact.update(entry.lat, entry.lon, UnitType.METER.convertTo(entry.alt, UnitType.FOOT), entry.heading, simTime);
        this.bus.pub('traffic_contact_added', contact.uid, false, false);
    }
    /**
     * Updates a contact.
     * @param contact The contact to update.
     * @param entry The current traffic data entry for the contact.
     * @param simTime The sim time at which the traffic data entry was generated.
     */
    updateContact(contact, entry, simTime) {
        contact.update(entry.lat, entry.lon, UnitType.METER.convertTo(entry.alt, UnitType.FOOT), entry.heading, simTime);
        this.bus.pub('traffic_contact_updated', contact.uid, false, false);
    }
    /**
     * Removes all contacts whose time since last contact exceeds the deprecation threshold.
     * @param simTime The current sim time.
     */
    deprecateContacts(simTime) {
        this.tracked.forEach(contact => {
            const dt = Math.abs(simTime - contact.lastContactTime);
            if (dt >= this.options.contactDeprecateTime) {
                this.tracked.delete(contact.uid);
                this.bus.pub('traffic_contact_removed', contact.uid, false, false);
            }
        });
    }
    /**
     * A callback which is called when the sim time changes.
     * @param simTime The current sim time.
     */
    async onSimTimeChanged(simTime) {
        const realTime = Date.now();
        if (this.isBusy
            || Math.abs(simTime - this.lastUpdateSimTime) < 1000 / this.options.simTimeUpdateFreq
            || Math.abs(realTime - this.lastUpdateRealTime) < 1000 / this.options.realTimeUpdateFreq) {
            return;
        }
        this.isBusy = true;
        try {
            const data = await Promise.race([Coherent.call('GET_AIR_TRAFFIC'), Wait.awaitDelay(1000)]);
            if (data) {
                this.updateContacts(data, simTime);
                this.deprecateContacts(simTime);
                this.lastUpdateSimTime = simTime;
                this.lastUpdateRealTime = realTime;
            }
        }
        catch (e) {
            console.error(e);
            if (e instanceof Error) {
                console.log(e.stack);
            }
        }
        this.isBusy = false;
    }
    /**
     * This method does nothing.
     */
    onUpdate() {
        // noop
    }
}
/**
 * An aircraft contact that is being tracked. Each contact tracks its last reported position, altitude, and heading.
 * Successively updating these values will allow ground speed, ground track, and vertical speed to be calculated based
 * on changes in the values over time. The calculated values are exponentially smoothed to reduce artifacts from
 * potentially noisy data.
 */
class TrafficContactClass {
    /**
     * Constructor.
     * @param uid This contact's unique ID number.
     * @param contactTimeResetThreshold The maximum allowed elapsed sim time, in milliseconds, since time of last contact
     * before this contact's computed values are reset.
     */
    constructor(uid, contactTimeResetThreshold) {
        this.uid = uid;
        this.contactTimeResetThreshold = contactTimeResetThreshold;
        // reported data
        this._lastPosition = new GeoPoint(NaN, NaN);
        this.lastPosition = this._lastPosition.readonly;
        this._lastAltitude = UnitType.FOOT.createNumber(NaN);
        this.lastAltitude = this._lastAltitude.readonly;
        this._lastHeading = NaN;
        this._lastContactTime = NaN;
        // computed data
        this._groundSpeed = UnitType.KNOT.createNumber(NaN);
        this.groundSpeed = this._groundSpeed.readonly;
        this._groundTrack = NaN;
        this._verticalSpeed = UnitType.FPM.createNumber(NaN);
        this.verticalSpeed = this._verticalSpeed.readonly;
        this.groundSpeedSmoother = new ExpSmoother(TrafficContactClass.GROUND_SPEED_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1000);
        this.groundTrackSmoother = new ExpSmoother(TrafficContactClass.GROUND_TRACK_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1000);
        this.verticalSpeedSmoother = new ExpSmoother(TrafficContactClass.VERTICAL_SPEED_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1000);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get lastHeading() {
        return this._lastHeading;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get lastContactTime() {
        return this._lastContactTime;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get groundTrack() {
        return this._groundTrack;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    predict(simTime, positionOut, altitudeOut) {
        if (this.groundSpeed.isNaN()) {
            positionOut.set(NaN, NaN);
            altitudeOut.set(NaN);
            return;
        }
        const dt = simTime - this.lastContactTime;
        const distance = UnitType.NMILE.convertTo(this._groundSpeed.number * (dt / 3600000), UnitType.GA_RADIAN);
        this._lastPosition.offset(this._groundTrack, distance, positionOut);
        const deltaAlt = this._verticalSpeed.number * (dt / 60000);
        this._lastAltitude.add(deltaAlt, UnitType.FOOT, altitudeOut);
    }
    /**
     * Updates this contact with the current reported position, altitude and heading. Also updates the computed ground
     * speed, ground track, and vertical speed if there are sufficient data to do so.
     * @param lat The current reported latitude.
     * @param lon The current reported longitude.
     * @param altitude The current reported altitude, in feet.
     * @param heading The current reported heading.
     * @param simTime The current sim time.
     */
    update(lat, lon, altitude, heading, simTime) {
        const dt = simTime - this._lastContactTime;
        if (!isNaN(dt) && (dt < 0 || dt > this.contactTimeResetThreshold)) {
            this.reset(lat, lon, altitude, heading, simTime);
            return;
        }
        if (!isNaN(dt) && dt > 0) {
            this.updateComputedValues(dt / 1000, lat, lon, altitude);
        }
        this.setReportedValues(lat, lon, altitude, heading);
        if (this.areComputedValuesValid()) {
            this._lastContactTime = simTime;
        }
        else {
            this.reset(lat, lon, altitude, heading, simTime);
        }
    }
    /**
     * Erases this contact's tracking history and sets the initial reported position, altitude, and heading.
     * @param lat The current reported latitude.
     * @param lon The current reported longitude.
     * @param altitude The current reported altitude, in feet.
     * @param heading The current reported heading.
     * @param simTime The current sim time.
     */
    reset(lat, lon, altitude, heading, simTime) {
        this.setReportedValues(lat, lon, altitude, heading);
        this._groundSpeed.set(NaN);
        this._groundTrack = NaN;
        this._verticalSpeed.set(NaN);
        this.groundSpeedSmoother.reset();
        this.groundTrackSmoother.reset();
        this.verticalSpeedSmoother.reset();
        this._lastContactTime = simTime;
    }
    /**
     * Sets the most recent reported values.
     * @param lat The reported latitude.
     * @param lon The reported longitude.
     * @param altitude The reported altitude, in feet.
     * @param heading The reported heading.
     */
    setReportedValues(lat, lon, altitude, heading) {
        this._lastPosition.set(lat, lon);
        this._lastAltitude.set(altitude);
        this._lastHeading = heading;
    }
    /**
     * Updates this contact's computed values.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param lat The current reported latitude.
     * @param lon The current reported longitude.
     * @param altitude The current reported altitude, in feet.
     */
    updateComputedValues(dt, lat, lon, altitude) {
        const pos = TrafficContactClass.tempGeoPoint.set(lat, lon);
        const distanceNM = UnitType.GA_RADIAN.convertTo(this.lastPosition.distance(pos), UnitType.NMILE);
        const track = pos.bearingFrom(this._lastPosition);
        this.updateGroundSpeed(dt, distanceNM);
        this.updateGroundTrack(dt, track, distanceNM);
        this.updateVerticalSpeed(dt, altitude);
    }
    /**
     * Updates this contact's ground speed.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param distanceNM The distance, in nautical miles, from this contact's position at last contact to this contact's
     * current reported position.
     */
    updateGroundSpeed(dt, distanceNM) {
        const dtHours = dt / 3600;
        const speedKnots = distanceNM / dtHours;
        this._groundSpeed.set(this.groundSpeedSmoother.next(speedKnots, dt));
    }
    /**
     * Updates this contact's ground track.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param track The true ground track from this contact's position at last contact to this contact's current reported
     * position, as measured at the current reported position.
     * @param distanceNM The distance, in nautical miles, from this contact's position at last contact to this contact's
     * current reported position.
     */
    updateGroundTrack(dt, track, distanceNM) {
        const last = this.groundTrackSmoother.last();
        if (distanceNM >= TrafficContactClass.MIN_GROUND_TRACK_DISTANCE) {
            if (last !== null && !isNaN(last)) {
                // need to handle wraparounds
                let delta = track - last;
                if (delta > 180) {
                    delta = delta - 360;
                }
                else if (delta < -180) {
                    delta = delta + 360;
                }
                track = last + delta;
            }
        }
        else {
            // if distance between current and last position is too small, computed ground track will be unreliable
            // (and if distance = 0 the track will be meaningless), so we just copy forward the last computed track,
            // or NaN if there is no previously computed track
            track = last === null ? NaN : last;
        }
        const next = last !== null && isNaN(last) ? this.groundTrackSmoother.reset(track) : this.groundTrackSmoother.next(track, dt);
        this._groundTrack = (next + 360) % 360; // enforce range 0-359
    }
    /**
     * Updates this contact's vertical speed.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param altitude The current reported altitude, in feet.
     */
    updateVerticalSpeed(dt, altitude) {
        const dtMin = dt / 60;
        const deltaAltFeet = altitude - this._lastAltitude.number;
        const vsFPM = deltaAltFeet / dtMin;
        this._verticalSpeed.set(this.verticalSpeedSmoother.next(vsFPM, dt));
    }
    /**
     * Checks whether this contact's calculated ground speed and vertical speeds are valid.
     * @returns whether this contact's calculated ground speed and vertical speeds are valid.
     */
    areComputedValuesValid() {
        const isGroundSpeedValid = this._groundSpeed.isNaN() || this._groundSpeed.number <= TrafficContactClass.MAX_VALID_GROUND_SPEED;
        const isVerticalSpeedValid = this._verticalSpeed.isNaN() || this._verticalSpeed.number <= TrafficContactClass.MAX_VALID_VERTICAL_SPEED;
        return isGroundSpeedValid && isVerticalSpeedValid;
    }
}
TrafficContactClass.GROUND_SPEED_TIME_CONSTANT = 2 / Math.LN2;
TrafficContactClass.GROUND_TRACK_TIME_CONSTANT = 2 / Math.LN2;
TrafficContactClass.VERTICAL_SPEED_TIME_CONSTANT = 2 / Math.LN2;
TrafficContactClass.MAX_VALID_GROUND_SPEED = 1500; // knots
TrafficContactClass.MAX_VALID_VERTICAL_SPEED = 10000; // fpm
TrafficContactClass.MIN_GROUND_TRACK_DISTANCE = 10 / 1852; // nautical miles
TrafficContactClass.tempGeoPoint = new GeoPoint(0, 0);

/**
 * Utility class for working with flight path calculations.
 */
class FlightPathUtils {
    /**
     * Creates an empty arc vector.
     * @returns An empty arc vector.
     */
    static createEmptyCircleVector() {
        return {
            vectorType: 'circle',
            radius: 0,
            centerX: 1,
            centerY: 0,
            centerZ: 0,
            startLat: 0,
            startLon: 0,
            endLat: 0,
            endLon: 0,
            distance: 0
        };
    }
    /**
     * Checks whether a circle vector describes a great-circle path.
     * @param vector A flight path circle vector.
     * @returns Whether the vector describes a great-circle path.
     */
    static isVectorGreatCircle(vector) {
        return vector.radius === Math.PI / 2;
    }
    /**
     * Sets the parameters of a GeoCircle from a flight path circle vector.
     * @param vector A flight path circle vector.
     * @param out The GeoCircle to set.
     * @returns The GeoCircle, after its parameters have been set.
     */
    static setGeoCircleFromVector(vector, out) {
        return out.set(Vec3Math.set(vector.centerX, vector.centerY, vector.centerZ, FlightPathUtils.vec3Cache[0]), vector.radius);
    }
    /**
     * Gets the initial true course bearing of a flight path vector.
     * @param vector A flight path vector.
     * @returns The initial true course bearing of the vector, or undefined if one could not be calculated.
     */
    static getVectorInitialCourse(vector) {
        return FlightPathUtils.setGeoCircleFromVector(vector, FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.startLat, vector.startLon), Math.PI);
    }
    /**
     * Gets the final true course bearing of a flight path vector.
     * @param vector A flight path vector.
     * @returns The final true course bearing of the vector, or undefined if one could not be calculated.
     */
    static getVectorFinalCourse(vector) {
        return FlightPathUtils.setGeoCircleFromVector(vector, FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.endLat, vector.endLon), Math.PI);
    }
    /**
     * Gets the final position of a calculated leg.
     * @param legCalc A set of leg calculations.
     * @param out The GeoPoint object to which to write the result.
     * @returns the final position of the leg, or undefined if one could not be obtained.
     */
    static getLegFinalPosition(legCalc, out) {
        if (legCalc.endLat !== undefined && legCalc.endLon !== undefined) {
            return out.set(legCalc.endLat, legCalc.endLon);
        }
        return undefined;
    }
    /**
     * Gets the final course of a calculated leg.
     * @param legCalc A set of leg calculations.
     * @returns the final course of the leg, or undefined if one could not be obtained.
     */
    static getLegFinalCourse(legCalc) {
        if (legCalc.flightPath.length > 0) {
            const vector = legCalc.flightPath[legCalc.flightPath.length - 1];
            return this.getVectorFinalCourse(vector);
        }
        return undefined;
    }
    /**
     * Gets the circle describing the path of a turn.
     * @param center The center of the turn.
     * @param radius The radius of the turn, in great-arc radians.
     * @param turnDirection The direction of the turn.
     * @param out A GeoCircle object to which to write the result.
     * @returns The circle describing the path of the turn.
     */
    static getTurnCircle(center, radius, turnDirection, out) {
        out.set(center, radius);
        if (turnDirection === 'right') {
            out.set(Vec3Math.multScalar(out.center, -1, FlightPathUtils.vec3Cache[0]), Math.PI - out.radius);
        }
        return out;
    }
    /**
     * Gets the direction of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @returns The direction of the turn described by the circle.
     */
    static getTurnDirectionFromCircle(circle) {
        return circle.radius > Math.PI / 2 ? 'right' : 'left';
    }
    /**
     * Gets the radius of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @returns The radius of the turn described by the circle, in great-arc radians.
     */
    static getTurnRadiusFromCircle(circle) {
        return Math.min(circle.radius, Math.PI - circle.radius);
    }
    /**
     * Gets the center of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @param out A GeoPoint or 3D vector object to which to write the result.
     * @returns The center of a turn described by the circle.
     */
    static getTurnCenterFromCircle(circle, out) {
        return (circle.radius > Math.PI / 2
            ? out instanceof Float64Array
                ? Vec3Math.multScalar(circle.center, -1, out)
                : out.setFromCartesian(-circle.center[0], -circle.center[1], -circle.center[2])
            : out instanceof Float64Array
                ? Vec3Math.copy(circle.center, out)
                : out.setFromCartesian(circle.center));
    }
    /**
     * Gets the signed distance along an arc from a defined start point to a query point. The query point must lie
     * somewhere on the arc's parent circle. A negative distance indicates that the query point lies somewhere before
     * the start of the arc but after the point on the arc's parent circle that is diametrically opposed to the midpoint
     * of the arc.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param end The end point of the arc.
     * @param pos The query point.
     * @returns The signed distance along the arc from the start point to the query point.
     * @throws Error if `start`, `end`, or `pos` does not lie on `circle`.
     */
    static getAlongArcSignedDistance(circle, start, end, pos) {
        const endAngularDistance = circle.angleAlong(start, end, Math.PI);
        const posAngularDistance = circle.angleAlong(start, pos, Math.PI);
        return circle.arcLength((posAngularDistance - (endAngularDistance / 2) + Math.PI) % (2 * Math.PI) - Math.PI + endAngularDistance / 2);
    }
    /**
     * Gets the normalized distance along an arc from a defined start point to a query point. The query point must lie
     * somewhere on the arc's parent circle. The distance is normalized such that 1 equals the arc length from the start
     * point to the end point. A negative distance indicates that the query point lies somewhere before the start of the
     * arc but after the point on the arc's parent circle that is diametrically opposed to the midpoint of the arc.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param end The end point of the arc.
     * @param pos The query point.
     * @returns The normalized distance along the arc from the start point to the query point.
     * @throws Error if `start`, `end`, or `pos` does not lie on `circle`.
     */
    static getAlongArcNormalizedDistance(circle, start, end, pos) {
        const endAngularDistance = circle.angleAlong(start, end, Math.PI);
        const posAngularDistance = circle.angleAlong(start, pos, Math.PI);
        return ((posAngularDistance - (endAngularDistance / 2) + Math.PI) % (2 * Math.PI) - Math.PI) / endAngularDistance + 0.5;
    }
}
FlightPathUtils.vec3Cache = [new Float64Array(3)];
FlightPathUtils.geoPointCache = [new GeoPoint(0, 0)];
FlightPathUtils.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * Builds circle vectors.
 */
class CircleVectorBuilder {
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, ...args) {
        if (args[0] instanceof GeoCircle) {
            this.setFromCircle(vectors, index, ...args);
        }
        else {
            this.setFromPoints(vectors, index, ...args);
        }
        return 1;
    }
    /**
     * Sets the parameters for a circle vector in a flight path vector sequence. If a circle vector does not exist at the
     * specified index in the sequence, a new one will be created.
     * @param vectors A flight path vector sequence.
     * @param index The index in the sequence at which to set the circle vector.
     * @param direction The direction of the circle.
     * @param radius The radius of the circle, in meters.
     * @param center The center of the circle.
     * @param start The start point.
     * @param end The end point.
     * @returns The set circle vector.
     */
    setFromPoints(vectors, index, direction, radius, center, start, end) {
        const circle = FlightPathUtils.getTurnCircle(center, UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), direction, CircleVectorBuilder.geoCircleCache[0]);
        return this.setFromCircle(vectors, index, circle, start, end);
    }
    /**
     * Sets the parameters for a circle vector in a flight path vector sequence. If a circle vector does not exist at the
     * specified index in the sequence, a new one will be created.
     * @param vectors A flight path vector sequence.
     * @param index The index in the sequence at which to set the circle vector.
     * @param circle The circle which defines the vector path.
     * @param start The start point.
     * @param end The end point.
     * @returns The set circle vector.
     */
    setFromCircle(vectors, index, circle, start, end) {
        var _a;
        const vector = (((_a = vectors[index]) === null || _a === void 0 ? void 0 : _a.vectorType) === 'circle' ? vectors[index] : (vectors[index] = FlightPathUtils.createEmptyCircleVector()));
        vector.radius = circle.radius;
        vector.centerX = circle.center[0];
        vector.centerY = circle.center[1];
        vector.centerZ = circle.center[2];
        vector.distance = UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.METER);
        start instanceof Float64Array && (start = CircleVectorBuilder.geoPointCache[0].setFromCartesian(start));
        end instanceof Float64Array && (end = CircleVectorBuilder.geoPointCache[1].setFromCartesian(end));
        vector.startLat = start.lat;
        vector.startLon = start.lon;
        vector.endLat = end.lat;
        vector.endLon = end.lon;
        return vector;
    }
}
CircleVectorBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
CircleVectorBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
/**
 * Builds great-circle paths between defined start and end points.
 */
class GreatCircleBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, pathArg, endArg) {
        if (pathArg instanceof GeoCircle) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.buildFromPath(vectors, index, start, pathArg, endArg);
        }
        else {
            return this.buildFromEndpoints(vectors, index, start, pathArg, endArg);
        }
    }
    /**
     * Builds a sequence of vectors representing the shortest great-circle path between two points.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param end The end point.
     * @param initialCourse The initial true course bearing. Used to define a unique great-circle path when `start` and
     * `end` are antipodal.
     * @returns The number of vectors added to the sequence.
     * @throws Error if `start` and `end` are antipodal and `initialCourse` is undefined.
     */
    buildFromEndpoints(vectors, index, start, end, initialCourse) {
        const startPoint = start instanceof Float64Array
            ? GreatCircleBuilder.geoPointCache[0].setFromCartesian(start)
            : GreatCircleBuilder.geoPointCache[0].set(start);
        const endPoint = end instanceof Float64Array
            ? GreatCircleBuilder.geoPointCache[1].setFromCartesian(end)
            : GreatCircleBuilder.geoPointCache[1].set(end);
        const distance = startPoint.distance(endPoint);
        const path = GreatCircleBuilder.geoCircleCache[0];
        if (distance >= Math.PI - GeoPoint.EQUALITY_TOLERANCE) {
            if (initialCourse === undefined) {
                throw new Error('GreatCircleVectorBuilder: cannot build a unique direct track from antipodal endpoints.');
            }
            else {
                path.setAsGreatCircle(start, initialCourse);
            }
        }
        else {
            path.setAsGreatCircle(start, end);
        }
        return this.buildFromPath(vectors, index, start, path, end);
    }
    /**
     * Builds a sequence of vectors representing a great-circle path from a start point to either a defined endpoint
     * or a distance offset.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param path The great-circle path.
     * @param endArg The end point or distance offset.
     * @returns The number of vectors added to the sequence.
     * @throws Error if `path` is not a great circle.
     */
    buildFromPath(vectors, index, start, path, endArg) {
        if (!path.isGreatCircle()) {
            throw new Error(`GreatCircleVectorBuilder: expected GeoCircle radius of pi / 2; instead was ${path.radius}`);
        }
        const end = typeof endArg === 'number'
            ? path.offsetDistanceAlong(start, UnitType.METER.convertTo(endArg, UnitType.GA_RADIAN), GreatCircleBuilder.vec3Cache[0], Math.PI)
            : endArg;
        return this.circleVectorBuilder.build(vectors, index, path, start, end);
    }
}
GreatCircleBuilder.vec3Cache = [new Float64Array(3)];
GreatCircleBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
GreatCircleBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
/**
 * Builds constant-radius turns toward specified course bearings.
 */
class TurnToCourseBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /**
     * Adds a turn from a defined start point and initial course to a specific final course to a flight path vector
     * sequence.
     * @param vectors The flight path vector sequence to which to add the turn.
     * @param index The index in the sequence at which to add the turn.
     * @param start The start point of the turn.
     * @param radius The radius of the turn, in meters.
     * @param direction The direction of the turn.
     * @param fromCourse The initial true course at the start of the turn.
     * @param toCourse The final true course at the end of the turn.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, radius, direction, fromCourse, toCourse) {
        if (start instanceof Float64Array) {
            start = TurnToCourseBuilder.geoPointCache[0].setFromCartesian(start);
        }
        const radiusRad = UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
        const turnCenterPoint = TurnToCourseBuilder.geoPointCache[1].set(start).offset(fromCourse + (direction === 'left' ? -90 : 90), radiusRad);
        const turnStartBearing = turnCenterPoint.bearingTo(start);
        const turnEndBearing = NavMath.normalizeHeading(turnStartBearing + (toCourse - fromCourse));
        const turnEndPoint = turnCenterPoint.offset(turnEndBearing, radiusRad, TurnToCourseBuilder.geoPointCache[2]);
        return this.circleVectorBuilder.build(vectors, index, direction, radius, turnCenterPoint, start, turnEndPoint);
    }
}
TurnToCourseBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
/**
 * Builds great-circle paths to intercept other geo circles.
 */
class CircleInterceptBuilder {
    constructor() {
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, pathArg, circle) {
        if (circle.includes(start)) {
            return 0;
        }
        let startPath;
        if (pathArg instanceof GeoCircle) {
            if (!pathArg.includes(start)) {
                throw new Error('CircleInterceptBuilder: the starting point does not lie on the starting path.');
            }
            startPath = pathArg;
        }
        else {
            startPath = CircleInterceptBuilder.geoCircleCache[0].setAsGreatCircle(start, pathArg);
        }
        const intersections = CircleInterceptBuilder.intersectionCache;
        const numIntersections = startPath.intersection(circle, intersections);
        if (numIntersections === 0) {
            return 0;
        }
        const endVec = intersections[(numIntersections === 1 || circle.encircles(start)) ? 0 : 1];
        return startPath.isGreatCircle()
            ? this.greatCircleBuilder.build(vectors, index, start, startPath, endVec)
            : this.circleVectorBuilder.build(vectors, index, startPath, start, endVec);
    }
}
CircleInterceptBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
CircleInterceptBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds constant-radius turns to join great-circle paths.
 */
class TurnToJoinGreatCircleBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, startPathArg, endPath, radius) {
        if (!endPath.isGreatCircle()) {
            throw new Error(`TurnToJoinPathBuilder: expected GeoCircle radius of pi / 2; instead was ${endPath.radius}`);
        }
        let startPath;
        if (startPathArg instanceof GeoCircle) {
            if (!startPathArg.isGreatCircle()) {
                throw new Error(`TurnToJoinPathBuilder: expected GeoCircle radius of pi / 2; instead was ${startPathArg.radius}`);
            }
            else if (!startPathArg.includes(start)) {
                throw new Error('TurnToJoinPathBuilder: the starting point does not lie on the starting path.');
            }
            startPath = startPathArg;
        }
        else {
            startPath = TurnToJoinGreatCircleBuilder.geoCircleCache[0].setAsGreatCircle(start, startPathArg);
        }
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, TurnToJoinGreatCircleBuilder.vec3Cache[0]);
        }
        const turnDirection = endPath.encircles(start) ? 'left' : 'right';
        const radiusRad = turnDirection === 'left'
            ? UnitType.METER.convertTo(radius, UnitType.GA_RADIAN)
            : Math.PI - UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
        const turnStartToCenterNormal = Vec3Math.cross(start, startPath.center, TurnToJoinGreatCircleBuilder.vec3Cache[1]);
        const turnStartToCenterPath = TurnToJoinGreatCircleBuilder.geoCircleCache[1].set(turnStartToCenterNormal, Math.PI / 2);
        const turnCenter = turnStartToCenterPath.offsetDistanceAlong(start, radiusRad, TurnToJoinGreatCircleBuilder.vec3Cache[2]);
        const turnCircle = TurnToJoinGreatCircleBuilder.geoCircleCache[1].set(turnCenter, radiusRad);
        const end = turnCircle.closest(Vec3Math.multScalar(endPath.center, turnDirection === 'left' ? -1 : 1, TurnToJoinGreatCircleBuilder.vec3Cache[3]), TurnToJoinGreatCircleBuilder.vec3Cache[1]);
        return this.circleVectorBuilder.build(vectors, index, turnCircle, start, end);
    }
}
TurnToJoinGreatCircleBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
TurnToJoinGreatCircleBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
/**
 * Builds paths to connect two geo circles.
 */
class ConnectCirclesBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /**
     * Builds a sequence of vectors representing a path which consists of a single geo circle which connects two other
     * circles and optionally paths to link the connecting circle with a start point on the from circle and an end point
     * on the to circle.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param fromCircle The circle from which to add the connecting circle.
     * @param toCircle The circle to which to add the connecting circle.
     * @param radius The radius, in meters, of the circle to join the two circles. If not defined, defaults to pi / 2
     * times the radius of the Earth (and therefore the connecting circle will be a great circle).
     * @param from The starting point along `fromCircle`. If not defined, this will be assumed to be equal to the
     * point where the connecting circle meets `fromCircle`.
     * @param to The ending point along `toCircle`. If not defined, this will be assumed to be equal to the point where
     * the connecting circle meets `toCircle`.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, fromCircle, toCircle, radius, from, to) {
        if (radius === 0) {
            return 0;
        }
        const angle = Math.acos(Vec3Math.dot(fromCircle.center, toCircle.center));
        if ((angle <= GeoPoint.EQUALITY_TOLERANCE && fromCircle.radius === toCircle.radius)
            || (Math.PI - angle <= GeoPoint.EQUALITY_TOLERANCE && Math.PI - fromCircle.radius - toCircle.radius <= GeoPoint.EQUALITY_TOLERANCE)) {
            return 0;
        }
        if (from && !(from instanceof Float64Array)) {
            from = GeoPoint.sphericalToCartesian(from, ConnectCirclesBuilder.vec3Cache[0]);
        }
        if (to && !(to instanceof Float64Array)) {
            to = GeoPoint.sphericalToCartesian(to, ConnectCirclesBuilder.vec3Cache[1]);
        }
        const radiusRad = Math.min(Math.PI / 2, radius ? UnitType.METER.convertTo(radius, UnitType.GA_RADIAN) : Infinity);
        const joinCircle = this.findCircleToJoinCircles(fromCircle, toCircle, radiusRad, ConnectCirclesBuilder.geoCircleCache[0], from, to);
        if (!joinCircle) {
            return 0;
        }
        let vectorIndex = index;
        const joinStart = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(fromCircle, ConnectCirclesBuilder.vec3Cache[2]), ConnectCirclesBuilder.vec3Cache[2]);
        const joinEnd = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(toCircle, ConnectCirclesBuilder.vec3Cache[3]), ConnectCirclesBuilder.vec3Cache[3]);
        if (from && Math.acos(Vec3Math.dot(from, joinStart)) > GeoPoint.EQUALITY_TOLERANCE) {
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, fromCircle, from, joinStart);
        }
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, joinCircle, joinStart, joinEnd);
        if (to && Math.acos(Vec3Math.dot(to, joinEnd)) > GeoPoint.EQUALITY_TOLERANCE) {
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, toCircle, joinEnd, to);
        }
        return vectorIndex - index;
    }
    /**
     * Finds a GeoCircle which connects (is tangent to) two other circles.
     * @param fromCircle The circle at the beginning of the connecting circle.
     * @param toCircle The circle at the end of the connecting circle.
     * @param radius The desired radius of the connecting circle, in great-arc radians.
     * @param out A GeoCircle object to which to write the result.
     * @param from The starting point along `fromCircle`. If not defined, this will be assumed to be equal to the
     * point where the connecting circle meets `fromCircle`.
     * @param to The ending point along `toCircle`. If not defined, this will be assumed to be equal to the point where
     * the connecting circle meets `toCircle`.
     * @returns a GeoCircle which connects the two circles, or null if one could not be found.
     */
    findCircleToJoinCircles(fromCircle, toCircle, radius, out, from, to) {
        /*
         * Theory: the locus of all centers of circle of radius r tangent to circle with center C and radius R is
         * equivalent to the set of circles S(C) with center C and positive radius |r +/- R|. If we further restrict the
         * set of tangent circles to those where both the original and tangent circle run in the same direction at the
         * tangent point, the locus of centers can be further reduced to the single circle Sd(C) with center C and
         * positive radius |r - R|. Therefore, to find the centers of the circles of radius r connecting the circles C1 and
         * C2, we need only find the intersections of Sd(C1) and Sd(C2).
         */
        const solutions = [];
        const intersections = ConnectCirclesBuilder.intersectionCache;
        const leftTurnRadius = radius;
        let fromCircleOffsetRadius = Math.abs(leftTurnRadius - fromCircle.radius);
        let toCircleOffsetRadius = Math.abs(leftTurnRadius - toCircle.radius);
        let fromCircleOffset = ConnectCirclesBuilder.geoCircleCache[1].set(fromCircle.center, fromCircleOffsetRadius);
        let toCircleOffset = ConnectCirclesBuilder.geoCircleCache[2].set(toCircle.center, toCircleOffsetRadius);
        const numLeftTurnSolutions = fromCircleOffset.intersection(toCircleOffset, intersections);
        if (numLeftTurnSolutions === 1) {
            solutions.push(ConnectCirclesBuilder.geoCircleCache[1].set(intersections[0], leftTurnRadius));
        }
        else if (numLeftTurnSolutions === 2) {
            solutions.push(ConnectCirclesBuilder.geoCircleCache[1].set(intersections[0], leftTurnRadius));
            solutions.push(ConnectCirclesBuilder.geoCircleCache[2].set(intersections[1], leftTurnRadius));
        }
        if (radius !== Math.PI / 2) {
            const rightTurnRadius = Math.PI - radius;
            fromCircleOffsetRadius = Math.abs(rightTurnRadius - fromCircle.radius);
            toCircleOffsetRadius = Math.abs(rightTurnRadius - toCircle.radius);
            fromCircleOffset = ConnectCirclesBuilder.geoCircleCache[3].set(fromCircle.center, fromCircleOffsetRadius);
            toCircleOffset = ConnectCirclesBuilder.geoCircleCache[4].set(toCircle.center, toCircleOffsetRadius);
            const numRightTurnSolutions = fromCircleOffset.intersection(toCircleOffset, intersections);
            if (numRightTurnSolutions === 1) {
                solutions.push(ConnectCirclesBuilder.geoCircleCache[3].set(intersections[0], rightTurnRadius));
            }
            else if (numRightTurnSolutions === 2) {
                solutions.push(ConnectCirclesBuilder.geoCircleCache[3].set(intersections[0], rightTurnRadius));
                solutions.push(ConnectCirclesBuilder.geoCircleCache[4].set(intersections[1], rightTurnRadius));
            }
        }
        if (solutions.length === 0) {
            return null;
        }
        else if (solutions.length === 1) {
            return out.set(solutions[0].center, solutions[0].radius);
        }
        else {
            // choose the solution that results in the shortest path from fromVec to toVec
            let circle = solutions[0];
            let minDistance = this.calculateJoinCirclesPathDistance(fromCircle, toCircle, solutions[0], from, to);
            for (let i = 1; i < solutions.length; i++) {
                const distance = this.calculateJoinCirclesPathDistance(fromCircle, toCircle, solutions[i], from, to);
                if (distance < minDistance) {
                    circle = solutions[i];
                    minDistance = distance;
                }
            }
            return out.set(circle.center, circle.radius);
        }
    }
    /**
     * Calculates the total distance along the joining path between two circles.
     * @param fromCircle The circle at the beginning of the connecting circle.
     * @param toCircle The circle at the end of the connecting circle.
     * @param joinCircle The connecting circle.
     * @param from The starting point along `fromCircle`. If not defined, this will be assumed to be equal to the
     * point where the connecting circle meets `fromCircle`.
     * @param to The ending point along `toCircle`. If not defined, this will be assumed to be equal to the point where
     * the connecting circle meets `toCircle`.
     * @returns the total distance along the joining path, in great-arc radians.
     */
    calculateJoinCirclesPathDistance(fromCircle, toCircle, joinCircle, from, to) {
        let distance = 0;
        const joinStartVec = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(fromCircle, ConnectCirclesBuilder.vec3Cache[6]), ConnectCirclesBuilder.vec3Cache[6]);
        const joinEndVec = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(toCircle, ConnectCirclesBuilder.vec3Cache[7]), ConnectCirclesBuilder.vec3Cache[7]);
        if (from) {
            distance += fromCircle.distanceAlong(from, joinStartVec, Math.PI);
        }
        distance += joinCircle.distanceAlong(joinStartVec, joinEndVec, Math.PI);
        if (to) {
            distance += toCircle.distanceAlong(joinEndVec, to, Math.PI);
        }
        return distance;
    }
}
ConnectCirclesBuilder.vec3Cache = [
    new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3),
    new Float64Array(3), new Float64Array(3), new Float64Array(3)
];
ConnectCirclesBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0)
];
ConnectCirclesBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds paths connecting initial great-circle paths to final great-circle paths terminating at defined end points.
 */
class JoinGreatCircleToPointBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.joinCirclesBuilder = new ConnectCirclesBuilder();
        this.turnToJoinPathBuilder = new TurnToJoinGreatCircleBuilder();
    }
    /**
     * Builds a sequence of vectors representing a path from a defined start point and initial course which turns and
     * joins a great-circle path which terminates at a defined end point.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point in cartesian form.
     * @param startPath The great-circle path defining the initial course.
     * @param end The end point in cartesian form.
     * @param endPath The great-circle path defining the final course.
     * @param desiredTurnDirection The desired initial turn direction. If not defined, the most efficient turn direction
     * that satisfies the constraints will be chosen.
     * @param minTurnRadius The minimum turn radius, in meters. Defaults to 0.
     * @param intersection The point of intersection between the start and end paths closest to the start point. If
     * not defined, it will be calculated.
     * @returns the number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, end, endPath, desiredTurnDirection, minTurnRadius, intersection) {
        let vectorIndex = index;
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, JoinGreatCircleToPointBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, JoinGreatCircleToPointBuilder.vec3Cache[1]);
        }
        if (!intersection) {
            const intersections = JoinGreatCircleToPointBuilder.intersectionCache;
            const solutionCount = startPath.intersection(endPath, intersections);
            if (solutionCount === 0) {
                return 0;
            }
            // choose the intersection closest to the start point.
            intersection = Vec3Math.dot(intersections[0], start) > 0
                ? intersections[0]
                : intersections[1];
        }
        // Calculate the relative directions of the start point, intersection point, and end point.
        const startToIntersectionDot = Vec3Math.dot(Vec3Math.cross(startPath.center, intersection, JoinGreatCircleToPointBuilder.vec3Cache[2]), start);
        const startToIntersectionSign = startToIntersectionDot < -1e-8 ? 1
            : startToIntersectionDot > 1e-8 ? -1 : 0;
        const intersectionToEndDot = Vec3Math.dot(Vec3Math.cross(endPath.center, intersection, JoinGreatCircleToPointBuilder.vec3Cache[3]), end);
        const intersectionToEndSign = intersectionToEndDot < -1e-8 ? -1
            : intersectionToEndDot > 1e-8 ? 1 : 0;
        const isIntersectionForwardOfStart = startToIntersectionSign > 0;
        const isEndForwardOfIntersection = intersectionToEndSign > 0;
        minTurnRadius !== null && minTurnRadius !== void 0 ? minTurnRadius : (minTurnRadius = 0);
        // Calculate the minimum along-track distance taken up by the initial turn.
        const minTurnRadiusRad = UnitType.METER.convertTo(minTurnRadius, UnitType.GA_RADIAN);
        const pathDot = Vec3Math.dot(startPath.center, endPath.center);
        const theta = Math.acos(-pathDot);
        const tanHalfTheta = Math.tan(theta / 2);
        const minD = Math.asin(Math.tan(minTurnRadiusRad) / tanHalfTheta);
        const intersectionStartDistance = startToIntersectionSign === 0 ? 0 : Math.acos(Vec3Math.dot(intersection, start));
        const intersectionEndDistance = intersectionToEndSign === 0 ? 0 : Math.acos(Vec3Math.dot(intersection, end));
        let d = Math.max(minD, intersectionStartDistance);
        const isStartPastRequiredTurnStart = startToIntersectionSign * intersectionStartDistance < d;
        const isEndBeforeRequiredTurnEnd = intersectionToEndSign * intersectionEndDistance < d;
        // The turn direction required to join the final course with a single constant-radius turn.
        const singleTurnDirection = startPath.encircles(end) === ((isStartPastRequiredTurnStart || isEndBeforeRequiredTurnEnd) && isEndForwardOfIntersection)
            ? 'right'
            : 'left';
        let needSingleTurn = true;
        if (!isEndForwardOfIntersection && isIntersectionForwardOfStart && (desiredTurnDirection === undefined || desiredTurnDirection !== singleTurnDirection)) {
            // Attempt a side step.
            const fromCircleTurnOffsetPath = JoinGreatCircleToPointBuilder.geoCircleCache[0].setAsGreatCircle(start, startPath.center);
            const fromCircleRadius = singleTurnDirection === 'left' ? minTurnRadiusRad : Math.PI - minTurnRadiusRad;
            const fromCircle = JoinGreatCircleToPointBuilder.geoCircleCache[0].set(fromCircleTurnOffsetPath.offsetDistanceAlong(start, fromCircleRadius, JoinGreatCircleToPointBuilder.vec3Cache[2]), fromCircleRadius);
            const toCircleTurnOffsetPath = JoinGreatCircleToPointBuilder.geoCircleCache[1].setAsGreatCircle(end, endPath.center);
            const toCircleRadius = singleTurnDirection === 'left' ? Math.PI - minTurnRadiusRad : minTurnRadiusRad;
            const toCircle = JoinGreatCircleToPointBuilder.geoCircleCache[1].set(toCircleTurnOffsetPath.offsetDistanceAlong(end, toCircleRadius, JoinGreatCircleToPointBuilder.vec3Cache[3]), toCircleRadius);
            const numVectorsAdded = this.joinCirclesBuilder.build(vectors, vectorIndex, fromCircle, toCircle, undefined, start, end);
            if (numVectorsAdded > 0) {
                vectorIndex += numVectorsAdded;
                needSingleTurn = false;
            }
        }
        else if (isEndForwardOfIntersection
            && (isStartPastRequiredTurnStart || isEndBeforeRequiredTurnEnd)
            && (desiredTurnDirection === undefined || desiredTurnDirection !== singleTurnDirection)) {
            // In this case we will allow the calculated path to overshoot the final course path in an attempt to honor the
            // initial desired turn direction, if defined, or otherwise to turn towards the terminator instead of away from
            // it. After the overshoot, the path will turn back to intercept the final course path.
            const toCircleTurnOffsetPath = JoinGreatCircleToPointBuilder.geoCircleCache[0].setAsGreatCircle(end, endPath.center);
            const toCircleRadius = singleTurnDirection === 'left' ? minTurnRadiusRad : Math.PI - minTurnRadiusRad;
            const toCircle = JoinGreatCircleToPointBuilder.geoCircleCache[0].set(toCircleTurnOffsetPath.offsetDistanceAlong(end, toCircleRadius, JoinGreatCircleToPointBuilder.vec3Cache[3]), toCircleRadius);
            let needFindFromCircle = true;
            if (!isEndBeforeRequiredTurnEnd) {
                // The terminator is far enough from the intersection point that an immediate turn from the start point may be
                // sufficient to put the airplane on a course to intercept the final course before the terminator fix.
                const fromCircleTurnOffsetPath = JoinGreatCircleToPointBuilder.geoCircleCache[1].setAsGreatCircle(start, startPath.center);
                const fromCircleRadius = singleTurnDirection === 'left' ? Math.PI - minTurnRadiusRad : minTurnRadiusRad;
                const fromCircle = JoinGreatCircleToPointBuilder.geoCircleCache[1].set(fromCircleTurnOffsetPath.offsetDistanceAlong(start, fromCircleRadius, JoinGreatCircleToPointBuilder.vec3Cache[2]), fromCircleRadius);
                const turnCenterSeparation = Math.acos(Vec3Math.dot(FlightPathUtils.getTurnCenterFromCircle(fromCircle, JoinGreatCircleToPointBuilder.vec3Cache[2]), FlightPathUtils.getTurnCenterFromCircle(toCircle, JoinGreatCircleToPointBuilder.vec3Cache[3])));
                const turnCenterSeparationDiff = turnCenterSeparation - 2 * minTurnRadiusRad;
                if (Math.abs(turnCenterSeparationDiff) <= GeoPoint.EQUALITY_TOLERANCE) {
                    // The turn circles are tangent.
                    needFindFromCircle = false;
                    const tangentVec = fromCircle.closest(toCircle.closest(fromCircle.center, JoinGreatCircleToPointBuilder.vec3Cache[2]), JoinGreatCircleToPointBuilder.vec3Cache[2]);
                    vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, fromCircle, start, tangentVec);
                    vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, toCircle, tangentVec, end);
                    needSingleTurn = false;
                }
                else if (turnCenterSeparationDiff > GeoPoint.EQUALITY_TOLERANCE) {
                    // The turn circles do not intersect.
                    needFindFromCircle = false;
                    const numVectorsAdded = this.joinCirclesBuilder.build(vectors, vectorIndex, fromCircle, toCircle, undefined, start, end);
                    if (numVectorsAdded > 0) {
                        vectorIndex += numVectorsAdded;
                        needSingleTurn = false;
                    }
                }
            }
            if (needFindFromCircle && Math.abs(startPath.distance(toCircle.center)) >= minTurnRadiusRad + GeoPoint.EQUALITY_TOLERANCE) {
                // We need to place the initial turn from the start path such that the turn circle is tangent to the final turn
                // toward the final course path.
                const fromCircleTurnDirection = singleTurnDirection === 'left' ? 'right' : 'left';
                const offset = fromCircleTurnDirection === 'left' ? -minTurnRadiusRad : minTurnRadiusRad;
                const startPathOffset = JoinGreatCircleToPointBuilder.geoCircleCache[1].set(startPath.center, startPath.radius + offset);
                const toCircleOffset = JoinGreatCircleToPointBuilder.geoCircleCache[2].set(toCircle.center, toCircle.radius + offset);
                const intersections = JoinGreatCircleToPointBuilder.intersectionCache;
                const numIntersections = startPathOffset.intersection(toCircleOffset, intersections);
                if (numIntersections === 2) {
                    // Choose the intersection that is farther along the start path. The other one will either lead to a turn
                    // that begins before the start point or one that produces a sub-optimal path.
                    const fromCircleTurnCenter = intersections[fromCircleTurnDirection === 'left' ? 1 : 0];
                    const fromCircle = FlightPathUtils.getTurnCircle(fromCircleTurnCenter, minTurnRadiusRad, fromCircleTurnDirection, JoinGreatCircleToPointBuilder.geoCircleCache[1]);
                    const fromTurnStartVec = startPath.closest(fromCircleTurnCenter, JoinGreatCircleToPointBuilder.vec3Cache[2]);
                    const tangentVec = fromCircle.closest(toCircle.closest(fromCircle.center, JoinGreatCircleToPointBuilder.vec3Cache[3]), JoinGreatCircleToPointBuilder.vec3Cache[3]);
                    vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, fromTurnStartVec);
                    vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, fromCircle, fromTurnStartVec, tangentVec);
                    vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, toCircle, tangentVec, end);
                    needSingleTurn = false;
                }
            }
        }
        if (needSingleTurn) {
            let intersectionToTurnEndSign = isStartPastRequiredTurnStart ? -1 : 1;
            let intersectionToTurnStartSign = -intersectionToTurnEndSign;
            const isTurnInvalid = intersectionToTurnEndSign * d > intersectionEndDistance * intersectionToEndSign;
            const turnStartVec = JoinGreatCircleToPointBuilder.vec3Cache[2];
            const turnStartPoint = JoinGreatCircleToPointBuilder.geoPointCache[0];
            const turnEndPoint = JoinGreatCircleToPointBuilder.geoPointCache[1];
            if (isTurnInvalid) {
                // if we can't make the turn in time by immediately making a turn from startPoint, we will instead have the
                // turn end at the terminator fix, with a radius such that the turn begins at some point along the plane's
                // current track (startPoint projected forward with a bearing of currentCourse). Because of the way we have
                // chosen the direction of the turn and where to start it, this will guarantee a valid solution, albeit not
                // necessarily an optimal one.
                d = Math.max(minD, intersectionEndDistance);
                intersectionToTurnStartSign = (intersectionToEndSign * intersectionEndDistance < d) ? 1
                    : startToIntersectionSign <= 0 ? 1 : -1;
                intersectionToTurnEndSign = -intersectionToTurnStartSign;
            }
            turnStartPoint.setFromCartesian(startPath.offsetDistanceAlong(intersection, d * intersectionToTurnStartSign, turnStartVec, Math.PI));
            endPath.offsetDistanceAlong(intersection, d * intersectionToTurnEndSign, turnEndPoint, Math.PI);
            const startPoint = JoinGreatCircleToPointBuilder.geoPointCache[2].setFromCartesian(start);
            if (!startPoint.equals(turnStartPoint)) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, turnStartPoint);
            }
            const turnRadius = d === minD ? minTurnRadius : UnitType.GA_RADIAN.convertTo(Math.atan(tanHalfTheta * Math.sin(d)), UnitType.METER);
            vectorIndex += this.turnToJoinPathBuilder.build(vectors, vectorIndex, turnStartVec, startPath, endPath, turnRadius);
            const endPoint = JoinGreatCircleToPointBuilder.geoPointCache[2].setFromCartesian(end);
            if (!endPoint.equals(turnEndPoint)) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, endPoint);
            }
        }
        return vectorIndex - index;
    }
}
JoinGreatCircleToPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
JoinGreatCircleToPointBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
JoinGreatCircleToPointBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
JoinGreatCircleToPointBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds procedure turns.
 */
class ProcedureTurnBuilder {
    constructor() {
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /**
     * Builds a sequence of vectors representing a procedure turn from a defined starting point and initial course to a
     * defined end point and final course. A procedure turn begins with a variable-length leg from the start point along
     * the initial course followed by an initial turn to intercept the outbound leg of the procedure turn, then a
     * variable-length outbound leg, a 180-degree turn, a variable-length inbound leg, and finally a turn to intercept
     * the final course at the end point. If a full set of vectors cannot be computed given the restraints imposed by the
     * path geometry and the desired turn radius, parts of the turn beginning with the inbound leg of the procedure turn
     * may be altered or omitted entirely.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point in cartesian form.
     * @param startPath The great-circle path defining the initial course.
     * @param end The end point in cartesian form.
     * @param endPath The great-circle path defining the final course.
     * @param outboundCourse The true course, in degrees, of the outbound leg of the turn.
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @param desiredTurnDirection The desired turn direction.
     * @param initialCourse The initial course. If not defined, it will be calculated from `startPath` and `start`.
     * @param finalCourse The final course. If not defined, it will be calculated from `endPath` and `end`.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, end, endPath, outboundCourse, desiredTurnRadius, desiredTurnDirection, initialCourse, finalCourse) {
        let vectorIndex = index;
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, ProcedureTurnBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, ProcedureTurnBuilder.vec3Cache[1]);
        }
        /*
         * We need to calculate two parameters: (1) the distance to stay on the initial outbound segment, and (2) the
         * distance to stay on the outbound segment of the turn. We ideally would like to choose these parameters such
         * that the procedure turn ends at a location where it can immediately make another turn to intercept the next
         * leg. However, this may not be possible since we are constrained by the fact that the two distance parameters
         * cannot be negative. To simplify the math, we will do an approximated calculation based on a pseudo-Euclidean
         * geometry instead of spherical geometry. The error is proportional to the angle between the outbound path and the
         * the path to intercept; if they are exactly antiparallel the error is zero.
         */
        initialCourse !== null && initialCourse !== void 0 ? initialCourse : (initialCourse = startPath.bearingAt(start, Math.PI));
        finalCourse !== null && finalCourse !== void 0 ? finalCourse : (finalCourse = endPath.bearingAt(end, Math.PI));
        const startPoint = ProcedureTurnBuilder.geoPointCache[0].setFromCartesian(start);
        const initialTurnDirection = NavMath.getTurnDirection(initialCourse, outboundCourse);
        const isInitialTurnTowardEndPath = startPath.encircles(end) === (initialTurnDirection === 'left');
        const deltaOutbound = Math.abs(NavMath.diffAngle(initialCourse, outboundCourse)) * Avionics.Utils.DEG2RAD;
        const thetaOutbound = (Math.PI - deltaOutbound) / 2;
        const desiredTurnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
        // If there is a desired turn direction, honor it. Otherwise choose the direction that results in the shortest path
        // to intercept the next leg.
        const turnDirection = desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : (((initialTurnDirection === 'left') === deltaOutbound < Math.PI) ? 'right' : 'left');
        let desiredAlongTurnOutboundPathDistance = Math.abs(deltaOutbound - Math.PI / 2) > 1e-10
            ? Math.asin(Math.tan(2 * desiredTurnRadiusRad) / Math.tan(deltaOutbound)) * (turnDirection === initialTurnDirection ? -1 : 1)
            : 0;
        const endPointToStartPathXTrackDistance = Math.abs(startPath.distance(end));
        desiredAlongTurnOutboundPathDistance += Math.asin(Math.sin(endPointToStartPathXTrackDistance) / Math.sin(deltaOutbound))
            * (isInitialTurnTowardEndPath ? 1 : -1);
        const alongTurnOutboundPathDistance = Math.max(0, desiredAlongTurnOutboundPathDistance);
        const startToEndToEndPathAngleDiff = Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(start, end, ProcedureTurnBuilder.vec3Cache[2]), startPath.center));
        let desiredAlongStartPathDistance = Math.abs(startToEndToEndPathAngleDiff - Math.PI / 2) > 1e-8
            ? Math.asin(Math.tan(endPointToStartPathXTrackDistance) / Math.tan(startToEndToEndPathAngleDiff))
            : 0;
        desiredAlongStartPathDistance -= desiredAlongTurnOutboundPathDistance === 0 ? 0 : Math.atan(Math.cos(deltaOutbound) * Math.tan(desiredAlongTurnOutboundPathDistance));
        desiredAlongStartPathDistance += Math.asin(Math.sin(deltaOutbound) * Math.sin(2 * desiredTurnRadiusRad)) * (turnDirection === initialTurnDirection ? 1 : -1);
        const alongStartPathDistance = Math.max(0, desiredAlongStartPathDistance);
        const initialTurnStartPoint = alongStartPathDistance > 0
            ? startPath.offsetDistanceAlong(start, alongStartPathDistance, ProcedureTurnBuilder.geoPointCache[1])
            : startPoint;
        const initialTurnCenterPoint = initialTurnStartPoint.offset(initialCourse + (initialTurnDirection === 'left' ? -90 : 90), desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[2]);
        const initialTurnHalfAngularWidth = Math.acos(Math.sin(thetaOutbound) * Math.cos(desiredTurnRadiusRad)) * Avionics.Utils.RAD2DEG;
        const initialTurnStartBearing = initialTurnCenterPoint.bearingTo(initialTurnStartPoint);
        const initialTurnEndBearing = NavMath.normalizeHeading(initialTurnStartBearing + initialTurnHalfAngularWidth * 2 * (initialTurnDirection === 'left' ? -1 : 1));
        const initialTurnEndPoint = initialTurnCenterPoint.offset(initialTurnEndBearing, desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[3]);
        const turnStartPoint = alongTurnOutboundPathDistance > 0
            ? initialTurnEndPoint.offset(outboundCourse, alongTurnOutboundPathDistance, ProcedureTurnBuilder.geoPointCache[4])
            : initialTurnEndPoint;
        const turnCenterPoint = turnStartPoint.offset(outboundCourse + (turnDirection === 'left' ? -90 : 90), desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[5]);
        const turnStartBearing = turnCenterPoint.bearingTo(turnStartPoint);
        let turnEndBearing = NavMath.normalizeHeading(turnStartBearing + 180);
        const turnEndPoint = turnCenterPoint.offset(turnEndBearing, desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[6]);
        const turnEndVec = turnEndPoint.toCartesian(ProcedureTurnBuilder.vec3Cache[2]);
        let finalTurnDirection;
        let finalTurnRadius;
        let finalTurnStartPoint;
        let finalTurnCenterPoint;
        let finalTurnEndPoint;
        let endPoint;
        if (endPath.encircles(turnEndVec) === (initialTurnDirection === 'left')) {
            // the end of the turn lies beyond the path to intercept due to approximation error, so we need to end the turn early.
            const turnCircle = ProcedureTurnBuilder.geoCircleCache[0].set(turnCenterPoint, desiredTurnRadiusRad);
            const intersections = ProcedureTurnBuilder.intersectionCache;
            const numIntersections = turnCircle.intersection(endPath, intersections);
            if (numIntersections === 0) {
                // the path to intersect is completely outside of the turn, which can only happen if there is a major deviation
                // from the pseudo-Euclidean approximation. There is no easy way to recover from this state, so we just bail
                // out with a track directly to the endpoint.
                endPoint = ProcedureTurnBuilder.geoPointCache[7].setFromCartesian(end);
            }
            else {
                if (numIntersections === 2) {
                    // choose the intersection point which gives the smallest angle between the end of the turn and the path to intercept
                    const headingAdjustment = turnDirection === 'left' ? -90 : 90;
                    const angleDiff_0 = Math.abs(NavMath.diffAngle(Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(turnCenterPoint, intersections[0], ProcedureTurnBuilder.vec3Cache[3]), endPath.center)) * Avionics.Utils.RAD2DEG + headingAdjustment, 0));
                    const angleDiff_1 = Math.abs(NavMath.diffAngle(Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(turnCenterPoint, intersections[1], ProcedureTurnBuilder.vec3Cache[3]), endPath.center)) * Avionics.Utils.RAD2DEG + headingAdjustment, 0));
                    turnEndPoint.setFromCartesian(intersections[angleDiff_0 < angleDiff_1 ? 0 : 1]);
                }
                else {
                    turnEndPoint.setFromCartesian(intersections[0]);
                }
                turnEndBearing = turnCenterPoint.bearingTo(turnEndPoint);
            }
        }
        else {
            const turnFinalCourse = NavMath.normalizeHeading(outboundCourse + 180);
            const turnInboundPath = ProcedureTurnBuilder.geoCircleCache[0].setAsGreatCircle(turnEndPoint, turnFinalCourse);
            const intersections = ProcedureTurnBuilder.intersectionCache;
            const numIntersections = turnInboundPath.intersection(endPath, intersections);
            // Only move forward if the end of the turn does not lie on the path to intercept.
            if (numIntersections !== 0 && !endPath.includes(turnEndVec)) {
                const intersection = intersections[(numIntersections === 1 || endPath.encircles(turnEndVec)) ? 0 : 1];
                // Only move forward if the intersection lies before the endpoint, otherwise we will just end the leg at the
                // end of the procedure turn.
                if (Vec3Math.dot(GeoCircle.getGreatCircleNormal(intersection, end, ProcedureTurnBuilder.vec3Cache[3]), endPath.center) > 0) {
                    // Because we used an approximation to place the procedure turn, the inbound segment of the turn may not
                    // allow for a turn of the desired radius to perfectly intercept the final path. Therefore, we need to
                    // explicitly calculate the maximum allowed turn radius for this final turn and adjust the turn radius as
                    // needed. Note that if the initial and final paths are antiparallel, these calculations are not strictly
                    // necessary, but we will carry them out in all cases to account for floating point errors that may have
                    // accrued during previous calculations.
                    const deltaInbound = Math.acos(Vec3Math.dot(endPath.center, turnInboundPath.center));
                    const thetaInbound = (Math.PI - deltaInbound) / 2;
                    const tanThetaInbound = Math.tan(thetaInbound);
                    const desiredFinalTurnAlongTrackDistance = Math.asin(Math.tan(desiredTurnRadiusRad) / tanThetaInbound);
                    const finalTurnAlongTrackDistance = Math.min(desiredFinalTurnAlongTrackDistance, Math.acos(Vec3Math.dot(intersection, turnEndVec)), Math.acos(Vec3Math.dot(intersection, end)));
                    const finalTurnRadiusRad = finalTurnAlongTrackDistance === desiredFinalTurnAlongTrackDistance
                        ? desiredTurnRadiusRad
                        : Math.atan(Math.sin(finalTurnAlongTrackDistance) * tanThetaInbound);
                    finalTurnDirection = NavMath.getTurnDirection(turnFinalCourse, finalCourse);
                    finalTurnRadius = UnitType.GA_RADIAN.convertTo(finalTurnRadiusRad, UnitType.METER);
                    finalTurnStartPoint = turnInboundPath.offsetDistanceAlong(intersection, -finalTurnAlongTrackDistance, ProcedureTurnBuilder.geoPointCache[7], Math.PI);
                    finalTurnCenterPoint = finalTurnStartPoint.offset(turnFinalCourse + (finalTurnDirection === 'left' ? -90 : 90), finalTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[8]);
                    finalTurnEndPoint = endPath.offsetDistanceAlong(intersection, finalTurnAlongTrackDistance, ProcedureTurnBuilder.geoPointCache[9], Math.PI);
                }
            }
        }
        // Set vectors.
        if (initialTurnStartPoint !== startPoint) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, initialTurnStartPoint);
        }
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, initialTurnDirection, desiredTurnRadius, initialTurnCenterPoint, initialTurnStartPoint, initialTurnEndPoint);
        if (turnStartPoint !== initialTurnEndPoint) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, initialTurnEndPoint, turnStartPoint);
        }
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, desiredTurnRadius, turnCenterPoint, turnStartPoint, turnEndPoint);
        if (finalTurnCenterPoint) {
            if (!finalTurnStartPoint.equals(turnEndPoint)) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, finalTurnStartPoint);
            }
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, finalTurnDirection, finalTurnRadius, finalTurnCenterPoint, finalTurnStartPoint, finalTurnEndPoint);
        }
        else {
            if (endPoint) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, endPoint);
            }
        }
        return vectorIndex - index;
    }
}
ProcedureTurnBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
ProcedureTurnBuilder.geoPointCache = [
    new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0),
    new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)
];
ProcedureTurnBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
ProcedureTurnBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];

/**
 * Abstract implementation of FlightPathLegCalculator.
 */
class AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     * @param skipWhenActive Whether this calculator will skip calculations for active legs when the leg has already
     * been calculated. False by default.
     */
    constructor(facilityCache, skipWhenActive = false) {
        this.facilityCache = facilityCache;
        this.skipWhenActive = skipWhenActive;
    }
    /**
     * Gets a geographical position from an ICAO string.
     * @param icao An ICAO string.
     * @param out A GeoPoint object to which to write the result.
     * @returns The geographical position corresponding to the ICAO string, or undefined if one could not be obtained.
     */
    getPositionFromIcao(icao, out) {
        const facility = this.facilityCache.get(icao);
        return facility ? out.set(facility) : undefined;
    }
    /**
     * Gets the geographic position for a flight plan leg terminator.
     * @param leg A flight plan leg.
     * @param icao The ICAO string of the leg's terminator fix.
     * @param out A GeoPoint object to which to write the result.
     * @returns The position of the leg terminator, or undefined if it could not be determined.
     */
    getTerminatorPosition(leg, icao, out) {
        if (leg.lat !== undefined && leg.lon !== undefined) {
            return out.set(leg.lat, leg.lon);
        }
        else {
            const facility = this.facilityCache.get(icao);
            return facility ? out.set(facility.lat, facility.lon) : undefined;
        }
    }
    /**
     * Gets the true course for a flight plan leg. If the leg defines an origin or fix VOR facility, then the magnetic
     * variation defined at the VOR is used to adjust magnetic course, otherwise the computed magnetic variation for the
     * specified point is used.
     * @param leg A flight plan leg.
     * @param point The location from which to get magnetic variation, if an origin VOR is not found.
     * @returns the true course for the flight plan leg.
     */
    getLegTrueCourse(leg, point) {
        if (leg.trueDegrees) {
            return leg.course;
        }
        const facIcao = (leg.originIcao && ICAO.isFacility(leg.originIcao) && ICAO.getFacilityType(leg.originIcao) === FacilityType.VOR) ? leg.originIcao
            : (leg.fixIcao && ICAO.isFacility(leg.fixIcao) && ICAO.getFacilityType(leg.fixIcao) === FacilityType.VOR) ? leg.fixIcao
                : undefined;
        const facility = facIcao ? this.facilityCache.get(facIcao) : undefined;
        const magVar = facility
            ? -facility.magneticVariation
            : Facilities.getMagVar(point.lat, point.lon);
        return NavMath.normalizeHeading(leg.course + magVar);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculate(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c;
        const calcs = (_a = legs[calculateIndex].calculated) !== null && _a !== void 0 ? _a : {
            startLat: undefined,
            startLon: undefined,
            endLat: undefined,
            endLon: undefined,
            ingressTurn: FlightPathUtils.createEmptyCircleVector(),
            egressTurn: FlightPathUtils.createEmptyCircleVector(),
            distance: 0,
            distanceWithTurns: 0,
            initialDtk: undefined,
            cumulativeDistance: 0,
            cumulativeDistanceWithTurns: 0,
            flightPath: []
        };
        const vectors = calcs.flightPath;
        if (this.skipWhenActive && activeLegIndex === calculateIndex && vectors.length > 0) {
            state.currentPosition = FlightPathUtils.getLegFinalPosition(calcs, (_b = state.currentPosition) !== null && _b !== void 0 ? _b : new GeoPoint(0, 0));
            state.currentCourse = (_c = FlightPathUtils.getLegFinalCourse(calcs)) !== null && _c !== void 0 ? _c : state.currentCourse;
            return calcs;
        }
        try {
            const vectorCount = this.calculateVectors(legs, calculateIndex, activeLegIndex, state, vectors);
            vectors.length = vectorCount;
        }
        catch (e) {
            console.error(e);
            vectors.length = 0;
        }
        return calcs;
    }
}
/**
 * Calculates flight path vectors for discontinuity legs.
 */
class DiscontinuityLegCalculator extends AbstractFlightPathLegCalculator {
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    vectors) {
        state.currentCourse = undefined;
        state.currentPosition = undefined;
        return 0;
    }
}
/**
 * Calculates flight path vectors for track to fix legs.
 */
class TrackToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.vectorBuilder = new GreatCircleBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state, vectors) {
        var _a, _b;
        const prevLeg = (_a = legs[calculateIndex - 1]) === null || _a === void 0 ? void 0 : _a.leg;
        const leg = legs[calculateIndex].leg;
        let vectorIndex = 0;
        const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[0]);
        if (!terminatorPos) {
            return vectorIndex;
        }
        (_b = state.currentPosition) !== null && _b !== void 0 ? _b : (state.currentPosition = terminatorPos.copy());
        const distance = state.currentPosition.distance(terminatorPos);
        if ((!prevLeg || (prevLeg.type !== LegType.FM && prevLeg.type !== LegType.VM)) && distance > GeoPoint.EQUALITY_TOLERANCE) {
            vectorIndex += this.vectorBuilder.build(vectors, vectorIndex, state.currentPosition, terminatorPos, state.currentCourse);
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(vectors[vectorIndex - 1]);
        }
        state.currentPosition.set(terminatorPos);
        return vectorIndex;
    }
}
/**
 * Calculates flight path vectors for direct to fix legs.
 */
class DirectToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleVectorBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state, vectors) {
        var _a, _b;
        const leg = legs[calculateIndex].leg;
        let vectorIndex = 0;
        const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[1]);
        if (!terminatorPos) {
            return vectorIndex;
        }
        (_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = terminatorPos.copy());
        const startPoint = this.geoPointCache[0].set(state.currentPosition);
        const initialCourse = leg.course !== 0
            ? leg.course % 360
            : (_b = state.currentCourse) !== null && _b !== void 0 ? _b : state.planeHeading;
        const distanceToTerminator = state.currentPosition.distance(terminatorPos);
        if (distanceToTerminator < GeoPoint.EQUALITY_TOLERANCE) {
            state.currentPosition.set(terminatorPos);
            return 0;
        }
        else if (Math.abs(distanceToTerminator - Math.PI) < GeoPoint.EQUALITY_TOLERANCE) {
            // terminator is antipodal to current position
            const path = this.geoCircleCache[0].setAsGreatCircle(state.currentPosition, initialCourse);
            vectorIndex += this.greatCircleVectorBuilder.build(vectors, vectorIndex, state.currentPosition, path, terminatorPos);
            state.currentCourse = path.bearingAt(terminatorPos, Math.PI);
            state.currentPosition.set(terminatorPos);
            return vectorIndex;
        }
        const startVec = startPoint.toCartesian(this.vec3Cache[0]);
        const terminatorVec = terminatorPos.toCartesian(this.vec3Cache[1]);
        const startPath = this.geoCircleCache[0].setAsGreatCircle(startPoint, initialCourse);
        state.currentCourse = initialCourse;
        const startPathEncirclesTerminator = startPath.encircles(terminatorVec);
        const startPathIncludesTerminator = startPath.includes(terminatorVec);
        const turnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
            : leg.turnDirection === LegTurnDirection.Right ? 'right'
                : startPathEncirclesTerminator && !startPathIncludesTerminator ? 'left' : 'right';
        const startToTurnCenterPath = this.geoCircleCache[0].setAsGreatCircle(startPoint, initialCourse + (turnDirection === 'left' ? -90 : 90));
        let maxTurnRadiusRad;
        if (!startPathIncludesTerminator && startPathEncirclesTerminator === (turnDirection === 'left')) {
            // terminator lies on the same side as the turn, which means there is the possibility that the turn circle can
            // encircle the terminator, which would make defining a great circle intersecting the terminator fix and also
            // tangent to the turn circle impossible. Therefore, we compute the maximum allowed turn radius, defined as the
            // radius such that the terminator fix lies exactly on the turn circle.
            const startToTerminatorPathNormal = GeoCircle.getGreatCircleNormal(startVec, terminatorVec, this.vec3Cache[2]);
            // the angle between the great-circle path from the start point to the turn center and the path from the start
            // point to the terminator fix
            const theta = Math.acos(Vec3Math.dot(startToTurnCenterPath.center, startToTerminatorPathNormal));
            maxTurnRadiusRad = Math.atan(Math.sin(distanceToTerminator) / (Math.cos(theta) * (1 + Math.cos(distanceToTerminator))));
        }
        else {
            // terminator lies on the starting path or on the opposite side as the turn. Either way, no turn can encircle the
            // terminator, and so there is no maximum turn radius.
            maxTurnRadiusRad = Math.PI / 2;
        }
        const turnRadiusRad = Math.min(maxTurnRadiusRad, state.desiredTurnRadius.asUnit(UnitType.GA_RADIAN));
        const turnCenterVec = startToTurnCenterPath.offsetDistanceAlong(startVec, turnRadiusRad, this.vec3Cache[2]);
        const turnCenterPoint = this.geoPointCache[2].setFromCartesian(turnCenterVec);
        // Find the great-circle path from the terminator fix that is tangent to the turn circle. There are guaranteed to
        // be two such paths. We choose between the two based on the initial turn direction.
        const turnCenterToTerminatorDistance = Math.acos(Vec3Math.dot(turnCenterVec, terminatorVec));
        // the angle between the the great-circle path from the terminator fix to the turn center and the two
        // great-circle paths from the terminator fix that are tangent to the turn circle.
        const alpha = Math.asin(Math.min(1, Math.sin(turnRadiusRad) / Math.sin(turnCenterToTerminatorDistance)));
        const terminatorFixBearingToTurnCenter = terminatorPos.bearingTo(turnCenterPoint);
        const finalPathCourse = NavMath.normalizeHeading(terminatorFixBearingToTurnCenter + alpha * Avionics.Utils.RAD2DEG * (turnDirection === 'left' ? -1 : 1) + 180);
        const finalPath = this.geoCircleCache[0].setAsGreatCircle(terminatorPos, finalPathCourse);
        const turnEndPoint = finalPath.closest(turnCenterPoint, this.geoPointCache[3]);
        if (!turnEndPoint.equals(startPoint)) {
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER), turnCenterPoint, startPoint, turnEndPoint);
        }
        state.currentPosition.set(turnEndPoint);
        state.currentCourse = finalPathCourse;
        if (!state.currentPosition.equals(terminatorPos)) {
            vectorIndex += this.greatCircleVectorBuilder.build(vectors, vectorIndex, state.currentPosition, terminatorPos);
        }
        state.currentPosition.set(terminatorPos);
        return vectorIndex;
    }
}
/**
 * Calculates flight path vectors for legs which define a turn ending at a defined terminator fix.
 */
class TurnToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state, vectors) {
        var _a, _b;
        const leg = legs[calculateIndex].leg;
        let vectorIndex = 0;
        const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[0]);
        const turnCenter = this.getTurnCenter(leg);
        if (!terminatorPos || !turnCenter) {
            return vectorIndex;
        }
        if (state.currentPosition && !state.currentPosition.equals(terminatorPos)) {
            const direction = leg.turnDirection === LegTurnDirection.Left ? 'left' : 'right';
            const radius = this.getTurnRadius(leg, turnCenter);
            if (radius) {
                const circle = FlightPathUtils.getTurnCircle(turnCenter, radius, direction, this.geoCircleCache[0]);
                const currentVec = circle.closest(state.currentPosition, this.vec3Cache[0]);
                const terminatorVec = circle.closest(terminatorPos, this.vec3Cache[1]);
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, circle, currentVec, terminatorVec);
                state.currentCourse = circle.bearingAt(terminatorVec);
                const turnVector = vectors[vectorIndex - 1];
                ((_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = new GeoPoint(0, 0))).set(turnVector.endLat, turnVector.endLon);
            }
        }
        (_b = state.currentPosition) !== null && _b !== void 0 ? _b : (state.currentPosition = terminatorPos.copy());
        return vectorIndex;
    }
}
/**
 * Calculates flight path vectors for radius to fix legs.
 */
class RadiusToFixLegCalculator extends TurnToFixLegCalculator {
    constructor() {
        super(...arguments);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getTurnCenter(leg) {
        return this.facilityCache.get(leg.arcCenterFixIcao);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getTurnRadius(leg, center) {
        var _a;
        return (_a = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[2])) === null || _a === void 0 ? void 0 : _a.distance(center);
    }
}
/**
 * Calculates flight path vectors for arc to fix legs.
 */
class ArcToFixLegCalculator extends TurnToFixLegCalculator {
    // eslint-disable-next-line jsdoc/require-jsdoc
    getTurnCenter(leg) {
        return this.facilityCache.get(leg.originIcao);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    getTurnRadius(leg, center) {
        return UnitType.METER.convertTo(leg.rho, UnitType.GA_RADIAN);
    }
}
/**
 * Calculates flight path vectors for legs which define a great-circle path terminating at an intercept with another
 * geo circle.
 */
class CircleInterceptLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     * @param includeInitialTurn Whether this calculator should calculate an initial turn toward the intercept course.
     */
    constructor(facilityCache, includeInitialTurn) {
        super(facilityCache, includeInitialTurn);
        this.includeInitialTurn = includeInitialTurn;
        this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.turnBuilder = new TurnToCourseBuilder();
        this.interceptBuilder = new CircleInterceptBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state, vectors) {
        var _a;
        const leg = legs[calculateIndex].leg;
        let vectorIndex = 0;
        const course = this.getInterceptCourse(legs, calculateIndex, state);
        const circleToIntercept = this.getCircleToIntercept(legs, calculateIndex, state, this.geoCircleCache[0]);
        if (course === undefined || !circleToIntercept || !state.currentPosition) {
            return vectorIndex;
        }
        const startCourse = (_a = state.currentCourse) !== null && _a !== void 0 ? _a : course;
        if (this.includeInitialTurn && Math.abs(NavMath.diffAngle(course, startCourse)) >= 1) {
            const turnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
                : leg.turnDirection === LegTurnDirection.Right ? 'right'
                    : NavMath.getTurnDirection(startCourse, course);
            vectorIndex += this.turnBuilder.build(vectors, vectorIndex, state.currentPosition, state.desiredTurnRadius.asUnit(UnitType.METER), turnDirection, startCourse, course);
            const turnVector = vectors[vectorIndex - 1];
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(turnVector);
            state.currentPosition.set(turnVector.endLat, turnVector.endLon);
        }
        else {
            state.currentCourse = course;
        }
        const numVectorsAdded = this.interceptBuilder.build(vectors, vectorIndex, state.currentPosition, course, circleToIntercept);
        if (numVectorsAdded > 0) {
            vectorIndex += numVectorsAdded;
            const lastVector = vectors[vectorIndex - 1];
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
            state.currentPosition.set(lastVector.endLat, lastVector.endLon);
        }
        return vectorIndex;
    }
}
/**
 * Calculates flight path vectors for course to DME legs.
 */
class CourseToDMELegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getInterceptCourse(legs, index) {
        const leg = legs[index].leg;
        const dmeFacility = this.facilityCache.get(leg.originIcao);
        return dmeFacility ? this.getLegTrueCourse(leg, dmeFacility) : undefined;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getCircleToIntercept(legs, index, state, out) {
        const leg = legs[index].leg;
        const dmeFacility = this.facilityCache.get(leg.originIcao);
        return dmeFacility ? out.set(dmeFacility, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN)) : undefined;
    }
}
/**
 * Calculates flight path vectors for course to radial intercept legs.
 */
class CourseToRadialLegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getInterceptCourse(legs, index) {
        const leg = legs[index].leg;
        const radialFacility = this.facilityCache.get(leg.originIcao);
        return radialFacility ? this.getLegTrueCourse(leg, radialFacility) : undefined;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getCircleToIntercept(legs, index, state, out) {
        const leg = legs[index].leg;
        const radialFacility = this.facilityCache.get(leg.originIcao);
        if (!radialFacility) {
            return undefined;
        }
        const magVar = (ICAO.getFacilityType(radialFacility.icao) === FacilityType.VOR)
            ? -radialFacility.magneticVariation
            : MagVar.get(radialFacility);
        return out.setAsGreatCircle(radialFacility, leg.theta + magVar);
    }
}
/**
 * Calculates flight path vectors for fix to DME legs.
 */
class FixToDMELegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getInterceptCourse(legs, index) {
        const leg = legs[index].leg;
        const startFacility = this.facilityCache.get(leg.fixIcao);
        return startFacility ? this.getLegTrueCourse(leg, startFacility) : undefined;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getCircleToIntercept(legs, index, state, out) {
        const leg = legs[index].leg;
        const dmeFacility = this.facilityCache.get(leg.originIcao);
        return dmeFacility ? out.set(dmeFacility, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN)) : undefined;
    }
}
/**
 * Calculates flight path vectors for course to intercept legs.
 */
class CourseToInterceptLegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getInterceptCourse(legs, index, state) {
        const leg = legs[index].leg;
        return state.currentPosition ? this.getLegTrueCourse(leg, state.currentPosition) : undefined;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getCircleToIntercept(legs, index, state, out) {
        return this.predictLegPath(legs, index + 1, out);
    }
    /**
     * Predicts the path of a leg. If a prediction cannot be made, NaN will be written to all fields of the result.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param out A GeoCircle to which to write the result.
     * @returns the predicted path of the leg.
     */
    predictLegPath(legs, index, out) {
        var _a;
        const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
        if (!leg) {
            return undefined;
        }
        switch (leg.type) {
            case LegType.CF:
                {
                    const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[2]);
                    return terminator ? out.setAsGreatCircle(terminator, this.getLegTrueCourse(leg, terminator)) : undefined;
                }
            case LegType.AF:
                {
                    const facility = this.facilityCache.get(leg.originIcao);
                    return facility ? out.set(facility, UnitType.METER.convertTo(leg.rho, UnitType.GA_RADIAN)) : undefined;
                }
            case LegType.RF:
                {
                    const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[2]);
                    const centerFacility = this.facilityCache.get(leg.arcCenterFixIcao);
                    return terminator && centerFacility ? out.set(centerFacility, terminator.distance(centerFacility)) : undefined;
                }
            case LegType.FM:
            case LegType.VM:
                {
                    const origin = this.facilityCache.get(leg.originIcao);
                    return origin ? out.setAsGreatCircle(origin, this.getLegTrueCourse(leg, origin)) : undefined;
                }
            default:
                return undefined;
        }
    }
}
/**
 * Calculates flight path vectors for track from fix legs.
 */
class TrackFromFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.vectorBuilder = new GreatCircleBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state, vectors) {
        var _a;
        const leg = legs[calculateIndex].leg;
        let vectorIndex = 0;
        const fixIcaoPoint = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        const startPoint = fixIcaoPoint !== null && fixIcaoPoint !== void 0 ? fixIcaoPoint : state.currentPosition;
        if (!startPoint) {
            return vectorIndex;
        }
        const course = this.getLegTrueCourse(leg, startPoint);
        const path = this.geoCircleCache[0].setAsGreatCircle(startPoint, course);
        vectorIndex += this.vectorBuilder.build(vectors, vectorIndex, startPoint, path, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN));
        if (vectorIndex > 0) {
            const lastVector = vectors[vectorIndex - 1];
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
            ((_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = new GeoPoint(0, 0))).set(lastVector.endLat, lastVector.endLon);
        }
        return vectorIndex;
    }
}
/**
 * Calculates flight path vectors for course to fix legs.
 */
class CourseToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [
            new GeoCircle(new Float64Array(3), 0),
            new GeoCircle(new Float64Array(3), 0),
            new GeoCircle(new Float64Array(3), 0)
        ];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
        this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state, vectors) {
        var _a, _b, _c;
        const leg = legs[calculateIndex].leg;
        const prevLeg = legs[calculateIndex - 1];
        let vectorIndex = 0;
        const startPoint = state.currentPosition ? this.geoPointCache[0].set(state.currentPosition) : undefined;
        const endPoint = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[1]);
        if (!endPoint) {
            return vectorIndex;
        }
        const endCourse = this.getLegTrueCourse(leg, endPoint);
        const endVec = endPoint.toCartesian(this.vec3Cache[1]);
        const endPath = this.geoCircleCache[1].setAsGreatCircle(endPoint, endCourse);
        if (!startPoint || (prevLeg && (prevLeg.leg.type === LegType.FM || prevLeg.leg.type === LegType.VM))) {
            // Begins at a discontinuity OR previous leg is a manual termination leg.
            // Default to a track with start arbitrarily placed 5 NM from the terminator fix.
            const midPoint = endPath.offsetDistanceAlong(endVec, UnitType.NMILE.convertTo(-5, UnitType.GA_RADIAN), this.geoPointCache[2]);
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, midPoint, endPoint);
        }
        else {
            const startVec = startPoint.toCartesian(this.vec3Cache[0]);
            const currentCourse = (_a = state.currentCourse) !== null && _a !== void 0 ? _a : startPoint.bearingTo(endPoint);
            const startPath = this.geoCircleCache[0].setAsGreatCircle(startPoint, currentCourse);
            const startToEndPath = this.geoCircleCache[2].setAsGreatCircle(startVec, endVec);
            const pathDot = Vec3Math.dot(startPath.center, endPath.center);
            if (-pathDot > 1 - GeoPoint.EQUALITY_TOLERANCE) {
                // The start and end paths are anti-parallel, which means we need to execute a procedure turn to do a 180.
                // Favor right turn unless we are explicitly told to turn left.
                const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left' : 'right';
                vectorIndex += this.procTurnBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, currentCourse + 45 * (desiredTurnDirection === 'left' ? -1 : 1), state.desiredTurnRadius.asUnit(UnitType.METER), desiredTurnDirection, currentCourse, endCourse);
            }
            else if (endPath.angleAlong(startVec, endVec, Math.PI) < Math.PI
                && (pathDot > 1 - GeoPoint.EQUALITY_TOLERANCE
                    || (prevLeg && ((_b = prevLeg.calculated) === null || _b === void 0 ? void 0 : _b.flightPath.length) && endPath.includes(startVec, UnitType.METER.convertTo(10, UnitType.GA_RADIAN)))
                    || Vec3Math.dot(startToEndPath.center, endPath.center) >= 0.996194698 // 5 degrees
                )) {
                /*
                 * The start and end paths are parallel, so we can just connect the start and end with a track.
                 *
                 * OR the start point lies on the final course path (within a generous tolerance) and the previous leg has at
                 * least one calculated vector. In this case we will simply create a track from the start to end and let turn
                 * anticipation handle the initial turn into the final course.
                 *
                 * OR the difference between the course from start to end points and the final course is < 5 degrees, in which
                 * case we will just use the track to prevent us from calculating really long and suboptimal intercept paths.
                 */
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, endPoint);
            }
            else {
                const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
                    : leg.turnDirection === LegTurnDirection.Right ? 'right'
                        : NavMath.getTurnDirection(currentCourse, endCourse);
                vectorIndex += this.joinGreatCircleToPointBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, desiredTurnDirection, state.desiredTurnRadius.asUnit(UnitType.METER));
            }
        }
        ((_c = state.currentPosition) !== null && _c !== void 0 ? _c : (state.currentPosition = new GeoPoint(0, 0))).set(endPoint);
        state.currentCourse = endCourse;
        return vectorIndex;
    }
}
/**
 * Calculates flight path vectors for procedure turn legs.
 */
class ProcedureTurnLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
        this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state, vectors) {
        var _a, _b, _c;
        const leg = legs[calculateIndex].leg;
        let vectorIndex = 0;
        const origin = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        if (!origin) {
            return vectorIndex;
        }
        // If current lat/lon is not defined, then set it to the origin's location, simulating an IF at the leg origin.
        (_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = origin.copy());
        const nextLeg = (_b = legs[calculateIndex + 1]) === null || _b === void 0 ? void 0 : _b.leg;
        if (!origin.equals(state.currentPosition)) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, state.currentPosition, origin, state.currentCourse);
            state.currentCourse = origin.bearingFrom(state.currentPosition);
            state.currentPosition.set(origin);
        }
        if (!nextLeg) {
            return vectorIndex;
        }
        const nextLegTerminatorFix = this.getTerminatorPosition(nextLeg, nextLeg.fixIcao, this.geoPointCache[1]);
        if (!nextLegTerminatorFix) {
            return vectorIndex;
        }
        const inboundCourse = (_c = this.predictLegFinalTrueCourse(legs, calculateIndex + 1, nextLegTerminatorFix)) !== null && _c !== void 0 ? _c : 0;
        const outboundCourse = NavMath.normalizeHeading(inboundCourse + 180);
        const turnInitialCourse = leg.trueDegrees ? leg.course : MagVar.magneticToTrue(leg.course, origin);
        if (outboundCourse === turnInitialCourse) {
            return vectorIndex;
        }
        // must intercept the next leg at least 1 NM from the terminator fix
        const inboundPathEndpoint = nextLegTerminatorFix.offset(inboundCourse + 180, UnitType.NMILE.convertTo(1, UnitType.GA_RADIAN));
        const outboundPath = this.geoCircleCache[0].setAsGreatCircle(origin, outboundCourse);
        const inboundPath = this.geoCircleCache[1].setAsGreatCircle(inboundPathEndpoint, inboundCourse);
        const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
            : leg.turnDirection === LegTurnDirection.Right ? 'right'
                : undefined;
        vectorIndex += this.procTurnBuilder.build(vectors, vectorIndex, origin, outboundPath, inboundPathEndpoint, inboundPath, turnInitialCourse, state.desiredTurnRadius.asUnit(UnitType.METER), desiredTurnDirection, outboundCourse, inboundCourse);
        // addVectorsForProcTurn() is guaranteed to add at least one vector.
        const lastVector = vectors[vectorIndex - 1];
        state.currentPosition.set(lastVector.endLat, lastVector.endLon);
        state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
        return vectorIndex;
    }
    /**
     * Predicts the final true course of a leg at its terminator fix.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param terminator The location of the leg's terminator fix.
     * @returns the predicted final course of a leg at its terminator fix, or undefined if a prediction cannot be made.
     */
    predictLegFinalTrueCourse(legs, index, terminator) {
        var _a;
        const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
        if (!leg) {
            return undefined;
        }
        switch (leg.type) {
            case LegType.IF:
                return this.predictLegInitialTrueCourse(legs, index + 1, terminator);
            case LegType.CF:
                return this.getLegTrueCourse(leg, terminator);
            default:
                return undefined;
        }
    }
    /**
     * Predicts the initial true course of a leg at its origin fix.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param origin The location of the leg's origin.
     * @returns the predicted final course of a leg at its terminator fix, or undefined if a prediction cannot be made.
     */
    predictLegInitialTrueCourse(legs, index, origin) {
        var _a;
        const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
        if (!leg) {
            return undefined;
        }
        try {
            switch (leg.type) {
                case LegType.IF:
                case LegType.TF:
                case LegType.DF:
                case LegType.CF:
                    {
                        const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[2]);
                        return terminator ? origin.bearingTo(terminator) : undefined;
                    }
                case LegType.CD:
                case LegType.VD:
                case LegType.CR:
                case LegType.VR:
                case LegType.FC:
                case LegType.FD:
                    return this.getLegTrueCourse(leg, origin);
                case LegType.FA:
                case LegType.CA:
                case LegType.VA:
                case LegType.FM:
                case LegType.VM:
                case LegType.CI:
                case LegType.VI:
                    return leg.trueDegrees ? leg.course : MagVar.magneticToTrue(leg.course, origin);
                default:
                    return undefined;
            }
        }
        catch (e) {
            return undefined;
        }
    }
}
/**
 * Calculates flight path vectors for course to manual legs.
 */
class CourseToManualLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state, vectors) {
        const leg = legs[calculateIndex].leg;
        let vectorIndex = 0;
        if (!state.currentPosition) {
            return vectorIndex;
        }
        const course = leg.trueDegrees ? leg.course : MagVar.magneticToTrue(leg.course, state.currentPosition);
        const normalizedEnd = state.currentPosition.offset(course, UnitType.NMILE.convertTo(1, UnitType.GA_RADIAN), this.geoPointCache[0]);
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, state.currentPosition, normalizedEnd);
        state.currentPosition.set(normalizedEnd);
        state.currentCourse = course;
        return vectorIndex;
    }
}
/**
 * Calculates flight path vectors for course to altitude legs.
 */
class CourseToAltitudeLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state, vectors) {
        const leg = legs[calculateIndex].leg;
        let vectorIndex = 0;
        if (!state.currentPosition) {
            return vectorIndex;
        }
        const course = this.getLegTrueCourse(leg, state.currentPosition);
        const path = this.geoCircleCache[0].setAsGreatCircle(state.currentPosition, course);
        const originVec = state.currentPosition.toCartesian(this.vec3Cache[0]);
        const climbStartVec = activeLegIndex === calculateIndex
            ? path.closest(state.planePosition, this.vec3Cache[1])
            : originVec;
        const originToClimbStartDistance = (path.distanceAlong(originVec, climbStartVec) + 3 * Math.PI) % (2 * Math.PI) - Math.PI; // -pi to +pi
        const targetFeet = UnitType.METER.convertTo(leg.altitude1, UnitType.FOOT);
        const deltaAltitude = Math.max(0, targetFeet - state.planeAltitude.asUnit(UnitType.FOOT));
        const distanceRemaining = UnitType.NMILE.convertTo((deltaAltitude / state.planeClimbRate.asUnit(UnitType.FPM)) / 60 * state.planeSpeed.asUnit(UnitType.KNOT), UnitType.GA_RADIAN);
        const offsetDistance = Math.max(UnitType.FOOT.convertTo(100, UnitType.GA_RADIAN), originToClimbStartDistance + distanceRemaining);
        const legEndVec = path.offsetDistanceAlong(originVec, offsetDistance, this.vec3Cache[1]);
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, originVec, path, legEndVec);
        state.currentPosition.setFromCartesian(legEndVec);
        state.currentCourse = path.bearingAt(legEndVec);
        return vectorIndex;
    }
}
/**
 * Calculates flight path vectors for hold legs.
 */
class HoldLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.turnToCourseBuilder = new TurnToCourseBuilder();
        this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
        this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state, vectors) {
        var _a, _b, _c, _d;
        const leg = legs[calculateIndex].leg;
        let vectorIndex = 0;
        const holdPos = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        if (!holdPos) {
            return vectorIndex;
        }
        // If current lat/lon is not defined, then set it to the facility's location, simulating an IF at the hold's
        // facility.
        (_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = holdPos.copy());
        if (!state.currentPosition.equals(holdPos)) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, state.currentPosition, holdPos, state.currentCourse);
            state.currentCourse = holdPos.bearingFrom(state.currentPosition);
        }
        const course = this.getLegTrueCourse(leg, holdPos);
        const distance = leg.distanceMinutes
            ? UnitType.NMILE.convertTo(leg.distance * (state.planeSpeed.asUnit(UnitType.KNOT) / 60), UnitType.GA_RADIAN)
            : UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN);
        const turnDirection = leg.turnDirection === LegTurnDirection.Right ? 'right' : 'left';
        const turnRadiusMeters = state.desiredTurnRadius.asUnit(UnitType.METER);
        const inboundPath = this.geoCircleCache[0].setAsGreatCircle(holdPos, course);
        // Handle hold entry
        state.currentPosition.set(holdPos);
        (_b = state.currentCourse) !== null && _b !== void 0 ? _b : (state.currentCourse = course);
        const turnDirectionSign = turnDirection === 'left' ? -1 : 1;
        const normalizedEntryCourse = ((state.currentCourse - course) + 540) % 360 - 180; // -180 to +180
        let isDirectEntry = true;
        if (normalizedEntryCourse > 110) {
            isDirectEntry = false;
            // teardrop entry
            if (normalizedEntryCourse * turnDirectionSign > 135) {
                // need to make initial turn to get a 45-degree outbound leg
                const outboundCourse = course + 135 * turnDirectionSign;
                vectorIndex += this.turnToCourseBuilder.build(vectors, vectorIndex, holdPos, turnRadiusMeters, turnDirection === 'left' ? 'right' : 'left', state.currentCourse, outboundCourse);
                const turnVector = vectors[vectorIndex - 1];
                state.currentPosition.set(turnVector.endLat, turnVector.endLon);
                state.currentCourse = (_c = FlightPathUtils.getVectorFinalCourse(turnVector)) !== null && _c !== void 0 ? _c : outboundCourse;
            }
            vectorIndex += this.joinGreatCircleToPointBuilder.build(vectors, vectorIndex, state.currentPosition, this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, state.currentCourse), holdPos, inboundPath, turnDirection, turnRadiusMeters);
        }
        else if (normalizedEntryCourse * turnDirectionSign < -70) {
            isDirectEntry = false;
            // parallel entry
            const parallelCourse = course + 180;
            vectorIndex += this.turnToCourseBuilder.build(vectors, vectorIndex, holdPos, turnRadiusMeters, turnDirection === 'left' ? 'right' : 'left', state.currentCourse, parallelCourse);
            const turnVector = vectors[vectorIndex - 1];
            state.currentPosition.set(turnVector.endLat, turnVector.endLon);
            state.currentCourse = (_d = FlightPathUtils.getVectorFinalCourse(turnVector)) !== null && _d !== void 0 ? _d : parallelCourse;
            vectorIndex += this.procTurnBuilder.build(vectors, vectorIndex, state.currentPosition, this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, state.currentCourse), holdPos, inboundPath, course + 135 * turnDirectionSign, turnRadiusMeters, turnDirection === 'left' ? 'right' : 'left', state.currentCourse, course);
        }
        if (leg.type !== LegType.HF || isDirectEntry) {
            const egressCenterCourse = NavMath.normalizeHeading(course + 90 * turnDirectionSign);
            const turnRadiusRad = state.desiredTurnRadius.asUnit(UnitType.GA_RADIAN);
            const egressCenter = holdPos.offset(egressCenterCourse, turnRadiusRad, this.geoPointCache[1]);
            const egressTurnEnd = holdPos.offset(egressCenterCourse, turnRadiusRad * 2, this.geoPointCache[2]);
            const oppositeCourse = NavMath.normalizeHeading(course + 180);
            const egressEnd = egressTurnEnd.offset(oppositeCourse, distance, this.geoPointCache[3]);
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, turnRadiusMeters, egressCenter, holdPos, egressTurnEnd);
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, egressTurnEnd, egressEnd);
            const ingressCenterCourse = NavMath.normalizeHeading(oppositeCourse + 90 * turnDirectionSign);
            const ingressCenter = egressEnd.offset(ingressCenterCourse, turnRadiusRad, this.geoPointCache[1]);
            const ingressTurnEnd = egressEnd.offset(ingressCenterCourse, turnRadiusRad * 2, this.geoPointCache[2]);
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, turnRadiusMeters, ingressCenter, egressEnd, ingressTurnEnd);
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, ingressTurnEnd, holdPos);
        }
        state.currentPosition.set(holdPos);
        state.currentCourse = course;
        return vectorIndex;
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * Calculates the flight path vectors for a given set of legs.
 */
class FlightPathCalculator {
    /**
     * Creates an instance of the FlightPathCalculator.
     * @param facilityLoader The facility loader to use with this instance.
     * @param options The options to use with this flight path calculator.
     */
    constructor(facilityLoader, options) {
        this.facilityLoader = facilityLoader;
        this.options = options;
        this.vector3Cache = [new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [
            GeoCircle.createFromPoint(this.geoPointCache[0], 0), GeoCircle.createFromPoint(this.geoPointCache[0], 0),
            GeoCircle.createFromPoint(this.geoPointCache[0], 0), GeoCircle.createFromPoint(this.geoPointCache[0], 0)
        ];
        this.intersectionVecArrayCache = [new Float64Array(3), new Float64Array(3)];
        this.intersectionGeoPointArrayCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.facilityCache = new Map();
        this.legCalculatorMap = this.createLegCalculatorMap();
        this.state = new FlightPathStateClass();
    }
    /**
     * Creates a map from leg types to leg calculators.
     * @returns A map from leg types to leg calculators.
     */
    createLegCalculatorMap() {
        let calc;
        return {
            [LegType.Unknown]: calc = new TrackToFixLegCalculator(this.facilityCache),
            [LegType.IF]: calc,
            [LegType.TF]: calc,
            [LegType.AF]: new ArcToFixLegCalculator(this.facilityCache),
            [LegType.CD]: calc = new CourseToDMELegCalculator(this.facilityCache),
            [LegType.VD]: calc,
            [LegType.CF]: new CourseToFixLegCalculator(this.facilityCache),
            [LegType.CR]: calc = new CourseToRadialLegCalculator(this.facilityCache),
            [LegType.VR]: calc,
            [LegType.FC]: new TrackFromFixLegCalculator(this.facilityCache),
            [LegType.FD]: new FixToDMELegCalculator(this.facilityCache),
            [LegType.RF]: new RadiusToFixLegCalculator(this.facilityCache),
            [LegType.DF]: new DirectToFixLegCalculator(this.facilityCache),
            [LegType.FA]: calc = new CourseToAltitudeLegCalculator(this.facilityCache),
            [LegType.CA]: calc,
            [LegType.VA]: calc,
            [LegType.FM]: calc = new CourseToManualLegCalculator(this.facilityCache),
            [LegType.VM]: calc,
            [LegType.CI]: calc = new CourseToInterceptLegCalculator(this.facilityCache),
            [LegType.VI]: calc,
            [LegType.PI]: new ProcedureTurnLegCalculator(this.facilityCache),
            [LegType.HA]: calc = new HoldLegCalculator(this.facilityCache),
            [LegType.HM]: calc,
            [LegType.HF]: calc,
            [LegType.Discontinuity]: new DiscontinuityLegCalculator(this.facilityCache)
        };
    }
    /**
     * Calculates a flight path for a given set of flight plan legs.
     * @param legs The legs of the flight plan and/or procedure.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the leg to start at.
     * @param count The number of legs to calculate.
     */
    async calculateFlightPath(legs, activeLegIndex, initialIndex = 0, count = Number.POSITIVE_INFINITY) {
        count = Math.min(legs.length - initialIndex, count);
        this.state.updatePlaneState(this.options);
        await this.loadFacilities(legs, initialIndex, count);
        this.initCurrentLatLon(legs, initialIndex);
        this.initCurrentCourse(legs, initialIndex);
        this.calculateLegPaths(legs, activeLegIndex, initialIndex, count);
        this.computeLegToLegTurns(legs, initialIndex, count);
        this.updateLegDistanceWithTurns(legs, initialIndex, count);
    }
    /**
     * Loads facilities required for flight path calculations from the flight plan.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     * @param count The number of legs to calculate.
     */
    async loadFacilities(legs, initialIndex, count) {
        const facilityPromises = [];
        for (let i = initialIndex; i < initialIndex + count; i++) {
            this.stageFacilityLoad(legs[i].leg.fixIcao, facilityPromises);
            this.stageFacilityLoad(legs[i].leg.originIcao, facilityPromises);
            this.stageFacilityLoad(legs[i].leg.arcCenterFixIcao, facilityPromises);
        }
        if (facilityPromises.length > 0) {
            await Promise.all(facilityPromises);
        }
    }
    /**
     * Initializes the current lat/lon.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    initCurrentLatLon(legs, initialIndex) {
        var _a;
        var _b;
        let index = Math.min(initialIndex, legs.length);
        while (--index >= 0) {
            const leg = legs[index];
            if (leg.leg.type === LegType.Discontinuity) {
                return;
            }
            const calc = leg.calculated;
            if (calc && calc.endLat !== undefined && calc.endLon !== undefined) {
                ((_a = (_b = this.state).currentPosition) !== null && _a !== void 0 ? _a : (_b.currentPosition = new GeoPoint(0, 0))).set(calc.endLat, calc.endLon);
                return;
            }
        }
        this.state.currentPosition = undefined;
    }
    /**
     * Initializes the current course.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    initCurrentCourse(legs, initialIndex) {
        let index = Math.min(initialIndex, legs.length);
        while (--index >= 0) {
            const leg = legs[index];
            if (leg.leg.type === LegType.Discontinuity) {
                return;
            }
            const legCalc = leg.calculated;
            if (legCalc && legCalc.flightPath.length > 0) {
                this.state.currentCourse = FlightPathUtils.getLegFinalCourse(legCalc);
                if (this.state.currentCourse !== undefined) {
                    return;
                }
            }
        }
        this.state.currentCourse = undefined;
    }
    /**
     * Calculates flight paths for a sequence of flight plan legs.
     * @param legs A sequence of flight plan legs.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the first leg to calculate.
     * @param count The number of legs to calculate.
     */
    calculateLegPaths(legs, activeLegIndex, initialIndex, count) {
        const end = initialIndex + count;
        for (let i = initialIndex; i < end; i++) {
            this.calculateLegPath(legs, i, activeLegIndex);
        }
    }
    /**
     * Calculates a flight path for a leg in a sequence of legs.
     * @param legs A sequence of flight plan legs.
     * @param calculateIndex The index of the leg to calculate.
     * @param activeLegIndex The index of the active leg.
     */
    calculateLegPath(legs, calculateIndex, activeLegIndex) {
        var _a, _b, _c;
        const definition = legs[calculateIndex];
        definition.calculated = this.legCalculatorMap[definition.leg.type].calculate(legs, calculateIndex, activeLegIndex, this.state);
        definition.calculated.distance = 0;
        const len = definition.calculated.flightPath.length;
        for (let i = 0; i < len; i++) {
            definition.calculated.distance += definition.calculated.flightPath[i].distance;
        }
        definition.calculated.cumulativeDistance = definition.calculated.distance + ((_c = (_b = (_a = legs[calculateIndex - 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistance) !== null && _c !== void 0 ? _c : 0);
        const start = definition.calculated.flightPath[0];
        const end = definition.calculated.flightPath[definition.calculated.flightPath.length - 1];
        definition.calculated.initialDtk = undefined;
        if (start !== undefined) {
            const trueDtk = FlightPathUtils.getVectorInitialCourse(start);
            if (!isNaN(trueDtk)) {
                definition.calculated.initialDtk = MagVar.trueToMagnetic(trueDtk, start.startLat, start.startLon);
            }
        }
        definition.calculated.startLat = start === null || start === void 0 ? void 0 : start.startLat;
        definition.calculated.startLon = start === null || start === void 0 ? void 0 : start.startLon;
        definition.calculated.endLat = end === null || end === void 0 ? void 0 : end.endLat;
        definition.calculated.endLon = end === null || end === void 0 ? void 0 : end.endLon;
        if (!end && this.state.currentPosition) {
            definition.calculated.endLat = this.state.currentPosition.lat;
            definition.calculated.endLon = this.state.currentPosition.lon;
        }
    }
    /**
     * Updates leg distances with turn anticipation.
     * @param legs A sequence of flight plan legs.
     * @param initialIndex The index of the first leg to update.
     * @param count The number of legs to update.
     */
    updateLegDistanceWithTurns(legs, initialIndex, count) {
        var _a, _b, _c;
        const end = initialIndex + count;
        for (let i = initialIndex; i < end; i++) {
            const leg = legs[i];
            const calc = leg.calculated;
            calc.distanceWithTurns = 0;
            const len = calc.flightPath.length;
            for (let j = 0; j < len; j++) {
                calc.distanceWithTurns += this.calculateVectorWithTurnDistance(j, calc);
            }
            calc.cumulativeDistanceWithTurns = calc.distanceWithTurns + ((_c = (_b = (_a = legs[i - 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistanceWithTurns) !== null && _c !== void 0 ? _c : 0);
        }
    }
    /**
     * Calculates a flight path vector distance that includes a possible ingress or egress
     * turn.
     * @param index The index of the flight path vector in the calculations.
     * @param calcs The calculations to use.
     * @returns The flight path vector distance including turns.
     */
    calculateVectorWithTurnDistance(index, calcs) {
        let distance = 0;
        const start = this.geoPointCache[0];
        const end = this.geoPointCache[1];
        const vector = calcs.flightPath[index];
        if (index === 0 && calcs.ingressTurn.radius !== 0) {
            distance += calcs.ingressTurn.distance;
            start.set(calcs.ingressTurn.endLat, calcs.ingressTurn.endLon);
        }
        else {
            start.set(vector.startLat, vector.startLon);
        }
        if (index === calcs.flightPath.length - 1 && calcs.egressTurn.radius !== 0) {
            distance += calcs.egressTurn.distance;
            end.set(calcs.egressTurn.startLat, calcs.egressTurn.startLon);
        }
        else {
            end.set(vector.endLat, vector.endLon);
        }
        const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
        distance += UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.METER);
        return distance;
    }
    /**
     * Computes leg to leg turns for a given sequence of legs.
     * @param legs A sequence of legs.
     * @param startIndex The index of the first leg for which to compute turns.
     * @param count The total number of legs for which to compute turns.
     */
    computeLegToLegTurns(legs, startIndex, count) {
        var _a, _b;
        const turnRadiusMeters = this.state.desiredTurnRadius.asUnit(UnitType.METER);
        const end = startIndex + count;
        let currentIndex = startIndex;
        while (currentIndex < end) {
            const legBeforeCalc = (_a = legs[currentIndex]) === null || _a === void 0 ? void 0 : _a.calculated;
            const legAfterCalc = (_b = legs[currentIndex + 1]) === null || _b === void 0 ? void 0 : _b.calculated;
            if (legBeforeCalc && legAfterCalc) {
                const vectorBefore = legBeforeCalc.flightPath[legBeforeCalc.flightPath.length - 1];
                const vectorAfter = legAfterCalc.flightPath[0];
                if (vectorBefore && vectorAfter) {
                    if (vectorBefore.radius === Math.PI / 2 && vectorAfter.radius === Math.PI / 2) {
                        currentIndex = this.computeLegToLegTrackTrackTurn(legs, currentIndex, currentIndex + 1, vectorBefore, vectorAfter, turnRadiusMeters);
                        continue;
                    }
                    else if (vectorAfter.radius === Math.PI / 2) {
                        currentIndex = this.computeLegToLegArcTrackTurn(legs, currentIndex, currentIndex + 1, vectorBefore, vectorAfter, true, turnRadiusMeters);
                        continue;
                    }
                    else if (vectorBefore.radius === Math.PI / 2) {
                        currentIndex = this.computeLegToLegArcTrackTurn(legs, currentIndex, currentIndex + 1, vectorAfter, vectorBefore, false, turnRadiusMeters);
                        continue;
                    }
                }
                this.setEmptyLegToLegTurn(legBeforeCalc, legAfterCalc);
            }
            currentIndex++;
        }
    }
    /**
     * Calculates a leg to leg turn between two track vectors.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param fromTrack The track vector on which the turn begins.
     * @param toTrack The track vector on which the turn ends.
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @param previousTanTheta The tangent of the theta value of the previous turn. Theta is defined as the (acute)
     * angle between either `fromTrack` or `toTrack` and the great circle passing through the turn vertex (where the two
     * tracks meet) and the center of the turn. If this value is defined, the anticipation of both turns will be adjusted
     * if necessary such that the turns do not overlap if they share a common flight path vector. If the value is
     * undefined, the anticipation of the current turn will be restricted by the previous turn, if necessary, without
     * changing the anticipation of the previous turn.
     * @returns the index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    computeLegToLegTrackTrackTurn(legs, fromIndex, toIndex, fromTrack, toTrack, desiredTurnRadius, previousTanTheta) {
        var _a, _b;
        let lastComputedIndex = toIndex;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const fromLegCalc = legs[fromIndex].calculated;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const toLegCalc = legs[toIndex].calculated;
        const turnVertexPoint = this.geoPointCache[0].set(fromTrack.endLat, fromTrack.endLon);
        const fromTrackBearing = turnVertexPoint.bearingFrom(fromTrack.startLat, fromTrack.startLon);
        const toTrackBearing = turnVertexPoint.bearingTo(toTrack.endLat, toTrack.endLon);
        const trackAngleDiff = Math.abs(NavMath.diffAngle(fromTrackBearing, toTrackBearing));
        if (trackAngleDiff < 1
            || trackAngleDiff > 179
            || fromTrack.distance === 0
            || toTrack.distance === 0
            || !turnVertexPoint.equals(toTrack.startLat, toTrack.startLon, 1e-5)) {
            this.setEmptyLegToLegTurn(fromLegCalc, toLegCalc);
            return lastComputedIndex;
        }
        const theta = (180 - trackAngleDiff) / 2;
        const tanTheta = Math.tan(theta * Avionics.Utils.DEG2RAD);
        // D is defined as the distance from the start/end of the turn to the turn vertex along the from- and to- tracks
        // (i.e. the anticipation).
        const desiredD = Math.asin(Math.tan(UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN)) / tanTheta);
        let restrictedD = Infinity;
        if (previousTanTheta === undefined) {
            // Check to see if there is a previous anticipated turn and if it shares a common flight path vector with this one.
            if (fromLegCalc.ingressTurn.radius > 0 && fromLegCalc.flightPath.length === 1) {
                restrictedD = turnVertexPoint.distance(fromLegCalc.ingressTurn.endLat, fromLegCalc.ingressTurn.endLon);
            }
        }
        else {
            // D is restricted by a previous turn. The values of D_current and D_previous are restricted such that their sum
            // cannot exceed the total length of their shared vector (the from- vector for this turn). Therefore, we set the
            // maximum value of D_current such that at D_current(max), the radius of this turn equals the radius of the
            // previous turn. This will maximize min(radius_current, radius_prev).
            const tanThetaRatio = previousTanTheta / tanTheta;
            const totalD = UnitType.METER.convertTo(fromTrack.distance, UnitType.GA_RADIAN);
            const cosTotalD = Math.cos(totalD);
            let prevTurnRestrictedD = Math.acos((tanThetaRatio * cosTotalD + 1) / Math.sqrt(tanThetaRatio * tanThetaRatio + 2 * tanThetaRatio * cosTotalD + 1));
            if (prevTurnRestrictedD > totalD) {
                prevTurnRestrictedD = Math.PI - prevTurnRestrictedD;
            }
            restrictedD = prevTurnRestrictedD;
        }
        // We need to scan forward in the leg sequence to compute any restrictions on D imposed by later turns.
        if (toLegCalc.flightPath.length === 1) {
            const nextVector = (_b = (_a = legs[toIndex + 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.flightPath[0];
            if (nextVector) {
                let nextTurnRestrictedD;
                if (!FlightPathUtils.isVectorGreatCircle(nextVector)) {
                    nextTurnRestrictedD = UnitType.METER.convertTo(toTrack.distance / 2, UnitType.GA_RADIAN);
                }
                else {
                    // if the next turn to share a vector with this turn is to a track vector, we need to recursively compute
                    // future turns since the next turn may be restricted by the turn after that, etc.
                    lastComputedIndex = this.computeLegToLegTrackTrackTurn(legs, toIndex, toIndex + 1, toTrack, nextVector, desiredTurnRadius, tanTheta);
                    turnVertexPoint.set(fromTrack.endLat, fromTrack.endLon);
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    const nextTurnEgress = legs[toIndex].calculated.egressTurn;
                    nextTurnRestrictedD = turnVertexPoint.distance(nextTurnEgress.startLat, nextTurnEgress.startLon);
                }
                restrictedD = Math.min(restrictedD, nextTurnRestrictedD);
            }
        }
        const D = Math.min(desiredD, restrictedD, UnitType.METER.convertTo(fromTrack.distance, UnitType.GA_RADIAN), UnitType.METER.convertTo(toTrack.distance, UnitType.GA_RADIAN));
        // distance from the turn vertex to the center of the turn
        const H = Math.atan(Math.tan(D) / Math.cos(theta * Avionics.Utils.DEG2RAD));
        const turnRadiusRad = desiredD === D
            ? UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN)
            : Math.atan(Math.sin(D) * tanTheta);
        const turnDirection = NavMath.getTurnDirection(fromTrackBearing, toTrackBearing);
        const turnBisectorBearing = toTrackBearing + theta * (turnDirection === 'left' ? -1 : 1);
        const turnCenter = turnVertexPoint.offset(turnBisectorBearing, H, this.geoPointCache[1]);
        const fromTrackPath = this.geoCircleCache[0].setAsGreatCircle(turnVertexPoint, fromTrackBearing);
        const toTrackPath = this.geoCircleCache[1].setAsGreatCircle(turnVertexPoint, toTrackBearing);
        const turnStart = fromTrackPath.closest(turnCenter, this.geoPointCache[2]);
        const turnMiddle = turnVertexPoint.offset(turnBisectorBearing, H - turnRadiusRad, this.geoPointCache[3]);
        const turnEnd = toTrackPath.closest(turnCenter, this.geoPointCache[4]);
        this.setLegToLegTurn(fromLegCalc, toLegCalc, turnDirection, UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER), turnCenter, turnStart, turnMiddle, turnEnd);
        return lastComputedIndex;
    }
    /**
     * Calculates a leg to leg turn between an arc vector and a track vector.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param arc The arc vector.
     * @param track The track vector.
     * @param isArcFirst Whether the arc vector precedes the track vector (i.e. whether the arc vector is the vector on
     * which the turn begins).
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @returns the index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    computeLegToLegArcTrackTurn(legs, fromIndex, toIndex, arc, track, isArcFirst, desiredTurnRadius) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const fromLegCalc = legs[fromIndex].calculated;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const toLegCalc = legs[toIndex].calculated;
        if (arc.distance === 0 || track.distance === 0) {
            this.setEmptyLegToLegTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        /*
         * Theory: find the center of the turn circle. Since the turn circle is tangent to both the arc circle and the
         * great circle defined by the track path, it follows that the center of the turn circle lies at a distance equal
         * to the turn radius from both the arc circle and great circle. Therefore, we can find the center by applying a
         * radial offset equal to +/-[turn radius] to both the arc circle and great circle (the sign of the offset depends
         * on the direction of the arc and track path) and solving for the points of intersection between the offset
         * circles.
         */
        const fromVector = isArcFirst ? arc : track;
        const toVector = isArcFirst ? track : arc;
        const fromVectorEndPoint = this.geoPointCache[0].set(fromVector.endLat, fromVector.endLon);
        const toVectorStartPoint = this.geoPointCache[1].set(toVector.startLat, toVector.startLon);
        if (!fromVectorEndPoint.equals(toVectorStartPoint, 1e-5)) {
            this.setEmptyLegToLegTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        const fromVectorEndBearing = FlightPathUtils.getVectorFinalCourse(fromVector);
        const toVectorStartBearing = FlightPathUtils.getVectorInitialCourse(toVector);
        const vectorBearingDiff = Math.abs(NavMath.diffAngle(fromVectorEndBearing, toVectorStartBearing));
        if (vectorBearingDiff < 1) {
            this.setEmptyLegToLegTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        const circle = FlightPathUtils.setGeoCircleFromVector(arc, this.geoCircleCache[0]);
        const arcCenter = FlightPathUtils.getTurnCenterFromCircle(circle, this.geoPointCache[2]);
        const arcRadius = FlightPathUtils.getTurnRadiusFromCircle(circle);
        const arcDirection = FlightPathUtils.getTurnDirectionFromCircle(circle);
        // define the circles
        const arcCircle = this.geoCircleCache[0].set(arcCenter, arcRadius);
        const trackPath = FlightPathUtils.setGeoCircleFromVector(track, this.geoCircleCache[1]);
        const trackPathNormalPoint = this.geoPointCache[3].setFromCartesian(trackPath.center);
        const arcStartRadial = arcCircle.bearingAt(this.geoPointCache[4].set(arc.startLat, arc.startLon), Math.PI) + 90;
        const arcEndRadial = arcCircle.bearingAt(this.geoPointCache[4].set(arc.endLat, arc.endLon), Math.PI) + 90;
        // calculate whether the arc intersects the track; if they don't (or if they are entirely coincident), something
        // has gone wrong!
        const arcTrackIntersectionCount = arcCircle.numIntersectionPoints(trackPath);
        if (arcTrackIntersectionCount === 0 || isNaN(arcTrackIntersectionCount)) {
            this.setEmptyLegToLegTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        const turnDirection = NavMath.getTurnDirection(fromVectorEndBearing, toVectorStartBearing);
        let isInside;
        let turnRadiusRad;
        let arcCircleOffsetSign;
        let trackPathOffsetSign;
        if (arcTrackIntersectionCount === 1) {
            // arc circle and track path are tangent
            const isForward = Math.abs(NavMath.diffAngle(fromVectorEndBearing, toVectorStartBearing)) < 90;
            if (isForward) {
                this.setEmptyLegToLegTurn(fromLegCalc, toLegCalc);
                return toIndex;
            }
            else {
                // in this case, the plane effectively needs to make a 180...
                isInside = false;
                turnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
                arcCircleOffsetSign = 1;
                trackPathOffsetSign = trackPath.encircles(arcCenter) ? -1 : 1;
            }
        }
        else {
            const desiredTurnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
            isInside = isArcFirst
                ? Math.abs(NavMath.diffAngle(fromVectorEndPoint.bearingFrom(arcCenter), toVectorStartBearing)) >= 90
                : Math.abs(NavMath.diffAngle(fromVectorEndPoint.bearingFrom(arcCenter), fromVectorEndBearing)) < 90;
            /**
             * Now we must calculate the maximum allowed turn radius such that the turn does not start or end beyond the
             * limits of the arc or track. First, we convert the track limit to a pseudo-arc limit, then take the more
             * restrictive of the pseudo-arc limit and the actual arc limit. This maximally restrictive arc limit is then
             * used to compute the turn radius that would result in a turn which has an endpoint exactly at the limit.
             */
            const turnVertexRadialNormal = GeoCircle.getGreatCircleNormal(arcCenter, fromVectorEndPoint, this.vector3Cache[0]);
            // if the turn is inside the arc, then clamp track limit distance to half the length of the track path within the
            // arc, since that is the point at which turn radius is maximized.
            const maxTrackLimitDistance = isInside
                ? Math.atan(Math.abs(Vec3Math.dot(trackPath.center, turnVertexRadialNormal)) * Math.tan(arcRadius))
                : Infinity;
            const trackLimitDistance = Math.min(UnitType.METER.convertTo(track.distance / 2, UnitType.GA_RADIAN), maxTrackLimitDistance);
            const trackLimitPoint = isArcFirst
                ? toVectorStartPoint.offset(toVectorStartBearing, trackLimitDistance, this.geoPointCache[4])
                : fromVectorEndPoint.offset(fromVectorEndBearing + 180, trackLimitDistance, this.geoPointCache[4]);
            // the great circle which passes through the center of the arc and is perpendicular to the track
            const trackPerpendicularDiameter = this.geoCircleCache[2].set(Vec3Math.cross(Vec3Math.multScalar(trackPath.center, (isArcFirst === isInside ? -1 : 1), this.vector3Cache[1]), arcCircle.center, this.vector3Cache[1]), Math.PI / 2);
            const antipodes = this.intersectionVecArrayCache;
            trackPerpendicularDiameter.intersection(arcCircle, antipodes);
            // compute the great circle which passes through the appropriate antipode and the track limit endpoint. The
            // intersection of this great circle with the arc that is NOT the antipode is the pseudo-arc limit endpoint.
            const intersectingPath = this.geoCircleCache[3].setAsGreatCircle(isInside === (turnDirection === 'left') ? antipodes[0] : antipodes[1], trackLimitPoint);
            const arcIntersections = this.intersectionGeoPointArrayCache;
            const numArcIntersections = intersectingPath.intersectionGeoPoint(arcCircle, arcIntersections);
            let arcLimitAngularWidth = Infinity;
            if (numArcIntersections > 0) {
                const pseudoArcLimitPoint = arcIntersections[0];
                const pseudoArcLimitPointAngle = arcCenter.bearingTo(pseudoArcLimitPoint);
                arcLimitAngularWidth = Math.abs(NavMath.diffAngle((isArcFirst ? arcEndRadial : arcStartRadial), pseudoArcLimitPointAngle));
            }
            let arcTurnRadiusLimit = 0;
            const arcAngularWidth = ((arcDirection === 'left' ? (arcStartRadial - arcEndRadial) : (arcEndRadial - arcStartRadial)) + 360) % 360;
            arcLimitAngularWidth = Math.min(arcLimitAngularWidth, arcAngularWidth / 2);
            if (arcLimitAngularWidth > 0) {
                const arcLimitPointAngle = arcStartRadial + arcLimitAngularWidth * (arcDirection === 'left' ? -1 : 1);
                const arcLimitPoint = arcCenter.offset(arcLimitPointAngle, arcRadius, this.geoPointCache[4]);
                const arcLimitRadialPath = this.geoCircleCache[2].setAsGreatCircle(arcCenter, arcLimitPoint);
                // the angle between the radial to the arc endpoint and the track path (directed away from the arc at the point of intersection)
                const theta = Math.acos(Vec3Math.dot(arcLimitRadialPath.center, trackPath.center) * (isArcFirst === isInside ? -1 : 1));
                if (theta >= Math.PI / 2) {
                    if (isInside) {
                        const d = Math.asin(Math.sin(Math.acos(Math.abs(Vec3Math.dot(trackPath.center, turnVertexRadialNormal)))) * Math.sin(arcRadius));
                        arcTurnRadiusLimit = (arcRadius - d) / 2;
                    }
                    else {
                        arcTurnRadiusLimit = Infinity;
                    }
                }
                else {
                    const arcLimitRadialTrackIntersections = this.intersectionVecArrayCache;
                    arcLimitRadialPath.intersection(trackPath, arcLimitRadialTrackIntersections);
                    const arcLimitPointVec = arcLimitPoint.toCartesian(this.vector3Cache[0]);
                    const thresholdNormal = Vec3Math.normalize(Vec3Math.cross(arcLimitRadialPath.center, arcLimitPointVec, this.vector3Cache[1]), this.vector3Cache[1]);
                    const arcLimitRadialTrackIntersection = arcLimitRadialTrackIntersections[Vec3Math.dot(arcLimitRadialTrackIntersections[0], thresholdNormal) >= 0 ? 0 : 1];
                    // cosine of the distance from the arc endpoint to the intersection of the radial to the arc endpoint and the track path
                    const cosD = Vec3Math.dot(arcLimitRadialTrackIntersection, arcLimitPointVec);
                    const sinTheta = Math.sin(theta);
                    const sign = isInside ? -1 : 1;
                    arcTurnRadiusLimit = Math.acos((1 + sinTheta * cosD * sign) / Math.sqrt(1 + 2 * sinTheta * cosD * sign + sinTheta * sinTheta));
                }
            }
            turnRadiusRad = Math.min(desiredTurnRadiusRad, arcTurnRadiusLimit);
            arcCircleOffsetSign = isInside ? -1 : 1;
            trackPathOffsetSign = turnDirection === 'left' ? -1 : 1;
        }
        if (turnRadiusRad === 0) {
            this.setEmptyLegToLegTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        const arcCircleOffset = this.geoCircleCache[2].set(arcCircle.center, arcCircle.radius + turnRadiusRad * arcCircleOffsetSign);
        const trackPathOffset = this.geoCircleCache[3].set(trackPath.center, trackPath.radius + turnRadiusRad * trackPathOffsetSign);
        const intersections = this.intersectionGeoPointArrayCache;
        const intersectionCount = arcCircleOffset.intersectionGeoPoint(trackPathOffset, this.intersectionGeoPointArrayCache);
        if (intersectionCount === 0) {
            this.setEmptyLegToLegTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        let turnCenter;
        if (intersectionCount === 2) {
            if (arcTrackIntersectionCount === 1 || fromVectorEndPoint.distance(intersections[0]) >= fromVectorEndPoint.distance(intersections[1])) {
                turnCenter = intersections[1];
            }
            else {
                turnCenter = intersections[0];
            }
        }
        else {
            turnCenter = intersections[0];
        }
        const arcTangentBearing = (turnCenter.bearingTo(arcCenter) + (arcCircleOffsetSign === 1 ? 0 : 180)) % 360;
        const trackTangentBearing = (turnCenter.bearingTo(trackPathNormalPoint) + (trackPathOffsetSign === 1 ? 0 : 180)) % 360;
        const turnStartBearing = isArcFirst ? arcTangentBearing : trackTangentBearing;
        const turnEndBearing = isArcFirst ? trackTangentBearing : arcTangentBearing;
        let turnAngularDelta = turnEndBearing - turnStartBearing;
        if (turnDirection === 'right' && turnEndBearing <= turnStartBearing) {
            turnAngularDelta += 360;
        }
        else if (turnDirection === 'left' && turnEndBearing >= turnStartBearing) {
            turnAngularDelta -= 360;
        }
        const turnMiddleBearing = ((turnStartBearing + turnAngularDelta / 2) + 360) % 360;
        const turnStart = turnCenter.offset(turnStartBearing, turnRadiusRad, this.geoPointCache[0]);
        const turnEnd = turnCenter.offset(turnEndBearing, turnRadiusRad, this.geoPointCache[1]);
        const turnMiddle = turnCenter.offset(turnMiddleBearing, turnRadiusRad, this.geoPointCache[2]);
        turnRadiusRad = UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER);
        this.setLegToLegTurn(fromLegCalc, toLegCalc, turnDirection, turnRadiusRad, turnCenter, turnStart, turnMiddle, turnEnd);
        return toIndex;
    }
    /**
     * Stages a facility to be loaded.
     * @param icao The ICAO of the facility.
     * @param facilityPromises The array of facility load promises to push to.
     */
    stageFacilityLoad(icao, facilityPromises) {
        if (icao !== ICAO.emptyIcao && !this.facilityCache.has(icao)) {
            let facilityType;
            try {
                facilityType = ICAO.getFacilityType(icao);
            }
            catch (err) {
                //console.log(err);
            }
            if (facilityType !== undefined) {
                try {
                    facilityPromises.push(this.facilityLoader.getFacility(ICAO.getFacilityType(icao), icao)
                        .then(facility => {
                        this.facilityCache.set(facility.icao, facility);
                        return true;
                    })
                        .catch(() => false));
                }
                catch (err) {
                    //console.log(err);
                }
            }
        }
    }
    /**
     * Sets the parameters for a leg to leg turn.
     * @param fromLegCalc The calculations for the leg on which the turn begins.
     * @param toLegCalc The calculations for the leg on which the turn ends.
     * @param direction The direction of the turn.
     * @param radius The radius of the turn, in meters.
     * @param center The location of the center of the turn.
     * @param start The location of the start of the turn.
     * @param middle The location of the midpoint of the turn.
     * @param end The location of the end of the turn.
     */
    setLegToLegTurn(fromLegCalc, toLegCalc, direction, radius, center, start, middle, end) {
        var _a, _b;
        const egress = (_a = fromLegCalc.egressTurn) !== null && _a !== void 0 ? _a : (fromLegCalc.egressTurn = FlightPathUtils.createEmptyCircleVector());
        const ingress = (_b = toLegCalc.ingressTurn) !== null && _b !== void 0 ? _b : (toLegCalc.ingressTurn = FlightPathUtils.createEmptyCircleVector());
        const circle = FlightPathUtils.getTurnCircle(center, UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), direction, this.geoCircleCache[0]);
        egress.radius = circle.radius;
        egress.centerX = circle.center[0];
        egress.centerY = circle.center[1];
        egress.centerZ = circle.center[2];
        egress.startLat = start.lat;
        egress.startLon = start.lon;
        egress.endLat = middle.lat;
        egress.endLon = middle.lon;
        egress.distance = radius === 0 ? 0 : UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, middle, Math.PI), UnitType.METER);
        ingress.radius = circle.radius;
        ingress.centerX = circle.center[0];
        ingress.centerY = circle.center[1];
        ingress.centerZ = circle.center[2];
        ingress.startLat = middle.lat;
        ingress.startLon = middle.lon;
        ingress.endLat = end.lat;
        ingress.endLon = end.lon;
        ingress.distance = radius === 0 ? 0 : UnitType.GA_RADIAN.convertTo(circle.distanceAlong(middle, end, Math.PI), UnitType.METER);
    }
    /**
     * Sets an empty leg to leg turn.
     * @param fromLegCalc The calculations for the leg on which the turn begins.
     * @param toLegCalc The calculations for the leg on which the turn ends.
     */
    setEmptyLegToLegTurn(fromLegCalc, toLegCalc) {
        var _a, _b;
        const fromEnd = { lat: (_a = fromLegCalc.endLat) !== null && _a !== void 0 ? _a : 0, lon: (_b = fromLegCalc.endLon) !== null && _b !== void 0 ? _b : 0 };
        this.setLegToLegTurn(fromLegCalc, toLegCalc, 'left', 0, fromEnd, fromEnd, fromEnd, fromEnd);
    }
}
/**
 *
 */
class FlightPathStateClass {
    constructor() {
        this._planePosition = new GeoPoint(0, 0);
        this.planePosition = this._planePosition.readonly;
        this._planeHeading = 0;
        this._planeAltitude = UnitType.FOOT.createNumber(0);
        this.planeAltitude = this._planeAltitude.readonly;
        this._planeSpeed = UnitType.KNOT.createNumber(0);
        this.planeSpeed = this._planeSpeed.readonly;
        this._planeClimbRate = UnitType.FPM.createNumber(0);
        this.planeClimbRate = this._planeClimbRate.readonly;
        this._desiredTurnRadius = UnitType.METER.createNumber(0);
        this.desiredTurnRadius = this._desiredTurnRadius.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get planeHeading() {
        return this._planeHeading;
    }
    /**
     * Updates this state with the latest information on the airplane.
     * @param options Flight path calculator options.
     */
    updatePlaneState(options) {
        this._planePosition.set(SimVar.GetSimVarValue('PLANE LATITUDE', SimVarValueType.Degree), SimVar.GetSimVarValue('PLANE LONGITUDE', SimVarValueType.Degree));
        this._planeAltitude.set(SimVar.GetSimVarValue('INDICATED ALTITUDE', 'feet'));
        this._planeHeading = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', 'degree');
        this._planeSpeed.set(Math.max(SimVar.GetSimVarValue('GROUND VELOCITY', SimVarValueType.Knots), options.defaultSpeed));
        this._planeClimbRate.set(Math.max(SimVar.GetSimVarValue('VERTICAL SPEED', 'feet per minute'), options.defaultClimbRate));
        this._desiredTurnRadius.set(NavMath.turnRadius(this._planeSpeed.asUnit(UnitType.KNOT), options.bankAngle));
    }
}

/**
 * The details of procedures selected in the flight plan.
 */
class ProcedureDetails {
    constructor() {
        /** The origin runway object, consisting of the index of the origin runway
         * in the origin runway information and the direction */
        this.originRunway = undefined;
        /** The index of the departure in the origin airport information. */
        this.departureIndex = -1;
        /** The index of the departure transition in the origin airport departure information. */
        this.departureTransitionIndex = -1;
        /** The index of the selected runway in the original airport departure information. */
        this.departureRunwayIndex = -1;
        /** The index of the arrival in the destination airport information. */
        this.arrivalIndex = -1;
        /** The index of the arrival transition in the destination airport arrival information. */
        this.arrivalTransitionIndex = -1;
        /** The index of the selected runway transition at the destination airport arrival information. */
        this.arrivalRunwayTransitionIndex = -1;
        /** The index of the apporach in the destination airport information.*/
        this.approachIndex = -1;
        /** The index of the approach transition in the destination airport approach information.*/
        this.approachTransitionIndex = -1;
        /**
         * The destination runway object, consisting of the index of the destination runway
         * in the destination runway information and the direction
         */
        this.destinationRunway = undefined;
    }
}
/**
 * A prototype for signalling application-specific type metadata for plan segments.
 */
var FlightPlanSegmentType;
(function (FlightPlanSegmentType) {
    FlightPlanSegmentType["Origin"] = "Origin";
    FlightPlanSegmentType["Departure"] = "Departure";
    FlightPlanSegmentType["Enroute"] = "Enroute";
    FlightPlanSegmentType["Arrival"] = "Arrival";
    FlightPlanSegmentType["Approach"] = "Approach";
    FlightPlanSegmentType["Destination"] = "Destination";
    FlightPlanSegmentType["MissedApproach"] = "MissedApproach";
    FlightPlanSegmentType["RandomDirectTo"] = "RandomDirectTo";
})(FlightPlanSegmentType || (FlightPlanSegmentType = {}));
/**
 * A segment of a flight plan.
 */
class FlightPlanSegment {
    /**
     * Creates a new FlightPlanSegment.
     * @param segmentIndex The index of the segment within the flight plan.
     * @param offset The leg offset within the original flight plan that
     * the segment starts at.
     * @param legs The legs in the flight plan segment.
     * @param segmentType The type of segment this is.
     * @param airway The airway associated with this segment, if any.
     */
    constructor(segmentIndex, offset, legs, segmentType = FlightPlanSegmentType.Enroute, airway) {
        this.segmentIndex = segmentIndex;
        this.offset = offset;
        this.legs = legs;
        this.segmentType = segmentType;
        this.airway = airway;
    }
}
/** An empty flight plan segment. */
FlightPlanSegment.Empty = new FlightPlanSegment(-1, -1, []);

var PlanChangeType;
(function (PlanChangeType) {
    PlanChangeType["Added"] = "Added";
    PlanChangeType["Inserted"] = "Inserted";
    PlanChangeType["Removed"] = "Removed";
    PlanChangeType["Changed"] = "Changed";
    PlanChangeType["Cleared"] = "Cleared";
})(PlanChangeType || (PlanChangeType = {}));
var ActiveLegType;
(function (ActiveLegType) {
    ActiveLegType["Lateral"] = "Lateral";
    ActiveLegType["Vertical"] = "Vertical";
    ActiveLegType["Calculating"] = "Calculating";
})(ActiveLegType || (ActiveLegType = {}));
var OriginDestChangeType;
(function (OriginDestChangeType) {
    OriginDestChangeType["OriginAdded"] = "OriginAdded";
    OriginDestChangeType["OriginRemoved"] = "OriginRemoved";
    OriginDestChangeType["DestinationAdded"] = "DestinationAdded";
    OriginDestChangeType["DestinationRemoved"] = "DestinationRemoved";
})(OriginDestChangeType || (OriginDestChangeType = {}));
/**
 * A flight plan managed by the flight plan system.
 */
class FlightPlan {
    /**
     * Creates an instance of a FlightPlan.
     * @param planIndex The index within the flight planner of this flight plan.
     * @param calculator The flight path calculator to use to calculate the flight path.
     */
    constructor(planIndex, calculator) {
        this.planIndex = planIndex;
        this.calculator = calculator;
        this._activeLateralLeg = 0;
        this._activeVerticalLeg = 0;
        this._activeCalculatingLeg = 0;
        /** The direct to metadata for this plan. */
        this.directToData = { segmentIndex: -1, segmentLegIndex: -1 };
        /** Events fired when the plan is modified. */
        this.events = {};
        /** A callback fired when a flight plan leg is to be named. */
        this.onLegNameRequested = this.buildDefaultLegName;
        /** The details about the selected procedures. */
        this.procedureDetails = new ProcedureDetails();
        /** The flight plan segments that make up this flight plan. */
        this.planSegments = [];
        /** User assignable data. */
        this.userData = {};
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The ICAO of the origin airport in the flight plan, if any. */
    get originAirport() {
        return this._originAirport;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The ICAO of the destination airport in the flight plan, if any. */
    get destinationAirport() {
        return this._destinationAirport;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active lateral navigation leg. */
    get activeLateralLeg() {
        return this._activeLateralLeg;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active vertical navigation leg. */
    get activeVerticalLeg() {
        return this._activeVerticalLeg;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active calculating leg. */
    get activeCalculatingLeg() {
        return this._activeCalculatingLeg;
    }
    /**
     * Gets the current number of legs in the flight plan.
     * @returns The number of legs in the plan.
     */
    get length() {
        const segment = this.planSegments[this.planSegments.length - 1];
        if (segment !== undefined) {
            return segment.offset + segment.legs.length;
        }
        return 0;
    }
    /**
     * Gets the current number of segments in the flight plan.
     * @returns The number of legs in the plan.
     */
    get segmentCount() {
        return this.planSegments.length;
    }
    /**
     * Gets the legs for the flightplan.
     * @yields The flight plan legs.
     */
    *legs() {
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment !== undefined) {
                for (let l = 0; l < segment.legs.length; l++) {
                    yield segment.legs[l];
                }
            }
        }
    }
    /**
     * Gets the segments for the flightplan.
     * @yields The flight plan segments.
     */
    *segments() {
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment !== undefined) {
                yield segment;
            }
        }
    }
    /**
     * Gets all of the segments of a given type.
     * @param segmentType The type of the segments to retrieve.
     * @yields The segments of the requested type.
     */
    *segmentsOfType(segmentType) {
        for (const segment of this.segments()) {
            if (segment.segmentType == segmentType) {
                yield segment;
            }
        }
    }
    /**
     * Adds a segment to the flight plan at a specified index.
     * @param segmentIndex The index of the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any.
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    addSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
        const segment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
        this.planSegments[segmentIndex] = segment;
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, PlanChangeType.Added, segment);
        return segment;
    }
    /**
     * Inserts a segment into the flight plan at the specified index and
     * reflows the subsequent segments.
     * @param segmentIndex The index to insert the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    insertSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
        const segment = this.planSegments[segmentIndex];
        if (segment !== undefined) {
            const newSegment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
            this.planSegments.splice(segmentIndex, 0, newSegment);
            this.reflowSegments();
            this.reflowSegmentOffsets();
            notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, PlanChangeType.Inserted, newSegment);
            return newSegment;
        }
        else {
            return this.addSegment(segmentIndex, segmentType, airway, notify);
        }
    }
    /**
     * Reflows the flight plan segments after an insert.
     */
    reflowSegments() {
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment !== undefined && segment.segmentIndex !== i) {
                segment.segmentIndex = i;
            }
        }
    }
    /**
     * Deletes a segment from the flight plan, leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    deleteSegment(segmentIndex, notify = true) {
        const segment = this.planSegments[segmentIndex];
        if (segmentIndex === this.planSegments.length - 1) {
            this.planSegments.splice(segmentIndex, 1);
        }
        else {
            delete this.planSegments[segmentIndex];
        }
        if (this.directToData.segmentIndex === segmentIndex) ;
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, PlanChangeType.Removed, segment);
    }
    /**
     * Removes a segment from the flight plan and reflows the segments following
     * the removed segment, not leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeSegment(segmentIndex, notify = true) {
        const segment = this.planSegments[segmentIndex];
        this.planSegments.splice(segmentIndex, 1);
        this.reflowSegments();
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, PlanChangeType.Removed, segment);
    }
    /**
     * Gets a flight plan segment from the plan.
     * @param segmentIndex The index of the segment to get; if not specified returns the active segment.
     * @returns The requested flight plan segment.
     * @throws An error if the flight plan segment could not be found.
     */
    getSegment(segmentIndex) {
        if (segmentIndex === undefined) {
            let calculatedSegmentIndex = 0;
            for (const segment of this.segments()) {
                if (this.activeLateralLeg == 0 && segment.legs.length == 0) {
                    calculatedSegmentIndex++;
                }
                else if (this.activeLateralLeg > segment.offset + segment.legs.length) {
                    calculatedSegmentIndex++;
                }
                else {
                    break;
                }
            }
            const segment = this.planSegments[calculatedSegmentIndex];
            if (segment !== undefined) {
                return segment;
            }
        }
        else if (segmentIndex >= 0) {
            const segment = this.planSegments[segmentIndex];
            if (segment !== undefined) {
                return segment;
            }
        }
        throw new Error(`Flight plan segment with segment index ${segmentIndex} could not be found.`);
    }
    /**
     * Adds a leg to the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param leg The leg to add to the plan.
     * @param index The index of the leg in the segment to insert. Will add to the end of the segment if omitted.
     * @param isInDirectToSequence Whether the new leg is part of a direct to sequence.
     * @param isInMissedApproachSequence Whether the new leg is part of a missed approach sequence.
     * @param notify Whether or not to send notifications after the operation.
     * @returns the leg that was added.
     */
    addLeg(segmentIndex, leg, index, isInDirectToSequence = false, isInMissedApproachSequence = false, notify = true) {
        const segment = this.getSegment(segmentIndex);
        const legDefinition = { leg, isInDirectToSequence, isInMissedApproachSequence };
        if (index === undefined) {
            segment.legs.push(legDefinition);
            index = segment.legs.length - 1;
        }
        else {
            segment.legs.splice(index, 0, legDefinition);
        }
        legDefinition.name = this.onLegNameRequested(leg);
        this.reflowSegmentOffsets();
        notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, index, PlanChangeType.Added, legDefinition);
        return legDefinition;
    }
    /**
     * Gets a leg from the flight plan.
     * @param index The index of the leg to get.
     * @returns The definition of the plan leg.
     * @throws An error if the leg could not be found.
     */
    getLeg(index) {
        for (const segment of this.segments()) {
            if (segment.offset <= index && index < segment.offset + segment.legs.length) {
                return segment.legs[index - segment.offset];
            }
        }
        throw new Error('Leg with index ${index} could not be found.');
    }
    /**
     * Removes a leg from the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param index The index of the leg in the segment to remove. Will remove from the end of the segment if ommitted.
     * @param notify Whether or not to send notifications after the operation.
     * @returns the leg that was removed, or null if a leg was not removed.
     */
    removeLeg(segmentIndex, index, notify = true) {
        const segment = this.getSegment(segmentIndex);
        let legDefinition;
        if (index === undefined) {
            legDefinition = segment.legs.pop();
            index = segment.legs.length;
        }
        else {
            const deleted = segment.legs.splice(index, 1);
            legDefinition = deleted[0];
        }
        if (this.directToData.segmentIndex === segmentIndex && this.directToData.segmentLegIndex === index) ;
        this.reflowSegmentOffsets();
        notify && legDefinition && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, index, PlanChangeType.Removed, legDefinition);
        return legDefinition !== null && legDefinition !== void 0 ? legDefinition : null;
    }
    /**
     * Calculates the flight path for the plan.
     * @param index The leg index to start calculating from.
     * @param notify Whether or not to send notifications after the operation.
     */
    async calculate(index, notify = true) {
        const legs = [...this.legs()];
        await this.calculator.calculateFlightPath(legs, this.activeLateralLeg, index === undefined ? this.activeCalculatingLeg : index);
        notify && this.events.onCalculated && this.events.onCalculated(index);
    }
    /**
     * Sets the origin airport in the flight plan.
     * @param facilityIcao The origin airport to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setOriginAirport(facilityIcao, notify = true) {
        this._originAirport = facilityIcao;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginAdded, facilityIcao);
    }
    /**
     * Removes the origin airport from the flight plan.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeOriginAirport(notify = true) {
        const facilityIcao = this._originAirport;
        this._originAirport = undefined;
        this.procedureDetails.departureIndex = -1;
        this.procedureDetails.departureRunwayIndex = -1;
        this.procedureDetails.departureTransitionIndex = -1;
        this.procedureDetails.originRunway = undefined;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginRemoved, facilityIcao);
    }
    /**
     * Sets the destination airport in the flight plan.
     * @param facilityIcao The destination airport to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setDestinationAirport(facilityIcao, notify = true) {
        this._destinationAirport = facilityIcao;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationAdded, facilityIcao);
    }
    /**
     * Removes the destination airport from the flight plan.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeDestinationAirport(notify = true) {
        const facilityIcao = this._destinationAirport;
        this._destinationAirport = undefined;
        this.procedureDetails.approachIndex = -1;
        this.procedureDetails.approachTransitionIndex = -1;
        this.procedureDetails.arrivalIndex = -1;
        this.procedureDetails.arrivalRunwayTransitionIndex = -1;
        this.procedureDetails.arrivalTransitionIndex = -1;
        this.procedureDetails.destinationRunway = undefined;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationRemoved, facilityIcao);
    }
    /**
     * Sets the active lateral leg index in the flight plan.
     * @param index The index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setLateralLeg(index, notify = true) {
        let previousLegIndex = -1;
        let previousSegmentIndex = -1;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        if (this.length > 0) {
            previousSegmentIndex = this.getSegmentIndex(this._activeLateralLeg);
            if (previousSegmentIndex > -1) {
                previousLegIndex = this._activeLateralLeg - this.getSegment(previousSegmentIndex).offset;
            }
            this._activeLateralLeg = Utils.Clamp(index, 0, this.length - 1);
            segmentIndex = this.getSegmentIndex(this._activeLateralLeg);
            if (segmentIndex > -1) {
                segmentLegIndex = this._activeLateralLeg - this.getSegment(segmentIndex).offset;
            }
        }
        else {
            this._activeLateralLeg = 0;
        }
        notify
            && this.events.onActiveLegChanged
            && this.events.onActiveLegChanged(this._activeLateralLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Lateral);
    }
    /**
     * Sets the active lateral leg index in the flight plan.
     * @param index The index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setVerticalLeg(index, notify = true) {
        let previousLegIndex = -1;
        let previousSegmentIndex = -1;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        if (this.length > 0) {
            previousSegmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
            if (previousSegmentIndex > -1) {
                previousLegIndex = this._activeVerticalLeg - this.getSegment(previousSegmentIndex).offset;
            }
            this._activeVerticalLeg = Utils.Clamp(index, 0, this.length - 1);
            segmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
            if (segmentIndex > -1) {
                segmentLegIndex = this._activeVerticalLeg - this.getSegment(segmentIndex).offset;
            }
        }
        else {
            this._activeVerticalLeg = 0;
        }
        notify
            && this.events.onActiveLegChanged
            && this.events.onActiveLegChanged(this._activeVerticalLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Vertical);
    }
    /**
     * Sets the active calculating leg index in the flight plan.
     * @param index The index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setCalculatingLeg(index, notify = true) {
        let previousLegIndex = -1;
        let previousSegmentIndex = -1;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        if (this.length > 0) {
            previousSegmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
            if (previousSegmentIndex > -1) {
                previousLegIndex = this._activeCalculatingLeg - this.getSegment(previousSegmentIndex).offset;
            }
            this._activeCalculatingLeg = Utils.Clamp(index, 0, this.length - 1);
            segmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
            if (segmentIndex > -1) {
                segmentLegIndex = this._activeCalculatingLeg - this.getSegment(segmentIndex).offset;
            }
        }
        else {
            this._activeCalculatingLeg = 0;
        }
        notify
            && this.events.onActiveLegChanged
            && this.events.onActiveLegChanged(this._activeCalculatingLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Calculating);
    }
    /**
     * Sets the flight plan procedure details.
     * @param details The details of the flight plan's procedures.
     * @param notify Whether or not to send notifications after the operation.
     */
    setProcedureDetails(details, notify = true) {
        Object.assign(this.procedureDetails, details);
        notify && this.events.onProcedureDetailsChanged && this.events.onProcedureDetailsChanged(this.procedureDetails);
    }
    /**
     * Gets the index of a flight plan leg in this flight plan.
     * @param leg A flight plan leg definition.
     * @returns the index of the leg, or -1 if the leg is not in this flight plan.
     */
    getLegIndexFromLeg(leg) {
        let index = 0;
        for (const toCompare of this.legs()) {
            if (toCompare === leg) {
                return index;
            }
            index++;
        }
        return -1;
    }
    /**
     * Gets the flight plan segment to which a leg belongs.
     * @param leg A flight plan leg definition.
     * @returns The segment to which the leg belongs, or null if the leg is not in this flight plan.
     */
    getSegmentFromLeg(leg) {
        for (const segment of this.segments()) {
            if (segment.legs.includes(leg)) {
                return segment;
            }
        }
        return null;
    }
    /**
     * Gets the segment index for a given global leg index.
     * @param legIndex The global leg index to get the segment index for.
     * @returns The segment index for the given leg index.
     */
    getSegmentIndex(legIndex) {
        for (const segment of this.segments()) {
            if (segment.offset <= legIndex && legIndex < segment.offset + segment.legs.length) {
                return segment.segmentIndex;
            }
        }
        return -1;
    }
    /**
     * Gets the leg immediately previous to a position in this flight plan specified by segment index and leg index.
     * @param segmentIndex A segment index.
     * @param legIndex A leg index.
     * @returns the leg immediately previous to the specified position, or null if there is no such leg.
     */
    getPrevLeg(segmentIndex, legIndex) {
        var _a, _b;
        if (segmentIndex < 0) {
            return null;
        }
        segmentIndex = Math.min(segmentIndex, this.planSegments.length);
        legIndex = Math.min(legIndex, (_b = (_a = this.planSegments[segmentIndex]) === null || _a === void 0 ? void 0 : _a.legs.length) !== null && _b !== void 0 ? _b : 0);
        let segment = this.planSegments[segmentIndex];
        let leg = segment === null || segment === void 0 ? void 0 : segment.legs[legIndex - 1];
        while (!leg && --segmentIndex >= 0) {
            segment = this.planSegments[segmentIndex];
            if (segment) {
                leg = segment.legs[segment.legs.length - 1];
            }
        }
        return leg !== null && leg !== void 0 ? leg : null;
    }
    /**
     * Gets the leg immediately after a position in this flight plan specified by segment index and leg index.
     * @param segmentIndex A segment index.
     * @param legIndex A leg index.
     * @returns the leg immediately after the specified position, or null if there is no such leg.
     */
    getNextLeg(segmentIndex, legIndex) {
        if (segmentIndex >= this.planSegments.length) {
            return null;
        }
        segmentIndex = Math.max(segmentIndex, -1);
        legIndex = Math.max(legIndex, -1);
        let segment = this.planSegments[segmentIndex];
        let leg = segment === null || segment === void 0 ? void 0 : segment.legs[legIndex + 1];
        while (!leg && ++segmentIndex < this.planSegments.length) {
            segment = this.planSegments[segmentIndex];
            if (segment) {
                leg = segment.legs[0];
            }
        }
        return leg !== null && leg !== void 0 ? leg : null;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setDirectToData(arg1, arg2, arg3) {
        if (typeof arg1 !== 'number') {
            // arg1 is a LegDefinition or null.
            arg1 = arg1 ? this.getLegIndexFromLeg(arg1) : -1;
        }
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        let notify = true;
        if (typeof arg2 !== 'number') {
            // arg1 is global leg index
            if (arg1 >= 0) {
                segmentIndex = this.getSegmentIndex(arg1);
                if (segmentIndex >= 0) {
                    segmentLegIndex = arg1 - this.getSegment(segmentIndex).offset;
                }
            }
            notify = arg2 !== null && arg2 !== void 0 ? arg2 : true;
        }
        else {
            segmentIndex = arg1;
            segmentLegIndex = arg2;
            notify = arg3 !== null && arg3 !== void 0 ? arg3 : true;
        }
        this.directToData.segmentIndex = segmentIndex;
        this.directToData.segmentLegIndex = segmentLegIndex;
        notify && this.events.onDirectDataChanged && this.events.onDirectDataChanged(this.directToData);
    }
    /**
     * Sets the airway for a segment.
     * @param segmentIndex A segment index.
     * @param airway The airway name.
     * @param notify is whether to send an event for this change
     */
    setAirway(segmentIndex, airway, notify = true) {
        const segment = this.getSegment(segmentIndex);
        if (!airway) {
            segment.airway = undefined;
        }
        else {
            segment.airway = airway;
        }
        this.events.onSegmentChanged && notify && this.events.onSegmentChanged(segmentIndex, PlanChangeType.Changed, segment);
    }
    /**
     * Sets user data in the flight plan.
     * @param key The key of the user data.
     * @param data The data to set.
     * @param notify Whether or not to notify subscribers.
     */
    setUserData(key, data, notify = true) {
        this.userData[key] = data;
        this.events.onUserDataSet && notify && this.events.onUserDataSet(key, data);
    }
    /**
     * Sets user data in the flight plan.
     * @param key The key of the user data.
     * @param notify Whether or not to notify subscribers.
     */
    deleteUserData(key, notify = true) {
        if (this.userData[key] !== undefined) {
            delete this.userData[key];
        }
        this.events.onUserDataDelete && notify && this.events.onUserDataDelete(key);
    }
    /**
     * Gets user data from the flight plan.
     * @param key The key of the user data.
     * @returns The user data, if found.
     */
    getUserData(key) {
        return this.userData[key];
    }
    /**
     * Reflows all flight plan segment offsets after a plan change.
     */
    reflowSegmentOffsets() {
        let nextOffset = undefined;
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment) {
                if (nextOffset === undefined) {
                    segment.offset = 0;
                }
                else {
                    segment.offset = nextOffset;
                }
                nextOffset = segment.legs.length + segment.offset;
            }
        }
    }
    /**
     * Builds leg names using default nomenclature.
     * @param leg The leg to build a name for.
     * @returns The name of the leg.
     */
    buildDefaultLegName(leg) {
        let legDistanceNM;
        switch (leg.type) {
            case LegType.CA:
            case LegType.FA:
            case LegType.VA:
                return `${UnitType.METER.convertTo(leg.altitude1, UnitType.FOOT).toFixed(0)}FT`;
            case LegType.FM:
            case LegType.VM:
                return 'MANSEQ';
            case LegType.FC:
                legDistanceNM = Math.round(UnitType.METER.convertTo(leg.distance, UnitType.NMILE));
                return `D${leg.course.toFixed(0).padStart(3, '0')}${String.fromCharCode(64 + Utils.Clamp(legDistanceNM, 1, 26))}`;
            case LegType.CD:
            case LegType.FD:
            case LegType.VD:
                legDistanceNM = UnitType.METER.convertTo(leg.distance, UnitType.NMILE);
                return `${ICAO.getIdent(leg.originIcao)}${legDistanceNM.toFixed(1)}`;
            case LegType.CR:
            case LegType.VR:
                return `${ICAO.getIdent(leg.originIcao)}${leg.theta.toFixed(0)}`;
            case LegType.CI:
            case LegType.VI:
                return 'INTRCPT';
            case LegType.PI:
                return 'PROC. TURN';
            case LegType.HA:
            case LegType.HM:
            case LegType.HF:
                return 'HOLD';
            default:
                return ICAO.getIdent(leg.fixIcao);
        }
    }
    /**
     * Sets the origin runway in procedure details.
     * @param runway The oneway runway to set as the origin, or undefined
     * @param notify Whether or not to notify subscribers.
     */
    setOriginRunway(runway = undefined, notify = true) {
        this.procedureDetails.originRunway = runway;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the destination runway in procedure details.
     * @param runway The oneway runway to set as the destination, or undefined
     * @param notify Whether or not to notify subscribers.
     */
    setDestinationRunway(runway = undefined, notify = true) {
        this.procedureDetails.destinationRunway = runway;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the departure procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param departureIndex The index of the departure in the origin airport information
     * @param departureTransitionIndex The index of the departure transition in the origin airport departure information
     * @param departureRunwayIndex The index of the selected runway in the original airport departure information
     * @param notify Whether or not to notify subscribers.
     */
    setDeparture(facilityIcao = undefined, departureIndex = -1, departureTransitionIndex = -1, departureRunwayIndex = -1, notify = true) {
        this.procedureDetails.departureIndex = departureIndex;
        if (departureIndex === -1) {
            facilityIcao = undefined;
            departureTransitionIndex = -1;
            departureRunwayIndex = -1;
        }
        this.procedureDetails.departureFacilityIcao = facilityIcao;
        this.procedureDetails.departureTransitionIndex = departureTransitionIndex;
        this.procedureDetails.departureRunwayIndex = departureRunwayIndex;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the arrival procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param arrivalIndex The index of the arrival in the destination airport information
     * @param arrivalTransitionIndex index of the arrival transition in the destination airport arrival information
     * @param arrivalRunwayTransitionIndex The index of the selected runway transition at the destination airport arrival information
     * @param notify Whether or not to notify subscribers
     */
    setArrival(facilityIcao = undefined, arrivalIndex = -1, arrivalTransitionIndex = -1, arrivalRunwayTransitionIndex = -1, notify = true) {
        this.procedureDetails.arrivalIndex = arrivalIndex;
        if (arrivalIndex === -1) {
            facilityIcao = undefined;
            arrivalTransitionIndex = -1;
            arrivalRunwayTransitionIndex = -1;
        }
        this.procedureDetails.arrivalFacilityIcao = facilityIcao;
        this.procedureDetails.arrivalTransitionIndex = arrivalTransitionIndex;
        this.procedureDetails.arrivalRunwayTransitionIndex = arrivalRunwayTransitionIndex;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the approach procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param approachIndex The index of the apporach in the destination airport information
     * @param approachTransitionIndex The index of the approach transition in the destination airport approach information
     * @param notify Whether or not to notify subscribers
     */
    setApproach(facilityIcao = undefined, approachIndex = -1, approachTransitionIndex = -1, notify = true) {
        this.procedureDetails.approachIndex = approachIndex;
        if (approachIndex === -1) {
            facilityIcao = undefined;
            approachTransitionIndex = -1;
        }
        this.procedureDetails.approachFacilityIcao = facilityIcao;
        this.procedureDetails.approachIndex = approachIndex;
        this.procedureDetails.approachTransitionIndex = approachTransitionIndex;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Copies the flight plan.
     * @param planIndex The flight plan index to assign to this plan, or the same plan
     * index if not provided.
     * @returns The copied flight plan.
     */
    copy(planIndex) {
        if (planIndex === undefined) {
            planIndex = this.planIndex;
        }
        const newPlan = new FlightPlan(planIndex, this.calculator);
        newPlan.setProcedureDetails(this.procedureDetails, false);
        newPlan.setDirectToData(this.directToData.segmentIndex, this.directToData.segmentLegIndex);
        for (const segment of this.segments()) {
            newPlan.addSegment(segment.segmentIndex, segment.segmentType, segment.airway, false);
            for (const leg of segment.legs) {
                newPlan.addLeg(segment.segmentIndex, leg.leg, undefined, leg.isInDirectToSequence, leg.isInMissedApproachSequence, false);
            }
        }
        if (this.originAirport !== undefined) {
            newPlan.setOriginAirport(this.originAirport, false);
        }
        if (this.destinationAirport !== undefined) {
            newPlan.setDestinationAirport(this.destinationAirport, false);
        }
        newPlan.setLateralLeg(this.activeLateralLeg);
        newPlan.setVerticalLeg(this.activeVerticalLeg);
        newPlan.setCalculatingLeg(this.activeCalculatingLeg);
        if (this.userData.size > 0) {
            for (const kv in this.userData) {
                newPlan.setUserData(kv[0], kv[1], false);
            }
        }
        return newPlan;
    }
}
/**
 * Creates a default instance of a flight plan leg.
 * @param partial A portion of leg options to apply.
 * @returns A default instance of a flight plan leg.
 */
FlightPlan.createLeg = (partial) => Object.assign({
    type: 0,
    fixIcao: ICAO.emptyIcao,
    arcCenterFixIcao: ICAO.emptyIcao,
    originIcao: ICAO.emptyIcao,
    flyOver: 0,
    turnDirection: 0,
    trueDegrees: 0,
    theta: 0,
    rho: 0,
    distance: 0,
    distanceMinutes: 0,
    speedRestriction: 0,
    altDesc: 0,
    altitude1: 0,
    altitude2: 0,
    course: 0,
    fixTypeFlags: 0
}, partial);

/**
 * Manages the active flightplans of the navigational systems.
 */
class FlightPlanner {
    /**
     * Creates an instance of the FlightPlanner.
     * @param bus The event bus instance to notify changes on.
     * @param calculator The flight path calculator to use with this planner.
     */
    constructor(bus, calculator) {
        this.bus = bus;
        this.calculator = calculator;
        /** The flight plans managed by this flight planner. */
        this.flightPlans = [];
        this.ignoreSync = false;
        /** The active flight plan index. */
        this._activePlanIndex = 0;
        this.flightPlanSynced = new SubEvent();
        this.publisher = bus.getPublisher();
        const subscriber = bus.getSubscriber();
        subscriber.on('fplsync_fplRequest').handle(() => !this.ignoreSync && this.onFlightPlanRequest());
        subscriber.on('fplsync_fplResponse').handle(data => !this.ignoreSync && this.onFlightPlanResponse(data));
        subscriber.on('fplsync_fplCreated').handle(data => !this.ignoreSync && this.onPlanCreated(data));
        subscriber.on('fplsync_fplDeleted').handle(data => !this.ignoreSync && this.onPlanDeleted(data));
        subscriber.on('fplsync_fplActiveLegChange').handle(data => !this.ignoreSync && this.onActiveLegChanged(data));
        subscriber.on('fplsync_fplLegChange').handle(data => !this.ignoreSync && this.onLegChanged(data));
        subscriber.on('fplsync_fplSegmentChange').handle(data => !this.ignoreSync && this.onSegmentChanged(data));
        subscriber.on('fplsync_fplCalculated').handle(data => !this.ignoreSync && this.onCalculated(data));
        subscriber.on('fplsync_fplOriginDestChanged').handle(data => !this.ignoreSync && this.onOriginDestChanged(data));
        subscriber.on('fplsync_fplProcDetailsChanged').handle(data => !this.ignoreSync && this.onProcedureDetailsChanged(data));
        subscriber.on('fplsync_fplIndexChanged').handle(data => !this.ignoreSync && this.onPlanIndexChanged(data));
        subscriber.on('fplsync_fplCopied').handle(data => !this.ignoreSync && this.onPlanCopied(data));
        subscriber.on('fplsync_fplUserDataSet').handle(data => !this.ignoreSync && this.onUserDataSet(data));
        subscriber.on('fplsync_fplUserDataDelete').handle(data => !this.ignoreSync && this.onUserDataDelete(data));
        subscriber.on('fplsync_fplDirectToDataChanged').handle(data => !this.ignoreSync && this.onDirectToDataChanged(data));
    }
    /**
     * Set a new active plan index.
     * @param planIndex The new active plan index.
     */
    set activePlanIndex(planIndex) {
        this._activePlanIndex = planIndex;
    }
    /**
     * Get the active plan index.
     * @returns The active plan index number.
     */
    get activePlanIndex() {
        return this._activePlanIndex;
    }
    /**
     * Requests synchronization from other FlightPlanner instances.
     */
    requestSync() {
        this.sendFlightPlanRequest();
    }
    /**
     * An event generated when a set of flight plans is requested.
     */
    onFlightPlanRequest() {
        this.ignoreSync = true;
        this.publisher.pub('fplsync_fplResponse', {
            flightPlans: this.flightPlans.map(plan => {
                const newPlan = Object.assign({}, plan);
                newPlan.calculator = undefined;
                return newPlan;
            }), planIndex: this.activePlanIndex
        }, true, false);
        this.ignoreSync = false;
    }
    /**
     * Sends a flight plan request event.
     */
    sendFlightPlanRequest() {
        this.ignoreSync = true;
        this.publisher.pub('fplsync_fplRequest', {}, true, false);
        this.ignoreSync = false;
    }
    /**
     * A callback which is called in response to flight plan request response sync events.
     * @param data The event data.
     */
    onFlightPlanResponse(data) {
        for (let i = 0; i < data.flightPlans.length; i++) {
            const newPlan = Object.assign(new FlightPlan(i, this.calculator), data.flightPlans[i]);
            newPlan.events = this.buildPlanEventHandlers(i);
            this.flightPlans[i] = newPlan;
            this.sendEvent('fplLoaded', { planIndex: i }, false);
        }
        this.setActivePlanIndex(data.planIndex);
        this.flightPlanSynced.notify(this, true);
    }
    /**
     * Checks whether a flight plan exists at a specified index.
     * @param planIndex The index to check.
     * @returns Whether a a flight plan exists at `planIndex`.
     */
    hasFlightPlan(planIndex) {
        return !!this.flightPlans[planIndex];
    }
    /**
     * Gets a flight plan from the flight planner.
     * @param planIndex The index of the flight plan.
     * @returns The requested flight plan.
     * @throws Error if a flight plan does not exist at `planIndex`.
     */
    getFlightPlan(planIndex) {
        const plan = this.flightPlans[planIndex];
        if (!plan) {
            throw new Error(`FlightPlanner: Flight plan does not exist at index ${planIndex}`);
        }
        return plan;
    }
    /**
     * Creates a new flight plan at a specified index if one does not already exist.
     * @param planIndex The index at which to create the new flight plan.
     * @param notify Whether to send an event notification. True by default.
     * @returns The new flight plan, or the existing flight plan at `planIndex`.
     */
    createFlightPlan(planIndex, notify = true) {
        if (this.flightPlans[planIndex]) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.flightPlans[planIndex];
        }
        const flightPlan = new FlightPlan(planIndex, this.calculator);
        flightPlan.events = this.buildPlanEventHandlers(planIndex);
        this.flightPlans[planIndex] = flightPlan;
        notify && this.sendPlanCreated(planIndex);
        return flightPlan;
    }
    /**
     * A callback which is called in response to flight plan request response sync events.
     * @param data The event data.
     */
    onPlanCreated(data) {
        this.createFlightPlan(data.planIndex, false);
        this.sendEvent('fplCreated', data, false);
    }
    /**
     * Sends a flight plan created event.
     * @param planIndex The index of the flight plan that was created.
     */
    sendPlanCreated(planIndex) {
        const data = { planIndex };
        this.sendEvent('fplCreated', data, true);
    }
    /**
     * Deletes a flight plan from the flight planner.
     * @param planIndex The index of the flight plan to delete.
     * @param notify Whether to send an event notification. True by default.
     */
    deleteFlightPlan(planIndex, notify = true) {
        const flightPlan = this.flightPlans[planIndex];
        if (flightPlan) {
            flightPlan.events = {};
            this.flightPlans[planIndex] = undefined;
            notify && this.sendPlanDeleted(planIndex);
        }
        if (planIndex === this.flightPlans.length - 1) {
            this.flightPlans.length--;
        }
    }
    /**
     * A callback which is called in response to flight plan deleted sync events.
     * @param data The event data.
     */
    onPlanDeleted(data) {
        this.deleteFlightPlan(data.planIndex, false);
        this.sendEvent('fplDeleted', data, false);
    }
    /**
     * Sends a flight plan deleted event.
     * @param planIndex The index of the flight plan that was created.
     */
    sendPlanDeleted(planIndex) {
        const data = { planIndex };
        this.sendEvent('fplDeleted', data, true);
    }
    /**
     * Builds the plan event handlers for the flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The plan event handlers.
     */
    buildPlanEventHandlers(planIndex) {
        return {
            onLegChanged: (segmentIndex, index, type, leg) => this.sendLegChanged(planIndex, segmentIndex, index, type, leg),
            onSegmentChanged: (segmentIndex, type, segment) => this.sendSegmentChanged(planIndex, segmentIndex, type, segment),
            onActiveLegChanged: (index, segmentIndex, legIndex, previousSegmentIndex, previousLegIndex, type) => this.sendActiveLegChange(planIndex, index, segmentIndex, legIndex, previousSegmentIndex, previousLegIndex, type),
            onCalculated: (index) => this.sendCalculated(planIndex, index),
            onOriginDestChanged: (type, airport) => this.sendOriginDestChanged(planIndex, type, airport),
            onProcedureDetailsChanged: (details) => this.sendProcedureDetailsChanged(planIndex, details),
            onUserDataSet: (key, data) => this.sendUserDataSet(planIndex, key, data),
            onUserDataDelete: (key) => this.sendUserDataDelete(planIndex, key),
            onDirectDataChanged: (directToData) => this.sendDirectToData(planIndex, directToData)
        };
    }
    /**
     * Checks whether an active flight plan exists.
     * @returns Whether an active flight plan exists.
     */
    hasActiveFlightPlan() {
        return this.hasFlightPlan(this.activePlanIndex);
    }
    /**
     * Gets the currently active flight plan from the flight planner.
     * @returns The currently active flight plan.
     * @throws Error if no active flight plan exists.
     */
    getActiveFlightPlan() {
        return this.getFlightPlan(this.activePlanIndex);
    }
    /**
     * Copies a flight plan to another flight plan slot.
     * @param sourcePlanIndex The source flight plan index.
     * @param targetPlanIndex The target flight plan index.
     * @param notify Whether or not to notify subscribers that the plan has been copied.
     */
    copyFlightPlan(sourcePlanIndex, targetPlanIndex, notify = true) {
        const sourcePlan = this.flightPlans[sourcePlanIndex];
        if (!sourcePlan) {
            return;
        }
        const newPlan = sourcePlan.copy(targetPlanIndex);
        newPlan.events = this.buildPlanEventHandlers(targetPlanIndex);
        this.flightPlans[targetPlanIndex] = newPlan;
        if (notify) {
            this.sendPlanCopied(sourcePlanIndex, targetPlanIndex);
        }
    }
    /**
     * A callback which is called in response to flight plan copied sync events.
     * @param data The event data.
     */
    onPlanCopied(data) {
        this.copyFlightPlan(data.planIndex, data.targetPlanIndex, false);
        this.sendEvent('fplCopied', data, false);
    }
    /**
     * Sends a leg change event.
     * @param planIndex The index of the flight plan that was the source of the copy.
     * @param targetPlanIndex The index of the copy.
     */
    sendPlanCopied(planIndex, targetPlanIndex) {
        const data = { planIndex, targetPlanIndex };
        this.sendEvent('fplCopied', data, true);
    }
    /**
     * A callback which is called in response to leg changed sync events.
     * @param data The event data.
     */
    onLegChanged(data) {
        const plan = this.getFlightPlan(data.planIndex);
        switch (data.type) {
            case PlanChangeType.Added:
                data.leg && plan.addLeg(data.segmentIndex, data.leg.leg, data.legIndex, data.leg.isInDirectToSequence, data.leg.isInMissedApproachSequence, false);
                break;
            case PlanChangeType.Removed:
                plan.removeLeg(data.segmentIndex, data.legIndex, false);
                break;
        }
        this.sendEvent('fplLegChange', data, false);
    }
    /**
     * Sends a leg change event.
     * @param planIndex The index of the flight plan.
     * @param segmentIndex The index of the segment.
     * @param index The index of the leg.
     * @param type The type of change.
     * @param leg The leg that was changed.
     */
    sendLegChanged(planIndex, segmentIndex, index, type, leg) {
        const data = {
            planIndex, segmentIndex, legIndex: index, type, leg
        };
        this.sendEvent('fplLegChange', data, true);
    }
    /**
     * A callback which is called in response to segment changed sync events.
     * @param data The event data.
     */
    onSegmentChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        switch (data.type) {
            case PlanChangeType.Added:
                data.segment && plan.addSegment(data.segmentIndex, data.segment.segmentType, data.segment.airway, false);
                break;
            case PlanChangeType.Inserted:
                data.segment && plan.insertSegment(data.segmentIndex, data.segment.segmentType, data.segment.airway, false);
                break;
            case PlanChangeType.Removed:
                plan.removeSegment(data.segmentIndex, false);
                break;
            case PlanChangeType.Changed:
                data.segment && plan.setAirway(data.segmentIndex, data.segment.airway, false);
                break;
        }
        this.sendEvent('fplSegmentChange', data, false);
    }
    /**
     * Sends a segment change event.
     * @param planIndex The index of the flight plan.
     * @param index The index of the segment.
     * @param type The type of change.
     * @param segment The segment that was changed.
     */
    sendSegmentChanged(planIndex, index, type, segment) {
        const data = {
            planIndex, segmentIndex: index, type, segment
        };
        this.sendEvent('fplSegmentChange', data, true);
    }
    /**
     * A callback which is called in response to active leg changed sync events.
     * @param data The event data.
     */
    onActiveLegChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        switch (data.type) {
            case ActiveLegType.Lateral:
                plan.setLateralLeg(data.index, false);
                break;
            case ActiveLegType.Vertical:
                plan.setVerticalLeg(data.index, false);
                break;
            case ActiveLegType.Calculating:
                plan.setCalculatingLeg(data.index, false);
                break;
        }
        this.sendEvent('fplActiveLegChange', data, false);
    }
    /**
     * Sends an active leg change event.
     * @param planIndex The index of the flight plan.
     * @param index The index of the leg.
     * @param segmentIndex The index of the plan segment.
     * @param legIndex The index of the leg within the segment.
     * @param previousSegmentIndex The index of the segment in which the previously active leg is.
     * @param previousLegIndex The index of the previously active leg within the previously active segment.
     * @param type The type of leg that was changed.
     */
    sendActiveLegChange(planIndex, index, segmentIndex, legIndex, previousSegmentIndex, previousLegIndex, type) {
        const data = {
            segmentIndex, legIndex, planIndex,
            index, previousSegmentIndex, previousLegIndex, type
        };
        this.sendEvent('fplActiveLegChange', data, true);
    }
    /**
     * A callback which is called in response to calculation sync events.
     * @param data The event data.
     */
    async onCalculated(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        await plan.calculate(data.index, false);
        this.sendEvent('fplCalculated', data, false);
    }
    /**
     * Sends a calculated event.
     * @param planIndex The index of the flight plan.
     * @param index The index that the path was generated from.
     */
    sendCalculated(planIndex, index) {
        const data = { planIndex, index };
        this.sendEvent('fplCalculated', data, true);
    }
    /**
     * A callback which is called in response to origin/destination changed sync events.
     * @param data The event data.
     */
    onOriginDestChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        switch (data.type) {
            case OriginDestChangeType.OriginAdded:
                data.airport && plan.setOriginAirport(data.airport, false);
                break;
            case OriginDestChangeType.OriginRemoved:
                plan.removeOriginAirport(false);
                break;
            case OriginDestChangeType.DestinationAdded:
                data.airport && plan.setDestinationAirport(data.airport, false);
                break;
            case OriginDestChangeType.DestinationRemoved:
                plan.removeDestinationAirport(false);
                break;
        }
        this.sendEvent('fplOriginDestChanged', data, false);
    }
    /**
     * Sends a origin/dest change event.
     * @param planIndex The index of the flight plan.
     * @param type The origin/destination change type.
     * @param airport The airport that was changed.
     */
    sendOriginDestChanged(planIndex, type, airport) {
        const data = { planIndex, type, airport };
        this.sendEvent('fplOriginDestChanged', data, true);
    }
    /**
     * A callback which is called in response to procedure changed sync events.
     * @param data The event data.
     */
    onProcedureDetailsChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.setProcedureDetails(data.details, false);
        this.sendEvent('fplProcDetailsChanged', data, false);
    }
    /**
     * Sends a procedure details change event.
     * @param planIndex The index of the flight plan.
     * @param details The details that were changed.
     */
    sendProcedureDetailsChanged(planIndex, details) {
        const data = { planIndex, details };
        this.sendEvent('fplProcDetailsChanged', data, true);
    }
    /**
     * A callback which is called in response to flight plan index changed sync events.
     * @param data The event data.
     */
    onPlanIndexChanged(data) {
        this.activePlanIndex = data.planIndex;
        this.sendEvent('fplIndexChanged', data, false);
    }
    /**
     * Sends an active plan index change event.
     * @param planIndex The index of the flight plan.
     */
    sendPlanIndexChanged(planIndex) {
        const data = { planIndex };
        this.sendEvent('fplIndexChanged', data, true);
    }
    /**
     * A callback which is called in response to user data set sync events.
     * @param data The event data.
     */
    onUserDataSet(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.setUserData(data.key, data.data, false);
        this.sendEvent('fplUserDataSet', data, false);
    }
    /**
     * A callback which is called in response to user data delete sync events.
     * @param data The event data.
     */
    onUserDataDelete(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.deleteUserData(data.key, false);
        this.sendEvent('fplUserDataDelete', data, false);
    }
    /**
     * Sends a user data set event.
     * @param planIndex The index of the flight plan.
     * @param key The key of the user data.
     * @param userData The data that was set.
     */
    sendUserDataSet(planIndex, key, userData) {
        const data = { planIndex, key, data: userData };
        this.sendEvent('fplUserDataSet', data, true);
    }
    /**
     * Sends a user data delete event.
     * @param planIndex The index of the flight plan.
     * @param key The key of the user data.
     */
    sendUserDataDelete(planIndex, key) {
        const data = { planIndex, key, data: undefined };
        this.sendEvent('fplUserDataDelete', data, true);
    }
    /**
     * A callback which is called in response to direct to data changed sync events.
     * @param data The event data.
     */
    onDirectToDataChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.setDirectToData(data.directToData.segmentIndex, data.directToData.segmentLegIndex, false);
        this.sendEvent('fplDirectToDataChanged', data, false);
    }
    /**
     * Sends a direct to data changed event.
     * @param planIndex The index of the flight plan.
     * @param directToData The direct to data.
     */
    sendDirectToData(planIndex, directToData) {
        const data = { planIndex, directToData: directToData };
        this.sendEvent('fplDirectToDataChanged', data, true);
    }
    /**
     * Method to set an active flight plan index.
     * @param planIndex The index of the flight plan to make active.
     */
    setActivePlanIndex(planIndex) {
        if (this.hasFlightPlan(planIndex)) {
            this.activePlanIndex = planIndex;
            this.sendPlanIndexChanged(planIndex);
        }
    }
    /**
     * Sends a local event and its sync counterpart.
     * @param topic The topic of the local event.
     * @param data The event data.
     * @param sync Whether to send the sync event.
     */
    sendEvent(topic, data, sync) {
        if (sync) {
            this.ignoreSync = true;
            this.publisher.pub(`fplsync_${topic}`, data, true, false);
            this.ignoreSync = false;
        }
        this.publisher.pub(topic, data, false, false);
    }
    /**
     * Gets an instance of FlightPlanner.
     * @param bus The event bus.
     * @param calculator A flight path calculator.
     * @returns An instance of FlightPlanner.
     */
    static getPlanner(bus, calculator) {
        var _a;
        return (_a = FlightPlanner.INSTANCE) !== null && _a !== void 0 ? _a : (FlightPlanner.INSTANCE = new FlightPlanner(bus, calculator));
    }
}

/**
 * TCAS operating modes.
 */
var TCASOperatingMode;
(function (TCASOperatingMode) {
    TCASOperatingMode[TCASOperatingMode["Standby"] = 0] = "Standby";
    TCASOperatingMode[TCASOperatingMode["TAOnly"] = 1] = "TAOnly";
    TCASOperatingMode[TCASOperatingMode["TA_RA"] = 2] = "TA_RA";
})(TCASOperatingMode || (TCASOperatingMode = {}));
/**
 * TCAS alert level.
 */
var TCASAlertLevel;
(function (TCASAlertLevel) {
    TCASAlertLevel[TCASAlertLevel["None"] = 0] = "None";
    TCASAlertLevel[TCASAlertLevel["ProximityAdvisory"] = 1] = "ProximityAdvisory";
    TCASAlertLevel[TCASAlertLevel["TrafficAdvisory"] = 2] = "TrafficAdvisory";
    TCASAlertLevel[TCASAlertLevel["ResolutionAdvisory"] = 3] = "ResolutionAdvisory";
})(TCASAlertLevel || (TCASAlertLevel = {}));
/**
 * A TCAS-II-like system.
 */
class TCAS {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param tfcInstrument The traffic instrument which provides traffic contacts for this TCAS.
     * @param maxIntruderCount The maximum number of intruders tracked at any one time by this TCAS.
     * @param realTimeUpdateFreq The maximum update frequency (Hz) in real time.
     * @param simTimeUpdateFreq The maximum update frequency (Hz) in sim time.
     */
    constructor(bus, tfcInstrument, maxIntruderCount, realTimeUpdateFreq, simTimeUpdateFreq) {
        this.bus = bus;
        this.tfcInstrument = tfcInstrument;
        this.maxIntruderCount = maxIntruderCount;
        this.realTimeUpdateFreq = realTimeUpdateFreq;
        this.simTimeUpdateFreq = simTimeUpdateFreq;
        this.operatingModeSub = Subject.create(TCASOperatingMode.Standby);
        this.intrudersSorted = [];
        this.intrudersFiltered = [];
        this.contactCreatedHandler = this.onContactAdded.bind(this);
        this.contactRemovedHandler = this.onContactRemoved.bind(this);
        this.ownAirplaneSubs = {
            position: GeoPointSubject.createFromGeoPoint(new GeoPoint(0, 0)),
            altitude: NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(0)),
            groundTrack: Subject.create(0),
            groundSpeed: NumberUnitSubject.createFromNumberUnit(UnitType.KNOT.createNumber(0)),
            verticalSpeed: NumberUnitSubject.createFromNumberUnit(UnitType.FPM.createNumber(0))
        };
        this.isOwnAirplaneOnGround = false;
        this.lastUpdateSimTime = 0;
        this.lastUpdateRealTime = 0;
        this.alertLevelHandlers = new Map();
        this.eventSubscriber = this.bus.getSubscriber();
        this.sensitivity = this.createSensitivity();
        this.ownAirplane = new OwnAirplane(this.ownAirplaneSubs);
    }
    /**
     * Gets this system's operating mode.
     * @returns This system's operating mode.
     */
    getOperatingMode() {
        return this.operatingModeSub.get();
    }
    /**
     * Sets this system's operating mode.
     * @param mode The new operating mode.
     */
    setOperatingMode(mode) {
        this.operatingModeSub.set(mode);
    }
    /**
     * Gets an array of all currently tracked intruders. The intruders are sorted in order of decreasing threat.
     * @returns an array of all currently tracked intruders.
     */
    getIntruders() {
        return this.intrudersFiltered;
    }
    /**
     * Gets an event bus subscriber for TCAS events.
     * @returns an event bus subscriber for TCAS events..
     */
    getEventSubscriber() {
        return this.eventSubscriber;
    }
    /**
     * Initializes this system.
     */
    init() {
        // init contact listeners
        const sub = this.bus.getSubscriber();
        this.contactCreatedConsumer = sub.on('traffic_contact_added');
        this.contactRemovedConsumer = sub.on('traffic_contact_removed');
        this.contactCreatedConsumer.handle(this.contactCreatedHandler);
        this.contactRemovedConsumer.handle(this.contactRemovedHandler);
        // add all existing contacts
        this.tfcInstrument.forEachContact(contact => { this.onContactAdded(contact.uid); });
        // own airplane listeners
        const gnssSub = this.bus.getSubscriber();
        gnssSub.on('gps-position').atFrequency(this.realTimeUpdateFreq).handle(lla => { this.ownAirplaneSubs.position.set(lla.lat, lla.long); });
        gnssSub.on('track_deg_true').whenChanged().atFrequency(this.realTimeUpdateFreq).handle(track => { this.ownAirplaneSubs.groundTrack.set(track); });
        gnssSub.on('ground_speed').whenChanged().atFrequency(this.realTimeUpdateFreq).handle(gs => { this.ownAirplaneSubs.groundSpeed.set(gs); });
        const adcSub = this.bus.getSubscriber();
        adcSub.on('alt').whenChanged().atFrequency(this.realTimeUpdateFreq).handle(alt => { this.ownAirplaneSubs.altitude.set(alt); });
        adcSub.on('vs').whenChanged().atFrequency(this.realTimeUpdateFreq).handle(vs => { this.ownAirplaneSubs.verticalSpeed.set(vs); });
        adcSub.on('on_ground').whenChanged().handle(isOnGround => { this.isOwnAirplaneOnGround = isOnGround; });
        // init operating mode notifier
        this.operatingModeSub.sub(mode => { this.bus.pub('tcas_operating_mode', mode, false, true); }, true);
        // init update loop
        this.bus.getSubscriber().on('simTime').whenChanged().handle(this.onSimTimeChanged.bind(this));
    }
    /**
     * Sorts two intruders.
     * @param a The first intruder.
     * @param b The second intruder.
     * @returns A negative number if `a` is to be sorted before `b`, a positive number if `b` is to be sorted before `a`,
     * and zero if the two are equal.
     */
    intruderComparator(a, b) {
        // always sort intruders with valid predictions first
        if (a.isPredictionValid && !b.isPredictionValid) {
            return -1;
        }
        else if (!a.isPredictionValid && b.isPredictionValid) {
            return 1;
        }
        else if (a.isPredictionValid) {
            // always sort intruders predicted to violate protected zone first
            if (a.tcaNorm <= 1 && b.tcaNorm > 1) {
                return -1;
            }
            else if (a.tcaNorm > 1 && b.tcaNorm <= 1) {
                return 1;
            }
            else {
                // if both are predicted to violate protected zone, sort by TCA.
                // Otherwise sort by how close they approach the protected zone at TCA.
                const tcaComparison = a.tca.compare(b.tca);
                const normComparison = a.tcaNorm - b.tcaNorm;
                let firstComparison;
                let secondComparison;
                if (a.tcaNorm <= 1) {
                    firstComparison = tcaComparison;
                    secondComparison = normComparison;
                }
                else {
                    firstComparison = normComparison;
                    secondComparison = tcaComparison;
                }
                if (firstComparison === 0) {
                    return secondComparison;
                }
                else {
                    return firstComparison;
                }
            }
        }
        else {
            return 0;
        }
    }
    /**
     * A callback which is called when a new traffic contact is added by this system's traffic instrument.
     * @param uid The ID number of the new contact.
     */
    onContactAdded(uid) {
        const contact = this.tfcInstrument.getContact(uid);
        const intruder = this.createIntruderEntry(contact);
        this.intrudersSorted.push(intruder);
    }
    /**
     * A callback which is called when a traffic contact is removed by this system's traffic instrument.
     * @param uid The ID number of the removed contact.
     */
    onContactRemoved(uid) {
        const sortedIndex = this.intrudersSorted.findIndex(intruder => intruder.contact.uid === uid);
        const culledIndex = this.intrudersFiltered.findIndex(intruder => intruder.contact.uid === uid);
        if (sortedIndex >= 0) {
            this.intrudersSorted.splice(sortedIndex, 1);
        }
        if (culledIndex >= 0) {
            const removed = this.intrudersFiltered[culledIndex];
            this.intrudersFiltered.splice(culledIndex, 1);
            this.cleanUpIntruder(removed);
        }
    }
    /**
     * A callback which is called when the sim time changes.
     * @param simTime The current sim time.
     */
    onSimTimeChanged(simTime) {
        if (this.operatingModeSub.get() === TCASOperatingMode.Standby) {
            return;
        }
        const realTime = Date.now();
        if (Math.abs(simTime - this.lastUpdateSimTime) < 1000 / this.simTimeUpdateFreq
            || Math.abs(realTime - this.lastUpdateRealTime) < 1000 / this.realTimeUpdateFreq) {
            return;
        }
        this.doUpdate(simTime);
        this.lastUpdateSimTime = simTime;
        this.lastUpdateRealTime = realTime;
    }
    /**
     * Executes an update.
     * @param simTime The current sim time.
     */
    doUpdate(simTime) {
        this.updateSensitivity();
        this.updateIntruderPredictions(simTime);
        this.updateIntruderArrays();
        this.updateFilteredIntruderAlertLevels(simTime);
    }
    /**
     * Updates the TCA predictions for all intruders tracked by this system.
     * @param simTime The current sim time.
     */
    updateIntruderPredictions(simTime) {
        this.ownAirplane.update(simTime);
        const lookaheadTime = this.sensitivity.lookaheadTime.get();
        const protectedRadius = this.sensitivity.protectedRadius.get();
        const protectedHeight = this.sensitivity.protectedHeight.get();
        const len = this.intrudersSorted.length;
        for (let i = 0; i < len; i++) {
            this.intrudersSorted[i].updatePrediction(simTime, this.ownAirplane, lookaheadTime, protectedRadius, protectedHeight);
        }
    }
    /**
     * Updates the arrays of intruders tracked by this system.
     */
    updateIntruderArrays() {
        this.intrudersSorted.sort(this.intruderComparator.bind(this));
        const oldCulled = this.intrudersFiltered;
        this.intrudersFiltered = [];
        const len = this.intrudersSorted.length;
        for (let i = 0; i < len; i++) {
            const intruder = this.intrudersSorted[i];
            if (i < this.maxIntruderCount && intruder.isPredictionValid) {
                this.intrudersFiltered.push(intruder);
                if (!oldCulled.includes(intruder)) {
                    this.initIntruder(intruder);
                }
            }
            else {
                if (oldCulled.includes(intruder)) {
                    this.cleanUpIntruder(intruder);
                }
            }
        }
    }
    /**
     * Updates the alert levels for all intruders tracked by this system that have not been filtered out.
     * @param simTime The current sim time.
     */
    updateFilteredIntruderAlertLevels(simTime) {
        const len = this.intrudersFiltered.length;
        for (let i = 0; i < len; i++) {
            this.updateIntruderAlertLevel(simTime, this.intrudersFiltered[i]);
        }
    }
    /**
     * Executes initialization code when an intruder is added.
     * @param intruder The newly added intruder.
     */
    initIntruder(intruder) {
        const handler = this.onAlertLevelChanged.bind(this, intruder);
        this.alertLevelHandlers.set(intruder, handler);
        intruder.alertLevel.sub(handler);
        this.bus.pub('tcas_intruder_added', intruder, false, false);
    }
    /**
     * Executes cleanup code when an intruder is removed.
     * @param intruder The intruder that was removed.
     */
    cleanUpIntruder(intruder) {
        const handler = this.alertLevelHandlers.get(intruder);
        handler && intruder.alertLevel.unsub(handler);
        this.bus.pub('tcas_intruder_removed', intruder, false, false);
    }
    /**
     * A callback which is called when an intruder's alert level changes.
     * @param intruder The intruder whose alert level changed.
     */
    onAlertLevelChanged(intruder) {
        this.bus.pub('tcas_intruder_alert_changed', intruder, false, false);
    }
}
/**
 * An airplane managed by TCAS.
 */
class TCASAirplane {
    constructor() {
        this._position = new GeoPoint(0, 0);
        /** The position of this airplane at the time of the most recent update. */
        this.position = this._position.readonly;
        /** The altitude of this airplane at the time of the most recent update. */
        this._altitude = UnitType.FOOT.createNumber(0);
        this.altitude = this._altitude.readonly;
        this._groundTrack = 0;
        /** The ground speed of this airplane at the time of the most recent update. */
        this._groundSpeed = UnitType.KNOT.createNumber(0);
        this.groundSpeed = this._groundSpeed.readonly;
        /** The vertical speed of this airplane at the time of the most recent update. */
        this._verticalSpeed = UnitType.FPM.createNumber(0);
        this.verticalSpeed = this._verticalSpeed.readonly;
        /**
         * The 3D position vector of this airplane at the time of the last update. Each component is expressed in units of
         * meters. The coordinate system is an Euclidean approximation of the geodetic space around the own airplane such
         * that the z-coordinate represents orthometric height and the x- and y-coordinates represent an east-
         * counterclockwise equirectangular projection of latitude and longitude, with the origin at the location of the own
         * airplane.
         */
        this.positionVec = new Float64Array(3);
        /**
         * The 3D velocity vector of this airplane at the time of the last update. Each component is expressed in units of
         * meters per second. The coordinate system is defined the same as for position vectors.
         */
        this.velocityVec = new Float64Array(3);
        this.lastUpdateTime = 0;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The true ground track of this airplane at the time of the most recent update. */
    get groundTrack() {
        return this._groundTrack;
    }
}
/**
 * The own airplane managed by TCAS.
 */
class OwnAirplane extends TCASAirplane {
    /**
     * Constructor.
     * @param subs Subscribables which provide data related to this airplane.
     */
    constructor(subs) {
        super();
        this.subs = subs;
    }
    /**
     * Updates this airplane's position, altitude, ground track, ground speed, and vertical speed.
     */
    updateParameters() {
        this._position.set(this.subs.position.get());
        this._altitude.set(this.subs.altitude.get());
        this._groundTrack = this.subs.groundTrack.get();
        this._groundSpeed.set(this.subs.groundSpeed.get());
        this._verticalSpeed.set(this.subs.verticalSpeed.get());
    }
    /**
     * Updates this airplane's position and velocity vectors.
     */
    updateVectors() {
        Vec2Math.setFromPolar(this._groundSpeed.asUnit(UnitType.MPS), (90 - this._groundTrack) * Avionics.Utils.DEG2RAD, this.velocityVec);
        const verticalVelocity = this._verticalSpeed.asUnit(UnitType.MPS);
        this.velocityVec[2] = verticalVelocity;
    }
    /**
     * Updates this airplane's position and velocity data.
     * @param simTime The current sim time, as a UNIX millisecond timestamp.
     */
    update(simTime) {
        this.updateParameters();
        this.updateVectors();
        this.lastUpdateTime = simTime;
    }
}
/**
 * An abstract implementation of TCASIntruder.
 */
class AbstractTCASIntruder extends TCASAirplane {
    /**
     * Constructor.
     * @param contact The traffic contact associated with this intruder.
     */
    constructor(contact) {
        super();
        this.contact = contact;
        this.alertLevel = Subject.create(TCASAlertLevel.None);
        /** The 3D position vector of this intruder relative to own airplane. */
        this.relativePositionVec = new Float64Array(3);
        /** The 3D velocity vector of this intruder relative to own airplane. */
        this.relativeVelocityVec = new Float64Array(3);
        this._isPredictionValid = false;
        this._tca = UnitType.SECOND.createNumber(NaN);
        /** Time to closest approach between this intruder and own airplane. */
        this.tca = this._tca.readonly;
        this._tcaNorm = NaN;
        /** The predicted 3D displacement vector from own airplane to this intruder at time of closest approach. */
        this.tcaDisplacement = new Float64Array(3);
        this._tcaHorizontalSep = UnitType.NMILE.createNumber(0);
        /** The predicted horizontal separation between this intruder and own airplane at time of closest approach. */
        this.tcaHorizontalSep = this._tcaHorizontalSep.readonly;
        this._tcaVerticalSep = UnitType.FOOT.createNumber(0);
        /** The predicted vertical separation between this intruder and own airplane at time of closest approach. */
        this.tcaVerticalSep = this._tcaVerticalSep.readonly;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether there is a valid prediction for time of closest approach between this intruder and own airplane. */
    get isPredictionValid() {
        return this._isPredictionValid;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The cylindrical norm of the predicted displacement vector between this intruder and own airplane at time of
     * closest approach. A value less than or equal to 1 indicates the intruder will be inside the protected zone.
     * Larger values correspond to greater separation.
     */
    get tcaNorm() {
        return this._tcaNorm;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    predictDisplacement(simTime, out) {
        if (!this._isPredictionValid) {
            return Vec3Math.set(NaN, NaN, NaN, out);
        }
        const dt = (simTime - this.contact.lastContactTime) / 1000;
        return Vec3Math.add(this.relativePositionVec, Vec3Math.multScalar(this.relativeVelocityVec, dt, out), out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    predictSeparation(simTime, horizontalOut, verticalOut) {
        if (!this._isPredictionValid) {
            horizontalOut.set(NaN);
            verticalOut.set(NaN);
            return;
        }
        const displacement = this.predictDisplacement(simTime, AbstractTCASIntruder.vec3Cache[0]);
        AbstractTCASIntruder.displacementToHorizontalSeparation(displacement, horizontalOut);
        AbstractTCASIntruder.displacementToVerticalSeparation(displacement, verticalOut);
    }
    /**
     * Updates this intruder's predicted TCA and related data.
     * @param simTime The current sim time.
     * @param ownAirplane Own airplane.
     * @param lookaheadTime The maximum lookahead time to calculate TCA.
     * @param protectedRadius The radius of the own airplane's protected zone.
     * @param protectedHeight The half-height of the own airplane's protected zone.
     */
    updatePrediction(simTime, ownAirplane, lookaheadTime, protectedRadius, protectedHeight) {
        this.updateParameters(simTime, ownAirplane);
        if (this.isPredictionValid) {
            this.updateTCA(ownAirplane, lookaheadTime, protectedRadius, protectedHeight);
        }
        else {
            this.invalidatePrediction();
        }
        this.lastUpdateTime = simTime;
    }
    /**
     * Updates this intruder's position and velocity data.
     * @param simTime The current sim time.
     * @param ownAirplane The own airplane.
     */
    updateParameters(simTime, ownAirplane) {
        if (isNaN(this.contact.groundTrack) || this.contact.groundSpeed.compare(AbstractTCASIntruder.MIN_GROUND_SPEED) < 0) {
            this._isPredictionValid = false;
            this._position.set(NaN, NaN);
            this._altitude.set(NaN);
            this._groundTrack = NaN;
            this._groundSpeed.set(NaN);
            this._verticalSpeed.set(NaN);
            Vec3Math.set(NaN, NaN, NaN, this.positionVec);
            Vec3Math.set(NaN, NaN, NaN, this.velocityVec);
        }
        else {
            this.updatePosition(simTime, ownAirplane);
            this.updateVelocity();
            this._groundSpeed.set(this.contact.groundSpeed);
            this._verticalSpeed.set(this.contact.verticalSpeed);
            this._isPredictionValid = true;
        }
    }
    /**
     * Updates this intruder's position.
     * @param simTime The current sim time.
     * @param ownAirplane The own airplane.
     */
    updatePosition(simTime, ownAirplane) {
        this.contact.predict(simTime, this._position, this._altitude);
        this._groundTrack = this._position.equals(this.contact.lastPosition) ? this.contact.groundTrack : this._position.bearingFrom(this.contact.lastPosition);
        const distance = UnitType.GA_RADIAN.convertTo(this._position.distance(ownAirplane.position), UnitType.METER);
        const bearing = ownAirplane.position.bearingTo(this._position);
        Vec2Math.setFromPolar(distance, (90 - bearing) * Avionics.Utils.DEG2RAD, this.positionVec);
        const verticalPosition = this._altitude.asUnit(UnitType.METER) - ownAirplane.altitude.asUnit(UnitType.METER);
        this.positionVec[2] = verticalPosition;
    }
    /**
     * Updates this intruder's velocity.
     */
    updateVelocity() {
        Vec2Math.setFromPolar(this.contact.groundSpeed.asUnit(UnitType.MPS), (90 - this.contact.groundTrack) * Avionics.Utils.DEG2RAD, this.velocityVec);
        const verticalVelocity = this.contact.verticalSpeed.asUnit(UnitType.MPS);
        this.velocityVec[2] = verticalVelocity;
    }
    /**
     * Updates the time-to-closest-approach (TCA) and related data of this intruder.
     * @param ownAirplane The own airplane.
     * @param lookaheadTime The maximum lookahead time.
     * @param protectedRadius The radius of the own airplane's protected zone.
     * @param protectedHeight The half-height of the own airplane's protected zone.
     */
    updateTCA(ownAirplane, lookaheadTime, protectedRadius, protectedHeight) {
        // Source: Munoz, CA and Narkawicz, AJ. "Time of Closest Approach in Three-Dimensional Airspace." 2010.
        // https://ntrs.nasa.gov/api/citations/20100037766/downloads/20100037766.pdf
        const s = Vec3Math.sub(this.positionVec, ownAirplane.positionVec, this.relativePositionVec);
        const v = Vec3Math.sub(this.velocityVec, ownAirplane.velocityVec, this.relativeVelocityVec);
        const sHoriz = Vec2Math.set(s[0], s[1], AbstractTCASIntruder.vec2Cache[0]);
        const vHoriz = Vec2Math.set(v[0], v[1], AbstractTCASIntruder.vec2Cache[0]);
        const h = protectedHeight.asUnit(UnitType.METER);
        const r = protectedRadius.asUnit(UnitType.METER);
        const vHorizSquared = Vec2Math.dot(vHoriz, vHoriz);
        const sHorizSquared = Vec2Math.dot(sHoriz, sHoriz);
        const hSquared = h * h;
        const rSquared = r * r;
        const a = (v[2] * v[2]) / hSquared - vHorizSquared / rSquared;
        const b = 2 * s[2] * v[2] / hSquared - 2 * Vec2Math.dot(sHoriz, vHoriz) / rSquared;
        const c = (s[2] * s[2]) / hSquared - sHorizSquared / rSquared;
        const solution = AbstractTCASIntruder.calculateSolution(0, s, v, r, h, AbstractTCASIntruder.solutionCache[0]);
        if (vHorizSquared !== 0) {
            const t = -Vec2Math.dot(sHoriz, vHoriz) / vHorizSquared;
            if (t > 0) {
                AbstractTCASIntruder.evaluateCandidate(t, s, v, r, h, solution, AbstractTCASIntruder.solutionCache[1]);
            }
        }
        if (v[2] !== 0) {
            const t = -s[2] / v[2];
            if (t > 0) {
                AbstractTCASIntruder.evaluateCandidate(t, s, v, r, h, solution, AbstractTCASIntruder.solutionCache[1]);
            }
        }
        const discriminant = b * b - 4 * a * c;
        if (a !== 0 && discriminant >= 0) {
            const sqrt = Math.sqrt(discriminant);
            let t = (-b + sqrt) / (2 * a);
            if (t > 0) {
                AbstractTCASIntruder.evaluateCandidate(t, s, v, r, h, solution, AbstractTCASIntruder.solutionCache[1]);
            }
            t = (-b - sqrt) / (2 * a);
            if (t > 0) {
                AbstractTCASIntruder.evaluateCandidate(t, s, v, r, h, solution, AbstractTCASIntruder.solutionCache[1]);
            }
        }
        else if (a === 0 && b !== 0) {
            const t = -c / b;
            if (t > 0) {
                AbstractTCASIntruder.evaluateCandidate(t, s, v, r, h, solution, AbstractTCASIntruder.solutionCache[1]);
            }
        }
        const lookaheadTimeSeconds = lookaheadTime.asUnit(UnitType.SECOND);
        if (solution.tca > lookaheadTimeSeconds) {
            AbstractTCASIntruder.calculateSolution(lookaheadTimeSeconds, s, v, r, h, solution);
        }
        this._tca.set(solution.tca);
        this._tcaNorm = solution.norm;
        AbstractTCASIntruder.displacementToHorizontalSeparation(solution.displacement, this._tcaHorizontalSep);
        AbstractTCASIntruder.displacementToVerticalSeparation(solution.displacement, this._tcaVerticalSep);
    }
    /**
     * Invalidates this intruder's predicted TCA and related data.
     */
    invalidatePrediction() {
        Vec3Math.set(NaN, NaN, NaN, this.relativePositionVec);
        Vec3Math.set(NaN, NaN, NaN, this.relativeVelocityVec);
        this._tca.set(NaN);
        this._tcaNorm = NaN;
        Vec3Math.set(NaN, NaN, NaN, this.tcaDisplacement);
        this._tcaHorizontalSep.set(NaN);
        this._tcaVerticalSep.set(NaN);
    }
    /**
     * Evaluates a TCA candidate against the best existing solution, and if the candidate produces a smaller cylindrical
     * norm, replaces the best existing solution with the candidate.
     * @param t The candidate TCA time, in seconds.
     * @param s The relative position vector of the intruder, in meters.
     * @param v The relative velocity vector of the intruder, in meters per second.
     * @param r The radius of the own airplane's protected zone, in meters.
     * @param h The half-height of the own airplane's protected zone, in meters.
     * @param best The best existing solution.
     * @param candidate A TcaSolution object to which to temporarily write the candidate solution.
     */
    static evaluateCandidate(t, s, v, r, h, best, candidate) {
        AbstractTCASIntruder.calculateSolution(t, s, v, r, h, candidate);
        if (candidate.norm < best.norm) {
            AbstractTCASIntruder.copySolution(candidate, best);
        }
    }
    /**
     * Calculates a TCA solution.
     * @param t The candidate TCA time, in seconds.
     * @param s The relative position vector of the intruder, in meters.
     * @param v The relative velocity vector of the intruder, in meters per second.
     * @param r The radius of the own airplane's protected zone, in meters.
     * @param h The half-height of the own airplane's protected zone, in meters.
     * @param out A TcaSolution object to which to write the result.
     * @returns A TCA solution.
     */
    static calculateSolution(t, s, v, r, h, out) {
        out.tca = t;
        AbstractTCASIntruder.calculateDisplacementVector(s, v, t, out.displacement);
        out.norm = AbstractTCASIntruder.calculateCylindricalNorm(out.displacement, r, h);
        return out;
    }
    /**
     * Copies a TCA solution.
     * @param from The solution from which to copy.
     * @param to The solution to which to copy.
     */
    static copySolution(from, to) {
        to.tca = from.tca;
        Vec3Math.copy(from.displacement, to.displacement);
        to.norm = from.norm;
    }
    /**
     * Calculates a time-offset displacement vector given an initial displacement, a velocity vector, and elapsed time.
     * @param initial The initial displacement vector.
     * @param velocity A velocity vector.
     * @param elapsedTime The elapsed time.
     * @param out A Float64Array object to which to write the result.
     * @returns The time-offset displacement vector.
     */
    static calculateDisplacementVector(initial, velocity, elapsedTime, out) {
        return Vec3Math.add(initial, Vec3Math.multScalar(velocity, elapsedTime, out), out);
    }
    /**
     * Calculates a cylindrical norm.
     * @param vector A displacement vector.
     * @param radius The radius of the protected zone.
     * @param halfHeight The half-height of the protected zone.
     * @returns A cylindrical norm.
     */
    static calculateCylindricalNorm(vector, radius, halfHeight) {
        const horizLength = Math.hypot(vector[0], vector[1]);
        return Math.max(Math.abs(vector[2]) / halfHeight, horizLength / radius);
    }
    /**
     * Converts a 3D displacement vector to a horizontal separation distance.
     * @param displacement A displacement vector, in meters.
     * @param out A NumberUnit object to which to write the result.
     * @returns The horizontal separation distance corresponding to the displacement vector.
     */
    static displacementToHorizontalSeparation(displacement, out) {
        return out.set(Math.hypot(displacement[0], displacement[1]), UnitType.METER);
    }
    /**
     * Converts a 3D displacement vector to a vertical separation distance.
     * @param displacement A displacement vector, in meters.
     * @param out A NumberUnit object to which to write the result.
     * @returns The vertical separation distance corresponding to the displacement vector.
     */
    static displacementToVerticalSeparation(displacement, out) {
        return out.set(Math.abs(displacement[2]), UnitType.METER);
    }
}
AbstractTCASIntruder.MIN_GROUND_SPEED = UnitType.KNOT.createNumber(30);
AbstractTCASIntruder.vec2Cache = [new Float64Array(2), new Float64Array(2)];
AbstractTCASIntruder.vec3Cache = [new Float64Array(3), new Float64Array(3)];
AbstractTCASIntruder.solutionCache = [
    {
        tca: 0,
        displacement: new Float64Array(3),
        norm: 0
    },
    {
        tca: 0,
        displacement: new Float64Array(3),
        norm: 0
    }
];
/**
 * An abstract implementation of TCASSensitivity.
 */
class AbstractTCASSensitivity {
    constructor() {
        this.lookaheadTime = NumberUnitSubject.createFromNumberUnit(UnitType.SECOND.createNumber(0));
        this.protectedRadius = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(0));
        this.protectedHeight = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(0));
    }
}

/// <reference types="msfstypes/Pages/VCockpit/Instruments/Shared/utils/XMLLogic" />
/** The acceptable priority types for a given annunciation. */
var AnnunciationType;
(function (AnnunciationType) {
    AnnunciationType[AnnunciationType["Warning"] = 0] = "Warning";
    AnnunciationType[AnnunciationType["Caution"] = 1] = "Caution";
    AnnunciationType[AnnunciationType["Advisory"] = 2] = "Advisory";
    AnnunciationType[AnnunciationType["SafeOp"] = 3] = "SafeOp";
})(AnnunciationType || (AnnunciationType = {}));
/** The main logic for a cabin annunciation. */
class Annunciation {
    /**
     * Creates an instance of Annunciation.
     * @param type The type of annuniciaton this is.
     * @param text The text label to show.
     * @param condition The logic condition for setting it.
     * @param suffix Any suffix text to past to the end.
     */
    constructor(type, text, condition, suffix) {
        this.type = type;
        this.text = text;
        this.condition = condition;
        this.suffix = suffix;
    }
}

/// <reference types="msfstypes/Pages/VCockpit/Instruments/Shared/utils/XMLLogic" />
/** Create a list of annunciations from the instrument XML config. */
class XMLAnnunciationFactory {
    /**
     * Create an XMLAnnunciationFactory.
     * @param instrument The instrument that holds this engine display.
     */
    constructor(instrument) {
        this.instrument = instrument;
    }
    /**
     * Parse an panel.xml configuration
     * @param document The configuration as an XML document.
     * @returns An array of Annunciations.
     */
    parseConfig(document) {
        const annunciations = new Array();
        const configs = document.getElementsByTagName('Annunciations');
        if (configs.length == 0) {
            return annunciations;
        }
        const config = configs[0];
        for (const ann of config.children) {
            let type;
            let suffix;
            // Priority type that this alert has.
            const typeElem = ann.getElementsByTagName('Type');
            if (typeElem.length == 0) {
                continue;
            }
            switch (typeElem[0].textContent) {
                case 'Warning':
                    type = AnnunciationType.Warning;
                    break;
                case 'Caution':
                    type = AnnunciationType.Caution;
                    break;
                case 'Advisory':
                    type = AnnunciationType.Advisory;
                    break;
                case 'SafeOp':
                    type = AnnunciationType.SafeOp;
                    break;
                default:
                    continue;
            }
            // Get the XML logic condition for state control.
            const condElem = ann.getElementsByTagName('Condition');
            if (condElem.length == 0) {
                continue;
            }
            const condition = new CompositeLogicXMLElement(this.instrument, condElem[0]);
            // The actual text shown when the alert is displayed.
            const textElem = ann.getElementsByTagName('Text');
            if (textElem.length == 0 || textElem[0].textContent == null) {
                continue;
            }
            const text = textElem[0].textContent;
            // A suffix put on the text when it's shown.
            const suffElem = ann.getElementsByTagName('Suffix');
            if (suffElem.length != 0 && suffElem[0].textContent !== null) {
                suffix = suffElem[0].textContent;
            }
            else {
                suffix = undefined;
            }
            annunciations.push(new Annunciation(type, text, condition, suffix));
        }
        return annunciations;
    }
}

/** The acceptable priority types for a given warning. */
var WarningType;
(function (WarningType) {
    WarningType[WarningType["Warning"] = 0] = "Warning";
    WarningType[WarningType["Caution"] = 1] = "Caution";
    WarningType[WarningType["Test"] = 2] = "Test";
    WarningType[WarningType["SoundOnly"] = 3] = "SoundOnly";
})(WarningType || (WarningType = {}));
/** The main logic for a system warning. */
class Warning {
    /**
     * Creates an instance of a Warning.
     * @param type The type of warning this is.
     * @param condition An XML logic element with the trigger logic.
     * @param shortText The warning message in short form.
     * @param longText The warning message in long form.
     * @param soundId The sound name to use with this warning.
     * @param once True if this warning only fires once
     */
    constructor(type, condition, shortText, longText, soundId, once) {
        this.type = type;
        this.shortText = shortText;
        this.longText = longText;
        this.soundId = soundId;
        this.condition = condition;
        this.once = once;
        this._triggered = false;
        if (this.soundId) {
            this._soundEventId = new Name_Z(this.soundId);
        }
    }
    /**
     * Whether or not we have any text at all.
     * @returns True if any non-empty text strings are set.
     */
    get hasText() {
        return this.shortText || this.longText ? true : false;
    }
    /**
     * The alert is being fired, take action.
     */
    trigger() {
        this._triggered = true;
    }
    /**
     * A text description for the warning, for debugging purposes.
     * @returns A string
     */
    get description() {
        return `<${this.shortText}|${this.longText}|${this.soundId}>`;
    }
    /**
     * Whether or not the warning has been triggered in this session.
     * @returns True if the warning has been triggered.
     */
    get triggered() {
        return this._triggered;
    }
    /**
     * Can this alert fire?
     * @returns True if the current configuration allows the alert to fire.
     */
    get canTrigger() {
        return !this.once || !this._triggered;
    }
    /**
     * The event ID Coherent returns when this sound has been played.
     * @returns A Name_Z based on the sound ID.
     */
    get eventId() {
        return this._soundEventId;
    }
}
/** The basic component for handling warning logic. */
class WarningManager {
    /**
     * Create a WarningManager.
     * @param warnings An array of warnings to manage.
     * @param logicHost An event bus.
     * @param textCb A callback to display new warning text.
     * @param soundCb A callback to play an instrument sound from a sound ID.
     */
    constructor(warnings, logicHost, textCb, soundCb) {
        this.warnings = warnings;
        this.logicHost = logicHost;
        this.textCb = textCb;
        this.soundCb = soundCb;
        this.curSndIdx = null;
        this.curTxtIdx = null;
        this.warnActiveStates = new Array();
        for (let i = 0; i < warnings.length; i++) {
            this.logicHost.addLogicAsNumber(warnings[i].condition, this.handleWarning.bind(this, i), 0);
            this.warnActiveStates.push(false);
        }
    }
    /**
     * Handle a warning firing.  This is rather complex, but it basically keeps
     * track of every warning that is active, both for text and for sound, and
     * makes sure that the highest priority version of each is played or
     * displayed, masking and restoring lower priority warnings as needed.
     * @param warnIndex The index of our warnings array that's firing.
     * @param active 1 if the warning is active, 0 otherwise.
     */
    handleWarning(warnIndex, active) {
        const warning = this.warnings[warnIndex];
        // Handle a warning that is going active.
        if (active && warning.canTrigger) {
            this.warnActiveStates[warnIndex] = true;
            warning.trigger();
            // Only worry about text if the warning has text.
            if (warning.hasText) {
                // If there is no existing text displayed, or text of a lower priority, replace it.
                if ((this.curTxtIdx == undefined || this.curTxtIdx > warnIndex)) {
                    // First, if the prior warning was a one-shot, force it to inactive so it won't be restored later.
                    if (this.curTxtIdx && this.warnings[this.curTxtIdx].once) {
                        this.warnActiveStates[this.curTxtIdx] = false;
                    }
                    this.textCb(warning);
                    this.curTxtIdx = warnIndex;
                }
            }
            // Now check for sound.
            if (this.soundCb !== undefined && warning.soundId) {
                // Make sure we have the right to play our sound.
                if (this.curSndIdx == undefined || this.curSndIdx > warnIndex) {
                    // Disable a prior sound, if one was playing.
                    if (this.curSndIdx && this.curSndIdx > warnIndex) {
                        this.soundCb(this.warnings[this.curSndIdx], false);
                        // If the prior warning was a one-shot, force it to inactive so it won't be restored.
                        if (this.warnings[this.curSndIdx].once) {
                            this.warnActiveStates[this.curSndIdx] = false;
                        }
                    }
                    this.soundCb(warning, true);
                    this.curSndIdx = warnIndex;
                }
            }
            // If that was a one-time alert, turn it off, too.
            if (warning.once) {
                this.handleWarning(warnIndex, 0);
            }
        }
        else if (!active) {
            this.warnActiveStates[warnIndex] = false;
            let isCurSnd = this.curSndIdx == warnIndex ? true : false;
            let isCurTxt = this.curTxtIdx == warnIndex ? true : false;
            // If this warning is the current active text or sound, we need to disable it.
            if (isCurSnd && this.soundCb) {
                this.soundCb(warning, false);
            }
            if (isCurTxt) {
                this.textCb(undefined);
            }
            // If either of those were true, let's see if there's anything else
            // of lower prirority that should be made active.
            if (isCurSnd || isCurTxt) {
                // We know there was no higher-priority warning, so we step through
                // everything lower than us.
                let i = warnIndex + 1;
                while ((isCurSnd || isCurTxt) && i < this.warnings.length) {
                    // Only continue this iteration if the next potential warning
                    // is active.
                    if (this.warnActiveStates[i]) {
                        const nextWarning = this.warnings[i];
                        // Make sure we can trigger the warning.   This will be false if
                        // it's a one-shot that's already triggered.  If so, just fall
                        // through to the next iteration.
                        if (nextWarning.canTrigger) {
                            // See if the lower priority warning has sound.  If so, activate.
                            if (isCurSnd && nextWarning.soundId && this.soundCb) {
                                this.soundCb(this.warnings[i], true);
                                this.curSndIdx = i;
                                // We can stop looking for another sound.
                                isCurSnd = false;
                            }
                            // Now do the same sort of thing for text.
                            if (isCurTxt && this.warnings[i].hasText) {
                                this.textCb(this.warnings[i]);
                                this.curTxtIdx = i;
                                // We can stop looking for another text.
                                isCurTxt = false;
                            }
                        }
                    }
                    // Move to the next warning on the list.
                    i++;
                }
            }
            // If we haven't yet set new sound or text, just nullify them.
            if (isCurSnd && this.soundCb) {
                this.curSndIdx = null;
            }
            if (isCurTxt) {
                this.curTxtIdx = null;
            }
        }
    }
}

/// <reference types="msfstypes/Pages/VCockpit/Instruments/Shared/utils/XMLLogic" />
/** Create a list of system warnings. */
class XMLWarningFactory {
    /**
     * Create an XMLWarningFactory.
     * @param instrument The instrument that the warnings run in.
     */
    constructor(instrument) {
        this.instrument = instrument;
    }
    /**
     * Parse a panel.xml configuration to create a list of warnings.  The warning
     * priority is defined by their order in panel.xml, with higher priority
     * warnings coming sooner in the file.
     * @param document The configuration as an XML document.
     * @returns An array of Warnings
     */
    parseConfig(document) {
        const warnings = new Array();
        const configs = document.getElementsByTagName('VoicesAlerts');
        if (configs.length == 0) {
            return warnings;
        }
        const config = configs[0];
        for (const warn of config.children) {
            let type;
            const typeElem = warn.getElementsByTagName('Type');
            if (typeElem.length == 0) {
                continue;
            }
            switch (typeElem[0].textContent) {
                case 'Warning':
                    type = WarningType.Warning;
                    break;
                case 'Caution':
                    type = WarningType.Caution;
                    break;
                case 'Test':
                    type = WarningType.Test;
                    break;
                case 'SoundOnly':
                    type = WarningType.SoundOnly;
                    break;
                default:
                    continue;
            }
            let textElem = warn.getElementsByTagName('Condition');
            if (textElem.length == 0) {
                continue;
            }
            const condition = new CompositeLogicXMLElement(this.instrument, textElem[0]);
            textElem = warn.getElementsByTagName('ShortText');
            let shortText = undefined;
            if (textElem.length > 0 && textElem[0].textContent !== null) {
                shortText = textElem[0].textContent;
            }
            textElem = warn.getElementsByTagName('LongText');
            let longText = undefined;
            if (textElem.length > 0 && textElem[0].textContent !== null) {
                longText = textElem[0].textContent;
            }
            textElem = warn.getElementsByTagName('SoundEvent');
            let soundEvent = undefined;
            if (textElem.length > 0 && textElem[0].textContent !== null) {
                soundEvent = textElem[0].textContent;
            }
            textElem = warn.getElementsByTagName('Once');
            let once = false;
            if (textElem.length > 0 && textElem[0].textContent == 'True') {
                once = true;
            }
            warnings.push(new Warning(type, condition, shortText, longText, soundEvent, once));
        }
        return warnings;
    }
}

/** A control publisher that handles G1000 events too. */
class G1000ControlPublisher extends BasePublisher {
    /**
     * Create a ControlPublisher.
     * @param bus The EventBus to publish to.
     */
    constructor(bus) {
        super(bus);
    }
    /**
     * Publish a control event.
     * @param event The event from ControlEvents.
     * @param value The value of the event.
     */
    publishEvent(event, value) {
        this.publish(event, value, true);
    }
}

var LNavVars;
(function (LNavVars) {
    /** The name of the LVar used to publish the current dtk (magnetic). */
    LNavVars["DTK"] = "L:WT1000_LNav_DTK_Mag";
    /** The name of the LVar used to publish the current xtk. */
    LNavVars["XTK"] = "L:WT1000_LNav_XTK";
    /** The name of the LVar used to publish the next dtk (magnetic). */
    LNavVars["NextDTK"] = "L:WT1000_LNav_Next_DTK_Mag";
    /** The name of the LVar used to publish the next xtk. */
    LNavVars["NextXTK"] = "L:WT1000_LNav_Next_XTK";
    /** The name of the LVar used to publish the bearing (magnetic) to the current waypoint. */
    LNavVars["Bearing"] = "L:WT1000_LNav_BRG_Mag";
    /** The name of the LVar used to publish the distance to the current waypoint. */
    LNavVars["Distance"] = "L:WT1000_LNav_DIS";
    /** The name of the LVar used to publish the distance to the current waypoint. */
    LNavVars["DistanceToTurn"] = "L:WT1000_LNav_DIS_Turn";
    /** Whether or not the LNAV is in a leg-to-leg turn. */
    LNavVars["IsTurning"] = "L:WT1000_LNav_IsTurning";
    /** The current max CDI deflection, in NM. */
    LNavVars["CDIScale"] = "L:WT1000_CDI_Scale";
    /** The current value of the CDI scale label enum. */
    LNavVars["CDIScaleLabel"] = "L:WT1000_CDI_Scale_Label";
    /** The current index of the vector LNAV is tracking. */
    LNavVars["CurrentVector"] = "L:WT1000_LNav_Current_Vector";
    /** The current calculated Distance to the Destination. */
    LNavVars["DistanceToDestination"] = "L:WT1000_LNav_Destination_Dis";
})(LNavVars || (LNavVars = {}));
/**
 * Valid CDI scale labels for the LVar scale enum.
 */
var CDIScaleLabel;
(function (CDIScaleLabel) {
    CDIScaleLabel[CDIScaleLabel["Departure"] = 0] = "Departure";
    CDIScaleLabel[CDIScaleLabel["Terminal"] = 1] = "Terminal";
    CDIScaleLabel[CDIScaleLabel["Enroute"] = 2] = "Enroute";
    CDIScaleLabel[CDIScaleLabel["Oceanic"] = 3] = "Oceanic";
    CDIScaleLabel[CDIScaleLabel["LNav"] = 4] = "LNav";
    CDIScaleLabel[CDIScaleLabel["LNavPlusV"] = 5] = "LNavPlusV";
    CDIScaleLabel[CDIScaleLabel["Visual"] = 6] = "Visual";
    CDIScaleLabel[CDIScaleLabel["LNavVNav"] = 7] = "LNavVNav";
    CDIScaleLabel[CDIScaleLabel["LP"] = 8] = "LP";
    CDIScaleLabel[CDIScaleLabel["LPPlusV"] = 9] = "LPPlusV";
    CDIScaleLabel[CDIScaleLabel["LPV"] = 10] = "LPV";
    CDIScaleLabel[CDIScaleLabel["MissedApproach"] = 11] = "MissedApproach";
})(CDIScaleLabel || (CDIScaleLabel = {}));
/** A publisher to poll and publish nav/com simvars. */
class LNavSimVarPublisher extends SimVarPublisher {
    /**
     * Create a NavComSimVarPublisher
     * @param bus The EventBus to publish to
     */
    constructor(bus) {
        super(LNavSimVarPublisher.simvars, bus);
    }
}
LNavSimVarPublisher.simvars = new Map([
    ['lnavBrgMag', { name: LNavVars.Bearing, type: SimVarValueType.Degree }],
    ['lnavDis', { name: LNavVars.Distance, type: SimVarValueType.NM }],
    ['lnavDisTurn', { name: LNavVars.DistanceToTurn, type: SimVarValueType.NM }],
    ['lnavDtkMag', { name: LNavVars.DTK, type: SimVarValueType.Degree }],
    ['lnavXtk', { name: LNavVars.XTK, type: SimVarValueType.NM }],
    ['lnavNextDtkMag', { name: LNavVars.NextDTK, type: SimVarValueType.Degree }],
    ['lnavNextXtkMag', { name: LNavVars.NextXTK, type: SimVarValueType.NM }],
    ['lnavCdiScaling', { name: LNavVars.CDIScale, type: SimVarValueType.NM }],
    ['lnavCdiScalingLabel', { name: LNavVars.CDIScaleLabel, type: SimVarValueType.Number }],
    ['lnavCurrentVector', { name: LNavVars.CurrentVector, type: SimVarValueType.Number }],
    ['lnavDistanceToDestination', { name: LNavVars.DistanceToDestination, type: SimVarValueType.NM }],
]);

/**
 * Events published by the VNAV system on the bus.
 */
var VNavSimVars;
(function (VNavSimVars) {
    /** The vertical deviation. */
    VNavSimVars["VerticalDeviation"] = "L:WT1000_VNav_Vertical_Deviation";
    /** The VNAV target altitude. */
    VNavSimVars["TargetAltitude"] = "L:WT1000_VNav_Target_Altitude";
    /** The VNAV path mode. */
    VNavSimVars["PathMode"] = "L:WT1000_VNav_Path_Mode";
    /** The VNAV mode. */
    VNavSimVars["VNAVMode"] = "L:WT1000_VNav_Mode";
    /** The VNAV approach guidance mode. */
    VNavSimVars["ApproachMode"] = "L:WT1000_VNav_Approach_Mode";
    /** The distance to the next TOD, or -1 if one does not exist. */
    VNavSimVars["TODDistance"] = "L:WT1000_VNav_Distance_To_TOD";
    /** The index of the leg for the next TOD. */
    VNavSimVars["TODLegIndex"] = "L:WT1000_VNav_TOD_Leg_Index";
    /** The distance from the end of the TOD leg that the TOD is. */
    VNavSimVars["TODDistanceInLeg"] = "L:WT1000_VNav_TOD_Distance_In_Leg";
    /** The index of the leg for the next BOD. */
    VNavSimVars["BODLegIndex"] = "L:WT1000_VNav_BOD_Leg_Index";
    /** The index of the leg for the next constraint. */
    VNavSimVars["CurrentConstraintLegIndex"] = "L:WT1000_VNav_Constraint_Leg_Index";
    /** The current constraint altitude. */
    VNavSimVars["CurrentConstraintAltitude"] = "L:WT1000_VNav_Constraint_Altitude";
    /** The distance to the next BOD, or -1 if one does not exist. */
    VNavSimVars["BODDistance"] = "L:WT1000_VNav_Distance_To_BOD";
    /** The VNAV current altitude capture type. */
    VNavSimVars["CaptureType"] = "L:WT1000_VNav_Alt_Capture_Type";
    /** The current required flight path angle. */
    VNavSimVars["FPA"] = "L:WT1000_VNav_FPA";
    /** The current LPV vertical deviation. */
    VNavSimVars["LPVVerticalDeviation"] = "L:WT1000_LPV_Vertical_Deviation";
    /** The current remaining LPV distance. */
    VNavSimVars["LPVDistance"] = "L:WT1000_LPV_Distance";
    /** The required VS to the current constraint. */
    VNavSimVars["RequiredVS"] = "L:WT1000_VNAV_Required_VS";
})(VNavSimVars || (VNavSimVars = {}));
/** A publisher to poll and publish nav/com simvars. */
class VNavSimVarPublisher extends SimVarPublisher {
    /**
     * Create a NavComSimVarPublisher
     * @param bus The EventBus to publish to
     */
    constructor(bus) {
        super(VNavSimVarPublisher.simvars, bus);
    }
}
VNavSimVarPublisher.simvars = new Map([
    ['vnavVDev', { name: VNavSimVars.VerticalDeviation, type: SimVarValueType.Feet }],
    ['vnavTargetAlt', { name: VNavSimVars.TargetAltitude, type: SimVarValueType.Feet }],
    ['vnavPathMode', { name: VNavSimVars.PathMode, type: SimVarValueType.Number }],
    ['vnavMode', { name: VNavSimVars.VNAVMode, type: SimVarValueType.Number }],
    ['vnavApproachMode', { name: VNavSimVars.ApproachMode, type: SimVarValueType.Number }],
    ['vnavTodDistance', { name: VNavSimVars.TODDistance, type: SimVarValueType.Number }],
    ['vnavTodLegDistance', { name: VNavSimVars.TODDistanceInLeg, type: SimVarValueType.Number }],
    ['vnavTodLegIndex', { name: VNavSimVars.TODLegIndex, type: SimVarValueType.Number }],
    ['vnavBodLegIndex', { name: VNavSimVars.BODLegIndex, type: SimVarValueType.Number }],
    ['vnavConstraintLegIndex', { name: VNavSimVars.CurrentConstraintLegIndex, type: SimVarValueType.Number }],
    ['vnavConstraintAltitude', { name: VNavSimVars.CurrentConstraintAltitude, type: SimVarValueType.Feet }],
    ['vnavBodDistance', { name: VNavSimVars.BODDistance, type: SimVarValueType.Number }],
    ['vnavAltCaptureType', { name: VNavSimVars.CaptureType, type: SimVarValueType.Number }],
    ['vnavFpa', { name: VNavSimVars.FPA, type: SimVarValueType.FPM }],
    ['vnavLpvVDev', { name: VNavSimVars.LPVVerticalDeviation, type: SimVarValueType.Feet }],
    ['vnavLpvDistance', { name: VNavSimVars.LPVDistance, type: SimVarValueType.Number }],
    ['vnavRequiredVs', { name: VNavSimVars.RequiredVS, type: SimVarValueType.Number }]
]);

/**
 * A manager for user settings. Provides settings using their names as keys, publishes value change events on the
 * event bus, and keeps setting values up to date when receiving change events across the bus.
 */
class DefaultUserSettingManager {
    /**
     * Constructor.
     * @param bus The bus used by this manager to publish setting change events.
     * @param settingDefs The setting definitions used to initialize manager's settings.
     */
    constructor(bus, settingDefs) {
        this.bus = bus;
        this.publisher = bus.getPublisher();
        this.subscriber = bus.getSubscriber();
        this.settings = new Map(settingDefs.map(def => {
            const syncTopic = `${DefaultUserSettingManager.SYNC_TOPIC_PREFIX}${def.name}`;
            const entry = {
                syncTopic,
                syncTime: 0
            };
            entry.setting = new SyncableUserSetting(def, this.onSettingValueChanged.bind(this, entry));
            this.subscriber.on(syncTopic).handle(this.onSettingValueSynced.bind(this, entry));
            this.onSettingValueChanged(entry, entry.setting.value);
            return [def.name, entry];
        }));
    }
    /**
     * Gets a setting from this manager.
     * @param name The name of the setting to get.
     * @returns a setting.
     * @throws Error if no setting with the specified name exists.
     */
    getSetting(name) {
        const entry = this.settings.get(name);
        if (!entry) {
            throw new Error(`Could not find setting with name ${name}`);
        }
        return entry.setting;
    }
    /**
     * Gets an array of all settings of this manager.
     * @returns an array of all settings of this manager.
     */
    getAllSettings() {
        return Array.from(this.settings.values(), entry => entry.setting);
    }
    /**
     * Gets a consumer which notifies handlers when the value of a setting changes.
     * @param name The name of a setting.
     * @returns a consumer which notifies handlers when the value of the setting changes.
     * @throws Error if no setting with the specified name exists.
     */
    whenSettingChanged(name) {
        const setting = this.settings.get(name);
        if (!setting) {
            throw new Error(`Could not find setting with name ${name}`);
        }
        return this.subscriber.on(name).whenChanged();
    }
    /**
     * Maps a user setting manager to abstracted settings keys.
     * @param map The map of key abstractions to apply.
     * @returns A new mapped user setting manager.
     */
    mapTo(map) {
        return new MappedUserSettingManager(this, map);
    }
    /**
     * A callback which is called when one of this manager's settings has its value changed locally.
     * @param entry The entry for the setting that was changed.
     * @param value The new value of the setting.
     */
    onSettingValueChanged(entry, value) {
        entry.syncTime = Date.now();
        this.publisher.pub(entry.syncTopic, { value, syncTime: entry.syncTime }, true, true);
    }
    /**
     * A callback which is called when a setting changed event is received over the event bus.
     * @param entry The entry for the setting that was changed.
     * @param data The sync data.
     */
    onSettingValueSynced(entry, data) {
        // protect against race conditions by not responding to sync events older than the last time this manager synced
        // the setting
        if (data.syncTime < entry.syncTime) {
            return;
        }
        entry.syncTime = data.syncTime;
        entry.setting.syncValue(data.value);
        // publish the public setting change event. Do NOT sync across the bus because doing so can result in older events
        // being received after newer events.
        this.publisher.pub(entry.setting.definition.name, data.value, false, true);
    }
}
DefaultUserSettingManager.SYNC_TOPIC_PREFIX = 'usersetting.';
/**
 * A manager for user settings. Provides settings using their names as keys, publishes value change events on the
 * event bus, and keeps setting values up to date when receiving change events across the bus, using a mapping from
 * abstracted settings keys to true underlying settings keys.
 */
class MappedUserSettingManager {
    /**
     * Creates an instance of a MappedUserSettingManager.
     * @param parent The parent setting manager.
     * @param map The map of abstracted keys to true underlying keys.
     */
    constructor(parent, map) {
        this.parent = parent;
        this.map = map;
    }
    /** @inheritdoc */
    getSetting(name) {
        var _a;
        const mappedName = ((_a = this.map[name]) !== null && _a !== void 0 ? _a : name);
        return this.parent.getSetting(mappedName);
    }
    /** @inheritdoc */
    whenSettingChanged(name) {
        var _a;
        const mappedName = ((_a = this.map[name]) !== null && _a !== void 0 ? _a : name);
        return this.parent.whenSettingChanged(mappedName);
    }
}
/**
 * An implementation of a user setting which can be synced across multiple instances.
 */
class SyncableUserSetting {
    /**
     * Constructor.
     * @param definition This setting's definition.
     * @param valueChangedCallback A function to be called whenever the value of this setting changes.
     */
    constructor(definition, valueChangedCallback) {
        this.definition = definition;
        this.valueChangedCallback = valueChangedCallback;
        this.isSyncing = false;
        this.valueSub = Subject.create(definition.defaultValue);
        this.valueSub.sub(v => {
            !this.isSyncing && valueChangedCallback(v);
        });
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This setting's current value. */
    get value() {
        return this.valueSub.get();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set value(v) {
        this.valueSub.set(v);
    }
    /**
     * Syncs this setting to a value. This will not trigger a call to valueChangedCallback.
     * @param value The value to which to sync.
     */
    syncValue(value) {
        this.isSyncing = true;
        this.valueSub.set(value);
        this.isSyncing = false;
    }
}

/**
 * A manager for user settings that are saved and persistent across flight sessions. The manager facilitates saving
 * and loading setting values to and from multiple keyed save slots and also supports auto-saving. Uses Data Store to
 * store saved setting values.
 */
class UserSettingSaveManager {
    /**
     * Constructor.
     * @param settings This manager's managed settings.
     * @param bus The event bus.
     */
    constructor(settings, bus) {
        this.autoSaveKeys = new Set();
        const subscriber = bus.getSubscriber();
        this.entries = Array.from(settings, setting => {
            const autoSaveDataStoreKeys = [];
            return {
                setting,
                consumer: subscriber.on(setting.definition.name).whenChanged(),
                eventHandler: this.onSettingChanged.bind(this, autoSaveDataStoreKeys),
                autoSaveDataStoreKeys
            };
        });
    }
    /**
     * A callback which is called when a setting's value changes.
     * @param autoSaveDataStoreKeys The data store keys to which the setting's value should be automatically saved.
     * @param value The new value of the setting.
     */
    onSettingChanged(autoSaveDataStoreKeys, value) {
        const len = autoSaveDataStoreKeys.length;
        for (let i = 0; i < len; i++) {
            DataStore.set(autoSaveDataStoreKeys[i], value);
        }
    }
    /**
     * Loads the saved values of this manager's settings.
     * @param key The key from which to load the values.
     */
    load(key) {
        const len = this.entries.length;
        for (let i = 0; i < len; i++) {
            const entry = this.entries[i];
            const dataStoreKey = UserSettingSaveManager.getDataStoreKey(entry.setting, key);
            const storedValue = DataStore.get(dataStoreKey);
            if (storedValue !== undefined) {
                entry.setting.value = storedValue;
            }
        }
    }
    /**
     * Saves the current values of this manager's settings.
     * @param key The key to which to save the values.
     */
    save(key) {
        const len = this.entries.length;
        for (let i = 0; i < len; i++) {
            const entry = this.entries[i];
            const dataStoreKey = UserSettingSaveManager.getDataStoreKey(entry.setting, key);
            DataStore.set(dataStoreKey, entry.setting.value);
        }
    }
    /**
     * Starts automatically saving this manager's settings when their values change.
     * @param key The key to which to save the values.
     */
    startAutoSave(key) {
        if (this.autoSaveKeys.has(key)) {
            return;
        }
        const len = this.entries.length;
        for (let i = 0; i < len; i++) {
            const entry = this.entries[i];
            entry.autoSaveDataStoreKeys.push(UserSettingSaveManager.getDataStoreKey(entry.setting, key));
            if (entry.autoSaveDataStoreKeys.length === 1) {
                entry.consumer.handle(entry.eventHandler);
            }
        }
    }
    /**
     * Stops automatically saving this manager's settings when their values change.
     * @param key The key to which to stop saving the values.
     */
    stopAutoSave(key) {
        if (!this.autoSaveKeys.has(key)) {
            return;
        }
        const len = this.entries.length;
        for (let i = 0; i < len; i++) {
            const entry = this.entries[i];
            entry.autoSaveDataStoreKeys.splice(entry.autoSaveDataStoreKeys.indexOf(UserSettingSaveManager.getDataStoreKey(entry.setting, key)), 1);
            if (entry.autoSaveDataStoreKeys.length === 0) {
                entry.consumer.off(entry.eventHandler);
            }
        }
    }
    /**
     * Gets a data store key for a specific setting and save key.
     * @param setting A user setting.
     * @param saveKey The save key.
     * @returns the data store key for the setting and save key.
     */
    static getDataStoreKey(setting, saveKey) {
        return `${UserSettingSaveManager.DATASTORE_PREFIX}.${saveKey}.${setting.definition.name}`;
    }
}
UserSettingSaveManager.DATASTORE_PREFIX = 'persistent-setting';

/**
 * Traffic alert level modes.
 */
var MapTrafficAlertLevelMode;
(function (MapTrafficAlertLevelMode) {
    MapTrafficAlertLevelMode[MapTrafficAlertLevelMode["All"] = 0] = "All";
    MapTrafficAlertLevelMode[MapTrafficAlertLevelMode["Advisories"] = 1] = "Advisories";
    MapTrafficAlertLevelMode[MapTrafficAlertLevelMode["TA_RA"] = 2] = "TA_RA";
    MapTrafficAlertLevelMode[MapTrafficAlertLevelMode["RA"] = 3] = "RA";
})(MapTrafficAlertLevelMode || (MapTrafficAlertLevelMode = {}));
/**
 * Traffic motion vector modes.
 */
var MapTrafficMotionVectorMode;
(function (MapTrafficMotionVectorMode) {
    MapTrafficMotionVectorMode[MapTrafficMotionVectorMode["Off"] = 0] = "Off";
    MapTrafficMotionVectorMode[MapTrafficMotionVectorMode["Absolute"] = 1] = "Absolute";
    MapTrafficMotionVectorMode[MapTrafficMotionVectorMode["Relative"] = 2] = "Relative";
})(MapTrafficMotionVectorMode || (MapTrafficMotionVectorMode = {}));
/**
 * Traffic display altitude restriction modes.
 */
var MapTrafficAltitudeRestrictionMode;
(function (MapTrafficAltitudeRestrictionMode) {
    MapTrafficAltitudeRestrictionMode[MapTrafficAltitudeRestrictionMode["Unrestricted"] = 0] = "Unrestricted";
    MapTrafficAltitudeRestrictionMode[MapTrafficAltitudeRestrictionMode["Above"] = 1] = "Above";
    MapTrafficAltitudeRestrictionMode[MapTrafficAltitudeRestrictionMode["Normal"] = 2] = "Normal";
    MapTrafficAltitudeRestrictionMode[MapTrafficAltitudeRestrictionMode["Below"] = 3] = "Below";
})(MapTrafficAltitudeRestrictionMode || (MapTrafficAltitudeRestrictionMode = {}));
/**
 * A module describing the display of traffic.
 */
class MapTrafficModule {
    /**
     * Constructor.
     * @param tcas This module's associated TCAS.
     */
    constructor(tcas) {
        this.tcas = tcas;
        /** Whether to show traffic information. */
        this.show = Subject.create(true);
        /** The TCAS operating mode. */
        this.operatingMode = Subject.create(TCASOperatingMode.Standby);
        /** Whether to show intruder labels. */
        this.showIntruderLabel = Subject.create(true);
        /** The index of the outer ring range. */
        this.outerRangeIndex = Subject.create(0);
        /** The index of the inner ring range. */
        this.innerRangeIndex = Subject.create(0);
        /** The alert level mode. */
        this.alertLevelMode = Subject.create(MapTrafficAlertLevelMode.All);
        /** The altitude restriction mode. */
        this.altitudeRestrictionMode = Subject.create(MapTrafficAltitudeRestrictionMode.Unrestricted);
        /** The motion vector mode. */
        this.altitudeRestrictionAbove = ComputedSubject.create(MapTrafficAltitudeRestrictionMode.Unrestricted, mode => {
            return mode === MapTrafficAltitudeRestrictionMode.Unrestricted || mode === MapTrafficAltitudeRestrictionMode.Above
                ? MapTrafficModule.ALTITUDE_RESTRICTION_UNRES
                : MapTrafficModule.ALTITUDE_RESTRICTION_NORMAL;
        });
        /** The motion vector mode. */
        this.altitudeRestrictionBelow = ComputedSubject.create(MapTrafficAltitudeRestrictionMode.Unrestricted, mode => {
            return mode === MapTrafficAltitudeRestrictionMode.Unrestricted || mode === MapTrafficAltitudeRestrictionMode.Below
                ? MapTrafficModule.ALTITUDE_RESTRICTION_UNRES
                : MapTrafficModule.ALTITUDE_RESTRICTION_NORMAL;
        });
        /** Whether displayed intruder altitude is relative. */
        this.isAltitudeRelative = Subject.create(true);
        /** The motion vector mode. */
        this.motionVectorMode = Subject.create(MapTrafficMotionVectorMode.Off);
        /** The motion vector mode. */
        this.motionVectorLookahead = NumberUnitSubject.createFromNumberUnit(UnitType.SECOND.createNumber(60));
        this.altitudeRestrictionMode.sub(mode => {
            this.altitudeRestrictionAbove.set(mode);
            this.altitudeRestrictionBelow.set(mode);
        });
        tcas.getEventSubscriber().on('tcas_operating_mode').whenChanged().handle(mode => {
            this.operatingMode.set(mode);
        });
    }
}
MapTrafficModule.ALTITUDE_RESTRICTION_UNRES = UnitType.FOOT.createNumber(9900);
MapTrafficModule.ALTITUDE_RESTRICTION_NORMAL = UnitType.FOOT.createNumber(2700);

/**
 * Setting modes for map orientation.
 */
var MapOrientationSettingMode;
(function (MapOrientationSettingMode) {
    MapOrientationSettingMode[MapOrientationSettingMode["NorthUp"] = 0] = "NorthUp";
    MapOrientationSettingMode[MapOrientationSettingMode["TrackUp"] = 1] = "TrackUp";
    MapOrientationSettingMode[MapOrientationSettingMode["HeadingUp"] = 2] = "HeadingUp";
})(MapOrientationSettingMode || (MapOrientationSettingMode = {}));
/**
 * Setting modes for map terrain display.
 */
var MapTerrainSettingMode;
(function (MapTerrainSettingMode) {
    MapTerrainSettingMode[MapTerrainSettingMode["None"] = 0] = "None";
    MapTerrainSettingMode[MapTerrainSettingMode["Absolute"] = 1] = "Absolute";
    MapTerrainSettingMode[MapTerrainSettingMode["Relative"] = 2] = "Relative";
})(MapTerrainSettingMode || (MapTerrainSettingMode = {}));
/**
 * Setting modes for map declutter.
 */
var MapDeclutterSettingMode;
(function (MapDeclutterSettingMode) {
    MapDeclutterSettingMode[MapDeclutterSettingMode["All"] = 0] = "All";
    MapDeclutterSettingMode[MapDeclutterSettingMode["Level3"] = 1] = "Level3";
    MapDeclutterSettingMode[MapDeclutterSettingMode["Level2"] = 2] = "Level2";
    MapDeclutterSettingMode[MapDeclutterSettingMode["Level1"] = 3] = "Level1";
})(MapDeclutterSettingMode || (MapDeclutterSettingMode = {}));
/**
 * Utility class for retrieving map user setting managers.
 */
class MapUserSettings {
    /**
     * Retrieves a manager for map user settings.
     * @param bus The event bus.
     * @returns a manager for map user settings.
     */
    static getManager(bus) {
        var _a;
        return (_a = MapUserSettings.INSTANCE) !== null && _a !== void 0 ? _a : (MapUserSettings.INSTANCE = new DefaultUserSettingManager(bus, [
            {
                name: 'mapOrientation',
                defaultValue: MapOrientationSettingMode.HeadingUp
            },
            {
                name: 'mapAutoNorthUpActive',
                defaultValue: true
            },
            {
                name: 'mapAutoNorthUpRangeIndex',
                defaultValue: 27
            },
            {
                name: 'mapPfdDeclutter',
                defaultValue: MapDeclutterSettingMode.All
            },
            {
                name: 'mapMfdDeclutter',
                defaultValue: MapDeclutterSettingMode.All
            },
            {
                name: 'mapPfdTerrainMode',
                defaultValue: MapTerrainSettingMode.Absolute
            },
            {
                name: 'mapMfdTerrainMode',
                defaultValue: MapTerrainSettingMode.Absolute
            },
            {
                name: 'mapTerrainRangeIndex',
                defaultValue: 27
            },
            {
                name: 'mapTerrainScaleShow',
                defaultValue: false
            },
            {
                name: 'mapAirportLargeShow',
                defaultValue: true
            },
            {
                name: 'mapAirportLargeRangeIndex',
                defaultValue: 21
            },
            {
                name: 'mapAirportMediumShow',
                defaultValue: true
            },
            {
                name: 'mapAirportMediumRangeIndex',
                defaultValue: 19
            },
            {
                name: 'mapAirportSmallShow',
                defaultValue: true
            },
            {
                name: 'mapAirportSmallRangeIndex',
                defaultValue: 17
            },
            {
                name: 'mapVorShow',
                defaultValue: true
            },
            {
                name: 'mapVorRangeIndex',
                defaultValue: 19
            },
            {
                name: 'mapNdbShow',
                defaultValue: true
            },
            {
                name: 'mapNdbRangeIndex',
                defaultValue: 17
            },
            {
                name: 'mapIntersectionShow',
                defaultValue: true
            },
            {
                name: 'mapIntersectionRangeIndex',
                defaultValue: 17
            },
            {
                name: 'mapPfdTrafficShow',
                defaultValue: false
            },
            {
                name: 'mapMfdTrafficShow',
                defaultValue: false
            },
            {
                name: 'mapTrafficRangeIndex',
                defaultValue: 17
            },
            {
                name: 'mapTrafficLabelShow',
                defaultValue: true
            },
            {
                name: 'mapTrafficLabelRangeIndex',
                defaultValue: 17
            },
            {
                name: 'mapTrafficAlertLevelMode',
                defaultValue: MapTrafficAlertLevelMode.All
            },
            {
                name: 'mapPfdNexradShow',
                defaultValue: false
            },
            {
                name: 'mapMfdNexradShow',
                defaultValue: false
            },
            {
                name: 'mapNexradRangeIndex',
                defaultValue: 27
            }
        ]));
    }
    /**
     * Retrieves a manager for PFD map user settings.
     * @param bus The event bus.
     * @returns a manager for PFD map user settings.
     */
    static getPfdManager(bus) {
        var _a;
        return (_a = MapUserSettings.PFD_INSTANCE) !== null && _a !== void 0 ? _a : MapUserSettings.getManager(bus).mapTo({
            mapDeclutter: 'mapPfdDeclutter',
            mapNexradShow: 'mapPfdNexradShow',
            mapTerrainMode: 'mapPfdTerrainMode',
            mapTrafficShow: 'mapPfdTrafficShow'
        });
    }
    /**
     * Retrieves a manager for MFD map user settings.
     * @param bus The event bus.
     * @returns a manager for PFD map user settings.
     */
    static getMfdManager(bus) {
        var _a;
        return (_a = MapUserSettings.MFD_INSTANCE) !== null && _a !== void 0 ? _a : MapUserSettings.getManager(bus).mapTo({
            mapDeclutter: 'mapMfdDeclutter',
            mapNexradShow: 'mapMfdNexradShow',
            mapTerrainMode: 'mapMfdTerrainMode',
            mapTrafficShow: 'mapMfdTrafficShow'
        });
    }
}

/**
 * A softkey menu instance.
 */
class SoftKeyMenu {
    /**
     * Creates an instance of a SoftKeyMenu.
     * @param menuSystem The menu system that will manage this menu.
     */
    constructor(menuSystem) {
        this.menuSystem = menuSystem;
        /** The menu items in this menu. */
        this.menuItems = [];
    }
    /**
     * Adds a menu item to the softkey menu.
     * @param index The softkey index to add the menu item to.
     * @param label The label of the menu item.
     * @param handler The handler to call when the menu item is selected.
     * @param value The value of the menu item, if any.
     * @param disabled Whether or not the menu item is disabled.
     */
    addItem(index, label, handler, value, disabled = false) {
        this.menuItems[index] = { label: Subject.create(label), handler, value: Subject.create(value), disabled: Subject.create(handler === undefined || disabled) };
    }
    /**
     * Removes a menu item from the menu.
     * @param index The softkey index to remove the menu item from.
     */
    removeItem(index) {
        this.menuItems[index] = SoftKeyMenu.EmptyMenuItem;
    }
    /**
     * Gets a menu item.
     * @param index The index of the menu item.
     * @returns The requested menu item.
     */
    getItem(index) {
        return this.menuItems[index];
    }
    /**
     * Handles a back menu action.
     */
    handleBack() {
        this.menuSystem.back();
    }
    /**
     * Iterates over the menu items.
     * @param each The function to run over each menu item.
     */
    forEach(each) {
        for (let i = 0; i < 12; i++) {
            const item = this.menuItems[i];
            each(item !== null && item !== void 0 ? item : SoftKeyMenu.EmptyMenuItem, i);
        }
    }
    /**
     * Handles when a menu item is pressed.
     * @param index The index of the menu item that was pressed.
     */
    handleItemPressed(index) {
        const menuItem = this.menuItems[index];
        if (menuItem && menuItem.handler && !menuItem.disabled.get()) {
            menuItem.handler(this);
        }
    }
}
/** An empty menu item. */
SoftKeyMenu.EmptyMenuItem = {
    label: Subject.create(''),
    handler: undefined,
    disabled: Subject.create(true),
    value: Subject.create(undefined)
};

/**
 * The Map/HSI softkey menu.
 */
class MapHSIMenu extends SoftKeyMenu {
    /**
     * Creates an instance of the Map/HSI softkey menu.
     * @param menuSystem The menu system.
     */
    constructor(menuSystem) {
        super(menuSystem);
        this.settings = MapUserSettings.getPfdManager(this.menuSystem.bus);
        this.addItem(0, 'Layout', () => menuSystem.pushMenu('map-hsi-layout'));
        this.addItem(1, 'Detail', this.cycleDeclutterSetting.bind(this), '', false);
        this.addItem(2, 'Traffic', this.toggleBooleanSetting.bind(this, 'mapTrafficShow'), false, false);
        this.addItem(3, 'Topo', this.toggleTerrainMode.bind(this, MapTerrainSettingMode.Absolute), false, false);
        this.addItem(4, 'Rel Ter', this.toggleTerrainMode.bind(this, MapTerrainSettingMode.Relative), false, false);
        this.addItem(5, 'NEXRAD', this.toggleBooleanSetting.bind(this, 'mapNexradShow'), false, false);
        this.addItem(6, 'METAR');
        this.addItem(7, 'Lightning');
        this.addItem(10, 'Back', () => menuSystem.back());
        this.addItem(11, 'Alerts');
        this.initSettings();
    }
    /**
     * Sets the map model to use for these options.
     */
    initSettings() {
        this.settings.whenSettingChanged('mapDeclutter').handle(v => this.getItem(1).value.set(MapHSIMenu.DECLUTTER_TEXT[v]));
        this.settings.whenSettingChanged('mapTrafficShow').handle(v => this.getItem(2).value.set(v));
        this.settings.whenSettingChanged('mapTerrainMode').handle(this.onTerrainModeChanged.bind(this));
        this.settings.whenSettingChanged('mapNexradShow').handle(v => this.getItem(5).value.set(v));
    }
    /**
     * Handles menu changes when the terrain mode changes.
     * @param v The new terrain mode.
     */
    onTerrainModeChanged(v) {
        switch (v) {
            case MapTerrainSettingMode.Absolute:
                this.getItem(3).value.set(true);
                this.getItem(4).value.set(false);
                break;
            case MapTerrainSettingMode.Relative:
                this.getItem(3).value.set(false);
                this.getItem(4).value.set(true);
                break;
            default:
                this.getItem(3).value.set(false);
                this.getItem(4).value.set(false);
                break;
        }
    }
    /**
     * Toggles a boolean map setting on or off.
     * @param setting The setting to toggle.
     */
    toggleBooleanSetting(setting) {
        const mapSetting = this.settings.getSetting(setting);
        mapSetting.value = !mapSetting.value;
    }
    /**
     * Cycles the declutter setting.
     */
    cycleDeclutterSetting() {
        const setting = this.settings.getSetting('mapDeclutter');
        switch (setting.value) {
            case MapDeclutterSettingMode.All:
                setting.value = MapDeclutterSettingMode.Level3;
                break;
            case MapDeclutterSettingMode.Level3:
                setting.value = MapDeclutterSettingMode.Level2;
                break;
            case MapDeclutterSettingMode.Level2:
                setting.value = MapDeclutterSettingMode.Level1;
                break;
            case MapDeclutterSettingMode.Level1:
                setting.value = MapDeclutterSettingMode.All;
                break;
        }
    }
    /**
     * Toggles a specified terrain mode.
     * @param mode The mode to toggle.
     */
    toggleTerrainMode(mode) {
        const setting = this.settings.getSetting('mapTerrainMode');
        const currentMode = setting.value;
        if (mode === currentMode) {
            setting.value = MapTerrainSettingMode.None;
        }
        else {
            setting.value = mode;
        }
    }
}
MapHSIMenu.DECLUTTER_TEXT = {
    [MapDeclutterSettingMode.All]: 'All',
    [MapDeclutterSettingMode.Level3]: '3',
    [MapDeclutterSettingMode.Level2]: '2',
    [MapDeclutterSettingMode.Level1]: '1',
};

/**
 * The wind overlay options.
 */
var WindOverlaySettingMode;
(function (WindOverlaySettingMode) {
    WindOverlaySettingMode[WindOverlaySettingMode["Off"] = 0] = "Off";
    WindOverlaySettingMode[WindOverlaySettingMode["Opt1"] = 1] = "Opt1";
    WindOverlaySettingMode[WindOverlaySettingMode["Opt2"] = 2] = "Opt2";
    WindOverlaySettingMode[WindOverlaySettingMode["Opt3"] = 3] = "Opt3";
})(WindOverlaySettingMode || (WindOverlaySettingMode = {}));
/**
 * Setting modes for the pfd map layout option.
 */
var PfdMapLayoutSettingMode;
(function (PfdMapLayoutSettingMode) {
    PfdMapLayoutSettingMode[PfdMapLayoutSettingMode["Off"] = 0] = "Off";
    PfdMapLayoutSettingMode[PfdMapLayoutSettingMode["Inset"] = 1] = "Inset";
    PfdMapLayoutSettingMode[PfdMapLayoutSettingMode["HSI"] = 2] = "HSI";
    PfdMapLayoutSettingMode[PfdMapLayoutSettingMode["TFC"] = 3] = "TFC";
})(PfdMapLayoutSettingMode || (PfdMapLayoutSettingMode = {}));
/**
 * Utility class for retrieving PFD user setting managers.
 */
class PFDUserSettings {
    /**
     * Retrieves a manager for map user settings.
     * @param bus The event bus.
     * @returns a manager for map user settings.
     */
    static getManager(bus) {
        var _a;
        return (_a = PFDUserSettings.INSTANCE) !== null && _a !== void 0 ? _a : (PFDUserSettings.INSTANCE = new DefaultUserSettingManager(bus, [
            {
                name: 'windOption',
                defaultValue: WindOverlaySettingMode.Off
            },
            {
                name: 'mapLayout',
                defaultValue: PfdMapLayoutSettingMode.Off
            },
            {
                name: 'svtToggle',
                defaultValue: true
            },
            {
                name: 'baroHpa',
                defaultValue: false
            },
            {
                name: 'svtHdgLabelToggle',
                defaultValue: true
            },
        ]));
    }
}

/**
 * The Map/HSI softkey menu.
 */
class MapHSILayoutMenu extends SoftKeyMenu {
    /**
     * Creates an instance of the Layout menu inside the Map/HSI menu.
     * @param menuSystem The menu system.
     */
    constructor(menuSystem) {
        super(menuSystem);
        this.addItem(0, 'Map Off', () => this.pressMapMode(PfdMapLayoutSettingMode.Off), false);
        this.addItem(1, 'Inset Map', () => this.pressMapMode(PfdMapLayoutSettingMode.Inset), false);
        this.addItem(2, 'HSI Map', () => this.pressMapMode(PfdMapLayoutSettingMode.HSI), false);
        this.addItem(3, 'TFC Map', () => this.pressMapMode(PfdMapLayoutSettingMode.TFC), false, true);
        this.addItem(7, 'WX LGND');
        this.addItem(10, 'Back', () => menuSystem.back());
        this.addItem(11, 'Alerts');
        PFDUserSettings.getManager(menuSystem.bus).whenSettingChanged('mapLayout').handle(this.onMapOptionSettingChanged.bind(this));
    }
    /**
     * Callback for when the map option setting changes.
     * @param mode the map option mode.
     */
    onMapOptionSettingChanged(mode) {
        for (let i = 0; i < 4; i++) {
            const item = this.getItem(i);
            item.value.set(i === mode);
        }
    }
    /**
     * Handles when a map mode button is pressed.
     * @param mode the mode to be set.
     */
    pressMapMode(mode) {
        PFDUserSettings.getManager(this.menuSystem.bus).getSetting('mapLayout').value = mode;
    }
}

/**
 * A system that manages the Garmin softkey menus.
 */
class MenuSystem {
    /**
     * Creates an instance of the MenuSystem.
     * @param bus The event bus to use with this instance.
     * @param hEventPrefix The event prefix to use for the softkey H Events.
     */
    constructor(bus, hEventPrefix) {
        this.bus = bus;
        /** The current menu stack. */
        this.menuStack = [new SoftKeyMenu(this)];
        /**The currently registered menus. */
        this.registeredMenus = {};
        this.subscriber = bus.getSubscriber();
        this.subscriber.on('hEvent').handle(hEvent => {
            if (hEvent.startsWith(hEventPrefix)) {
                this.handleSoftKey(hEvent);
            }
        });
        this.hEventPrefix = hEventPrefix;
    }
    /**
     * The current menu on the stack.
     * @returns The current menu.
     */
    get currentMenu() {
        return this.menuStack[this.menuStack.length - 1];
    }
    /**
     * Adds a menu to the menu system.
     * @param name The route to the menu to add this menu entry to.
     * @param entry The menu entry to add.
     */
    addMenu(name, entry) {
        this.registeredMenus[name] = entry;
    }
    /**
     * Pushes a menu onto the menu system stack.
     * @param name The name of the menu to push.
     */
    pushMenu(name) {
        this.menuStack.push(this.registeredMenus[name]);
        this.renderToSoftKeys();
    }
    /**
     * Replaces one menu with another on top of the stack.
     * @param name The name of the menu to activate.
     */
    replaceMenu(name) {
        if (this.menuStack.length > 1) {
            this.menuStack.pop();
        }
        this.menuStack.push(this.registeredMenus[name]);
        this.renderToSoftKeys();
    }
    /**
     * Pops a menu off the stack and returns to the previous menu.
     */
    back() {
        if (this.menuStack.length === 1) {
            // do not pop the base empty menu.
            return;
        }
        this.menuStack.pop();
        this.renderToSoftKeys();
    }
    /**
     * Clears the menu stack.
     */
    clear() {
        this.menuStack.length = 1;
        this.renderToSoftKeys();
    }
    /**
     * Attaches the softkeys display component to the menu system.
     * @param softKeys The softkeys display component instance.
     */
    attachSoftKeys(softKeys) {
        this.softKeys = softKeys;
        this.renderToSoftKeys();
    }
    /**
     * Renders the current menu to the softkeys.
     */
    renderToSoftKeys() {
        this.currentMenu.forEach((item, index) => {
            var _a;
            (_a = this.softKeys) === null || _a === void 0 ? void 0 : _a.setMenuItem(index, item);
        });
    }
    /**
     * Handles a softkey HEvent and delgates to the handler.
     * @param hEvent The HEvent to handle.
     */
    handleSoftKey(hEvent) {
        const softKeyIndex = parseInt(hEvent.replace(this.hEventPrefix, '')) - 1;
        this.currentMenu.handleItemPressed(softKeyIndex);
    }
}

/**
 * The PFD Opt softkey menu.
 */
class PFDOptMenu extends SoftKeyMenu {
    /**
     * Creates an instance of the PFD Opt softkey menu.
     * @param menuSystem The menu system.
     * @param publisher A publisher to use for sending control events
     * @param g1000Publisher A G1000 control publisher local to the PFD
     * @param bus is an event bus
     */
    constructor(menuSystem, publisher, g1000Publisher, bus) {
        super(menuSystem);
        this.dmeActive = false;
        this.stdBaroSet = false;
        this.bus = bus;
        this.addItem(0, 'SVT', () => menuSystem.pushMenu('svt'));
        this.addItem(2, 'Wind', () => menuSystem.pushMenu('wind'));
        this.addItem(3, 'DME', () => {
            this.dmeActive = !this.dmeActive;
            publisher.publishEvent('dme_toggle', this.dmeActive);
        });
        this.addItem(4, 'Bearing 1', () => { publisher.publishEvent('brg_src_switch', 1); });
        this.addItem(6, 'Bearing 2', () => { publisher.publishEvent('brg_src_switch', 2); });
        this.addItem(8, 'ALT Units', () => menuSystem.pushMenu('alt-units'));
        this.addItem(9, 'STD Baro', () => {
            //this.stdBaroSet = !this.stdBaroSet;
            g1000Publisher.publishEvent('std_baro_switch', !this.stdBaroSet);
            menuSystem.back();
        });
        this.addItem(10, 'Back', () => menuSystem.back());
        this.addItem(11, 'Alerts');
        this.init();
    }
    /**
     * Init the PFD Opt Menu to watch the baro std event and track the status.
     */
    init() {
        this.bus.getSubscriber().on('std_baro_switch')
            .handle(this.updateBaroStd.bind(this));
    }
    /**
     * Update the locally stored value for whether baro is set to standard when updated by either this menu or by adjusting the baro knob.
     * @param baroStd is whether the altimeter instrument is in std baro mode.
     */
    updateBaroStd(baroStd) {
        this.stdBaroSet = baroStd;
    }
}

/**
 * The PFD Opt softkey menu.
 */
class SVTMenu extends SoftKeyMenu {
    /**
     * Creates an instance of the PFD Opt SVT menu.
     * @param menuSystem The menu system.
     */
    constructor(menuSystem) {
        super(menuSystem);
        this.settingManager = PFDUserSettings.getManager(this.menuSystem.bus);
        this.addItem(0, 'Pathways');
        this.addItem(1, 'Terrain', () => { this.onSvtTogglePressed(); }, false);
        this.addItem(2, 'HDG LBL', () => { this.onHdgLblPressed(); }, false);
        this.addItem(3, 'APT Sign');
        this.addItem(10, 'Back', () => menuSystem.back());
        this.addItem(11, 'Alerts');
        this.settingManager.whenSettingChanged('svtToggle').handle(this.onSvtActiveChanged.bind(this));
        this.settingManager.whenSettingChanged('svtHdgLabelToggle').handle(this.onHdgLblActiveChanged.bind(this));
    }
    /**
     * Callback when the SVT setting is changed.
     * @param v true if SVT is active, false otherwise.
     */
    onSvtActiveChanged(v) {
        this.getItem(1).value.set(v);
    }
    /**
     * Callback when the Hdg label setting is changed.
     * @param v true if hdg label is active, false otherwise.
     */
    onHdgLblActiveChanged(v) {
        this.getItem(2).value.set(v);
    }
    /**
     * Callback when the SVT setting toggle is pressed.
     */
    onSvtTogglePressed() {
        this.settingManager.getSetting('svtToggle').value = !this.settingManager.getSetting('svtToggle').value;
    }
    /**
     * Callback when the SVT setting toggle is pressed.
     */
    onHdgLblPressed() {
        this.settingManager.getSetting('svtHdgLabelToggle').value = !this.settingManager.getSetting('svtHdgLabelToggle').value;
    }
}

/**
 * The PFD Opt wind menu.
 */
class WindMenu extends SoftKeyMenu {
    /**
     * Creates an instance of the PFD Opt Wind menu.
     * @param menuSystem The menu system.
     */
    constructor(menuSystem) {
        super(menuSystem);
        this.settingMap = new Map([
            [WindOverlaySettingMode.Off, 1],
            [WindOverlaySettingMode.Opt1, 2],
            [WindOverlaySettingMode.Opt2, 3],
            [WindOverlaySettingMode.Opt3, 4],
        ]);
        this.addItem(1, 'Off', () => {
            this.onWindOptionSelected(WindOverlaySettingMode.Off);
        }, false);
        this.addItem(2, 'Option 1', () => {
            this.onWindOptionSelected(WindOverlaySettingMode.Opt1);
        }, false);
        this.addItem(3, 'Option 2', () => {
            this.onWindOptionSelected(WindOverlaySettingMode.Opt2);
        }, false);
        this.addItem(4, 'Option 3', () => {
            this.onWindOptionSelected(WindOverlaySettingMode.Opt3);
        }, false);
        this.addItem(10, 'Back', () => menuSystem.back());
        this.addItem(11, 'Alerts');
        PFDUserSettings.getManager(menuSystem.bus).whenSettingChanged('windOption').handle(this.onWindOptionSettingChanged.bind(this));
    }
    /**
     * Callback when wind option setting changed.
     * @param mode the selected wind option
     */
    onWindOptionSettingChanged(mode) {
        const softkeyIndex = this.settingMap.get(mode);
        for (let i = 1; i < 5; i++) {
            const item = this.getItem(i);
            item.value.set(i === softkeyIndex);
        }
    }
    /**
     * Callback fired when a wind option is selected.
     * @param mode the selected wind option
     */
    onWindOptionSelected(mode) {
        PFDUserSettings.getManager(this.menuSystem.bus).getSetting('windOption').value = mode;
    }
}

/**
 * The PFD Opt ALT units menu.
 */
class ALTUnitsMenu extends SoftKeyMenu {
    /**
     * Creates an instance of the PFD Opt ALT units menu.
     * @param menuSystem The menu system.
     */
    constructor(menuSystem) {
        super(menuSystem);
        this.addItem(5, 'Meters', undefined, false);
        this.addItem(7, 'IN', () => {
            this.onBaroHpaSettingSelected(false);
        }, false);
        this.addItem(8, 'HPA', () => {
            this.onBaroHpaSettingSelected(true);
        }, false);
        this.addItem(10, 'Back', () => menuSystem.back());
        this.addItem(11, 'Alerts');
        PFDUserSettings.getManager(menuSystem.bus).whenSettingChanged('baroHpa').handle(this.onBaroHpaSettingChanged.bind(this));
    }
    /**
     * Callback fired when a baro unit option is selected.
     * @param isHpa true if HPA, false if IN.
     */
    onBaroHpaSettingSelected(isHpa) {
        PFDUserSettings.getManager(this.menuSystem.bus).getSetting('baroHpa').value = isHpa;
    }
    /**
     * Callback fired when a baro unit setting is changed.
     * @param isHpa true if HPA, false if IN.
     */
    onBaroHpaSettingChanged(isHpa) {
        this.getItem(7).value.set(!isHpa);
        this.getItem(8).value.set(isHpa);
    }
}

var APVerticalModes;
(function (APVerticalModes) {
    APVerticalModes[APVerticalModes["NONE"] = 0] = "NONE";
    APVerticalModes[APVerticalModes["PITCH"] = 1] = "PITCH";
    APVerticalModes[APVerticalModes["VS"] = 2] = "VS";
    APVerticalModes[APVerticalModes["FLC"] = 3] = "FLC";
    APVerticalModes[APVerticalModes["ALT"] = 4] = "ALT";
    APVerticalModes[APVerticalModes["VNAV"] = 5] = "VNAV";
    APVerticalModes[APVerticalModes["GP"] = 6] = "GP";
    APVerticalModes[APVerticalModes["GS"] = 7] = "GS";
    APVerticalModes[APVerticalModes["CAP"] = 8] = "CAP";
})(APVerticalModes || (APVerticalModes = {}));
var APLateralModes;
(function (APLateralModes) {
    APLateralModes[APLateralModes["NONE"] = 0] = "NONE";
    APLateralModes[APLateralModes["ROLL"] = 1] = "ROLL";
    APLateralModes[APLateralModes["LEVEL"] = 2] = "LEVEL";
    APLateralModes[APLateralModes["GPSS"] = 3] = "GPSS";
    APLateralModes[APLateralModes["HEADING"] = 4] = "HEADING";
    APLateralModes[APLateralModes["VOR"] = 5] = "VOR";
    APLateralModes[APLateralModes["LOC"] = 6] = "LOC";
    APLateralModes[APLateralModes["BC"] = 7] = "BC";
    APLateralModes[APLateralModes["NAV"] = 8] = "NAV";
})(APLateralModes || (APLateralModes = {}));
var APAltitudeModes;
(function (APAltitudeModes) {
    APAltitudeModes[APAltitudeModes["NONE"] = 0] = "NONE";
    APAltitudeModes[APAltitudeModes["ALTS"] = 1] = "ALTS";
    APAltitudeModes[APAltitudeModes["ALTV"] = 2] = "ALTV";
})(APAltitudeModes || (APAltitudeModes = {}));

/** AP Mode Types */
var APModeType;
(function (APModeType) {
    APModeType[APModeType["LATERAL"] = 0] = "LATERAL";
    APModeType[APModeType["VERTICAL"] = 1] = "VERTICAL";
    APModeType[APModeType["APPROACH"] = 2] = "APPROACH";
})(APModeType || (APModeType = {}));

var APStates;
(function (APStates) {
    APStates[APStates["None"] = 0] = "None";
    APStates[APStates["APActive"] = 1] = "APActive";
    APStates[APStates["YawDamper"] = 2] = "YawDamper";
    APStates[APStates["Heading"] = 4] = "Heading";
    APStates[APStates["Nav"] = 8] = "Nav";
    APStates[APStates["NavArmed"] = 16] = "NavArmed";
    APStates[APStates["Approach"] = 32] = "Approach";
    APStates[APStates["ApproachArmed"] = 64] = "ApproachArmed";
    APStates[APStates["Backcourse"] = 128] = "Backcourse";
    APStates[APStates["BackcourseArmed"] = 256] = "BackcourseArmed";
    APStates[APStates["Alt"] = 512] = "Alt";
    APStates[APStates["AltS"] = 1024] = "AltS";
    APStates[APStates["AltV"] = 2048] = "AltV";
    APStates[APStates["VS"] = 4096] = "VS";
    APStates[APStates["FLC"] = 8192] = "FLC";
    APStates[APStates["GP"] = 16384] = "GP";
    APStates[APStates["GPArmed"] = 32768] = "GPArmed";
    APStates[APStates["GS"] = 65536] = "GS";
    APStates[APStates["GSArmed"] = 131072] = "GSArmed";
    APStates[APStates["Path"] = 262144] = "Path";
    APStates[APStates["PathArmed"] = 524288] = "PathArmed";
    APStates[APStates["PathInvalid"] = 1048576] = "PathInvalid";
    APStates[APStates["Pitch"] = 2097152] = "Pitch";
    APStates[APStates["Roll"] = 4194304] = "Roll";
    APStates[APStates["VNAV"] = 8388608] = "VNAV";
    APStates[APStates["ATSpeed"] = 16777216] = "ATSpeed";
    APStates[APStates["ATMach"] = 33554432] = "ATMach";
    APStates[APStates["ATArmed"] = 67108864] = "ATArmed";
    APStates[APStates["FD"] = 134217728] = "FD";
})(APStates || (APStates = {}));

/**
 * The state of a given plane director.
 */
var DirectorState;
(function (DirectorState) {
    /** The plane director is not currently armed or active. */
    DirectorState["Inactive"] = "Inactive";
    /** The plane director is currently armed. */
    DirectorState["Armed"] = "Armed";
    /** The plane director is currently active. */
    DirectorState["Active"] = "Active";
})(DirectorState || (DirectorState = {}));

/**
 * The current vertical navigation mode.
 */
var VNavMode;
(function (VNavMode) {
    /** No vertical navigation mode is selected. */
    VNavMode[VNavMode["None"] = 0] = "None";
    /** VNAV is following the VNAV profile. */
    VNavMode[VNavMode["VNAV"] = 1] = "VNAV";
    /** VNAV is following an RNAV approach profile. */
    VNavMode[VNavMode["RNAV"] = 2] = "RNAV";
    /** VNAV is following ILS beacon guidance. */
    VNavMode[VNavMode["ILS"] = 3] = "ILS";
})(VNavMode || (VNavMode = {}));
/**
 * The current VNAV path mode.
 */
var VNavPathMode;
(function (VNavPathMode) {
    /** VNAV path is not active. */
    VNavPathMode[VNavPathMode["None"] = 0] = "None";
    /** VNAV path is armed for capture. */
    VNavPathMode[VNavPathMode["PathArmed"] = 1] = "PathArmed";
    /** VNAV path is actively navigating. */
    VNavPathMode[VNavPathMode["PathActive"] = 2] = "PathActive";
    /** The current VNAV path is not valid. */
    VNavPathMode[VNavPathMode["PathInvalid"] = 3] = "PathInvalid";
})(VNavPathMode || (VNavPathMode = {}));
/**
 * The current VNAV approach guidance mode.
 */
var VNavApproachGuidanceMode;
(function (VNavApproachGuidanceMode) {
    /** VNAV is not currently following approach guidance. */
    VNavApproachGuidanceMode[VNavApproachGuidanceMode["None"] = 0] = "None";
    /** VNAV has armed ILS glideslope guidance for capture. */
    VNavApproachGuidanceMode[VNavApproachGuidanceMode["GSArmed"] = 1] = "GSArmed";
    /** VNAV is actively following ILS glideslope guidance. */
    VNavApproachGuidanceMode[VNavApproachGuidanceMode["GSActive"] = 2] = "GSActive";
    /** VNAV RNAV glidepath guidance is armed for capture. */
    VNavApproachGuidanceMode[VNavApproachGuidanceMode["GPArmed"] = 3] = "GPArmed";
    /** VNAV is actively follow RNAV glidepath guidance. */
    VNavApproachGuidanceMode[VNavApproachGuidanceMode["GPActive"] = 4] = "GPActive";
})(VNavApproachGuidanceMode || (VNavApproachGuidanceMode = {}));
/**
 * The current VNAV altitude capture type.
 */
var VNavAltCaptureType;
(function (VNavAltCaptureType) {
    /** Altitude capture is not armed. */
    VNavAltCaptureType[VNavAltCaptureType["None"] = 0] = "None";
    /** Altitude will capture the selected altitude. */
    VNavAltCaptureType[VNavAltCaptureType["Selected"] = 1] = "Selected";
    /** Altitude will capture the VANV target altitude. */
    VNavAltCaptureType[VNavAltCaptureType["VNAV"] = 2] = "VNAV";
})(VNavAltCaptureType || (VNavAltCaptureType = {}));

var NavSensitivity;
(function (NavSensitivity) {
    NavSensitivity["DPRT"] = "DPRT";
    NavSensitivity["TERM"] = "TERM";
    NavSensitivity["ENR"] = "ENR";
    NavSensitivity["OCN"] = "OCN";
    NavSensitivity["LNAV"] = "LNAV+V";
    NavSensitivity["VIS"] = "VISUAL";
    NavSensitivity["LVNAV"] = "L/VNAV";
    NavSensitivity["LPV"] = "LPV";
    NavSensitivity["LP"] = "LP+V";
    NavSensitivity["MAPR"] = "MAPR";
    NavSensitivity["VOR"] = "VOR";
    NavSensitivity["ILS"] = "ILS";
})(NavSensitivity || (NavSensitivity = {}));
var ObsSuspModes;
(function (ObsSuspModes) {
    ObsSuspModes[ObsSuspModes["NONE"] = 0] = "NONE";
    ObsSuspModes[ObsSuspModes["SUSP"] = 1] = "SUSP";
    ObsSuspModes[ObsSuspModes["OBS"] = 2] = "OBS";
})(ObsSuspModes || (ObsSuspModes = {}));
var VNavDisplayMode;
(function (VNavDisplayMode) {
    VNavDisplayMode[VNavDisplayMode["NONE"] = 0] = "NONE";
    VNavDisplayMode[VNavDisplayMode["PATH"] = 1] = "PATH";
})(VNavDisplayMode || (VNavDisplayMode = {}));
var GPDisplayMode;
(function (GPDisplayMode) {
    GPDisplayMode[GPDisplayMode["NONE"] = 0] = "NONE";
    GPDisplayMode[GPDisplayMode["PREVIEW"] = 1] = "PREVIEW";
    GPDisplayMode[GPDisplayMode["ACTIVE"] = 2] = "ACTIVE";
})(GPDisplayMode || (GPDisplayMode = {}));
/**
 * Encapsulation of the logic for an nav source.
 */
class HsiSource {
    /**
     * Create an HSI Source
     * @param id The navsourceid.
     */
    constructor(id) {
        this.valid = false;
        this.bearing = null;
        this.distance = null;
        this.deviation = null;
        this.deviationScale = 1.0;
        this.deviationScaleLabel = null;
        this.toFrom = VorToFrom.OFF;
        this.dtk_obs = null;
        this.isLocalizer = false;
        this.hasSignal = false;
        this.hasLocalizer = false;
        this.localizerCourse = null;
        this.hasGlideslope = false;
        this.gsDeviation = null;
        this.altDeviation = null;
        this.hasDme = false;
        this.frequency = null;
        this.source = id;
        if (this.source.type === NavSourceType.Nav) {
            this.dtk_obs = 0;
        }
    }
}
/**
 * A NavIndicatorController to control what nav sources are being indicated on the panel.
 */
class NavIndicatorController {
    /**
     * Initialize an instance of the NavIndicatorController.
     * @param bus is the event bus
     * @param fms is the fms
     */
    constructor(bus, fms) {
        this.fms = fms;
        this.navStates = [];
        this.activeSensitivity = NavSensitivity.VOR;
        this.activeSourceIndex = 0;
        this.hsiMapActive = false;
        this.courseNeedleRefs = { hsiRose: undefined, hsiMap: undefined };
        this.hsiRefs = { hsiRose: undefined, hsiMap: undefined };
        this.hsiMapDeviationRef = undefined;
        this.vdi = undefined;
        this.bearingPointerStatus = [false, false];
        this.bearingPointerAdf = [false, false];
        this.bearingPointerDirection = [null, null];
        this.firstRun = true;
        this.obsSuspMode = ObsSuspModes.NONE;
        this.missedApproachActive = false;
        this.currentSpeed = 30;
        this.currentHeading = 0;
        this.currentAltitude = 0;
        this.currentVNavTodDistance = -1;
        this.currentVNavBodDistance = -1;
        this.vnavPathInRange = false;
        this.currentVNavTargetAltitude = -1;
        this.currentVNavConstraintAltitude = -1;
        this.currentVNavFpa = 0;
        this.currentVNavPathMode = VNavPathMode.None;
        this.vnavDisplayMode = Subject.create(VNavDisplayMode.NONE);
        this.gpDisplayMode = Subject.create(GPDisplayMode.NONE);
        this.currentVnavApproachMode = VNavApproachGuidanceMode.None;
        this.currentLpvDeviation = Number.POSITIVE_INFINITY;
        this.currentLpvDistance = Number.POSITIVE_INFINITY;
        this.dmeSourceIndex = Subject.create(0);
        this.dmeDistanceSubject = Subject.create(-1);
        this.isLnavCalculating = Subject.create(false);
        /**
         * A callback called when the CDI Source Changes.
         * @param source The current selected CDI Source.
         */
        this.onUpdateCdiSelect = (source) => {
            if (source.type !== this.navStates[this.activeSourceIndex].source.type
                || source.index !== this.navStates[this.activeSourceIndex].source.index) {
                switch (source.type) {
                    case NavSourceType.Nav:
                        if (source.index == 1) {
                            this.activeSourceIndex = 0;
                        }
                        else {
                            this.activeSourceIndex = 1;
                        }
                        if (this.navStates[this.activeSourceIndex].isLocalizer && this.navStates[this.activeSourceIndex].hasLocalizer) {
                            this.slewObs();
                        }
                        break;
                    case NavSourceType.Gps:
                        this.activeSourceIndex = 2;
                        break;
                }
                this.updateSensitivity();
                this.updateVNavDisplayMode();
            }
        };
        /**
         * A callback called when the obs updates from the event bus.
         * @param obs The current obs/dtk value.
         */
        this.onUpdateDtk = (obs) => {
            if (obs.source.type === NavSourceType.Nav) {
                switch (obs.source.index) {
                    case 1:
                        this.navStates[0].dtk_obs = obs.heading;
                        break;
                    case 2:
                        this.navStates[1].dtk_obs = obs.heading;
                        break;
                }
                this.updateComponentsData(obs.source);
            }
        };
        /**
         * A callback called when the lnav dtk updates from the event bus.
         * @param dtk The current lnav dtk value.
         */
        this.onUpdateLnavDtk = (dtk) => {
            if (!this.isLnavCalculating.get()) {
                this.navStates[2].dtk_obs = this.currentHeading;
            }
            else if (dtk !== this.navStates[2].dtk_obs) {
                this.navStates[2].dtk_obs = dtk;
            }
            if (this.activeSourceIndex == 2) {
                this.updateComponentsData();
            }
        };
        /**
         * A callback called when the lnav xtk updates from the event bus.
         * @param xtk The current lnav xtk value.
         */
        this.onUpdateLnavXtk = (xtk) => {
            // Check for both a full or direct to flight plan.
            if (!this.isLnavCalculating.get()) {
                if (this.navStates[2].toFrom !== VorToFrom.OFF) {
                    this.navStates[2].toFrom = VorToFrom.OFF;
                    this.updateComponentsDisplay(this.navStates[2].source);
                }
            }
            else if (this.navStates[2].deviation === null || -xtk !== (this.navStates[2].deviation * this.navStates[2].deviationScale)) {
                this.navStates[2].deviation = (-xtk / this.navStates[2].deviationScale);
                if (this.navStates[2].toFrom !== VorToFrom.TO) {
                    this.navStates[2].toFrom = VorToFrom.TO;
                    this.updateComponentsDisplay(this.navStates[2].source);
                }
            }
            if (this.activeSourceIndex == 2) {
                this.updateComponentsData();
            }
        };
        /**
         * A callback called when the bearing to an lnav fix updates across the event bus to set the to/from flag for GPS.
         * @param brg The current bearing to the current fix.
         */
        this.onUpdateLnavBrg = (brg) => {
            if (this.isLnavCalculating.get()) {
                const dtk = this.navStates[2].dtk_obs;
                if (dtk !== null && Math.abs(NavMath.diffAngle(brg, dtk)) > 120) {
                    this.navStates[2].toFrom = VorToFrom.FROM;
                }
                else {
                    this.navStates[2].toFrom = VorToFrom.TO;
                }
                this.updateComponentsDisplay(this.navStates[2].source);
            }
        };
        /**
         * A callback called when the cdi deviation updates from the event bus.
         * @param deviation The current deviation value.
         */
        this.onUpdateCdiDeviation = (deviation) => {
            if (deviation.source.type !== NavSourceType.Nav) {
                return;
            }
            switch (deviation.source.index) {
                case this.navStates[0].source.index:
                    this.navStates[0].deviation = deviation.deviation !== null ? deviation.deviation / 127 : -100;
                    break;
                case this.navStates[1].source.index:
                    this.navStates[1].deviation = deviation.deviation !== null ? deviation.deviation / 127 : -100;
                    break;
            }
            this.updateComponentsData(deviation.source);
        };
        /**
         * A callback called when the vor to/from updates from the event bus.
         * @param toFrom The current to/from value.
         */
        this.onUpdateToFrom = (toFrom) => {
            if (toFrom.source.type !== NavSourceType.Nav) {
                return;
            }
            switch (toFrom.source.index) {
                case this.navStates[0].source.index:
                    this.navStates[0].toFrom = toFrom.toFrom;
                    break;
                case this.navStates[1].source.index:
                    this.navStates[1].toFrom = toFrom.toFrom;
                    break;
            }
            this.updateComponentsDisplay(toFrom.source);
        };
        /**
         * A callback called when the dme updates from the event bus.
         * @param dme The current deviation value.
         */
        this.onUpdateDme = (dme) => {
            if (dme.source.type !== NavSourceType.Nav) {
                return;
            }
            switch (dme.source.index) {
                case this.navStates[0].source.index:
                    this.navStates[0].hasDme = dme.hasDme;
                    this.navStates[0].distance = dme.dmeDistance;
                    break;
                case this.navStates[1].source.index:
                    this.navStates[1].hasDme = dme.hasDme;
                    this.navStates[1].distance = dme.dmeDistance;
                    break;
            }
            const dmeSource = this.dmeSourceIndex.get();
            const dmeDistance = this.navStates[dmeSource].distance;
            if (this.navStates[dmeSource].hasDme && dmeDistance !== null && dmeDistance > 0) {
                this.dmeDistanceSubject.set(dmeDistance);
            }
            else {
                this.dmeDistanceSubject.set(-1);
            }
        };
        /**
         * A callback called when the localizer data updates from the event bus.
         * @param localizer The current localizer data.
         */
        this.onUpdateLocalizer = (localizer) => {
            if (localizer.source.type !== NavSourceType.Nav) {
                return;
            }
            switch (localizer.source.index) {
                case this.navStates[0].source.index:
                    this.navStates[0].hasLocalizer = localizer.isValid;
                    if (localizer.isValid) {
                        this.navStates[0].localizerCourse = localizer.course;
                    }
                    break;
                case this.navStates[1].source.index:
                    this.navStates[1].hasLocalizer = localizer.isValid;
                    if (localizer.isValid) {
                        this.navStates[1].localizerCourse = localizer.course;
                    }
                    break;
            }
            this.slewObs();
            this.updateSensitivity(localizer.source);
            this.updateVNavDisplayMode();
        };
        /**
         * A callback called when the glideslope data updates from the event bus.
         * @param glideslope The current glideslope data.
         */
        this.onUpdateGlideslope = (glideslope) => {
            var _a, _b;
            if (glideslope.source.type !== NavSourceType.Nav) {
                return;
            }
            switch (glideslope.source.index) {
                case this.navStates[0].source.index:
                    if (glideslope.isValid == this.navStates[0].hasGlideslope && glideslope.isValid) {
                        this.navStates[0].gsDeviation = glideslope.deviation;
                        (_a = this.vdi) === null || _a === void 0 ? void 0 : _a.updateDeviation();
                        return;
                    }
                    else {
                        this.navStates[0].hasGlideslope = glideslope.isValid;
                        if (glideslope.isValid) {
                            this.navStates[0].gsDeviation = glideslope.deviation;
                        }
                    }
                    break;
                case this.navStates[1].source.index:
                    if (glideslope.isValid == this.navStates[1].hasGlideslope && glideslope.isValid) {
                        this.navStates[1].gsDeviation = glideslope.deviation;
                        (_b = this.vdi) === null || _b === void 0 ? void 0 : _b.updateDeviation();
                        return;
                    }
                    else {
                        this.navStates[1].hasGlideslope = glideslope.isValid;
                        if (glideslope.isValid) {
                            this.navStates[1].gsDeviation = glideslope.deviation;
                        }
                    }
                    break;
            }
        };
        /**
         * A callback called when isLoc value updates from the event bus.
         * @param isLoc The current isLoc value.
         */
        this.onUpdateIsLocFreq = (isLoc) => {
            if (isLoc.source.type !== NavSourceType.Nav) {
                return;
            }
            switch (isLoc.source.index) {
                case this.navStates[0].source.index:
                    this.navStates[0].isLocalizer = isLoc.isLocalizer;
                    break;
                case this.navStates[1].source.index:
                    this.navStates[1].isLocalizer = isLoc.isLocalizer;
                    break;
            }
            this.updateComponentsDisplay(isLoc.source);
        };
        /**
         * Update the source of a bearing pointer.
         * @param data The new bearing source info.
         */
        this.updateBearingSrc = (data) => {
            var _a;
            if (((_a = data.source) === null || _a === void 0 ? void 0 : _a.type) === undefined) {
                this.bearingPointerStatus[data.index] = false;
                this.bearingPointerAdf[data.index] = false;
            }
            else if (data.source.type === NavSourceType.Adf) {
                this.bearingPointerStatus[data.index] = true;
                this.bearingPointerAdf[data.index] = true;
            }
            else {
                this.bearingPointerStatus[data.index] = true;
                this.bearingPointerAdf[data.index] = false;
            }
            if (this.bearingPointerDirection[data.index] !== null) {
                this.updateBearingDir({ index: data.index, direction: this.bearingPointerDirection[data.index] });
            }
            if (this.bearingPointerStatus[0] == true || this.bearingPointerStatus[1] == true) {
                this.hsiRefs.hsiRose.instance.compassRoseComponent.instance.setCircleVisible(true);
            }
            else {
                this.hsiRefs.hsiRose.instance.compassRoseComponent.instance.setCircleVisible(false);
            }
            this.updateBearingPointers(data.index, (element) => {
                if (element !== null && element.instance !== null && data.source) {
                    const source = data.source;
                    if (source.type !== NavSourceType.Nav && source.type !== NavSourceType.Gps && source.type !== NavSourceType.Adf) {
                        element.instance.style.display = 'none';
                        this.bearingPointerStatus[data.index] = false;
                    }
                    else if (source.type == NavSourceType.Nav && this.navStates[source.index - 1].isLocalizer) {
                        element.instance.style.display = 'none';
                    }
                    else {
                        element.instance.style.display = '';
                    }
                }
            });
        };
        /**
         * Update the validity of a bearing source.
         * @param data The validity event.
         */
        this.updateBearingValidity = (data) => {
            this.updateBearingPointers(data.index, (element) => {
                if (element !== null && element.instance !== null) {
                    if (data.valid) {
                        element.instance.style.display = '';
                    }
                    else {
                        element.instance.style.display = 'none';
                    }
                }
            });
        };
        /**
         * Update the heading of a bearing pointer.
         * @param data The BearingDirection message.
         */
        this.updateBearingDir = (data) => {
            let direction = data.direction;
            this.bearingPointerDirection[data.index] = direction;
            if (this.bearingPointerAdf[data.index] && data.direction !== null) {
                direction = NavMath.normalizeHeading(data.direction + this.currentHeading);
            }
            this.updateBearingPointers(data.index, (element) => {
                if (element !== null && element.instance !== null && direction !== null) {
                    const newDirection = Math.round(direction * 100) / 100;
                    element.instance.style.transform = `rotate3d(0, 0, 1, ${newDirection}deg)`;
                }
                else if (element !== null && element.instance !== null && direction == null) {
                    element.instance.style.display = 'none';
                }
            });
        };
        this.bus = bus;
        for (let i = 0; i < 3; i++) {
            const type = i < 2 ? NavSourceType.Nav : NavSourceType.Gps;
            const index = i == 1 ? 2 : 1;
            const sourceId = { type: type, index: index };
            const source = new HsiSource(sourceId);
            source.toFrom = VorToFrom.OFF;
            this.navStates.push(source);
        }
        this.monitorEvents();
    }
    /**
     * Method to monitor nav processor events to keep track of HSI-related data.
     */
    monitorEvents() {
        const g1000 = this.bus.getSubscriber();
        g1000.on('approach_details_set').handle(() => {
            this.updateSensitivity();
            this.onUpdateLpv(this.currentLpvDeviation, this.currentLpvDistance);
        });
        this.bus.getSubscriber().on('ground_speed').handle(speed => this.currentSpeed = speed);
        const adc = this.bus.getSubscriber();
        adc.on('hdg_deg').withPrecision(1).handle(hdg => this.currentHeading = hdg);
        adc.on('alt').atFrequency(1).handle(alt => this.currentAltitude = alt);
        const navcom = this.bus.getSubscriber();
        navcom.on('setFrequency').handle((setFrequency) => {
            if (setFrequency.radio.radioType === RadioType.Nav && setFrequency.bank == FrequencyBank.Active) {
                this.navStates[setFrequency.radio.index - 1].frequency = setFrequency.frequency;
            }
        });
        const nav = this.bus.getSubscriber();
        nav.on('cdi_select').handle(this.onUpdateCdiSelect);
        nav.on('obs_set').handle(this.onUpdateDtk);
        nav.on('cdi_deviation').handle(this.onUpdateCdiDeviation);
        nav.on('vor_to_from').handle(this.onUpdateToFrom);
        nav.on('localizer').handle(this.onUpdateLocalizer);
        nav.on('glideslope').handle(this.onUpdateGlideslope);
        nav.on('is_localizer_frequency').handle(this.onUpdateIsLocFreq);
        nav.on('brg_source').whenChanged().handle(this.updateBearingSrc);
        nav.on('brg_direction').handle(this.updateBearingDir);
        nav.on('dme_state').handle(this.onUpdateDme);
        nav.on('brg_validity').handle(this.updateBearingValidity);
        nav.on('gps_obs_active').handle(obsActive => {
            if (obsActive) {
                this.obsSuspMode = ObsSuspModes.OBS;
            }
            else {
                this.obsSuspMode = ObsSuspModes.NONE;
            }
            if (this.onUpdateDtkBox !== undefined) {
                this.onUpdateDtkBox();
            }
            this.updateSensitivity();
        });
        const lnavSimVars = this.bus.getSubscriber();
        lnavSimVars.on('lnavDtkMag').handle(this.onUpdateLnavDtk);
        lnavSimVars.on('lnavXtk').handle(this.onUpdateLnavXtk);
        lnavSimVars.on('lnavBrgMag').whenChangedBy(5).handle(this.onUpdateLnavBrg);
        lnavSimVars.on('lnavCdiScaling').handle(scale => {
            this.navStates[2].deviationScale = scale;
        });
        lnavSimVars.on('lnavCdiScalingLabel').handle(label => {
            this.navStates[2].deviationScaleLabel = label;
            this.updateSensitivity();
        });
        const lnavEvents = this.bus.getSubscriber();
        lnavEvents.on('suspChanged').handle(isSuspended => {
            if (isSuspended) {
                this.obsSuspMode = ObsSuspModes.SUSP;
            }
            else {
                this.obsSuspMode = ObsSuspModes.NONE;
            }
            this.updateSensitivity();
        });
        const vnav = this.bus.getSubscriber();
        vnav.on('vnavVDev').withPrecision(0).handle(deviation => this.onUpdateVnav(deviation));
        vnav.on('vnavLpvVDev').withPrecision(0).handle(deviation => this.onUpdateLpv(deviation, this.currentLpvDistance));
        vnav.on('vnavLpvDistance').withPrecision(0).handle(distance => this.onUpdateLpv(this.currentLpvDeviation, distance));
        vnav.on('vnavApproachMode').whenChanged().handle((mode) => {
            this.currentVnavApproachMode = mode;
            this.updateVNavDisplayMode();
        });
        vnav.on('vnavPathMode').handle(mode => {
            this.currentVNavPathMode = mode;
            this.updateVNavDisplayMode();
        });
        vnav.on('vnavTodDistance').atFrequency(1).handle(distance => {
            this.currentVNavTodDistance = distance;
        });
        vnav.on('vnavBodDistance').atFrequency(1).handle(distance => {
            this.currentVNavBodDistance = distance;
            this.checkIfVnavPathInRange();
        });
        vnav.on('vnavTargetAlt').handle(alt => {
            if (alt > 45000 || alt <= 0) {
                this.currentVNavTargetAltitude = -1;
            }
            else {
                this.currentVNavTargetAltitude = alt;
            }
            this.updateVNavDisplayMode();
        });
        vnav.on('vnavConstraintAltitude').whenChanged().handle(alt => {
            if (alt > 45000 || alt <= 0) {
                this.currentVNavConstraintAltitude = -1;
            }
            else {
                this.currentVNavConstraintAltitude = alt;
            }
            this.updateVNavDisplayMode();
        });
        vnav.on('vnavFpa').handle(fpa => {
            this.currentVNavFpa = fpa;
            this.updateVNavDisplayMode();
        });
        const fpl = this.bus.getSubscriber();
        fpl.on('fplLegChange').handle((e) => {
            if (e.planIndex === this.fms.flightPlanner.activePlanIndex) {
                this.onFplChange();
            }
        });
        fpl.on('fplIndexChanged').handle(() => this.onFplChange());
        fpl.on('fplLoaded').handle(() => this.onFplChange());
        this.dmeSourceIndex.sub((v) => {
            const dmeSource = v;
            const dmeDistance = this.navStates[dmeSource].distance;
            if (this.navStates[dmeSource].hasDme && dmeDistance !== null && dmeDistance > 0) {
                this.dmeDistanceSubject.set(dmeDistance);
            }
            else {
                this.dmeDistanceSubject.set(-1);
            }
        });
        this.isLnavCalculating.sub((v) => {
            if (!v) {
                this.onUpdateLnavXtk(0);
            }
            else {
                this.updateComponentsDisplay(this.navStates[2].source);
            }
        });
    }
    /**
     * A method to check if the VNAV Path is in a displayable range.
     */
    checkIfVnavPathInRange() {
        let vnavPathInRange = false;
        if (this.currentVNavBodDistance > 0
            && this.currentSpeed > 30
            && this.navStates[2].altDeviation !== null
            && this.currentVNavTargetAltitude > 0
            && this.currentVNavConstraintAltitude > 0
            && this.currentVNavConstraintAltitude < this.currentAltitude
            && Math.abs(this.currentVNavFpa) > 0) {
            const todNM = UnitType.METER.convertTo(this.currentVNavTodDistance, UnitType.NMILE);
            const bodNM = UnitType.METER.convertTo(this.currentVNavBodDistance, UnitType.NMILE);
            if (todNM < this.currentSpeed / 60 && bodNM > 0) {
                vnavPathInRange = true;
            }
        }
        if (vnavPathInRange !== this.vnavPathInRange) {
            this.vnavPathInRange = vnavPathInRange;
            this.updateVNavDisplayMode();
        }
    }
    /**
     * A method to update the VNAV Display Mode Subject.
     */
    updateVNavDisplayMode() {
        var _a;
        const activeSource = this.navStates[this.activeSourceIndex];
        let vnavMode = VNavDisplayMode.NONE;
        let gpMode = GPDisplayMode.NONE;
        if (this.currentVNavPathMode === VNavPathMode.PathActive) {
            vnavMode = VNavDisplayMode.PATH;
            if (activeSource.source.type === NavSourceType.Gps && activeSource.hasGlideslope && !this.missedApproachActive) {
                gpMode = GPDisplayMode.PREVIEW;
            }
        }
        else if (this.currentVnavApproachMode === VNavApproachGuidanceMode.GPActive) {
            vnavMode = VNavDisplayMode.NONE;
            gpMode = GPDisplayMode.ACTIVE;
        }
        else if (activeSource.source.type === NavSourceType.Gps) {
            if (this.vnavPathInRange) {
                vnavMode = VNavDisplayMode.PATH;
            }
            if (activeSource.hasGlideslope && !this.missedApproachActive) {
                switch (this.activeSensitivity) {
                    case NavSensitivity.VIS:
                    case NavSensitivity.LNAV:
                    case NavSensitivity.LP:
                    case NavSensitivity.LPV:
                    case NavSensitivity.LVNAV:
                        gpMode = GPDisplayMode.ACTIVE;
                        break;
                    default:
                        gpMode = GPDisplayMode.PREVIEW;
                }
            }
        }
        this.vnavDisplayMode.set(vnavMode);
        this.gpDisplayMode.set(gpMode);
        (_a = this.vdi) === null || _a === void 0 ? void 0 : _a.updateSourceSensitivity();
    }
    /**
     * A method called on flight plan changes to set whether lnav has a valid plan.
     */
    onFplChange() {
        const length = this.fms.flightPlanner.hasActiveFlightPlan() ? this.fms.flightPlanner.getActiveFlightPlan().length : 0;
        if (length < 2) {
            this.isLnavCalculating.set(false);
        }
        else {
            this.isLnavCalculating.set(true);
        }
    }
    /**
     * A method called from hsimap when the HSI format is changed.
     * @param hsiMap a bool set to true when the hsiMap should be displayed and false when the rose should be displayed.
     */
    onFormatChange(hsiMap) {
        switch (hsiMap) {
            case true:
                this.hsiMapActive = true;
                this.hsiRefs.hsiRose.instance.setVisible(false);
                this.hsiRefs.hsiMap.instance.setVisible(true);
                break;
            case false:
                this.hsiMapActive = false;
                this.hsiRefs.hsiMap.instance.setVisible(false);
                this.hsiRefs.hsiRose.instance.setVisible(true);
        }
        this.updateComponentsDisplay();
    }
    /**
     * A method to compare the incoming NavSourceId with the Active Nav Source.
     * @param source The current selected CDI Source.
     * @returns a bool of whether the incoming NavSourceId is the active nav source.
     */
    checkIfActive(source) {
        const type = source.type;
        const index = source.index;
        if (type === this.navStates[this.activeSourceIndex].source.type && index === this.navStates[this.activeSourceIndex].source.index) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * A callback called to update the nav sensitivity.
     * @param updatedSource is the source that was updated
     */
    updateSensitivity(updatedSource = undefined) {
        const update = updatedSource === undefined ? true : this.checkIfActive(updatedSource);
        if (update) {
            switch (this.navStates[this.activeSourceIndex].source.type) {
                case NavSourceType.Nav:
                    if (this.navStates[this.activeSourceIndex].isLocalizer) {
                        this.activeSensitivity = NavSensitivity.ILS;
                    }
                    else {
                        this.activeSensitivity = NavSensitivity.VOR;
                    }
                    break;
                case NavSourceType.Gps:
                    this.setGpsSensitivity();
                    break;
            }
            this.updateComponentsDisplay();
        }
    }
    /**
     * Sets the GPS nav sentitivity value.
     */
    setGpsSensitivity() {
        const nav = this.navStates[this.activeSourceIndex];
        let missedApproachActive = false;
        switch (nav.deviationScaleLabel) {
            case CDIScaleLabel.Departure:
                this.activeSensitivity = NavSensitivity.DPRT;
                break;
            case CDIScaleLabel.Terminal:
                this.activeSensitivity = NavSensitivity.TERM;
                break;
            case CDIScaleLabel.LNav:
            case CDIScaleLabel.LNavPlusV:
                this.activeSensitivity = NavSensitivity.LNAV;
                break;
            case CDIScaleLabel.LNavVNav:
                this.activeSensitivity = NavSensitivity.LVNAV;
                break;
            case CDIScaleLabel.LP:
            case CDIScaleLabel.LPPlusV:
                this.activeSensitivity = NavSensitivity.LP;
                break;
            case CDIScaleLabel.LPV:
                this.activeSensitivity = NavSensitivity.LPV;
                break;
            case CDIScaleLabel.Visual:
                this.activeSensitivity = NavSensitivity.VIS;
                break;
            case CDIScaleLabel.MissedApproach:
                this.activeSensitivity = NavSensitivity.MAPR;
                missedApproachActive = true;
                break;
            default:
                this.activeSensitivity = NavSensitivity.ENR;
        }
        if (missedApproachActive !== this.missedApproachActive) {
            this.missedApproachActive = missedApproachActive;
        }
    }
    /**
     * A callback called when the LPV data is updated.
     * @param deviation The LPV vertical deviation.
     * @param distance The LPV lateral distance.
     */
    onUpdateLpv(deviation, distance) {
        var _a;
        this.currentLpvDeviation = deviation;
        const hasGlideslope = this.navStates[2].hasGlideslope;
        if (distance !== this.currentLpvDistance) {
            this.currentLpvDistance = distance;
            const approachType = this.fms.approachDetails.approachType;
            if (this.fms.approachDetails.approachIsActive && Math.abs(distance) < 30000 &&
                (approachType === ApproachType.APPROACH_TYPE_GPS || approachType === ApproachType.APPROACH_TYPE_RNAV || approachType === AdditionalApproachType.APPROACH_TYPE_VISUAL)) {
                if (!hasGlideslope) {
                    this.navStates[2].hasGlideslope = true;
                    this.updateVNavDisplayMode();
                }
            }
            else if (hasGlideslope) {
                this.navStates[2].hasGlideslope = false;
                this.updateVNavDisplayMode();
            }
        }
        else if (distance <= 0 && hasGlideslope) {
            this.navStates[2].hasGlideslope = false;
            this.updateVNavDisplayMode();
        }
        if (isFinite(deviation) && isFinite(distance) && this.navStates[2].hasGlideslope) {
            const scale = Math.tan(UnitType.DEGREE.convertTo(2.0, UnitType.RADIAN)) * distance;
            const scaleClamped = NavMath.clamp(scale, 200, 1000) * -1;
            this.navStates[2].gsDeviation = deviation / scaleClamped;
            (_a = this.vdi) === null || _a === void 0 ? void 0 : _a.updateDeviation();
        }
    }
    /**
     * A callback called when the VNAV data is updated.
     * @param deviation The vnav vertical deviation.
     */
    onUpdateVnav(deviation) {
        var _a;
        this.navStates[2].altDeviation = deviation / -750;
        (_a = this.vdi) === null || _a === void 0 ? void 0 : _a.updateDeviation();
    }
    /**
     * A callback called to slew the obs to the ILS inbound course when an loc becomes valid.
     */
    slewObs() {
        const course = this.navStates[this.activeSourceIndex].localizerCourse;
        if (this.activeSourceIndex < 2 && this.navStates[this.activeSourceIndex].isLocalizer &&
            this.navStates[this.activeSourceIndex].hasLocalizer && course !== null) {
            SimVar.SetSimVarValue(`K:VOR${this.activeSourceIndex + 1}_SET`, 'number', Math.round(course));
        }
    }
    /**
     * A method called when xtk/dtk data updates.
     * @param updatedSource is the source that was updated
     */
    updateComponentsData(updatedSource = undefined) {
        const update = updatedSource === undefined ? true : this.checkIfActive(updatedSource);
        if (update || this.firstRun) {
            if (this.onUpdateDtkBox !== undefined) {
                this.onUpdateDtkBox();
            }
            if (this.hsiMapActive) {
                this.courseNeedleRefs.hsiMap.instance.updateData();
                this.hsiMapDeviationRef.instance.updateData();
            }
            else {
                this.courseNeedleRefs.hsiRose.instance.updateData();
            }
            if (this.firstRun) {
                this.firstRun = false;
            }
        }
    }
    /**
     * A method called when any value updates that needs to trigger a component update.
     * @param updatedSource is the source that was updated
     */
    updateComponentsDisplay(updatedSource = undefined) {
        const update = updatedSource === undefined ? true : this.checkIfActive(updatedSource);
        if (update || this.firstRun) {
            if (this.hsiMapActive) {
                this.courseNeedleRefs.hsiMap.instance.updateSourceSensitivity();
                this.hsiMapDeviationRef.instance.updateSourceSensitivity();
            }
            else {
                this.courseNeedleRefs.hsiRose.instance.updateSourceSensitivity();
                this.hsiRefs.hsiRose.instance.updateSourceSensitivity();
            }
            this.updateComponentsData(updatedSource);
        }
    }
    /**
     * Utility function to update a given bearing pointer in both the rose and map.
     * @param index The index of the bearing pointer to update.
     * @param func A function to execute on the pointer instances.
     */
    updateBearingPointers(index, func) {
        const elements = [
            index === 0 ? this.hsiRefs.hsiRose.instance.bearingPointer1Element :
                index === 1 ? this.hsiRefs.hsiRose.instance.bearingPointer2Element : null,
            index === 0 ? this.hsiRefs.hsiMap.instance.bearingPointer1Element :
                index === 1 ? this.hsiRefs.hsiMap.instance.bearingPointer2Element : null
        ];
        for (const element of elements) {
            func(element);
        }
    }
}

/**
 * The root PFD softkey menu.
 */
class RootMenu extends SoftKeyMenu {
    /**
     * Creates an instance of the root PFD softkey menu.
     * @param menuSystem The menu system.
     * @param controlPublisher A ControlPublisher for command events.
     * @param g1000Publisher A publisher for G1000-specific command events.
     * @param bus The event bus to use.
     */
    constructor(menuSystem, controlPublisher, g1000Publisher, bus) {
        super(menuSystem);
        this.obsMode = ObsSuspModes.NONE;
        this.obsAvailable = false;
        this.obsButtonDisabled = true;
        this.obsLabel = ComputedSubject.create(ObsSuspModes.NONE, (v) => {
            return v === ObsSuspModes.SUSP ? 'SUSP' : 'OBS';
        });
        this.obsButtonValue = ComputedSubject.create(ObsSuspModes.NONE, (v) => {
            return v === ObsSuspModes.NONE ? false : true;
        });
        const obsButtonPressed = () => {
            if (this.obsMode === ObsSuspModes.SUSP) {
                g1000Publisher.publishEvent('suspend', false);
            }
            else if (this.obsMode === ObsSuspModes.OBS || this.obsAvailable) {
                SimVar.SetSimVarValue('K:GPS_OBS', 'number', 0);
            }
        };
        this.addItem(1, 'Map/HSI', () => menuSystem.pushMenu('map-hsi'));
        this.addItem(2, 'TFC Map');
        this.addItem(3, 'PFD Opt', () => menuSystem.pushMenu('pfd-opt'));
        this.addItem(4, this.obsLabel.get(), () => obsButtonPressed(), this.obsButtonValue.get(), this.obsButtonDisabled);
        this.addItem(5, 'CDI', () => { controlPublisher.publishEvent('cdi_src_switch', true); });
        this.addItem(6, 'ADF/DME', () => {
            g1000Publisher.publishEvent('pfd_dme_push', true);
        });
        this.addItem(7, 'XPDR', () => menuSystem.pushMenu('xpdr'));
        this.addItem(8, 'Ident', () => {
            controlPublisher.publishEvent('xpdr_send_ident', true);
        });
        this.addItem(9, 'Tmr/Ref', () => {
            g1000Publisher.publishEvent('pfd_timerref_push', true);
        });
        this.addItem(10, 'Nearest', () => {
            g1000Publisher.publishEvent('pfd_nearest_push', true);
        });
        this.addItem(11, 'Alerts', () => {
            g1000Publisher.publishEvent('pfd_alert_push', true);
        }, undefined, true);
        const obsMenuItemHandler = () => {
            this.obsLabel.set(this.obsMode);
            this.obsButtonValue.set(this.obsMode);
            if (this.obsMode === ObsSuspModes.NONE && !this.obsAvailable) {
                this.obsButtonDisabled = true;
            }
            else {
                this.obsButtonDisabled = false;
            }
            const item = this.getItem(4);
            item.disabled.set(this.obsButtonDisabled);
            item.label.set(this.obsLabel.get());
            item.value.set(this.obsButtonValue.get());
        };
        bus.getSubscriber().on('gps_obs_active').whenChanged().handle(obsActive => {
            this.obsMode = obsActive ? ObsSuspModes.OBS : ObsSuspModes.NONE;
            obsMenuItemHandler();
        });
        bus.getSubscriber().on('suspChanged').whenChanged().handle(isSuspended => {
            if (this.obsMode === ObsSuspModes.OBS && !isSuspended) {
                SimVar.SetSimVarValue('K:GPS_OBS', 'number', 0);
            }
            this.obsMode = isSuspended ? ObsSuspModes.SUSP : ObsSuspModes.NONE;
            obsMenuItemHandler();
        });
        bus.getSubscriber().on('obs_available').whenChanged().handle(v => {
            this.obsAvailable = v;
            obsMenuItemHandler();
        });
    }
}

/**
 * The XPDR softkey menu.
 */
class XPDRMenu extends SoftKeyMenu {
    /**
     * Creates an instance of the XPDR PFD softkey menu.
     * @param menuSystem the menu system
     * @param controlPublisher is the instance of the control publisher
     * @param g1000Publisher the G1000 control events publisher
     * @param bus the event bus
     */
    constructor(menuSystem, controlPublisher, g1000Publisher, bus) {
        super(menuSystem);
        this.xpdrMode = Subject.create(XPDRMode.OFF);
        this.isVfr = Subject.create(false);
        this.modeToIndex = new Map([
            [XPDRMode.STBY, 2],
            [XPDRMode.ON, 3],
            [XPDRMode.ALT, 4]
        ]);
        this.addItem(2, 'Standby', () => {
            controlPublisher.publishEvent('publish_xpdr_mode', XPDRMode.STBY);
        }, this.xpdrMode.get() === XPDRMode.STBY);
        this.addItem(3, 'On', () => {
            controlPublisher.publishEvent('publish_xpdr_mode', XPDRMode.ON);
        }, this.xpdrMode.get() === XPDRMode.ON);
        this.addItem(4, 'Alt', () => {
            controlPublisher.publishEvent('publish_xpdr_mode', XPDRMode.ALT);
        }, this.xpdrMode.get() === XPDRMode.ALT);
        this.addItem(6, 'VFR', () => {
            controlPublisher.publishEvent('publish_xpdr_code', 1200);
        }, this.isVfr.get());
        this.addItem(7, 'Code', () => {
            menuSystem.pushMenu('xpdr-code');
            g1000Publisher.publishEvent('xpdr_code_push', true);
        }, false);
        this.addItem(8, 'Ident', () => {
            controlPublisher.publishEvent('xpdr_send_ident', true);
            menuSystem.back();
        });
        this.addItem(10, 'Back', () => menuSystem.back());
        this.addItem(11, 'Alerts');
        const xpdrSub = bus.getSubscriber();
        // this.xpdrMode.set(xpdrInstr.getXpdrMode());
        this.xpdrMode.sub(this.onXpdrModeChanged.bind(this));
        xpdrSub.on('xpdrMode1').handle((mode) => {
            this.xpdrMode.set(mode);
        });
        // this.isVfr.set(xpdrInstr.getXpdrCode() === 1200);
        this.isVfr.sub(this.onIsVfrChanged.bind(this));
        xpdrSub.on('xpdrCode1').handle((code) => {
            this.isVfr.set(code === 1200);
        });
    }
    /**
     * Callback when the isVfr indication is changed
     * @param v the new isVfr indication
     */
    onIsVfrChanged(v) {
        this.getItem(6).value.set(v);
    }
    /**
     * Callback when the xpdr mode is changed
     * @param v the new xpdr mode
     */
    onXpdrModeChanged(v) {
        this.modeToIndex.forEach((index, mode) => {
            this.getItem(index).value.set(mode === v);
        });
    }
}

/**
 * The XPDR softkey menu.
 */
class XPDRCodeMenu extends SoftKeyMenu {
    /**
     * Creates an instance of the transponder code menu.
     * @param menuSystem The menu system.
     * @param bus is the event bus
     * @param g1000Publisher the G1000 control events publisher
     */
    constructor(menuSystem, bus, g1000Publisher) {
        super(menuSystem);
        this.addItem(0, '0', () => {
            g1000Publisher.publishEvent('xpdr_code_digit', 0);
        });
        this.addItem(1, '1', () => {
            g1000Publisher.publishEvent('xpdr_code_digit', 1);
        });
        this.addItem(2, '2', () => {
            g1000Publisher.publishEvent('xpdr_code_digit', 2);
        });
        this.addItem(3, '3', () => {
            g1000Publisher.publishEvent('xpdr_code_digit', 3);
        });
        this.addItem(4, '4', () => {
            g1000Publisher.publishEvent('xpdr_code_digit', 4);
        });
        this.addItem(5, '5', () => {
            g1000Publisher.publishEvent('xpdr_code_digit', 5);
        });
        this.addItem(6, '6', () => {
            g1000Publisher.publishEvent('xpdr_code_digit', 6);
        });
        this.addItem(7, '7', () => {
            g1000Publisher.publishEvent('xpdr_code_digit', 7);
        });
        this.addItem(8, 'Ident');
        this.addItem(9, 'BKSP', () => {
            g1000Publisher.publishEvent('xpdr_code_digit', -1);
        });
        this.addItem(10, 'Back', () => {
            g1000Publisher.publishEvent('xpdr_code_push', false);
            menuSystem.back();
        });
        this.addItem(11, 'Alerts');
        this.onNewCodeFromSim(bus, menuSystem);
    }
    /**
     * Method to close menu when a new code is published from the xpdr component.
     * @param bus is the event bus
     * @param menuSystem The menu system.
     */
    onNewCodeFromSim(bus, menuSystem) {
        const controlPublisher = bus.getSubscriber();
        controlPublisher.on('publish_xpdr_code').handle(() => {
            menuSystem.back();
        });
    }
}

/**
 * A softkey tab in the soft key bar interface.
 */
class SoftKey extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.menuItem = SoftKeyMenu.EmptyMenuItem;
        this.rootEl = new NodeReference();
        this.labelEl = new NodeReference();
        this.indicatorEl = new NodeReference();
        this.valueEl = new NodeReference();
        /**
         * Menu item value changed handler.
         * @param v the new value
         */
        this.menuItemValueChangedHandler = (v) => {
            if (typeof v === 'string') {
                this.showIndicator(false);
                this.indicate(false);
                this.valueEl.instance.style.display = '';
                this.valueEl.instance.textContent = v;
                this.labelEl.instance.classList.add('text-value');
            }
            else if (typeof v === 'boolean') {
                this.showIndicator(true);
                this.valueEl.instance.style.display = 'none';
                this.labelEl.instance.classList.remove('text-value');
                this.valueEl.instance.textContent = '';
                this.indicate(v);
            }
            else {
                this.showIndicator(false);
                this.valueEl.instance.textContent = '';
                this.valueEl.instance.style.display = 'none';
                this.labelEl.instance.classList.remove('text-value');
            }
        };
        /**
         * Sets the css class to make the soft key look disabled.
         * @param isDisabled Whether or not the soft key is disabled.
         */
        this.setDisabled = (isDisabled) => {
            if (isDisabled) {
                this.rootEl.instance.classList.add('text-disabled');
            }
            else {
                this.rootEl.instance.classList.remove('text-disabled');
            }
        };
        /**
         * Sets the text of this soft key.
         * @param text the text
         */
        this.setLabel = (text) => {
            this.labelEl.instance.textContent = text;
        };
    }
    /** @inheritdoc */
    onAfterRender() {
        super.onAfterRender();
        this.setMenuItem(this.props.menuItem);
    }
    /**
     * Sets and binds a menu item to this soft key.
     * @param item the menu item
     */
    setMenuItem(item) {
        // remove former subs
        this.unsubscribeFromMenuItem(this.menuItem);
        this.menuItem = item;
        const value = item.value.get();
        this.menuItemValueChangedHandler(value);
        item.value.sub(this.menuItemValueChangedHandler);
        this.setDisabled(item.disabled.get() === true);
        item.disabled.sub(this.setDisabled);
        this.setLabel(item.label.get());
        item.label.sub(this.setLabel);
    }
    /**
     * Unsubscribes from change events on the menu item.
     * @param item the menu item
     */
    unsubscribeFromMenuItem(item) {
        item.value.unsub(this.menuItemValueChangedHandler);
        item.disabled.unsub(this.setDisabled);
        item.label.unsub(this.setLabel);
    }
    /**
     * Shows or hides the active/inactive indicator.
     * @param isShown Whether or not the indicator is shown.
     */
    showIndicator(isShown) {
        if (isShown) {
            this.indicatorEl.instance.classList.add('shown');
        }
        else {
            this.indicatorEl.instance.classList.remove('shown');
        }
    }
    /**
     * Activates or inactivates the indicator.
     * @param isIndicating Whether or not the indicator is indicating.
     */
    indicate(isIndicating) {
        if (isIndicating) {
            this.showIndicator(true);
            this.indicatorEl.instance.classList.add('indicating');
        }
        else {
            this.indicatorEl.instance.classList.remove('indicating');
        }
    }
    /**
     * Renders the component.
     * @returns The rendered component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: 'softkey-tab', ref: this.rootEl },
            FSComponent.buildComponent("div", { class: 'softkey-tab-borders' }),
            FSComponent.buildComponent("label", { class: 'softkey-tab-label', ref: this.labelEl }),
            FSComponent.buildComponent("span", { class: 'softkey-tab-value', ref: this.valueEl, style: 'display: none' }),
            FSComponent.buildComponent("div", { class: 'softkey-tab-indicator', ref: this.indicatorEl })));
    }
}

/**
 * The Garmin softkeys tab display for the PFD and MFD.
 */
class SoftKeyBar extends DisplayComponent {
    /**
     * Creates an instance of SoftKeys.
     * @param props The properties to use.
     */
    constructor(props) {
        super(props);
        /** References to the softkey div nodes. */
        this.refs = [];
        this.menuSystem = this.props.menuSystem;
    }
    /**
     * Builds the softkeys tab elements.
     * @returns A collection of soft key div elements.
     */
    buildSoftKeys() {
        const softKeys = [];
        for (let i = 0; i < 12; i++) {
            const ref = FSComponent.createRef();
            softKeys.push(FSComponent.buildComponent(SoftKey, { ref: ref, menuItem: SoftKeyMenu.EmptyMenuItem }));
            this.refs[i] = ref;
        }
        return softKeys;
    }
    /**
     * Starts the softkey HEvent listener after render.
     */
    onAfterRender() {
        this.menuSystem.attachSoftKeys(this);
    }
    /**
     * Binds a menu item to a soft key.
     * @param index  the index of the softkey
     * @param menuItem the menu item to set
     */
    setMenuItem(index, menuItem) {
        this.refs[index].instance.setMenuItem(menuItem);
    }
    /**
     * Renders the component.
     * @returns The rendered component.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: 'softkeys-container' }, this.buildSoftKeys()));
    }
}

/**
 * A Vspeed type.
 */
var VSpeedType;
(function (VSpeedType) {
    VSpeedType[VSpeedType["Vx"] = 0] = "Vx";
    VSpeedType[VSpeedType["Vy"] = 1] = "Vy";
    VSpeedType[VSpeedType["Vglide"] = 2] = "Vglide";
    VSpeedType[VSpeedType["Vapp"] = 3] = "Vapp";
    VSpeedType[VSpeedType["Vr"] = 4] = "Vr";
})(VSpeedType || (VSpeedType = {}));
var SpeedWarning;
(function (SpeedWarning) {
    SpeedWarning[SpeedWarning["None"] = 0] = "None";
    SpeedWarning[SpeedWarning["Caution"] = 1] = "Caution";
    SpeedWarning[SpeedWarning["Overspeed"] = 2] = "Overspeed";
})(SpeedWarning || (SpeedWarning = {}));
/**
 * The PFD airspeed indicator with speed tape.
 */
class AirspeedIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.airspeedHundredsDataElement = FSComponent.createRef();
        this.airspeedTensDataElement = FSComponent.createRef();
        this.airspeedOnesDataElement = FSComponent.createRef();
        this.airspeedTapeTickElement = FSComponent.createRef();
        this.airspeedBoxElement = FSComponent.createRef();
        this.airspeedTrendVector = FSComponent.createRef();
        this.currentDrawnIas = 0;
        this.ias = 0;
        this.currentTrend = 0;
        this.iasScrollerValues = [];
        this.tasElement = FSComponent.createRef();
        this.speedRangeValues = {
            barber: FSComponent.createRef(),
            yellow: FSComponent.createRef(),
            green: FSComponent.createRef(),
            greenWhite: FSComponent.createRef(),
            white: FSComponent.createRef(),
            red: FSComponent.createRef()
        };
        this.vxSpeedRef = FSComponent.createRef();
        this.vySpeedRef = FSComponent.createRef();
        this.vgSpeedRef = FSComponent.createRef();
        this.vrSpeedRef = FSComponent.createRef();
        this.vappSpeedRef = FSComponent.createRef();
        this.vSpeedBackgroundRef = FSComponent.createRef();
        this.vSpeedContainerRef = FSComponent.createRef();
        this.flcBugRef = FSComponent.createRef();
        this.flcBoxRef = FSComponent.createRef();
        this.flcSubject = Subject.create('- - - ');
        this.stallDirty = Simplane.getDesignSpeeds().VS0;
        this.stallClean = Simplane.getDesignSpeeds().VS1;
        this.flapsExtend = Simplane.getDesignSpeeds().VFe;
        this.yellowSpeed = Simplane.getDesignSpeeds().VNo;
        this.barberSpeed = Simplane.getDesignSpeeds().VNe;
        this.flcSpeed = 0;
        this.vSpeeds = [
            { type: VSpeedType.Vx, value: Simplane.getDesignSpeeds().Vx, modified: Subject.create(false), display: true },
            { type: VSpeedType.Vy, value: Simplane.getDesignSpeeds().Vy, modified: Subject.create(false), display: true },
            { type: VSpeedType.Vr, value: Simplane.getDesignSpeeds().Vr, modified: Subject.create(false), display: true },
            { type: VSpeedType.Vglide, value: Simplane.getDesignSpeeds().BestGlide, modified: Subject.create(false), display: true },
            { type: VSpeedType.Vapp, value: Simplane.getDesignSpeeds().Vapp, modified: Subject.create(false), display: false }
        ];
        this.vSpeedSubjects = [
            Subject.create('0'),
            Subject.create('0'),
            Subject.create('0'),
            Subject.create('0'),
            Subject.create('0')
        ];
        this.speedWarningSubject = Subject.create(SpeedWarning.None);
        /**
         * A method called when a flc speed value changes.
         * @param speed The flc ias speed value.
         */
        this.setFlcBug = (speed) => {
            this.flcSpeed = Math.round(speed);
            this.flcSubject.set(`${this.flcSpeed}`);
            this.updateFlcBug();
        };
        /**
         * A method called to update the location of the FLC Bug on the tape.
         * @param mode The enum of the ap mode
         */
        this.toggleFlcElements = (mode) => {
            switch (mode) {
                case APLockType.Flc:
                    this.flcBugRef.instance.style.display = '';
                    this.flcBoxRef.instance.style.display = '';
                    break;
                case APLockType.Pitch:
                case APLockType.Vs:
                case APLockType.Alt:
                case APLockType.Glideslope:
                    this.flcBugRef.instance.style.display = 'none';
                    this.flcBoxRef.instance.style.display = 'none';
                    break;
            }
        };
        /**
         * A method called when a vspeed update event from the event bus is received.
         * @param vSpeed The vSpeed object to change.
         */
        this.setVSpeed = (vSpeed) => {
            const index = this.vSpeeds.findIndex((type) => {
                if (type.type === vSpeed.type) {
                    return true;
                }
            });
            this.vSpeeds[index].value = vSpeed.value;
            this.vSpeedSubjects[index].set(`${vSpeed.value}`);
            this.updateSpeedBugs(this.ias);
        };
        /**
         * A method called when a vspeed display event from the event bus is received.
         * @param vSpeed The vSpeed object to change.
         */
        this.setVSpeedVisibility = (vSpeed) => {
            const index = this.vSpeeds.findIndex((speed) => {
                if (speed.type === vSpeed.type) {
                    return true;
                }
            });
            this.vSpeeds[index].display = vSpeed.display === undefined ? false : vSpeed.display;
            /**
             * Handle updating visibility for each element.
             * @param speed instance to update
             */
            const setVisibility = (speed) => {
                const instance = speed.type === VSpeedType.Vx ? this.vxSpeedRef.instance :
                    speed.type === VSpeedType.Vy ? this.vySpeedRef.instance :
                        speed.type === VSpeedType.Vr ? this.vrSpeedRef.instance :
                            speed.type === VSpeedType.Vglide ? this.vgSpeedRef.instance : undefined;
                // speed.type === VSpeedType.Vapp ? this.vappSpeedRef.instance : undefined;
                if (instance !== null && instance !== undefined) {
                    instance.style.display = speed.display ? '' : 'none';
                }
            };
            this.vSpeeds.forEach(setVisibility);
            this.updateSpeedBugs(this.ias);
        };
        /**
         * A callback called when the IAS updates from the event bus.
         * @param ias The current IAS value.
         */
        this.onUpdateIAS = (ias) => {
            this.updateTrendVector(ias);
            if (ias <= this.barberSpeed) {
                this.speedWarningSubject.set(this.isSpeedTrendInOverspeed(ias) ? SpeedWarning.Caution : SpeedWarning.None);
            }
            else {
                this.speedWarningSubject.set(SpeedWarning.Overspeed);
            }
            this.ias = ias;
            const ones = ias % 10;
            const tens = (ias % 100 - ones) / 10;
            const hundreds = (ias - tens * 10 - ones) / 100;
            if (this.airspeedHundredsDataElement.instance !== null) {
                let newTranslation = -300 + (hundreds * 30);
                if (tens === 9 && ones > 9) {
                    newTranslation -= ((10 - ones) * 30) - 30;
                }
                if (ias < 20) {
                    newTranslation = -420;
                }
                this.airspeedHundredsDataElement.instance.setAttribute('transform', `translate(0,${newTranslation})`);
            }
            if (this.airspeedTensDataElement.instance !== null) {
                let newTranslation = -300 + (tens * 30);
                if (ones > 9) {
                    newTranslation -= ((10 - ones) * 30) - 30;
                }
                if (ias < 20) {
                    newTranslation = -420;
                }
                this.airspeedTensDataElement.instance.setAttribute('transform', `translate(0,${newTranslation})`);
            }
            if (this.airspeedOnesDataElement.instance !== null) {
                let newTranslation = -300 + (ones * 30);
                if (ias < 20) {
                    newTranslation = -420;
                }
                this.airspeedOnesDataElement.instance.setAttribute('transform', `translate(0,${newTranslation})`);
            }
            if (this.airspeedTapeTickElement.instance !== null) {
                let newTranslation = 10 * ((ias % 10));
                if (ias < 20) {
                    newTranslation = -400;
                }
                else if (ias < 50) {
                    newTranslation = -400 + (10 * (ias - 20));
                }
                this.airspeedTapeTickElement.instance.style.transform = `translate3d(0px, ${(newTranslation - 120.6) * (446 / 800)}px, 0px)`;
            }
            if (ias >= 50 && (ias / 10 >= this.currentDrawnIas + 1 || ias / 10 < this.currentDrawnIas)) {
                this.currentDrawnIas = Math.floor(ias / 10);
                for (let i = 0; i < this.iasScrollerValues.length; i++) {
                    const scrollerValue = this.iasScrollerValues[i].instance;
                    if (scrollerValue !== null) {
                        scrollerValue.textContent = (10 * ((i - 4) + this.currentDrawnIas)).toString();
                    }
                }
                this.updateSpeedRanges(ias);
            }
            else if (ias < 50 && (ias / 10 > this.currentDrawnIas + 1 || ias / 10 < this.currentDrawnIas)) {
                this.currentDrawnIas = Math.floor(ias / 10);
                for (let i = 0; i < this.iasScrollerValues.length; i++) {
                    const scrollerValue = this.iasScrollerValues[i].instance;
                    if (scrollerValue !== null) {
                        scrollerValue.textContent = ((i + 2) * 10).toString();
                    }
                }
                this.updateSpeedRanges(ias, true);
            }
            this.updateSpeedBugs(ias);
            this.updateFlcBug();
        };
        this._lastIAS = 0;
        this._lastTime = 0;
        this._computedIASAcceleration = 0;
        /**
         * A computation of the current IAS Acceleration used for the Airspeed Trend Vector.
         * @param ias The current IAS value.
         * @returns The current IAS Acceleration.
         */
        this.computeIASAcceleration = (ias) => {
            const newIASTime = {
                ias: ias,
                t: performance.now() / 1000
            };
            if (this._lastTime == 0) {
                this._lastIAS = ias;
                this._lastTime = performance.now() / 1000;
                return 0;
            }
            let frameIASAcceleration = (newIASTime.ias - this._lastIAS) / (newIASTime.t - this._lastTime);
            frameIASAcceleration = MathUtils.clamp(frameIASAcceleration, -10, 10);
            if (isFinite(frameIASAcceleration)) {
                this._computedIASAcceleration += (frameIASAcceleration - this._computedIASAcceleration) / (50 / ((newIASTime.t - this._lastTime) / .016));
            }
            this._lastIAS = ias;
            this._lastTime = performance.now() / 1000;
            const accel = this._computedIASAcceleration * 6;
            return accel;
        };
        /**
         * A callback called when the TAS updates from the event bus.
         * @param tas The current TAS value.
         */
        this.onUpdateTAS = (tas) => {
            if (this.tasElement.instance !== null) {
                this.tasElement.instance.textContent = `${(tas)}`;
            }
        };
    }
    /**
     * Builds a numerical scroller for the airspeed window.
     * @param startYValue The starting Y value in the svg to start number at.
     * @param blankZeroValue Whether or not the 0 digit should be replaced by an empty space.
     * @returns A collection of text elements for the numerical scroller.
     */
    buildScroller(startYValue = -2, blankZeroValue = false) {
        const scroller = [];
        let yValue = startYValue;
        for (let i = 11; i > -3; i--) {
            const number = i > 9 ? i - 10 : i < 0 ? i + 10 : i;
            let numberText = number.toString();
            if (blankZeroValue && number === 0) {
                numberText = ' ';
            }
            scroller.push(FSComponent.buildComponent("text", { x: '8', y: yValue, fill: "var(--speedNumberColor)", "text-anchor": "middle", "font-size": '32' }, numberText));
            yValue += 30;
        }
        scroller.push(FSComponent.buildComponent("text", { x: '8', y: yValue + 30, fill: "var(--speedNumberColor)", "text-anchor": "middle", "font-size": '32' }, "\u2013"));
        return scroller;
    }
    /**
     * Builds the tick marks on the airspeed tape.
     * @returns A collection of tick mark line elements.
     */
    buildSpeedTapeTicks() {
        const ticks = [];
        for (let i = 1; i < 18; i++) {
            const length = i % 2 == 0 ? 15 : 30;
            const startX = 94 + (length == 30 ? 0 : 15);
            const startY = 450 - (i * 50);
            const endX = startX + length;
            const endY = startY;
            ticks.push(FSComponent.buildComponent("line", { x1: startX, y1: startY, x2: endX, y2: endY, stroke: "white", "stroke-width": "4px" }));
        }
        return ticks;
    }
    /**
     * Builds the airspeed numbers for the airspeed tape.
     * @returns A collection of airspeed number text elements.
     */
    buildSpeedTapeNumbers() {
        const text = [];
        for (let i = 1; i < 10; i++) {
            const startX = 75;
            const startY = 513 - (i * 100);
            const numberText = (10 + (i * 10)).toString();
            const textElement = FSComponent.createRef();
            text.push(FSComponent.buildComponent("text", { x: startX, y: startY, fill: "rgb(203,203,203)", "text-anchor": "end", "font-size": '44', ref: textElement }, numberText));
            this.iasScrollerValues.push(textElement);
        }
        return text;
    }
    /**
     * Builds the airspeed tape color ranges.
     * @returns A collection of color range rect elements.
     */
    buildSVGSpeedTapeRanges() {
        const rectangle = [];
        const zeroYValue = 0;
        //red band (full width 8px top left)
        const redMin = zeroYValue;
        const redMax = 400 - redMin - (10 * (this.stallDirty - 20));
        rectangle.push(FSComponent.buildComponent("rect", { ref: this.speedRangeValues.red, x: "109", y: redMax, width: "16", height: 10 * (this.stallDirty - 20), fill: "red" }));
        const whiteMin = redMax;
        const whiteMax = Math.max(-400, whiteMin - (10 * (this.flapsExtend - this.stallDirty)));
        rectangle.push(FSComponent.buildComponent("rect", { ref: this.speedRangeValues.white, x: "109", y: whiteMax, width: "16", height: whiteMin - whiteMax, fill: "white" }));
        const halfGreenMin = whiteMin - (10 * (this.stallClean - this.stallDirty));
        const halfGreenMax = whiteMax;
        rectangle.push(FSComponent.buildComponent("rect", { ref: this.speedRangeValues.greenWhite, x: "117", y: halfGreenMax, width: "8", height: halfGreenMin - halfGreenMax, fill: "green" }));
        const greenMin = whiteMax;
        const greenMax = Math.max(-400, greenMin - (10 * (this.yellowSpeed - this.flapsExtend)));
        rectangle.push(FSComponent.buildComponent("rect", { ref: this.speedRangeValues.green, x: "109", y: greenMax, width: "16", height: greenMin - greenMax, fill: "green" }));
        const yellowMin = greenMax;
        const yellowMax = Math.max(-400, yellowMin - (10 * (this.barberSpeed - this.yellowSpeed)));
        rectangle.push(FSComponent.buildComponent("rect", { ref: this.speedRangeValues.yellow, x: "109", y: yellowMax, width: "16", height: yellowMin - yellowMax, fill: "yellow" }));
        return rectangle;
    }
    /**
     * Builds the airspeed tape color ranges.
     * @returns A collection of color range rect elements.
     */
    buildHTMLSpeedTapeRanges() {
        const divs = [];
        divs.push(FSComponent.buildComponent("div", { ref: this.speedRangeValues.barber, id: "barberpole" }));
        return divs;
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        this.updateSpeedBugs(this.ias);
        const adc = this.props.bus.getSubscriber();
        const ap = this.props.bus.getSubscriber();
        this.speedWarningSubject.sub(this.speedWarningChanged.bind(this));
        adc.on('ias')
            .withPrecision(2)
            .handle(this.onUpdateIAS);
        adc.on('tas')
            .withPrecision(0)
            .handle(this.onUpdateTAS);
        ap.on('flc_hold_knots')
            .whenChangedBy(1)
            .handle(this.setFlcBug);
        ap.on('ap_lock_set')
            .handle(this.toggleFlcElements);
        const g1000Events = this.props.bus.getSubscriber();
        g1000Events.on('vspeed_set').handle(this.setVSpeed);
        g1000Events.on('vspeed_display').handle(this.setVSpeedVisibility);
        //init the FLC elements to off
        this.flcBugRef.instance.style.display = 'none';
        this.flcBoxRef.instance.style.display = 'none';
    }
    /**
     * A callback called when the speedwarning state changes.
     * @param state the speed warning state
     */
    speedWarningChanged(state) {
        switch (state) {
            case SpeedWarning.None:
                this.airspeedBoxElement.instance.classList.remove('overspeed');
                this.airspeedBoxElement.instance.style.setProperty('--speedNumberColor', 'white');
                break;
            case SpeedWarning.Caution:
                this.airspeedBoxElement.instance.style.setProperty('--speedNumberColor', 'yellow');
                break;
            case SpeedWarning.Overspeed:
                this.airspeedBoxElement.instance.style.setProperty('--speedNumberColor', 'white');
                this.airspeedBoxElement.instance.classList.add('overspeed');
                break;
        }
    }
    /**
     * A method called to update the location of the FLC Bug on the tape.
     */
    updateFlcBug() {
        let deltaBug = this.flcSpeed - this.ias;
        if (this.ias < 20) {
            deltaBug = this.flcSpeed < 20 ? 0 : this.flcSpeed - 20;
        }
        else if (this.ias < 50) {
            deltaBug = Math.max(this.flcSpeed - (this.ias - 20), -30);
        }
        this.flcBugRef.instance.style.transform = `translate3d(0,${-5.583 * Utils.Clamp(deltaBug, -30, 25)}px,0)`;
    }
    /**
     * Determines whether speed trend is in the overspeed range.
     * @param ias the current ias
     * @returns true if speed trend in overspeed
     */
    isSpeedTrendInOverspeed(ias) {
        return ias + (this.currentTrend / 10) >= this.barberSpeed;
    }
    /**
     * Updates the Airspeed Trend Vector.
     * @param ias The current IAS value.
     */
    updateTrendVector(ias) {
        this.currentTrend = (ias >= 20) ? this.computeIASAcceleration(ias) * 5 : 0;
        const verticalOffset = -117 - Math.max(0, this.currentTrend);
        this.airspeedTrendVector.instance.setAttribute('y', verticalOffset.toString());
        this.airspeedTrendVector.instance.setAttribute('height', Math.abs(this.currentTrend).toString());
    }
    /**
     * Updates the speed bugs on the speed tape. (displayed if within 30 kts of ias)
     * @param ias The current IAS value.
     */
    updateSpeedBugs(ias) {
        if (this.ias < 20) {
            /**
             * Sort function for the v speeds
             * @param a the first value to compare
             * @param b the second value to compare
             * @returns the sorted array
             */
            const sortSpeeds = (a, b) => {
                const speedA = a.value;
                const speedB = b.value;
                let comparison = 0;
                if (speedA > speedB) {
                    comparison = 1;
                }
                else if (speedA < speedB) {
                    comparison = -1;
                }
                return comparison;
            };
            const sortedSpeeds = this.vSpeeds.sort(sortSpeeds);
            let offset = 153;
            let value = 0;
            for (let i = 0; i < 5; i++) {
                if (sortedSpeeds[i] && sortedSpeeds[i].display) {
                    const instance = sortedSpeeds[i].type === VSpeedType.Vx ? this.vxSpeedRef.instance :
                        sortedSpeeds[i].type === VSpeedType.Vy ? this.vySpeedRef.instance :
                            sortedSpeeds[i].type === VSpeedType.Vr ? this.vrSpeedRef.instance :
                                sortedSpeeds[i].type === VSpeedType.Vglide ? this.vgSpeedRef.instance : undefined;
                    // this.vSpeeds[i].type === VSpeedType.Vapp ? this.vappSpeedRef.instance : undefined;
                    if (instance !== null && instance !== undefined) {
                        instance.style.transform = `translate3d(0,${offset}px,0)`;
                    }
                    this.vSpeedSubjects[value].set('' + Math.round(sortedSpeeds[i].value));
                    offset -= 22;
                    value++;
                }
                if (value < 4) {
                    for (let j = value; j < 4; j++) {
                        this.vSpeedSubjects[j].set('');
                    }
                }
            }
            this.vSpeedContainerRef.instance.style.display = '';
        }
        else {
            this.vSpeedContainerRef.instance.style.display = 'none';
            const vxIndex = this.vSpeeds.findIndex((type) => {
                if (type.type === VSpeedType.Vx) {
                    return true;
                }
            });
            const vyIndex = this.vSpeeds.findIndex((type) => {
                if (type.type === VSpeedType.Vy) {
                    return true;
                }
            });
            const vrIndex = this.vSpeeds.findIndex((type) => {
                if (type.type === VSpeedType.Vr) {
                    return true;
                }
            });
            const vgIndex = this.vSpeeds.findIndex((type) => {
                if (type.type === VSpeedType.Vglide) {
                    return true;
                }
            });
            // const vappIndex = this.vSpeeds.findIndex((type) => {
            //   if (type.type === VSpeedType.Vapp) { return true; }
            // });
            const deltaVx = this.vSpeeds[vxIndex].value - ias;
            const deltaVy = this.vSpeeds[vyIndex].value - ias;
            const deltaVr = this.vSpeeds[vrIndex].value - ias;
            const deltaVg = this.vSpeeds[vgIndex].value - ias;
            // const deltaVapp = this.vSpeeds[vappIndex].value - ias;
            if (Math.abs(deltaVx) < 35) {
                this.vxSpeedRef.instance.style.transform = `translate3d(0,${-5.583 * deltaVx}px,0)`;
            }
            else {
                this.vxSpeedRef.instance.style.transform = `translate3d(0,${-5.583 * 35}px,0)`;
            }
            if (Math.abs(deltaVy) < 35) {
                this.vySpeedRef.instance.style.transform = `translate3d(0,${-5.583 * deltaVy}px,0)`;
            }
            else {
                this.vySpeedRef.instance.style.transform = `translate3d(0,${-5.583 * 35}px,0)`;
            }
            if (Math.abs(deltaVr) < 35) {
                this.vrSpeedRef.instance.style.transform = `translate3d(0,${-5.583 * deltaVr}px,0)`;
            }
            else {
                this.vrSpeedRef.instance.style.transform = `translate3d(0,${-5.583 * 35}px,0)`;
            }
            if (Math.abs(deltaVg) < 35) {
                this.vgSpeedRef.instance.style.transform = `translate3d(0,${-5.583 * deltaVg}px,0)`;
            }
            else {
                this.vgSpeedRef.instance.style.transform = `translate3d(0,${-5.583 * 35}px,0)`;
            }
            // if (Math.abs(deltaVapp) < 30) {
            //   this.vappSpeedRef.instance.style.transform = `translate3d(0,${10 * deltaVapp}px,0)`;
            // }
        }
        if (this.ias >= 0 && this.ias < 50) {
            this.vSpeedBackgroundRef.instance.style.display = 'block';
            if (this.ias >= 20) {
                this.vSpeedBackgroundRef.instance.style.transform = `translate3d(0,${5.583 * (ias - 20)}px,0)`;
            }
        }
        else {
            this.vSpeedBackgroundRef.instance.style.display = 'none';
        }
    }
    /**
     * Updates the speed range color bars and the IAS box style.
     * @param ias The current IAS value.
     * @param slowSpeed Whether or not the IAS is in the slow speed range.
     */
    updateSpeedRanges(ias, slowSpeed = false) {
        for (let i = 1; i < 7; i++) {
            let instance;
            let rangeBottom;
            let rangeTop;
            let isSVG = true;
            switch (i) {
                case 1:
                    instance = this.speedRangeValues.red.instance;
                    rangeBottom = 20;
                    rangeTop = this.stallDirty;
                    break;
                case 2:
                    instance = this.speedRangeValues.white.instance;
                    rangeBottom = this.stallDirty;
                    rangeTop = this.flapsExtend;
                    break;
                case 3:
                    instance = this.speedRangeValues.greenWhite.instance;
                    rangeBottom = this.stallClean;
                    rangeTop = this.flapsExtend;
                    break;
                case 4:
                    instance = this.speedRangeValues.green.instance;
                    rangeBottom = this.flapsExtend;
                    rangeTop = this.yellowSpeed;
                    break;
                case 5:
                    instance = this.speedRangeValues.yellow.instance;
                    rangeBottom = this.yellowSpeed;
                    rangeTop = this.barberSpeed;
                    break;
                case 6:
                    instance = this.speedRangeValues.barber.instance;
                    rangeBottom = this.barberSpeed;
                    rangeTop = Infinity;
                    isSVG = false;
                    break;
                default:
                    return;
            }
            if (ias < 40 + rangeTop && ias > rangeBottom - 41 && instance !== null) {
                let top;
                let bottom;
                if (slowSpeed) {
                    top = Math.max(-400, 400 - (10 * (rangeTop - 20)));
                    bottom = Math.min(400, 400 - (10 * (rangeBottom - 20)));
                }
                else {
                    top = Math.max(-400, 10 * ((10 * this.currentDrawnIas) - rangeTop));
                    bottom = Math.min(400, 10 * ((10 * this.currentDrawnIas) - rangeBottom));
                }
                if (isSVG) {
                    instance.setAttribute('y', `${top}`);
                    instance.setAttribute('height', `${bottom - top}`);
                }
                else {
                    instance.style.top = (233 + top * 0.5575).toString() + 'px';
                    instance.style.height = Math.max(0, ((bottom - top) * 0.5575)).toString() + 'px';
                }
                instance.style.display = '';
            }
            else if (instance !== null) {
                instance.style.display = 'none';
            }
        }
    }
    // private readonly vxSpeedRef = FSComponent.createRef<HTMLDivElement>();
    // private readonly vySpeedRef = FSComponent.createRef<HTMLDivElement>();
    // private readonly vgSpeedRef = FSComponent.createRef<HTMLDivElement>();
    // private readonly vrSpeedRef = FSComponent.createRef<HTMLDivElement>();
    // private readonly vappSpeedRef = FSComponent.createRef<HTMLDivElement>();
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "airspeed" },
            FSComponent.buildComponent("div", { class: "airspeed-top-border" }),
            FSComponent.buildComponent("div", { class: "airspeed-middle-border" },
                FSComponent.buildComponent("div", { class: "vspeed-values-background", ref: this.vSpeedBackgroundRef },
                    FSComponent.buildComponent("div", { class: "vspeed-values-container", ref: this.vSpeedContainerRef },
                        FSComponent.buildComponent("div", { class: "value1 bug-values cyan" }, this.vSpeedSubjects[0]),
                        FSComponent.buildComponent("div", { class: "value2 bug-values cyan" }, this.vSpeedSubjects[1]),
                        FSComponent.buildComponent("div", { class: "value3 bug-values cyan" }, this.vSpeedSubjects[2]),
                        FSComponent.buildComponent("div", { class: "value4 bug-values cyan" }, this.vSpeedSubjects[3])))),
            FSComponent.buildComponent("div", { class: "speed-tape" }),
            FSComponent.buildComponent("div", { class: "tick-marks" },
                FSComponent.buildComponent("div", { style: "height: 456px; width: 70px; transform: translate3d(0px, -291px, 0px); overflow:hidden", ref: this.airspeedTapeTickElement },
                    FSComponent.buildComponent("svg", { height: "466px", width: "70px", viewBox: "0 -400 125 800" },
                        FSComponent.buildComponent("g", { class: "speed-tape", transform: "translate(0,0)" },
                            this.buildSVGSpeedTapeRanges(),
                            this.buildSpeedTapeTicks(),
                            this.buildSpeedTapeNumbers())),
                    this.buildHTMLSpeedTapeRanges())),
            FSComponent.buildComponent("div", { class: "airspeed-trend-vector" },
                FSComponent.buildComponent("div", { style: "height: 466px; width: 70px;" },
                    FSComponent.buildComponent("svg", { height: "466px", width: "70px", viewBox: "0 -400 125 800" },
                        FSComponent.buildComponent("rect", { ref: this.airspeedTrendVector, x: "115", y: "-117", width: "7", height: "0", stroke: "white", "stroke-width": "1px", fill: "magenta" })))),
            FSComponent.buildComponent("div", { class: "ias-box", ref: this.airspeedBoxElement },
                FSComponent.buildComponent("svg", { viewBox: "0 0 90 70" },
                    FSComponent.buildComponent("path", { d: "M 86 35 l -11 -6 l 0 -26 c 0 -1 -1 -2 -2 -2 l -19 0 c -1 0 -2 1 -2 2 l 0 11 l -44 0 c -1 0 -2 1 -2 2 l 0 38 c 0 1 1 2 2 2 l 44 0 l 0 11 c 0 1 1 2 2 2 l 19 0 c 1 0 2 -1 2 -2 l 0 -26 l 11 -6 z", fill: "black", stroke: "whitesmoke", "stroke-width": "1" })),
                FSComponent.buildComponent("div", { class: "hundreds-scroller scroller-background" },
                    FSComponent.buildComponent("svg", { height: "35", width: "17" },
                        FSComponent.buildComponent("g", { transform: "translate(0,-420)", ref: this.airspeedHundredsDataElement }, this.buildScroller(-2, true)))),
                FSComponent.buildComponent("div", { class: "tens-scroller scroller-background" },
                    FSComponent.buildComponent("svg", { height: "35", width: "17" },
                        FSComponent.buildComponent("g", { transform: "translate(0,-420)", ref: this.airspeedTensDataElement }, this.buildScroller()))),
                FSComponent.buildComponent("div", { class: "ones-scroller scroller-background" },
                    FSComponent.buildComponent("div", { class: "ones-scroller-mask" }),
                    FSComponent.buildComponent("svg", { height: "57", width: "17" },
                        FSComponent.buildComponent("g", { transform: "translate(0,-420)", ref: this.airspeedOnesDataElement }, this.buildScroller(9))))),
            FSComponent.buildComponent("div", { class: "flc-bug", ref: this.flcBugRef },
                FSComponent.buildComponent("svg", { width: "13", height: "24" },
                    FSComponent.buildComponent("path", { d: 'M 0 0 m 8.789 9.794 l -7.789 -4.25 l 0 -5 l 8.5 0 l 0 18.5 l -8.5 0 l 0 -5 z', fill: "cyan" }))),
            FSComponent.buildComponent("div", { class: "vspeed-bug-container" },
                FSComponent.buildComponent("div", { class: "airspeed-bug glide", ref: this.vgSpeedRef },
                    FSComponent.buildComponent("svg", { width: "18", height: "22" },
                        FSComponent.buildComponent("path", { d: 'M 0 0 m 0 9 l 8 -9 l 12 0 l 0 20 l -12 0 l -8 -9 l 0 -2', fill: "black" }),
                        FSComponent.buildComponent("text", { x: "6", y: "16", fill: "cyan" }, "G"))),
                FSComponent.buildComponent("div", { class: "airspeed-bug vr", ref: this.vrSpeedRef },
                    FSComponent.buildComponent("svg", { width: "18", height: "22" },
                        FSComponent.buildComponent("path", { d: 'M 0 0 m 0 9 l 8 -9 l 12 0 l 0 20 l -12 0 l -8 -9 l 0 -2', fill: "black" }),
                        FSComponent.buildComponent("text", { x: "6", y: "16", fill: "cyan" }, "R"))),
                FSComponent.buildComponent("div", { class: "airspeed-bug vx", ref: this.vxSpeedRef },
                    FSComponent.buildComponent("svg", { width: "18", height: "22" },
                        FSComponent.buildComponent("path", { d: 'M 0 0 m 0 9 l 8 -9 l 12 0 l 0 20 l -12 0 l -8 -9 l 0 -2', fill: "black" }),
                        FSComponent.buildComponent("text", { x: "6", y: "16", fill: "cyan" }, "X"))),
                FSComponent.buildComponent("div", { class: "airspeed-bug vy", ref: this.vySpeedRef },
                    FSComponent.buildComponent("svg", { width: "18", height: "22" },
                        FSComponent.buildComponent("path", { d: 'M 0 0 m 0 9 l 8 -9 l 12 0 l 0 20 l -12 0 l -8 -9 l 0 -2', fill: "black" }),
                        FSComponent.buildComponent("text", { x: "6", y: "17", fill: "cyan" }, "Y")))),
            FSComponent.buildComponent("div", { class: "flc-box", ref: this.flcBoxRef },
                FSComponent.buildComponent("svg", null,
                    FSComponent.buildComponent("path", { d: 'M 6 7 m 6.3281 7.0517 l -5.6081 -3.06 l 0 -3.6 l 6.12 0 l 0 13.32 l -6.12 0 l 0 -3.6 z', fill: "cyan" })),
                FSComponent.buildComponent("div", { class: 'flc-value cyan' },
                    this.flcSubject,
                    FSComponent.buildComponent("span", { class: "size14" }, "KT"))),
            FSComponent.buildComponent("div", { class: "tas-box" },
                "TAS",
                FSComponent.buildComponent("div", { class: "tas-value" },
                    FSComponent.buildComponent("span", { ref: this.tasElement }),
                    FSComponent.buildComponent("span", { style: "font-size:14px" }, "KT")))));
    }
}

/**
 * The different types of map projection changes.
 */
var MapProjectionChangeType;
(function (MapProjectionChangeType) {
    MapProjectionChangeType[MapProjectionChangeType["Target"] = 1] = "Target";
    MapProjectionChangeType[MapProjectionChangeType["Center"] = 2] = "Center";
    MapProjectionChangeType[MapProjectionChangeType["TargetProjected"] = 4] = "TargetProjected";
    MapProjectionChangeType[MapProjectionChangeType["Range"] = 8] = "Range";
    MapProjectionChangeType[MapProjectionChangeType["Rotation"] = 16] = "Rotation";
    MapProjectionChangeType[MapProjectionChangeType["ProjectedSize"] = 32] = "ProjectedSize";
    MapProjectionChangeType[MapProjectionChangeType["ProjectedResolution"] = 64] = "ProjectedResolution";
})(MapProjectionChangeType || (MapProjectionChangeType = {}));
/**
 * A geographic projection model for a map. MapProjection uses a mercator projection.
 */
class MapProjection {
    /**
     * Creates a new map projection.
     * @param projectedWidth The initial width of the projection window, in pixels.
     * @param projectedHeight The initial height of the projection window, in pixels.
     */
    constructor(projectedWidth, projectedHeight) {
        // settable parameters
        this.target = new GeoPoint(0, 0);
        this.targetProjectedOffset = new Float64Array(2);
        this.targetProjected = new Float64Array(2);
        this.range = 1;
        this.projectedSize = new Float64Array(2);
        // computed parameters
        this.center = new GeoPoint(0, 0);
        this.centerProjected = new Float64Array(2);
        this.oldParameters = {
            target: new GeoPoint(0, 0),
            center: new GeoPoint(0, 0),
            targetProjected: new Float64Array(2),
            range: 1,
            rotation: 0,
            projectedSize: new Float64Array(2),
            projectedResolution: 0
        };
        this.changeListeners = [];
        Vec2Math.set(projectedWidth, projectedHeight, this.projectedSize);
        this.geoProjection = new MercatorProjection();
        Vec2Math.set(projectedWidth / 2, projectedHeight / 2, this.centerProjected);
        this.targetProjected.set(this.centerProjected);
        this.geoProjection.setReflectY(true).setTranslation(this.centerProjected);
        this.recompute();
    }
    /**
     * Gets this map projection's GeoProjection instance.
     * @returns this map projection's GeoProjection instance.
     */
    getGeoProjection() {
        return this.geoProjection;
    }
    /**
     * Gets the target geographic point of this projection. The target is guaranteed to be projected to a specific
     * point in the projected window defined by the center of the window plus the target projected offset.
     * @returns the target geographic point of this projection.
     */
    getTarget() {
        return this.target.readonly;
    }
    /**
     * Gets the projected offset from the center of the projected window of the target of this projection.
     * @returns the projected offset from the center of the projected window of the target of this projection.
     */
    getTargetProjectedOffset() {
        return this.targetProjectedOffset;
    }
    /**
     * Gets the projected location of the target of this projection.
     * @returns the projected location of the target of this projection.
     */
    getTargetProjected() {
        return this.targetProjected;
    }
    /**
     * Gets the range of this projection in great arc radians. The range is measured from the center of the top edge of
     * the projection to the center of the bottom edge.
     * @returns the range of this projection.
     */
    getRange() {
        return this.range;
    }
    /**
     * Gets the post-projected (planar) rotation angle of this projection in radians.
     * @returns the post-projected rotation angle of this projection.
     */
    getRotation() {
        return this.geoProjection.getPostRotation();
    }
    /**
     * Gets the size of the projected window, in pixels.
     * @returns the size of the projected window.
     */
    getProjectedSize() {
        return this.projectedSize;
    }
    /**
     * Gets the geographic point located at the center of this projection's projected window.
     * @returns the geographic point located at the center of this projection's projected window.
     */
    getCenter() {
        return this.center.readonly;
    }
    /**
     * Gets the center of this projection's projected window.
     * @returns the center of this projection's projected window.
     */
    getCenterProjected() {
        return this.centerProjected;
    }
    /**
     * Gets the resolution of the projected map, in great-arc radians per pixel.
     * @returns the resolution fo the projected map.
     */
    getProjectedResolution() {
        return this.range / this.projectedSize[1];
    }
    /**
     * Calculates the true range of this projection, in great-arc radians, given a hypothetical projected center point.
     * @param centerProjected - the projected location of the hypothetical center point to use for the calculation.
     * @returns the true range of this projection given the hypothetical projected center point.
     */
    calculateRangeAtCenter(centerProjected) {
        const projectedHeight = this.projectedSize[1];
        const topProjected = MapProjection.tempVec2_3;
        topProjected[0] = centerProjected[0];
        topProjected[1] = centerProjected[1] - projectedHeight / 2;
        const bottomProjected = MapProjection.tempVec2_4;
        bottomProjected[0] = centerProjected[0];
        bottomProjected[1] = centerProjected[1] + projectedHeight / 2;
        const top = this.geoProjection.invert(topProjected, MapProjection.tempGeoPoint_1);
        const bottom = this.geoProjection.invert(bottomProjected, MapProjection.tempGeoPoint_2);
        return top.distance(bottom);
    }
    /**
     * Recomputes this projection's computed parameters.
     */
    recompute() {
        const currentTargetProjected = this.geoProjection.project(this.target, MapProjection.tempVec2_1);
        if (isNaN(currentTargetProjected[0] + currentTargetProjected[1])) {
            return;
        }
        const currentCenterProjected = MapProjection.tempVec2_2;
        currentCenterProjected.set(currentTargetProjected);
        currentCenterProjected[0] -= this.targetProjectedOffset[0];
        currentCenterProjected[1] -= this.targetProjectedOffset[1];
        let currentRange = this.calculateRangeAtCenter(currentCenterProjected);
        let ratio = currentRange / this.range;
        if (isNaN(ratio) || ratio === 0) {
            return;
        }
        // iteratively find the appropriate scale factor (empiric testing shows this typically takes less than 4 iterations
        // to converge)
        let iterCount = 0;
        let ratioError = Math.abs(ratio - 1);
        let deltaRatioError = MapProjection.SCALE_FACTOR_TOLERANCE + 1;
        while (iterCount++ < MapProjection.SCALE_FACTOR_MAX_ITER
            && ratioError > MapProjection.SCALE_FACTOR_TOLERANCE
            && deltaRatioError > MapProjection.SCALE_FACTOR_TOLERANCE) {
            this.geoProjection.setScaleFactor(ratio * this.geoProjection.getScaleFactor());
            this.geoProjection.project(this.target, currentTargetProjected);
            currentCenterProjected.set(currentTargetProjected);
            currentCenterProjected[0] -= this.targetProjectedOffset[0];
            currentCenterProjected[1] -= this.targetProjectedOffset[1];
            currentRange = this.calculateRangeAtCenter(currentCenterProjected);
            ratio = currentRange / this.range;
            const newRatioError = Math.abs(ratio - 1);
            deltaRatioError = Math.abs(newRatioError - ratioError);
            ratioError = newRatioError;
        }
        // calculate the center point of the projection
        this.invert(currentCenterProjected, this.center);
        this.geoProjection.setCenter(this.center);
        // set the projection's pre-rotation to avoid anti-meridian wrapping issues
        const preRotation = Vec2Math.set(-this.center.lon * Avionics.Utils.DEG2RAD, 0, MapProjection.tempVec2_1);
        this.geoProjection.setPreRotation(preRotation);
    }
    /**
     * Sets this projection's parameters. Parameters not explicitly defined in the parameters argument will be left
     * unchanged.
     * @param parameters The new parameters.
     */
    set(parameters) {
        // save old values
        this.storeParameters(this.oldParameters);
        parameters.projectedSize && this.setProjectedSize(parameters.projectedSize);
        parameters.target && this.target.set(parameters.target);
        parameters.targetProjectedOffset && this.setTargetProjectedOffset(parameters.targetProjectedOffset);
        parameters.range !== undefined && (this.range = parameters.range);
        parameters.rotation !== undefined && this.geoProjection.setPostRotation(parameters.rotation);
        this.recompute();
        const changeFlags = this.computeChangeFlags(this.oldParameters);
        this.notifyChangeListeners(changeFlags);
    }
    /**
     * Sets the size of the projected window.
     * @param size The new size, in pixels.
     */
    setProjectedSize(size) {
        this.projectedSize.set(size);
        Vec2Math.set(size[0] / 2, size[1] / 2, this.centerProjected);
        this.geoProjection.setTranslation(this.centerProjected);
        Vec2Math.add(this.centerProjected, this.targetProjectedOffset, this.targetProjected);
    }
    /**
     * Sets the projected offset from the center of the projected window of the target of this projection.
     * @param offset The new offset, in pixels.
     */
    setTargetProjectedOffset(offset) {
        this.targetProjectedOffset.set(offset);
        Vec2Math.add(this.centerProjected, this.targetProjectedOffset, this.targetProjected);
    }
    /**
     * Stores this projection's current parameters into a record.
     * @param record The record in which to store the parameters.
     */
    storeParameters(record) {
        record.target.set(this.target);
        record.center.set(this.center);
        record.targetProjected.set(this.targetProjected);
        record.range = this.range;
        record.rotation = this.getRotation();
        record.projectedSize.set(this.projectedSize);
        record.projectedResolution = this.getProjectedResolution();
    }
    /**
     * Computes change flags given a set of old parameters.
     * @param oldParameters The old parameters.
     * @returns change flags based on the specified old parameters.
     */
    computeChangeFlags(oldParameters) {
        return BitFlags.union(oldParameters.target.equals(this.target) ? 0 : MapProjectionChangeType.Target, oldParameters.center.equals(this.center) ? 0 : MapProjectionChangeType.Center, Vec2Math.equals(oldParameters.targetProjected, this.targetProjected) ? 0 : MapProjectionChangeType.TargetProjected, oldParameters.range === this.range ? 0 : MapProjectionChangeType.Range, oldParameters.rotation === this.getRotation() ? 0 : MapProjectionChangeType.Rotation, Vec2Math.equals(oldParameters.projectedSize, this.projectedSize) ? 0 : MapProjectionChangeType.ProjectedSize, oldParameters.projectedResolution === this.getProjectedResolution() ? 0 : MapProjectionChangeType.ProjectedResolution);
    }
    /**
     * Projects a set of lat/lon coordinates.
     * @param point - the point to project.
     * @param out - the vector to which to write the result.
     * @returns the projected point, as a vector.
     */
    project(point, out) {
        return this.geoProjection.project(point, out);
    }
    /**
     * Inverts a set of projected coordinates. This method will determine the geographic point whose projected location
     * is the equal to that described by a 2D position vector.
     * @param vec - the 2D position vector describing the location of the projected coordinates.
     * @param out - the point to which to write the result.
     * @returns the inverted point.
     */
    invert(vec, out) {
        return this.geoProjection.invert(vec, out);
    }
    /**
     * Checks whether a point falls within certain projected bounds. The point can be specified as either a GeoPoint
     * object or a 2D vector. If a GeoPoint object is supplied, it will be projected before the bounds check takes
     * place.
     * @param point - the point to check.
     * @param bounds - the bounds to check against, expressed as a vector ([left, top, right, bottom]). Defaults to the
     * bounds of the projected window.
     * @returns whether the point falls within the projected bounds.
     */
    isInProjectedBounds(point, bounds) {
        let left;
        let top;
        let right;
        let bottom;
        if (bounds) {
            left = bounds[0];
            top = bounds[1];
            right = bounds[2];
            bottom = bounds[3];
        }
        else {
            left = 0;
            top = 0;
            right = this.projectedSize[0];
            bottom = this.projectedSize[1];
        }
        if (!(point instanceof Float64Array)) {
            point = this.project(point, MapProjection.tempVec2_2);
        }
        const x = point[0];
        const y = point[1];
        return x >= left && x <= right && y >= top && y <= bottom;
    }
    /**
     * Gets the geographic great-circle distance between two points in great-arc radians. The points can be specified as
     * either GeoPoint objects or 2D vectors. If 2D vectors are supplied, they are interpreted as projected points and
     * inverse projection will be used to convert them to geographic points.
     * @param point1 - the first point.
     * @param point2 - the second point.
     * @returns the geographic great-circle distance between the points.
     */
    geoDistance(point1, point2) {
        if (point1 instanceof Float64Array) {
            point1 = this.invert(point1, MapProjection.tempGeoPoint_1);
        }
        if (point2 instanceof Float64Array) {
            point2 = this.invert(point2, MapProjection.tempGeoPoint_2);
        }
        return point1.distance(point2);
    }
    /**
     * Gets the projected Euclidean distance between two points in pixels. The points can be specified as either GeoPoint
     * objects or 2D vectors. If GeoPoint objects are supplied, they will be projected to convert them to projected
     * points.
     * @param point1 - the first point.
     * @param point2 - the second point.
     * @returns the projected Euclidean distance between two points.
     */
    projectedDistance(point1, point2) {
        if (!(point1 instanceof Float64Array)) {
            point1 = this.project(point1, MapProjection.tempVec2_1);
        }
        if (!(point2 instanceof Float64Array)) {
            point2 = this.project(point2, MapProjection.tempVec2_2);
        }
        return Vec2Math.distance(point1, point2);
    }
    /**
     * Notifies all registered change listeners that this projection has been changed.
     * @param changeFlags The types of changes that were made.
     */
    notifyChangeListeners(changeFlags) {
        this.changeListeners.forEach(listener => listener(this, changeFlags));
    }
    /**
     * Registers a change listener with this projection. The listener will be called every time this projection changes.
     * A listener can be registered multiple times; it will be called once for every time it is registered.
     * @param listener - the change listener to register.
     */
    addChangeListener(listener) {
        this.changeListeners.push(listener);
    }
    /**
     * Removes a change listener from this projection. If the specified listener was registered multiple times, this
     * method will only remove one instance of the listener.
     * @param listener - the listener to remove.
     * @returns whether the listener was successfully removed.
     */
    removeChangeListener(listener) {
        const index = this.changeListeners.lastIndexOf(listener);
        if (index >= 0) {
            this.changeListeners.splice(index, 1);
            return true;
        }
        else {
            return false;
        }
    }
}
MapProjection.SCALE_FACTOR_MAX_ITER = 20;
MapProjection.SCALE_FACTOR_TOLERANCE = 1e-6;
MapProjection.tempVec2_1 = new Float64Array(2);
MapProjection.tempVec2_2 = new Float64Array(2);
MapProjection.tempVec2_3 = new Float64Array(2);
MapProjection.tempVec2_4 = new Float64Array(2);
MapProjection.tempGeoPoint_1 = new GeoPoint(0, 0);
MapProjection.tempGeoPoint_2 = new GeoPoint(0, 0);

/**
 * A component which displays a map. A map projects geographic coordinates onto a planar pixel grid. Each map component
 * maintains a MapProjection instance which handles the details of the projection. MapLayer objects added to the map
 * as children determine what is drawn on the map.
 */
class MapComponent extends DisplayComponent {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.layers = [];
        this.lastUpdateTime = 0;
        this._isAwake = true;
        this.mapProjection = new MapProjection(this.props.projectedWidth, this.props.projectedHeight);
    }
    /**
     * Gets the size of this map's projected window, in pixels.
     * @returns the size of this map's projected window.
     */
    getProjectedSize() {
        return this.mapProjection.getProjectedSize();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setProjectedSize(arg1, arg2) {
        const size = arg1 instanceof Float64Array ? arg1 : Vec2Math.set(arg1, arg2, new Float64Array(2));
        this.mapProjection.set({ projectedSize: size });
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * Whether this map is awake.
     */
    get isAwake() {
        return this._isAwake;
    }
    /**
     * Puts this map to sleep. While asleep, this map will not be updated.
     */
    sleep() {
        this.setAwakeState(false);
    }
    /**
     * Wakes this map, allowing it to be updated.
     */
    wake() {
        this.setAwakeState(true);
    }
    /**
     * Sets this map's awake state. If the new awake state is the same as the current state, nothing will happen.
     * Otherwise, this map's layers will be notified that the map has either been woken or put to sleep.
     * @param isAwake The new awake state.
     */
    setAwakeState(isAwake) {
        if (this._isAwake === isAwake) {
            return;
        }
        this._isAwake = isAwake;
        this._isAwake ? this.onWake() : this.onSleep();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.mapProjection.addChangeListener(this.onMapProjectionChanged.bind(this));
        this.props.bus.getSubscriber().on('realTime')
            .whenChanged().atFrequency(this.props.updateFreq).handle(this.updateCycleCallback.bind(this));
    }
    /**
     * This method is called when the map is awakened.
     */
    onWake() {
        this.wakeLayers();
    }
    /**
     * Calls the onWake() method of this map's layers.
     */
    wakeLayers() {
        const len = this.layers.length;
        for (let i = 0; i < len; i++) {
            this.layers[i].onWake();
        }
    }
    /**
     * This method is called when the map is put to sleep.
     */
    onSleep() {
        this.sleepLayers();
    }
    /**
     * Calls the onSleep() method of this map's layers.
     */
    sleepLayers() {
        const len = this.layers.length;
        for (let i = 0; i < len; i++) {
            this.layers[i].onSleep();
        }
    }
    /**
     * This method is called when the map projection changes.
     * @param mapProjection This layer's map projection.
     * @param changeFlags The types of changes made to the projection.
     */
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.onProjectedSizeChanged();
        }
        const len = this.layers.length;
        for (let i = 0; i < len; i++) {
            this.layers[i].onMapProjectionChanged(mapProjection, changeFlags);
        }
    }
    /**
     * Attaches a layer to this map component. If the layer is already attached, then this method has no effect.
     * @param layer The layer to attach.
     */
    attachLayer(layer) {
        if (this.layers.indexOf(layer) >= 0) {
            return;
        }
        this.layers.push(layer);
        layer.onAttached();
    }
    /**
     * Detaches a layer from this map component.
     * @param layer The layer to detach.
     * @returns whether the layer was succesfully detached.
     */
    detachLayer(layer) {
        const index = this.layers.indexOf(layer);
        if (index >= 0) {
            layer.onDetached();
            this.layers.splice(index, 1);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * A callback which is called once every update cycle.
     * @param time The current time as a UNIX timestamp.
     */
    updateCycleCallback(time) {
        if (!this._isAwake) {
            return;
        }
        this.onUpdated(time, time - this.lastUpdateTime);
        this.lastUpdateTime = time;
    }
    /**
     * This method is called once every update cycle.
     * @param time The current time as a UNIX timestamp.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    onUpdated(time, elapsed) {
        this.updateLayers(time, elapsed);
    }
    /**
     * Updates this map's attached layers.
     * @param time The current time as a UNIX timestamp.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    updateLayers(time, elapsed) {
        const len = this.layers.length;
        for (let i = 0; i < len; i++) {
            this.layers[i].onUpdated(time, elapsed);
        }
    }
}

/**
 * A base component for map layers.
 */
class MapLayer extends DisplayComponent {
    constructor() {
        super(...arguments);
        this._isVisible = true;
    }
    /**
     * Checks whether this layer is visible.
     * @returns whether this layer is visible.
     */
    isVisible() {
        return this._isVisible;
    }
    /**
     * Sets this layer's visibility.
     * @param val Whether this layer should be visible.
     */
    setVisible(val) {
        if (this._isVisible === val) {
            return;
        }
        this._isVisible = val;
        this.onVisibilityChanged(val);
    }
    /**
     * This method is called when this layer's visibility changes.
     * @param isVisible Whether the layer is now visible.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        // noop
    }
    /**
     * This method is called when this layer is attached to its parent map component.
     */
    onAttached() {
        // noop
    }
    /**
     * This method is called when this layer's parent map is woken.
     */
    onWake() {
        // noop
    }
    /**
     * This method is called when this layer's parent map is put to sleep.
     */
    onSleep() {
        // noop
    }
    /**
     * This method is called when the map projection changes.
     * @param mapProjection - this layer's map projection.
     * @param changeFlags The types of changes made to the projection.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onMapProjectionChanged(mapProjection, changeFlags) {
        // noop
    }
    /**
     * This method is called once every map update cycle.
     * @param time The current time as a UNIX timestamp.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        // noop
    }
    /**
     * This method is called when this layer is detached from its parent map component.
     */
    onDetached() {
        // noop
    }
}

/**
 * A model for maps. Specific functionality is added by adding one or more modules to the model. Each module added to
 * the model is assigned a name which is used to retrieve it from the model.
 */
class MapModel {
    constructor() {
        this.modules = new Map();
    }
    /**
     * Gets a module from this model.
     * @param name The name of the module.
     * @returns A module.
     */
    getModule(name) {
        return this.modules.get(name);
    }
    /**
     * Adds a module to this model.
     * @param name The name of the module to add.
     * @param module The module to add.
     */
    addModule(name, module) {
        if (this.modules.has(name)) {
            return;
        }
        this.modules.set(name, module);
    }
}

/**
 * An abstract implementation of a map text label.
 */
class AbstractMapTextLabel {
    /**
     * Constructor.
     * @param text The text of this label.
     * @param priority The render priority of this label.
     * @param options Options with which to initialize this label.
     */
    constructor(text, priority, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        this.text = text;
        this.priority = priority;
        /**
         * The anchor point of this label, expressed relative to this label's width/height. [0, 0] is the top-left corner,
         * and [1, 1] is the bottom-right corner.
         */
        this.anchor = new Float64Array(2);
        /** The padding of this label's background, in pixels. Expressed as [left, top, right, bottom]. */
        this.bgPadding = new Float64Array(4);
        (options === null || options === void 0 ? void 0 : options.anchor) && this.anchor.set(options.anchor);
        this.font = (_a = options === null || options === void 0 ? void 0 : options.font) !== null && _a !== void 0 ? _a : 'Roboto';
        this.fontSize = (_b = options === null || options === void 0 ? void 0 : options.fontSize) !== null && _b !== void 0 ? _b : 10;
        this.fontColor = (_c = options === null || options === void 0 ? void 0 : options.fontColor) !== null && _c !== void 0 ? _c : 'white';
        this.fontOutlineWidth = (_d = options === null || options === void 0 ? void 0 : options.fontOutlineWidth) !== null && _d !== void 0 ? _d : 0;
        this.fontOutlineColor = (_e = options === null || options === void 0 ? void 0 : options.fontOutlineColor) !== null && _e !== void 0 ? _e : 'black';
        this.showBg = (_f = options === null || options === void 0 ? void 0 : options.showBg) !== null && _f !== void 0 ? _f : false;
        this.bgColor = (_g = options === null || options === void 0 ? void 0 : options.bgColor) !== null && _g !== void 0 ? _g : 'black';
        (options === null || options === void 0 ? void 0 : options.bgPadding) && this.bgPadding.set(options.bgPadding);
        this.bgBorderRadius = (_h = options === null || options === void 0 ? void 0 : options.bgBorderRadius) !== null && _h !== void 0 ? _h : 0;
        this.bgOutlineWidth = (_j = options === null || options === void 0 ? void 0 : options.bgOutlineWidth) !== null && _j !== void 0 ? _j : 0;
        this.bgOutlineColor = (_k = options === null || options === void 0 ? void 0 : options.bgOutlineColor) !== null && _k !== void 0 ? _k : 'white';
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    draw(context, mapProjection) {
        this.setTextStyle(context);
        const width = context.measureText(this.text).width;
        const height = this.fontSize;
        const pos = this.getPosition(mapProjection, AbstractMapTextLabel.tempVec2);
        const centerX = pos[0] - (this.anchor[0] - 0.5) * width;
        const centerY = pos[1] - (this.anchor[1] - 0.5) * height;
        if (this.showBg) {
            this.drawBackground(context, centerX, centerY, width, height);
        }
        this.drawText(context, centerX, centerY);
    }
    /**
     * Loads this label's text style to a canvas rendering context.
     * @param context The canvas rendering context to use.
     */
    setTextStyle(context) {
        context.font = `${this.fontSize}px ${this.font}`;
        context.textBaseline = 'middle';
        context.textAlign = 'center';
    }
    /**
     * Draws this label's text to a canvas.
     * @param context The canvas rendering context.
     * @param centerX The x-coordinate of the center of the label, in pixels.
     * @param centerY the y-coordinate of the center of the label, in pixels.
     */
    drawText(context, centerX, centerY) {
        if (this.fontOutlineWidth > 0) {
            context.lineWidth = this.fontOutlineWidth * 2;
            context.strokeStyle = this.fontOutlineColor;
            context.strokeText(this.text, centerX, centerY);
        }
        context.fillStyle = this.fontColor;
        context.fillText(this.text, centerX, centerY);
    }
    /**
     * Draws this label's background to a canvas.
     * @param context The canvas rendering context.
     * @param centerX The x-coordinate of the center of the label, in pixels.
     * @param centerY the y-coordinate of the center of the label, in pixels.
     * @param width The width of the background, in pixels.
     * @param height The height of the background, in pixels.
     */
    drawBackground(context, centerX, centerY, width, height) {
        const backgroundLeft = centerX - width / 2 - (this.bgPadding[3] + this.bgOutlineWidth);
        const backgroundTop = centerY - height / 2 - (this.bgPadding[0] + this.bgOutlineWidth);
        const backgroundWidth = width + (this.bgPadding[1] + this.bgPadding[3] + 2 * this.bgOutlineWidth);
        const backgroundHeight = height + (this.bgPadding[0] + this.bgPadding[2] + 2 * this.bgOutlineWidth);
        let isRounded = false;
        if (this.bgBorderRadius > 0) {
            isRounded = true;
            this.loadBackgroundPath(context, backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight, this.bgBorderRadius);
        }
        if (this.bgOutlineWidth > 0) {
            context.lineWidth = this.bgOutlineWidth * 2;
            context.strokeStyle = this.bgOutlineColor;
            if (isRounded) {
                context.stroke();
            }
            else {
                context.strokeRect(backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight);
            }
        }
        context.fillStyle = this.bgColor;
        if (isRounded) {
            context.fill();
        }
        else {
            context.fillRect(backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight);
        }
    }
    /**
     * Loads the path of this label's background to a canvas rendering context.
     * @param context The canvas rendering context to use.
     * @param left The x-coordinate of the left edge of the background, in pixels.
     * @param top The y-coordinate of the top edge of the background, in pixels.
     * @param width The width of the background, in pixels.
     * @param height The height of the background, in pixels.
     * @param radius The border radius of the background, in pixels.
     */
    loadBackgroundPath(context, left, top, width, height, radius) {
        const right = left + width;
        const bottom = top + height;
        context.beginPath();
        context.moveTo(left + radius, top);
        context.lineTo(right - radius, top);
        context.arcTo(right, top, right, top + radius, radius);
        context.lineTo(right, bottom - radius);
        context.arcTo(right, bottom, right - radius, bottom, radius);
        context.lineTo(left + radius, bottom);
        context.arcTo(left, bottom, left, bottom - radius, radius);
        context.lineTo(left, top + radius);
        context.arcTo(left, top, left + radius, top, radius);
    }
}
AbstractMapTextLabel.tempVec2 = new Float64Array(2);
/**
 * A text label associated with a specific geographic location.
 */
class MapLocationTextLabel extends AbstractMapTextLabel {
    /**
     * Constructor.
     * @param text The text of this label.
     * @param priority The render priority of this label.
     * @param location The geographic location of this label.
     * @param options Options with which to initialize this label.
     */
    constructor(text, priority, location, options) {
        super(text, priority, options);
        this.offset = new Float64Array(2);
        this._location = location.copy();
        this.location = this._location.readonly;
        (options === null || options === void 0 ? void 0 : options.offset) && this.offset.set(options.offset);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getPosition(mapProjection, out) {
        mapProjection.project(this._location, out);
        Vec2Math.add(out, this.offset, out);
        return out;
    }
}

/**
 * A cullable text label associated with a specific geographic location.
 */
class MapCullableLocationTextLabel extends MapLocationTextLabel {
    /**
     * Constructor.
     * @param text The text of this label.
     * @param priority The priority of this label.
     * @param location The geographic location of this label.
     * @param alwaysShow Whether this label is immune to culling.
     * @param options Options with which to initialize this label.
     */
    constructor(text, priority, location, alwaysShow, options) {
        super(text, priority, location, options);
        this.alwaysShow = alwaysShow;
        this.bounds = new Float64Array(4);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    updateBounds(mapProjection) {
        const width = 0.6 * this.fontSize * this.text.length;
        const height = this.fontSize;
        const pos = this.getPosition(mapProjection, MapCullableLocationTextLabel.tempVec2);
        let left = pos[0] - this.anchor[0] * width;
        let right = left + width;
        let top = pos[1] - this.anchor[1] * height;
        let bottom = top + height;
        if (this.showBg) {
            left -= (this.bgPadding[3] + this.bgOutlineWidth);
            right += (this.bgPadding[1] + this.bgOutlineWidth);
            top -= (this.bgPadding[0] + this.bgOutlineWidth);
            bottom += (this.bgPadding[2] + this.bgOutlineWidth);
        }
        this.bounds[0] = left;
        this.bounds[1] = top;
        this.bounds[2] = right;
        this.bounds[3] = bottom;
    }
}
/**
 * Manages a set of MapCullableTextLabels. Colliding labels will be culled based on their render priority. Labels with
 * lower priorities will be culled before labels with higher priorities.
 */
class MapCullableTextLabelManager {
    constructor() {
        this.registered = new Set();
        this._visibleLabels = [];
        this.needUpdate = false;
        this.lastRange = 0;
        this.lastRotation = 0;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** An array of labels registered with this manager that are visible. */
    get visibleLabels() {
        return this._visibleLabels;
    }
    /**
     * Registers a label with this manager. Newly registered labels will be processed with the next manager update.
     * @param label The label to register.
     */
    register(label) {
        if (this.registered.has(label)) {
            return;
        }
        this.registered.add(label);
        this.needUpdate = true;
    }
    /**
     * Deregisters a label with this manager. Newly deregistered labels will be processed with the next manager update.
     * @param label The label to deregister.
     */
    deregister(label) {
        this.needUpdate = this.registered.delete(label) || this.needUpdate;
    }
    /**
     * Updates this manager.
     * @param mapProjection The projection of the map to which this manager's labels are to be drawn.
     */
    update(mapProjection) {
        if (!this.needUpdate) {
            if (mapProjection.getRange() === this.lastRange) {
                const rotationDelta = Math.abs(mapProjection.getRotation() - this.lastRotation);
                if (Math.min(rotationDelta, 2 * Math.PI - rotationDelta) < MapCullableTextLabelManager.ROTATION_UPDATE_THRESHOLD) {
                    return;
                }
            }
        }
        this._visibleLabels = [];
        const labelArray = Array.from(this.registered.values());
        const len = labelArray.length;
        for (let i = 0; i < len; i++) {
            labelArray[i].updateBounds(mapProjection);
        }
        labelArray.sort((a, b) => {
            if (a.alwaysShow && !b.alwaysShow) {
                return -1;
            }
            else if (b.alwaysShow && !a.alwaysShow) {
                return 1;
            }
            else {
                return b.priority - a.priority;
            }
        });
        const collisionArray = [];
        for (let i = 0; i < len; i++) {
            const label = labelArray[i];
            let show = true;
            if (!label.alwaysShow) {
                const len2 = collisionArray.length;
                for (let j = 0; j < len2; j++) {
                    const other = collisionArray[j];
                    if (MapCullableTextLabelManager.doesCollide(label.bounds, other)) {
                        show = false;
                        break;
                    }
                }
            }
            if (show) {
                collisionArray.push(label.bounds);
                this._visibleLabels.push(label);
            }
        }
        this.lastRange = mapProjection.getRange();
        this.lastRotation = mapProjection.getRotation();
        this.needUpdate = false;
    }
    /**
     * Checks if two bounding boxes collide.
     * @param a The first bounding box, as a 4-tuple [left, top, right, bottom].
     * @param b The second bounding box, as a 4-tuple [left, top, right, bottom].
     * @returns whether the bounding boxes collide.
     */
    static doesCollide(a, b) {
        return a[0] < b[2]
            && a[2] > b[0]
            && a[1] < b[3]
            && a[3] > b[1];
    }
}
MapCullableTextLabelManager.ROTATION_UPDATE_THRESHOLD = Math.PI / 6;

/**
 * An airspace renderer which does not draw any graphics.
 */
class NullAirspaceRenderer {
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    render(airspace, projection, context) {
        // noop
    }
}
/**
 * An airspace renderer which renders airspace borders as a single line.
 */
class SingleLineAirspaceRenderer {
    /**
     * Constructor.
     * @param lineWidth The stroke width of the rendered airspace line.
     * @param strokeStyle The stroke style of the rendered airspace line.
     * @param dash The dash of the rendered airspace line.
     */
    constructor(lineWidth, strokeStyle, dash) {
        this.lineWidth = lineWidth;
        this.strokeStyle = strokeStyle;
        this.dash = dash;
    }
    /** @inheritdoc */
    render(airspace, projection, context) {
        const segments = airspace.segments;
        if (segments.length < 2) {
            return;
        }
        context.beginPath();
        const firstProjected = projection.project(segments[0], SingleLineAirspaceRenderer.tempVec2_1);
        context.moveTo(firstProjected[0], firstProjected[1]);
        const max = segments.length - 1;
        for (let i = 1; i < max; i++) {
            const projected = projection.project(segments[i], SingleLineAirspaceRenderer.tempVec2_1);
            context.lineTo(projected[0], projected[1]);
        }
        if (segments[0].equals(segments[segments.length - 1])) {
            context.closePath();
        }
        else {
            const projected = projection.project(segments[segments.length - 1], SingleLineAirspaceRenderer.tempVec2_1);
            context.lineTo(projected[0], projected[1]);
        }
        context.lineWidth = this.lineWidth;
        context.strokeStyle = this.strokeStyle;
        context.setLineDash(this.dash);
        context.stroke();
    }
}
SingleLineAirspaceRenderer.tempVec2_1 = new Float64Array(2);
/**
 * An airspace renderer which supports rendering airspace borders as multiple, optionally offset lines.
 */
class MultiLineAirspaceRenderer {
    /** @inheritdoc */
    render(airspace, projection, context) {
        var _a;
        const segments = airspace.segments;
        if (segments.length < 2) {
            return;
        }
        // project all points and calculate winding order
        let signedArea = 0;
        const projectedArray = MultiLineAirspaceRenderer.tempProjectedArray;
        const len = segments.length;
        for (let i = 0; i < len; i++) {
            const projected = (_a = projectedArray[i]) !== null && _a !== void 0 ? _a : (projectedArray[i] = new Float64Array(2));
            projection.project(segments[i], projected);
            if (i > 0) {
                const prev = projectedArray[i - 1];
                signedArea += prev[0] * projected[1] - projected[0] * prev[1];
            }
        }
        const isClosed = segments[0].equals(segments[len - 1]);
        // if the path is not closed, we need to close the path to calculate a pseudo-winding order
        if (!isClosed) {
            const projected = projectedArray[0];
            const prev = projectedArray[len - 1];
            signedArea += prev[0] * projected[1] - projected[0] * prev[1];
        }
        const windingOrder = signedArea >= 0 ? 1 : -1;
        const vertexNormals = this.calculateVertexNormals(projectedArray, len, isClosed, windingOrder);
        this.renderLines(context, projectedArray, vertexNormals, len, isClosed);
    }
    /**
     * Calculates all vertex normals for the projected airspace polygon. Returns the results as an array with indexes
     * that match the indexes of the supplied vertex array.
     * @param vertexArray The vertices of the projected polygon.
     * @param length The number of the vertices in the projected polygon.
     * @param isClosed Whether the polygon is closed.
     * @param windingOrder the winding order of the polygon.
     * @returns an array of vertex normals.
     */
    calculateVertexNormals(vertexArray, length, isClosed, windingOrder) {
        var _a;
        const array = MultiLineAirspaceRenderer.tempVertexNormalArray;
        const max = isClosed ? length - 1 : length;
        for (let i = 0; i < max; i++) {
            const normal = (_a = array[i]) !== null && _a !== void 0 ? _a : (array[i] = new Float64Array(2));
            const prev = vertexArray[(i + max - 1) % max];
            const curr = vertexArray[i];
            const next = vertexArray[(i + 1) % max];
            this.calculateVertexNormal(windingOrder, prev, curr, next, normal);
        }
        return array;
    }
    /**
     * Calculates a vertex normal. For any given vertex v(i), its vertex normal is defined as the displacement vector d
     * from v(i) such that lines drawn from v(i-1) to v(i) and from v(i) to v(i+1) which are offset by +1 pixel from the
     * reference polygon would terminate at v(i) + d.
     * @param windingOrder The winding order of the polygon to which the vertex belongs.
     * @param prev The position vector of the previous vertex in the polygon.
     * @param curr The position vector of the vertex.
     * @param next The position vector of the next vertex in the polygon.
     * @param out The vector to which to write the result.
     * @returns the vertex normal.
     */
    calculateVertexNormal(windingOrder, prev, curr, next, out) {
        const prevDelta = prev
            ? Vec2Math.sub(Vec2Math.set(curr[0], curr[1], MultiLineAirspaceRenderer.tempVec2_1), prev, MultiLineAirspaceRenderer.tempVec2_1)
            : undefined;
        const nextDelta = next
            ? Vec2Math.sub(Vec2Math.set(next[0], next[1], MultiLineAirspaceRenderer.tempVec2_2), curr, MultiLineAirspaceRenderer.tempVec2_2)
            : undefined;
        if (prevDelta && nextDelta) {
            const segmentWindingOrder = this.getTriangleWindingOrder(prevDelta, nextDelta);
            if (segmentWindingOrder === 0) {
                // prevDelta and nextDelta are parallel
                return Vec2Math.normalize(Vec2Math.normal(prevDelta, out, windingOrder === -1), out);
            }
            else {
                // the normal will be in the direction of the bisecting vector
                // (inverted if the segment winding order is different from the polygon winding order)
                const prevDeltaUnit = Vec2Math.normalize(prevDelta, prevDelta);
                const nextDeltaUnit = Vec2Math.normalize(nextDelta, nextDelta);
                const norm = Vec2Math.multScalar(Vec2Math.normalize(Vec2Math.sub(nextDeltaUnit, prevDeltaUnit, out), out), windingOrder * segmentWindingOrder, out);
                // scale the vertex normal unit vector to adjust for angle between prevDelta and nextDelta
                // (the closer the angle to 0, the farther the point of intersection of offset lines from prev and next lie
                // to the vertex)
                const scaleFactor = Math.abs(1 / (norm[0] * nextDeltaUnit[1] - norm[1] * nextDeltaUnit[0]));
                return Vec2Math.multScalar(norm, scaleFactor, out);
            }
        }
        else if (prevDelta) {
            return Vec2Math.normalize(Vec2Math.normal(prevDelta, out, windingOrder === -1), out);
        }
        else {
            return Vec2Math.normalize(Vec2Math.normal(nextDelta, out, windingOrder === -1), out);
        }
    }
    /**
     * Gets the winding order of a triangle whose sides are described by two displacement vectors (the third side is
     * implied).
     * @param v1 The displacement vector describing the first side of the triangle.
     * @param v2 The displacement vector describing the second side of the triangle.
     * @returns the winding order of the triangle.
     */
    getTriangleWindingOrder(v1, v2) {
        const signedArea = v1[0] * (v2[1] + v1[1]) - (v2[0] + v1[0]) * v1[1];
        return Math.sign(signedArea);
    }
    /**
     * Renders a polygon with a line.
     * @param context The canvas rendering context to which to render.
     * @param vertexArray The vertices of the polygon.
     * @param vertexNormalArray The vertex normals of the polygon.
     * @param length The number of vertices in the polygon.
     * @param isClosed Whether the polygon is closed.
     * @param offset The offset, in pixels, of the rendered line with respect to the polygon. Positive offsets shift the
     * line toward the inside of the polygon.
     * @param lineWidth The stroke width of the line to render.
     * @param strokeStyle The stroke style of the line to render.
     * @param dash The dash of the line to render.
     */
    renderLine(context, vertexArray, vertexNormalArray, length, isClosed, offset, lineWidth, strokeStyle, dash) {
        context.beginPath();
        const max = isClosed ? length - 1 : length;
        for (let i = 0; i < max; i++) {
            const vertex = vertexArray[i];
            const vertexNormal = vertexNormalArray[i];
            const offsetVec = MultiLineAirspaceRenderer.tempVec2_1;
            Vec2Math.multScalar(Vec2Math.set(vertexNormal[0], vertexNormal[1], offsetVec), offset, offsetVec);
            const offsetVertex = Vec2Math.add(vertex, offsetVec, offsetVec);
            i === 0 ? context.moveTo(offsetVertex[0], offsetVertex[1]) : context.lineTo(offsetVertex[0], offsetVertex[1]);
        }
        if (isClosed) {
            context.closePath();
        }
        context.lineWidth = lineWidth;
        context.strokeStyle = strokeStyle;
        context.setLineDash(dash);
        context.stroke();
    }
}
MultiLineAirspaceRenderer.tempProjectedArray = [];
MultiLineAirspaceRenderer.tempVertexNormalArray = [];
MultiLineAirspaceRenderer.tempVec2_1 = new Float64Array(2);
MultiLineAirspaceRenderer.tempVec2_2 = new Float64Array(2);
MultiLineAirspaceRenderer.tempVec2_3 = new Float64Array(2);

/**
 * An abstract implementation of AirspaceRenderManager.
 */
class AbstractAirspaceRenderManager {
    constructor() {
        this.airspaces = [];
        this.taskQueueProcess = null;
    }
    /**
     * Gets all airspaces registered to this render manager.
     * @returns all airspaces registered to this render manager.
     */
    getRegisteredAirspaces() {
        return this.airspaces;
    }
    /**
     * Registers an airspace with this render manager. An airspace may only be registered once.
     * @param airspace The airspace to register.
     * @returns whether the airspace was successfully registered.
     */
    registerAirspace(airspace) {
        if (this.airspaces.findIndex(registered => registered.equals(airspace)) >= 0) {
            return false;
        }
        // Since it's unlikely the manager will be handling more than a few dozen airspaces at any given time, we won't
        // bother with binary search.
        const len = this.airspaces.length;
        let insertionIndex = 0;
        while (insertionIndex < len && this.getRenderOrder(airspace, this.airspaces[insertionIndex]) >= 0) {
            ++insertionIndex;
        }
        // to avoid creating a new array with splice(), we will shift manually.
        for (let i = len - 1; i >= insertionIndex; i--) {
            this.airspaces[i + 1] = this.airspaces[i];
        }
        this.airspaces[insertionIndex] = airspace;
        return true;
    }
    /**
     * Deregisters an airspace with this render manager.
     * @param airspace The airspace to deregister.
     * @returns whether the airspace was successfully deregistered.
     */
    deregisterAirspace(airspace) {
        const index = this.airspaces.findIndex(registered => registered.equals(airspace));
        if (index >= 0) {
            this.airspaces.splice(index, 1);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Replace all airspaces currently registered with this render manager with a new list of airspaces.
     * @param airspaces The new list of airspaces.
     * @returns whether the replace operation changed the set of registered airspaces.
     */
    replaceRegisteredAirspaces(airspaces) {
        const oldAirspaces = this.airspaces;
        this.airspaces = [];
        const len = airspaces.length;
        for (let i = 0; i < len; i++) {
            this.registerAirspace(airspaces[i]);
        }
        return this.airspaces.length !== oldAirspaces.length
            || this.airspaces.some(registered => oldAirspaces.findIndex(airspace => !airspace.equals(registered)) >= 0);
    }
    /**
     * Deregisters all airspaces currently registered with this render manager.
     * @returns whether any airspaces were deregistered.
     */
    clearRegisteredAirspaces() {
        if (this.airspaces.length === 0) {
            return false;
        }
        this.airspaces = [];
        return true;
    }
    /**
     * Generates a throttled task queue process, which when started will render all the airspaces registered with this
     * manager.
     * @param projection The projection to use when rendering.
     * @param context The canvas rendering context to which to render.
     * @param taskQueueHandler The handler to assign to the task queue process.
     * @returns a throttled task queue process.
     */
    prepareRenderProcess(projection, context, taskQueueHandler) {
        const tasks = this.airspaces.map(airspace => {
            const renderer = this.getAirspaceRenderer(airspace);
            return renderer.render.bind(renderer, airspace, projection, context);
        });
        return new ThrottledTaskQueueProcess(new ArrayTaskQueue(tasks), taskQueueHandler);
    }
}

/**
 * A module describing properties of the own airplane icon.
 */
class MapOwnAirplaneIconModule {
    constructor() {
        /** Whether to show the airplane icon. */
        this.show = Subject.create(true);
    }
}

/**
 * A module describing properties of the own airplane icon.
 */
class MapOwnAirplanePropsModule {
    constructor() {
        /** The airplane's position. */
        this.position = GeoPointSubject.createFromGeoPoint(new GeoPoint(0, 0));
        /** The airplane's true heading, in degrees. */
        this.hdgTrue = Subject.create(0);
        /** The airplane's true ground track, in degrees. */
        this.trackTrue = Subject.create(0);
        /** Whether the airplane is on the ground. */
        this.isOnGround = Subject.create(true);
        this.positionHandler = (pos) => {
            this.position.set(pos.lat, pos.long);
        };
        this.headingHandler = (heading) => {
            this.hdgTrue.set(heading);
        };
        this.trackHandler = (track) => {
            this.trackTrue.set(track);
        };
        this.onGroundHandler = (isOnGround) => {
            this.isOnGround.set(isOnGround);
        };
        this.isSyncing = false;
        this.positionConsumer = null;
        this.headingConsumer = null;
        this.trackConsumer = null;
        this.onGroundConsumer = null;
    }
    /**
     * Begins syncing this module with the event bus. While syncing is active, this module's properties will be
     * automatically updated with the latest information provided by the event bus.
     * @param bus The event bus.
     * @param updateFreq The frequencing at which to sync with the event bus.
     */
    beginSync(bus, updateFreq) {
        this.stopSync();
        const gnssSubscriber = bus.getSubscriber();
        this.positionConsumer = gnssSubscriber
            .on('gps-position')
            .atFrequency(updateFreq);
        this.positionConsumer.handle(this.positionHandler);
        this.trackConsumer = gnssSubscriber
            .on('track_deg_true')
            .atFrequency(updateFreq);
        this.trackConsumer.handle(this.trackHandler);
        const adcSubscriber = bus.getSubscriber();
        this.headingConsumer = adcSubscriber
            .on('hdg_deg_true')
            .atFrequency(updateFreq);
        this.headingConsumer.handle(this.headingHandler);
        this.onGroundConsumer = adcSubscriber
            .on('on_ground')
            .atFrequency(updateFreq);
        this.onGroundConsumer.handle(this.onGroundHandler);
        this.isSyncing = true;
    }
    /**
     * Stops syncing this module with the event bus.
     */
    stopSync() {
        var _a, _b, _c, _d;
        if (!this.isSyncing) {
            return;
        }
        (_a = this.positionConsumer) === null || _a === void 0 ? void 0 : _a.off(this.positionHandler);
        (_b = this.headingConsumer) === null || _b === void 0 ? void 0 : _b.off(this.headingHandler);
        (_c = this.trackConsumer) === null || _c === void 0 ? void 0 : _c.off(this.trackHandler);
        (_d = this.onGroundConsumer) === null || _d === void 0 ? void 0 : _d.off(this.onGroundHandler);
        this.isSyncing = false;
    }
}

/**
 * A module describing the nominal range of a map.
 */
class MapRangeModule {
    constructor() {
        this.nominalRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(1));
    }
}

/**
 * A module describing the nominal range of a map.
 */
class MapIndexedRangeModule extends MapRangeModule {
    /** @inheritdoc */
    constructor() {
        super();
        /** The index of the map nominal range. */
        this.nominalRangeIndex = Subject.create(0);
        /** The array of possible map nominal ranges. */
        this.nominalRanges = Subject.create([UnitType.NMILE.createNumber(1)]);
        this.nominalRanges.sub(this.onNominalRangesChanged.bind(this));
    }
    /**
     * A callback which is called when the nominal range array changes.
     * @param array The new array.
     */
    onNominalRangesChanged(array) {
        const currentIndex = this.nominalRangeIndex.get();
        this.setNominalRangeIndex(Utils.Clamp(currentIndex, 0, array.length - 1));
    }
    /**
     * Sets the nominal range by index.
     * @param index The index of the new nominal range.
     * @returns The value of the new nominal range.
     * @throws Error if index of out of bounds.
     */
    setNominalRangeIndex(index) {
        const rangeArray = this.nominalRanges.get();
        if (index < 0 || index >= rangeArray.length) {
            throw new Error('Index out of bounds.');
        }
        const range = rangeArray[index];
        this.nominalRangeIndex.set(index);
        this.nominalRange.set(range);
        return range;
    }
}

/// <reference types="msfstypes/JS/common" />
/**
 * A FSComponent that displays the MSFS Bing Map, weather radar, and 3D terrain.
 */
class BingComponent extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.modeFlags = this.props.mode === EBingMode.HORIZON ? 4 : 0;
        this.isListenerRegistered = false;
        this.imgRef = FSComponent.createRef();
        this.uid = 0;
        this._isBound = false;
        this._isAwake = true;
        this.pos = null;
        this.radius = 0;
        this.resolutionSub = Vec2Subject.createFromVector(new Float64Array([BingComponent.DEFAULT_RESOLUTION, BingComponent.DEFAULT_RESOLUTION]));
        this.resolutionPropHandler = (resolution) => {
            this.resolutionSub.set(resolution);
        };
        this.resolutionHandler = (resolution) => {
            Coherent.call('SET_MAP_RESOLUTION', this.uid, resolution[0], resolution[1]);
        };
        this.earthColorsSub = ArraySubject.create(BingComponent.createEarthColorsArray('#000000', [{ elev: 0, color: '#000000' }, { elev: 60000, color: '#000000' }]));
        this.skyColorSub = Subject.create(BingComponent.hexaToRGBColor('#000000'));
        this.referenceSub = Subject.create(EBingReference.SEA);
        this.wxrModeSub = Subject.create({ mode: EWeatherRadar.OFF, arcRadians: 0.5 }, (cur, prev) => cur.mode === prev.mode && cur.arcRadians === prev.arcRadians, (ref, val) => Object.assign(ref, val));
        this.earthColorsPropHandler = (index, type, item, array) => {
            if (array.length !== 61) {
                return;
            }
            this.earthColorsSub.set(array);
        };
        this.skyColorPropHandler = (color) => {
            this.skyColorSub.set(color);
        };
        this.referencePropHandler = (reference) => {
            this.referenceSub.set(reference);
        };
        this.wxrModePropHandler = (wxrMode) => {
            this.wxrModeSub.set(wxrMode);
        };
        this.earthColorsHandler = (index, type, item, array) => {
            if (type !== SubscribableArrayEventType.Cleared) {
                if (array.length !== 61) {
                    throw new Error(`Incorrect number of colors provided: was ${array.length} but should be 61`);
                }
                Coherent.call('SET_MAP_HEIGHT_COLORS', this.uid, array);
            }
        };
        this.skyColorHandler = (color) => {
            Coherent.call('SET_MAP_CLEAR_COLOR', this.uid, color);
        };
        this.referenceHandler = (reference) => {
            const flags = this.modeFlags | (reference === EBingReference.PLANE ? 1 : 0);
            this.mapListener.trigger('JS_BIND_BINGMAP', this.props.id, flags);
        };
        this.wxrModeHandler = (wxrMode) => {
            Coherent.call('SHOW_MAP_WEATHER', this.uid, wxrMode.mode, wxrMode.arcRadians);
        };
        /**
         * A callback called when the listener is registered.
         */
        this.onListenerRegistered = () => {
            if (this.isListenerRegistered) {
                return;
            }
            this.mapListener.on('MapBinded', this.onListenerBound);
            this.mapListener.on('MapUpdated', this.onMapUpdate);
            this.isListenerRegistered = true;
            this.mapListener.trigger('JS_BIND_BINGMAP', this.props.id, this.modeFlags);
        };
        /**
         * A callback called when the listener is fully bound.
         * @param binder The binder from the listener.
         * @param uid The unique ID of the bound map.
         */
        this.onListenerBound = (binder, uid) => {
            if (binder.friendlyName === this.props.id) {
                console.log('Bing map listener bound.');
                this.binder = binder;
                this.uid = uid;
                if (this._isBound) {
                    return;
                }
                this._isBound = true;
                Coherent.call('SHOW_MAP', uid, true);
                if (this._isAwake) {
                    Coherent.call('SET_MAP_RESOLUTION', uid, BingComponent.DEFAULT_RESOLUTION, BingComponent.DEFAULT_RESOLUTION);
                    this.earthColorsSub.sub(this.earthColorsHandler, true);
                    this.skyColorSub.sub(this.skyColorHandler, true);
                    this.referenceSub.sub(this.referenceHandler, true);
                    this.wxrModeSub.sub(this.wxrModeHandler, true);
                    this.resolutionSub.sub(this.resolutionHandler, true);
                }
                this.props.onBoundCallback(this);
            }
        };
        /**
         * A callback called when the map image is updated.
         * @param uid The unique ID of the bound map.
         * @param imgSrc The img tag src attribute to assign to the bing map image.
         */
        this.onMapUpdate = (uid, imgSrc) => {
            if (this.binder !== undefined && this.uid === uid && this.imgRef.instance !== null) {
                if (this.imgRef.instance.src !== imgSrc) {
                    this.imgRef.instance.src = imgSrc;
                }
            }
        };
        /**
         * A callback called when the instrument is destroyed.
         */
        this.onDestroy = () => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            this._isBound = false;
            (_a = this.props.earthColors) === null || _a === void 0 ? void 0 : _a.unsub(this.earthColorsPropHandler);
            (_b = this.props.skyColor) === null || _b === void 0 ? void 0 : _b.unsub(this.skyColorPropHandler);
            (_c = this.props.reference) === null || _c === void 0 ? void 0 : _c.unsub(this.referencePropHandler);
            (_d = this.props.wxrMode) === null || _d === void 0 ? void 0 : _d.unsub(this.wxrModePropHandler);
            (_e = this.props.resolution) === null || _e === void 0 ? void 0 : _e.unsub(this.resolutionPropHandler);
            (_f = this.mapListener) === null || _f === void 0 ? void 0 : _f.off('MapBinded', this.onListenerBound);
            (_g = this.mapListener) === null || _g === void 0 ? void 0 : _g.off('MapUpdated', this.onMapUpdate);
            (_h = this.mapListener) === null || _h === void 0 ? void 0 : _h.trigger('JS_UNBIND_BINGMAP', this.props.id);
            this.isListenerRegistered = false;
            if (this.imgRef.instance !== null) {
                this.imgRef.instance.src = '';
                (_j = this.imgRef.instance.parentNode) === null || _j === void 0 ? void 0 : _j.removeChild(this.imgRef.instance);
            }
        };
    }
    /**
     * Checks whether this Bing component has been bound.
     * @returns whether this Bing component has been bound.
     */
    isBound() {
        return this._isBound;
    }
    /**
     * Checks whether this Bing component is awake.
     * @returns whether this Bing component is awake.
     */
    isAwake() {
        return this._isAwake;
    }
    /** @inheritdoc */
    onAfterRender() {
        var _a, _b, _c, _d, _e;
        (_a = this.props.resolution) === null || _a === void 0 ? void 0 : _a.sub(this.resolutionPropHandler, true);
        (_b = this.props.earthColors) === null || _b === void 0 ? void 0 : _b.sub(this.earthColorsPropHandler, true);
        (_c = this.props.skyColor) === null || _c === void 0 ? void 0 : _c.sub(this.skyColorPropHandler, true);
        (_d = this.props.reference) === null || _d === void 0 ? void 0 : _d.sub(this.referencePropHandler, true);
        (_e = this.props.wxrMode) === null || _e === void 0 ? void 0 : _e.sub(this.wxrModePropHandler, true);
        setTimeout(() => {
            this.mapListener = RegisterViewListener('JS_LISTENER_MAPS', this.onListenerRegistered);
        }, 3000);
        window.addEventListener('OnDestroy', this.onDestroy);
    }
    /**
     * Wakes this Bing component. Upon awakening, this component will synchronize its state from when it was put to sleep
     * to the Bing instance to which it is bound.
     */
    wake() {
        this._isAwake = true;
        if (!this._isBound) {
            return;
        }
        Coherent.call('SET_MAP_PARAMS', this.uid, this.pos, this.radius, 1);
        this.earthColorsSub.sub(this.earthColorsHandler, true);
        this.skyColorSub.sub(this.skyColorHandler, true);
        this.referenceSub.sub(this.referenceHandler, true);
        this.wxrModeSub.sub(this.wxrModeHandler, true);
        this.resolutionSub.sub(this.resolutionHandler, true);
    }
    /**
     * Puts this Bing component to sleep. While asleep, this component cannot make changes to the Bing instance to which
     * it is bound.
     */
    sleep() {
        var _a;
        this._isAwake = false;
        if (!this._isBound) {
            return;
        }
        this.earthColorsSub.unsub(this.earthColorsHandler);
        this.skyColorSub.unsub(this.skyColorHandler);
        this.referenceSub.unsub(this.referenceHandler);
        this.wxrModeSub.unsub(this.wxrModeHandler);
        this.resolutionSub.unsub(this.resolutionHandler);
        (_a = this.mapListener) === null || _a === void 0 ? void 0 : _a.off('MapUpdated', this.onMapUpdate);
    }
    /**
     * Sets the center position and radius.
     * @param pos The center position.
     * @param radius The radius, in meters.
     */
    setPositionRadius(pos, radius) {
        if (this._isBound && this._isAwake) {
            Coherent.call('SET_MAP_PARAMS', this.uid, pos, radius, 1);
            this.pos = pos;
            this.radius = radius;
        }
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("img", { ref: this.imgRef, src: '', style: 'position: absolute; left: 0; top: 0; width: 100%; height: 100%;', class: `${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}` }));
    }
    /**
     * Converts an HTML hex color string to a numerical map RGB value.
     * @param hexColor The hex color string to convert.
     * @returns A numerical map RGB value.
     */
    static hexaToRGBColor(hexColor) {
        const hexStringColor = hexColor;
        let offset = 0;
        if (hexStringColor[0] === '#') {
            offset = 1;
        }
        const r = parseInt(hexStringColor.substr(0 + offset, 2), 16);
        const g = parseInt(hexStringColor.substr(2 + offset, 2), 16);
        const b = parseInt(hexStringColor.substr(4 + offset, 2), 16);
        const rgb = 256 * 256 * b + 256 * g + r;
        return rgb;
    }
    /**
     * Converts RGB color components to a numerical map RGB value.
     * @param r The red component, from 0 to 255.
     * @param g The green component, from 0 to 255.
     * @param b The blue component, from 0 to 255.
     * @returns A numerical map RGB value.
     */
    static rgbColor(r, g, b) {
        const rgb = 256 * 256 * b + 256 * g + r;
        return rgb;
    }
    /**
     * Creates a full Bing component earth colors array. The earth colors array will contain the specified water color
     * and terrain colors (including interpolated values between the explicitly defined ones, as necessary).
     * @param waterColor The desired water color, as a hex string with the format `#hhhhhh`.
     * @param terrainColors An array of desired terrain colors at specific elevations. Elevations should be specified in
     * feet and colors as hex strings with the format `#hhhhhh`.
     * @returns a full Bing component earth colors array.
     */
    // eslint-disable-next-line jsdoc/require-jsdoc
    static createEarthColorsArray(waterColor, terrainColors) {
        const earthColors = [BingComponent.hexaToRGBColor(waterColor)];
        const curve = new Avionics.Curve();
        curve.interpolationFunction = Avionics.CurveTool.StringColorRGBInterpolation;
        for (let i = 0; i < terrainColors.length; i++) {
            curve.add(terrainColors[i].elev, terrainColors[i].color);
        }
        for (let i = 0; i < 60; i++) {
            const color = curve.evaluate(i * 30000 / 60);
            earthColors[i + 1] = BingComponent.hexaToRGBColor(color);
        }
        return earthColors;
    }
}
BingComponent.DEFAULT_RESOLUTION = 1024;

/// <reference types="msfstypes/JS/common" />
/**
 * A FSComponent that display the MSFS Bing Map, weather radar, and 3D terrain.
 */
class MapBingLayer$1 extends MapLayer {
    constructor() {
        super(...arguments);
        this.wrapperRef = FSComponent.createRef();
        this.bingRef = FSComponent.createRef();
        this.size = 0;
        this.needUpdate = false;
        /**
         * A callback which is called when the Bing component is bound.
         * @param component The bound Bing component.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.onBingBound = (component) => {
            this.needUpdate = true;
        };
    }
    /** @inheritdoc */
    onAfterRender() {
        this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onWake() {
        this.bingRef.instance.wake();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onSleep() {
        this.bingRef.instance.sleep();
    }
    /**
     * Updates this layer according to the current size of the projected map window.
     * @param projectedSize The size of the projected map window.
     */
    updateFromProjectedSize(projectedSize) {
        this.size = this.getSize(projectedSize);
        const offsetX = (projectedSize[0] - this.size) / 2;
        const offsetY = (projectedSize[1] - this.size) / 2;
        this.wrapperRef.instance.style.left = `${offsetX}px`;
        this.wrapperRef.instance.style.top = `${offsetY}px`;
        this.wrapperRef.instance.style.width = `${this.size}px`;
        this.wrapperRef.instance.style.height = `${this.size}px`;
    }
    /**
     * Gets an appropriate size, in pixels, for this Bing layer given specific map projection window dimensions.
     * @param projectedSize - the size of the projected map window.
     * @returns an appropriate size for this Bing layer.
     */
    getSize(projectedSize) {
        return Vec2Math.abs(projectedSize);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.updateFromProjectedSize(mapProjection.getProjectedSize());
        }
        if (this.bingRef.instance.isBound()) {
            this.needUpdate = true;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        if (!this.needUpdate) {
            return;
        }
        this.updatePositionRadius();
        this.needUpdate = false;
    }
    /**
     * Updates the Bing map center position and radius.
     */
    updatePositionRadius() {
        const center = this.props.mapProjection.getCenter();
        const radius = this.calculateDesiredRadius(this.props.mapProjection);
        this.bingRef.instance.setPositionRadius(new LatLong(center.lat, center.lon), radius);
        this.wrapperRef.instance.style.transform = `rotate(${this.props.mapProjection.getRotation() * Avionics.Utils.RAD2DEG}deg)`;
    }
    /**
     * Gets the desired Bing map radius in meters given a map projection model.
     * @param mapProjection - a map projection model.
     * @returns the desired Bing map radius.
     */
    calculateDesiredRadius(mapProjection) {
        const scaleFactor = mapProjection.getGeoProjection().getScaleFactor();
        const pointScaleFactor = 1 / Math.cos(mapProjection.getCenter().lat * Avionics.Utils.DEG2RAD);
        const radiusGARad = this.size / (2 * scaleFactor * pointScaleFactor);
        return UnitType.GA_RADIAN.convertTo(radiusGARad, UnitType.METER);
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { ref: this.wrapperRef, style: 'position: absolute;', class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' },
            FSComponent.buildComponent(BingComponent, { ref: this.bingRef, id: this.props.bingId, mode: EBingMode.PLANE, onBoundCallback: this.onBingBound, earthColors: this.props.earthColors, reference: this.props.reference, wxrMode: this.props.wxrMode })));
    }
}
MapBingLayer$1.OVERDRAW_FACTOR = Math.SQRT2;
MapBingLayer$1.tempVec2_1 = new Float64Array(2);
MapBingLayer$1.tempVec2_2 = new Float64Array(2);
MapBingLayer$1.tempVec2_3 = new Float64Array(2);

/**
 * An implementation of MapCanvasLayerCanvasInstance.
 */
class MapCanvasLayerCanvasInstanceClass {
    /**
     * Creates a new canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     */
    constructor(canvas, context, isDisplayed) {
        this.canvas = canvas;
        this.context = context;
        this.isDisplayed = isDisplayed;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    clear() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    reset() {
        const width = this.canvas.width;
        this.canvas.width = 0;
        this.canvas.width = width;
    }
}
/**
 * A layer which uses a canvas to draw graphics.
 */
class MapCanvasLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.displayCanvasRef = FSComponent.createRef();
        this.width = 0;
        this.height = 0;
        this.displayCanvasContext = null;
        this.isInit = false;
        this.needUpdateCanvasVisibility = false;
    }
    /**
     * Gets this layer's display canvas instance.
     * @returns this layer's display canvas instance.
     */
    get display() {
        return this._display;
    }
    /**
     * Gets this layer's buffer canvas instance.
     * @returns this layer's buffer canvas instance.
     */
    get buffer() {
        return this._buffer;
    }
    /**
     * Gets the width of the canvas element, in pixels.
     * @returns the width of the canvas element.
     */
    getWidth() {
        return this.width;
    }
    /**
     * Gets the height of the canvas element, in pixels.
     * @returns the height of the canvas element.
     */
    getHeight() {
        return this.height;
    }
    /**
     * Sets the width of the canvas element, in pixels.
     * @param width The new width.
     */
    setWidth(width) {
        if (width === this.width) {
            return;
        }
        this.width = width;
        if (this.isInit) {
            this.updateCanvasSize();
        }
    }
    /**
     * Sets the height of the canvas element, in pixels.
     * @param height The new height.
     */
    setHeight(height) {
        if (height === this.height) {
            return;
        }
        this.height = height;
        if (this.isInit) {
            this.updateCanvasSize();
        }
    }
    /**
     * Copies the contents of the buffer to the display. Has no effect if this layer does not have a buffer.
     */
    copyBufferToDisplay() {
        if (!this.isInit || !this.props.useBuffer) {
            return;
        }
        this.display.context.drawImage(this.buffer.canvas, 0, 0, this.width, this.height);
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        this.displayCanvasContext = this.displayCanvasRef.instance.getContext('2d');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        this.needUpdateCanvasVisibility = true;
    }
    /**
     * Updates this layer according to its current visibility.
     */
    updateFromVisibility() {
        this.display.canvas.style.display = this.isVisible() ? 'block' : 'none';
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAttached() {
        this.initCanvasInstances();
        this.isInit = true;
        this.needUpdateCanvasVisibility = true;
        this.updateCanvasSize();
    }
    /**
     * Initializes this layer's canvas instances.
     */
    initCanvasInstances() {
        this._display = this.createCanvasInstance(this.displayCanvasRef.instance, this.displayCanvasContext, true);
        if (this.props.useBuffer) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            this._buffer = this.createCanvasInstance(canvas, context, false);
        }
    }
    /**
     * Creates a canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     * @returns a canvas instance.
     */
    createCanvasInstance(canvas, context, isDisplayed) {
        return new MapCanvasLayerCanvasInstanceClass(canvas, context, isDisplayed);
    }
    /**
     * Updates the canvas element's size.
     */
    updateCanvasSize() {
        const displayCanvas = this._display.canvas;
        displayCanvas.width = this.width;
        displayCanvas.height = this.height;
        displayCanvas.style.width = `${this.width}px`;
        displayCanvas.style.height = `${this.height}px`;
        if (this._buffer) {
            const bufferCanvas = this._buffer.canvas;
            bufferCanvas.width = this.width;
            bufferCanvas.height = this.height;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        if (this.needUpdateCanvasVisibility) {
            this.updateCanvasVisibility();
            this.needUpdateCanvasVisibility = false;
        }
    }
    /**
     * Updates the visibility of the display canvas.
     */
    updateCanvasVisibility() {
        this.display.canvas.style.display = this.isVisible() ? 'block' : 'none';
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("canvas", { ref: this.displayCanvasRef, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', width: '0', height: '0', style: 'position: absolute;' }));
    }
}

/**
 * A canvas map layer whose size and position is synced with the map projection window.
 */
class MapSyncedCanvasLayer extends MapCanvasLayer {
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAttached() {
        super.onAttached();
        this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
    }
    /**
     * Updates this layer according to the current size of the projected map window.
     * @param projectedSize The size of the projected map window.
     */
    updateFromProjectedSize(projectedSize) {
        this.setWidth(projectedSize[0]);
        this.setHeight(projectedSize[1]);
        const displayCanvas = this.display.canvas;
        displayCanvas.style.left = '0px';
        displayCanvas.style.top = '0px';
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.updateFromProjectedSize(mapProjection.getProjectedSize());
        }
    }
}

/**
 * Implementation of MapCachedCanvasLayerReference.
 */
class MapCachedCanvasLayerReferenceClass {
    constructor() {
        this._center = new GeoPoint(0, 0);
        this._range = UnitType.NMILE.createNumber(1);
        this._scaleFactor = 1;
        this._rotation = 0;
    }
    /** @inheritdoc */
    get center() {
        return this._center.readonly;
    }
    /** @inheritdoc */
    get range() {
        return this._range.readonly;
    }
    /** @inheritdoc */
    get scaleFactor() {
        return this._scaleFactor;
    }
    /** @inheritdoc */
    get rotation() {
        return this._rotation;
    }
    /**
     * Syncs this reference with the current state of a map projection.
     * @param mapProjection The map projection with which to sync.
     */
    syncWithMapProjection(mapProjection) {
        this._range.set(mapProjection.getRange(), UnitType.GA_RADIAN);
        this._center.set(mapProjection.getCenter());
        this._scaleFactor = mapProjection.getGeoProjection().getScaleFactor();
        this._rotation = mapProjection.getRotation();
    }
    /**
     * Syncs this reference with another reference.
     * @param reference - the reference with which to sync.
     */
    syncWithReference(reference) {
        this._range.set(reference.range);
        this._center.set(reference.center);
        this._scaleFactor = reference.scaleFactor;
        this._rotation = reference.rotation;
    }
}
/**
 * Implementation of MapCachedCanvasLayerTransform.
 */
class MapCachedCanvasLayerTransformClass {
    constructor() {
        this._scale = 0;
        this._rotation = 0;
        this._translation = new Float64Array(2);
        this._margin = 0;
    }
    /** @inheritdoc */
    get scale() {
        return this._scale;
    }
    /** @inheritdoc */
    get rotation() {
        return this._rotation;
    }
    /** @inheritdoc */
    get translation() {
        return this._translation;
    }
    /** @inheritdoc */
    get margin() {
        return this._margin;
    }
    /**
     * Updates this transform given the current map projection and a reference.
     * @param mapProjection The current map projection.
     * @param reference The reference to use.
     * @param referenceMargin The reference margin, in pixels.
     */
    update(mapProjection, reference, referenceMargin) {
        this._scale = mapProjection.getGeoProjection().getScaleFactor() / reference.scaleFactor;
        this._rotation = mapProjection.getRotation() - reference.rotation;
        mapProjection.project(reference.center, this._translation);
        Vec2Math.sub(this._translation, mapProjection.getCenterProjected(), this._translation);
        this._margin = referenceMargin * this._scale;
    }
    /**
     * Copies another transform's parameters to this one.
     * @param other The other transform.
     */
    copyFrom(other) {
        this._scale = other.scale;
        this._rotation = other.rotation;
        this._translation.set(other.translation);
        this._margin = other.margin;
    }
}
/**
 * An implementation of MapCachedCanvasLayerCanvasInstance.
 */
class MapCachedCanvasLayerCanvasInstanceClass extends MapCanvasLayerCanvasInstanceClass {
    constructor() {
        super(...arguments);
        this._reference = new MapCachedCanvasLayerReferenceClass();
        this._transform = new MapCachedCanvasLayerTransformClass();
        this._isInvalid = false;
        this._geoProjection = new MercatorProjection();
    }
    /** @inheritdoc */
    get reference() {
        return this._reference;
    }
    /** @inheritdoc */
    get transform() {
        return this._transform;
    }
    /** @inheritdoc */
    get isInvalid() {
        return this._isInvalid;
    }
    /** @inheritdoc */
    get geoProjection() {
        return this._geoProjection;
    }
    /** @inheritdoc */
    syncWithMapProjection(mapProjection, referenceMargin) {
        const projectedCenter = Vec2Math.set(this.canvas.width / 2, this.canvas.height / 2, MapCachedCanvasLayerCanvasInstanceClass.tempVec2_1);
        this._reference.syncWithMapProjection(mapProjection);
        this._geoProjection.copyParametersFrom(mapProjection.getGeoProjection()).setTranslation(projectedCenter);
        this._transform.update(mapProjection, this.reference, referenceMargin);
        this._isInvalid = false;
        if (this.isDisplayed) {
            this.transformCanvasElement();
        }
    }
    /** @inheritdoc */
    syncWithCanvasInstance(other) {
        this._reference.syncWithReference(other.reference);
        this._geoProjection.copyParametersFrom(other.geoProjection);
        this._transform.copyFrom(other.transform);
        this._isInvalid = other.isInvalid;
        if (this.isDisplayed && !this._isInvalid) {
            this.transformCanvasElement();
        }
    }
    /**
     * Updates this canvas instance's transform given the current map projection.
     * @param mapProjection The current map projection.
     * @param referenceMargin The reference margin, in pixels.
     */
    updateTransform(mapProjection, referenceMargin) {
        this._transform.update(mapProjection, this.reference, referenceMargin);
        const translationXAbs = Math.abs(this._transform.translation[0]);
        const translationYAbs = Math.abs(this._transform.translation[1]);
        this._isInvalid = this._isInvalid
            || !this._reference.range.equals(mapProjection.getRange(), UnitType.GA_RADIAN)
            || (translationXAbs > this._transform.margin || translationYAbs > this._transform.margin);
        if (this.isDisplayed && !this._isInvalid) {
            this.transformCanvasElement();
        }
    }
    /**
     * Transforms this instance's canvas element.
     */
    transformCanvasElement() {
        const transform = this.transform;
        const offsetX = transform.translation[0] / transform.scale;
        const offsetY = transform.translation[1] / transform.scale;
        this.canvas.style.transform = `scale(${transform.scale.toFixed(3)}) translate(${offsetX.toFixed(1)}px, ${offsetY.toFixed(1)}px) rotate(${(transform.rotation * Avionics.Utils.RAD2DEG).toFixed(2)}deg)`;
    }
    /** @inheritdoc */
    invalidate() {
        this._isInvalid = true;
        this.clear();
    }
}
MapCachedCanvasLayerCanvasInstanceClass.tempVec2_1 = new Float64Array(2);
/**
 * A canvas map layer whose image can be cached and transformed as the map projection changes.
 */
class MapCachedCanvasLayer extends MapCanvasLayer {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.size = 0;
        this.referenceMargin = 0;
        this.needUpdateTransforms = false;
        this.props.overdrawFactor = Math.max(1, this.props.overdrawFactor);
    }
    /** @inheritdoc */
    get display() {
        return super.display;
    }
    /** @inheritdoc */
    get buffer() {
        return super.buffer;
    }
    /**
     * Gets the size, in pixels, of this layer's canvas.
     * @returns the size of this layer's canvas.
     */
    getSize() {
        return this.size;
    }
    /**
     * Gets the reference translation margin, in pixels, of this layer's display canvas. This value is the maximum amount
     * the display canvas can be translated in the x or y direction at a scale of 1 without invalidation.
     * @returns the reference translation margin of this layer's display canvas.
     */
    getReferenceMargin() {
        return this.referenceMargin;
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
        this.needUpdateTransforms = true;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    createCanvasInstance(canvas, context, isDisplayed) {
        return new MapCachedCanvasLayerCanvasInstanceClass(canvas, context, isDisplayed);
    }
    /**
     * Updates this layer according to the current size of the projected map window.
     * @param projectedSize The size of the projected map window.
     */
    updateFromProjectedSize(projectedSize) {
        const projectedWidth = projectedSize[0];
        const projectedHeight = projectedSize[1];
        const diag = Math.hypot(projectedWidth, projectedHeight);
        this.size = diag * this.props.overdrawFactor;
        this.referenceMargin = (this.size - diag) / 2;
        this.setWidth(this.size);
        this.setHeight(this.size);
        const posX = (projectedWidth - this.size) / 2;
        const posY = (projectedHeight - this.size) / 2;
        const displayCanvas = this.display.canvas;
        displayCanvas.style.left = `${posX}px`;
        displayCanvas.style.top = `${posY}px`;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.updateFromProjectedSize(mapProjection.getProjectedSize());
            this.display.invalidate();
            this.buffer.invalidate();
        }
        this.needUpdateTransforms = true;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        super.onUpdated(time, elapsed);
        if (!this.needUpdateTransforms) {
            return;
        }
        this.updateTransforms();
    }
    /**
     * Updates this layer's canvas instances' transforms.
     */
    updateTransforms() {
        const mapProjection = this.props.mapProjection;
        const display = this.display;
        const buffer = this.buffer;
        display.updateTransform(mapProjection, this.referenceMargin);
        buffer.updateTransform(mapProjection, this.referenceMargin);
        this.needUpdateTransforms = false;
    }
}

/**
 * A map layer which displays a ring (circle) with one or more labels.
 */
class MapLabeledRingLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.labelContainerRef = FSComponent.createRef();
        this.canvasLayerRef = FSComponent.createRef();
        this.center = new Float64Array(2);
        this.radius = 0;
        this.strokeWidth = 0;
        this.strokeStyle = '';
        this.strokeDash = [];
        this.outlineWidth = 0;
        this.outlineStyle = '';
        this.outlineDash = [];
        this.needUpdateVisibility = false;
        this.needUpdateRingPosition = false;
        this.isInit = false;
        this.labels = [];
    }
    /**
     * Gets the center position of this layer's ring, in pixels.
     * @returns the center position of this layer's ring.
     */
    getRingCenter() {
        return this.center;
    }
    /**
     * Gets the radius of this layer's ring, in pixels.
     * @returns the radius of this layer's ring.
     */
    getRingRadius() {
        return this.radius;
    }
    /**
     * Sets the center and radius of this layer's ring.
     * @param center The new center, in pixels.
     * @param radius The new radius, in pixels.
     */
    setRingPosition(center, radius) {
        if (Vec2Math.equals(this.center, center) && radius === this.radius) {
            return;
        }
        this.center.set(center);
        this.radius = radius;
        this.needUpdateRingPosition = true;
    }
    /**
     * Sets the styling for this layer's ring stroke. Any style that is not explicitly defined will be left unchanged.
     * @param width The new stroke width.
     * @param style The new stroke style.
     * @param dash The new stroke dash.
     */
    setRingStrokeStyles(width, style, dash) {
        this.strokeWidth = width !== null && width !== void 0 ? width : this.strokeWidth;
        this.strokeStyle = style !== null && style !== void 0 ? style : this.strokeStyle;
        this.strokeDash = dash !== null && dash !== void 0 ? dash : this.strokeDash;
        this.needUpdateRingPosition = true;
    }
    /**
     * Sets the styling for this layer's ring outline. Any style that is not explicitly defined will be left unchanged.
     * @param width The new outline width.
     * @param style The new outline style.
     * @param dash The new outline dash.
     */
    setRingOutlineStyles(width, style, dash) {
        this.outlineWidth = width !== null && width !== void 0 ? width : this.outlineWidth;
        this.outlineStyle = style !== null && style !== void 0 ? style : this.outlineStyle;
        this.outlineDash = dash !== null && dash !== void 0 ? dash : this.outlineDash;
        this.needUpdateRingPosition = true;
    }
    /**
     * Creates a ring label. Labels can only be created after this layer has been rendered.
     * @param content The content of the new label.
     * @returns the newly created ring label, or null if a label could not be created.
     */
    createLabel(content) {
        if (!this.labelContainerRef.instance) {
            return null;
        }
        const wrapperRef = FSComponent.createRef();
        FSComponent.render(FSComponent.buildComponent("div", { ref: wrapperRef, style: 'position: absolute;' }, content), this.labelContainerRef.instance);
        const label = new MapLabeledRingLabelClass(content.instance, wrapperRef.instance);
        label.setRingPosition(this.center, this.radius);
        this.labels.push(label);
        return label;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        this.needUpdateVisibility = true;
    }
    /** @inheritdoc */
    onAttached() {
        this.canvasLayerRef.instance.onAttached();
        this.isInit = true;
        this.needUpdateVisibility = true;
        this.needUpdateRingPosition = true;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            // resizing the map will cause the canvas layer to clear itself, so we need to force a redraw.
            this.needUpdateRingPosition = true;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        if (this.needUpdateVisibility) {
            this.updateFromVisibility();
            this.needUpdateVisibility = false;
        }
        if (this.needUpdateRingPosition) {
            this.updateRingPosition();
            this.needUpdateRingPosition = false;
        }
        this.canvasLayerRef.instance.onUpdated(time, elapsed);
    }
    /**
     * Updates this layer according to its current visibility.
     */
    updateFromVisibility() {
        const isVisible = this.isVisible();
        this.canvasLayerRef.instance.setVisible(isVisible);
        this.labelContainerRef.instance.style.display = isVisible ? 'block' : 'none';
    }
    /**
     * Updates the position of this layer's ring.
     */
    updateRingPosition() {
        this.drawRing();
        this.updateLabelPositions();
    }
    /**
     * Draws this layer's ring to canvas.
     */
    drawRing() {
        const canvasDisplay = this.canvasLayerRef.instance.display;
        canvasDisplay.clear();
        if (!this.isRingInView()) {
            return;
        }
        canvasDisplay.context.beginPath();
        canvasDisplay.context.arc(this.center[0], this.center[1], this.radius, 0, Math.PI * 2);
        if (this.outlineWidth > 0) {
            this.applyStrokeToContext(canvasDisplay.context, this.strokeWidth + this.outlineWidth * 2, this.outlineStyle, this.outlineDash);
        }
        this.applyStrokeToContext(canvasDisplay.context, this.strokeWidth, this.strokeStyle, this.strokeDash);
    }
    /**
     * Checks whether this layer's ring is in view.
     * @returns whether this layer's ring is in view.
     */
    isRingInView() {
        const centerX = this.center[0];
        const centerY = this.center[1];
        const innerHalfLength = this.radius / Math.SQRT2;
        const innerLeft = centerX - innerHalfLength;
        const innerRight = centerX + innerHalfLength;
        const innerTop = centerY - innerHalfLength;
        const innerBottom = centerY + innerHalfLength;
        const outerLeft = centerX - this.radius;
        const outerRight = centerX + this.radius;
        const outerTop = centerY - this.radius;
        const outerBottom = centerY + this.radius;
        const width = this.props.mapProjection.getProjectedSize()[0];
        const height = this.props.mapProjection.getProjectedSize()[1];
        if (innerLeft < 0 && innerRight > width && innerTop < 0 && innerBottom > height) {
            return false;
        }
        if (outerLeft > width || outerRight < 0 || outerTop > height || outerBottom < 0) {
            return false;
        }
        return true;
    }
    /**
     * Applies a stroke to a canvas rendering context.
     * @param context The canvas to which to apply a stroke.
     * @param lineWidth The stroke width.
     * @param strokeStyle The stroke style.
     * @param dash The stroke dash.
     */
    applyStrokeToContext(context, lineWidth, strokeStyle, dash) {
        context.lineWidth = lineWidth;
        context.strokeStyle = strokeStyle;
        context.setLineDash(dash);
        context.stroke();
    }
    /**
     * Updates the position of this layer's labels based on the position of the ring.
     */
    updateLabelPositions() {
        const len = this.labels.length;
        for (let i = 0; i < len; i++) {
            this.labels[i].setRingPosition(this.center, this.radius);
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { style: 'position: absolute; left: 0; top: 0; width: 100%; height: 100%;' },
            FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection }),
            FSComponent.buildComponent("div", { ref: this.labelContainerRef, style: 'position: absolute; left: 0; top: 0; width: 100%; height: 100%;' })));
    }
}
/**
 *
 */
class MapLabeledRingLabelClass {
    /**
     * Constructor.
     * @param content The content of this label.
     * @param wrapper The wrapper for this label.
     */
    constructor(content, wrapper) {
        this.content = content;
        this.wrapper = wrapper;
        this.center = new Float64Array(2);
        this.radius = 0;
        this.anchor = new Float64Array(2);
        this.radialAngle = 0;
        this.radialOffset = 0;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getAnchor() {
        return this.anchor;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getRadialAngle() {
        return this.radialAngle;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getRadialOffset() {
        return this.radialOffset;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setAnchor(anchor) {
        this.anchor.set(anchor);
        this.wrapper.style.transform = `translate(${-anchor[0] * 100}%, ${-anchor[1] * 100}%)`;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setRadialAngle(angle) {
        if (this.radialAngle === angle) {
            return;
        }
        this.radialAngle = angle;
        this.updatePosition();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setRadialOffset(offset) {
        if (this.radialOffset === offset) {
            return;
        }
        this.radialOffset = offset;
        this.updatePosition();
    }
    /**
     * Sets the center and radius of this label's parent ring.
     * @param center The center of the ring, in pixels.
     * @param radius The radius of the ring, in pixels.
     */
    setRingPosition(center, radius) {
        if (Vec2Math.equals(this.center, center) && radius === this.radius) {
            return;
        }
        this.center.set(center);
        this.radius = radius;
        this.updatePosition();
    }
    /**
     * Updates this label's position.
     */
    updatePosition() {
        const pos = MapLabeledRingLabelClass.tempVec2_1;
        Vec2Math.setFromPolar(this.radius + this.radialOffset, this.radialAngle, pos);
        Vec2Math.add(this.center, pos, pos);
        this.wrapper.style.left = `${pos[0]}px`;
        this.wrapper.style.top = `${pos[1]}px`;
    }
}
MapLabeledRingLabelClass.tempVec2_1 = new Float64Array(2);

/**
 * A layer which draws an own airplane icon.
 */
class MapOwnAirplaneLayer extends MapLayer {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.iconImgRef = FSComponent.createRef();
        this.iconOffset = new Float64Array(2);
        this.updateFlags = 0;
        this.iconOffset.set(this.props.iconAnchor);
        Vec2Math.multScalar(this.iconOffset, -this.props.iconSize, this.iconOffset);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        this.scheduleUpdate(MapOwnAirplaneLayer.UPDATE_VISIBILITY);
    }
    /** @inheritdoc */
    onAttached() {
        const ownAirplaneIconModule = this.props.model.getModule('ownAirplaneIcon');
        ownAirplaneIconModule.show.sub(this.onIconShowChanged.bind(this));
        const ownAirplanePropsModule = this.props.model.getModule('ownAirplaneProps');
        ownAirplanePropsModule.position.sub(this.onAirplanePositionChanged.bind(this));
        ownAirplanePropsModule.hdgTrue.sub(this.onAirplaneHeadingChanged.bind(this));
        const img = this.iconImgRef.instance;
        img.style.left = `${this.iconOffset[0]}px`;
        img.style.top = `${this.iconOffset[1]}px`;
        img.style.transformOrigin = `${this.props.iconAnchor[0] * 100}% ${this.props.iconAnchor[1] * 100}%`;
        this.scheduleUpdate(MapOwnAirplaneLayer.UPDATE_VISIBILITY | MapOwnAirplaneLayer.UPDATE_TRANSFORM);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.scheduleUpdate(MapOwnAirplaneLayer.UPDATE_TRANSFORM);
    }
    /**
     * Schedules an update.
     * @param updateFlags The types of updates to schedule.
     */
    scheduleUpdate(updateFlags) {
        this.updateFlags = BitFlags.union(this.updateFlags, updateFlags);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        if (this.updateFlags === 0) {
            return;
        }
        if (BitFlags.isAll(this.updateFlags, MapOwnAirplaneLayer.UPDATE_VISIBILITY)) {
            this.updateIconVisibility();
        }
        if (BitFlags.isAll(this.updateFlags, MapOwnAirplaneLayer.UPDATE_TRANSFORM)) {
            this.updateIconTransform();
        }
        this.updateFlags = BitFlags.not(this.updateFlags, MapOwnAirplaneLayer.UPDATE_VISIBILITY | MapOwnAirplaneLayer.UPDATE_TRANSFORM);
    }
    /**
     * Updates the airplane icon's visibility.
     */
    updateIconVisibility() {
        const show = this.isVisible() && this.props.model.getModule('ownAirplaneIcon').show.get();
        this.iconImgRef.instance.style.display = show ? 'block' : 'none';
    }
    /**
     * Updates the airplane icon's display transformation.
     */
    updateIconTransform() {
        const ownAirplanePropsModule = this.props.model.getModule('ownAirplaneProps');
        const projected = this.props.mapProjection.project(ownAirplanePropsModule.position.get(), MapOwnAirplaneLayer.tempVec2_1);
        const rotation = ownAirplanePropsModule.hdgTrue.get() + this.props.mapProjection.getRotation() * Avionics.Utils.RAD2DEG;
        this.iconImgRef.instance.style.transform = `translate(${projected[0].toFixed(1)}px, ${projected[1].toFixed(1)}px) rotate(${rotation.toFixed(1)}deg) rotateX(0deg)`;
    }
    /**
     * A callback which is called when the show airplane icon property changes.
     * @param show The new value of the show airplane icon property.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onIconShowChanged(show) {
        this.scheduleUpdate(MapOwnAirplaneLayer.UPDATE_VISIBILITY);
    }
    /**
     * A callback which is called when the airplane's position changes.
     * @param pos The new position of the airplane.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onAirplanePositionChanged(pos) {
        this.scheduleUpdate(MapOwnAirplaneLayer.UPDATE_TRANSFORM);
    }
    /**
     * A callback which is called when the airplane's true heading changes.
     * @param hdgTrue - the new true heading of the airplane.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onAirplaneHeadingChanged(hdgTrue) {
        this.scheduleUpdate(MapOwnAirplaneLayer.UPDATE_TRANSFORM);
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("img", { ref: this.iconImgRef, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', src: this.props.imageFilePath, style: `position: absolute; width: ${this.props.iconSize}px; height: ${this.props.iconSize}px; transform: rotateX(0deg);` }));
    }
}
MapOwnAirplaneLayer.UPDATE_VISIBILITY = 1;
MapOwnAirplaneLayer.UPDATE_TRANSFORM = 1 << 1;
MapOwnAirplaneLayer.tempVec2_1 = new Float64Array(2);

/**
 * A layer which displays text which can be culled to avoid overlap.
 */
class MapCullableTextLayer extends MapSyncedCanvasLayer {
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        super.onUpdated(time, elapsed);
        this.props.manager.update(this.props.mapProjection);
        this.redrawLabels();
    }
    /**
     * Clears this layer's canvas and redraws the currently visible labels registered to this layer's text manager.
     */
    redrawLabels() {
        const labels = this.props.manager.visibleLabels;
        const display = this.display;
        display.clear();
        for (let i = labels.length - 1; i >= 0; i--) {
            labels[i].draw(display.context, this.props.mapProjection);
        }
    }
}

var AirspaceRangeType;
(function (AirspaceRangeType) {
    AirspaceRangeType["ClassB"] = "ClassB";
    AirspaceRangeType["ClassC"] = "ClassC";
    AirspaceRangeType["ClassD"] = "ClassD";
    AirspaceRangeType["Restricted"] = "Restricted";
    AirspaceRangeType["MOA"] = "MOA";
    AirspaceRangeType["Other"] = "Other";
})(AirspaceRangeType || (AirspaceRangeType = {}));
/**
 * A module describing the display of airspaces.
 */
class MapAirspaceModule {
    constructor() {
        /** Whether to show airspaces. */
        this.show = Subject.create(true);
        // TODO: Defaults are hard-coded here for now, but eventually will want to move default definitions outside of this
        // class (probably to initialization code of specific MapModels).
        /** The index of the maximum nominal map range at which to show airspaces of a specific type. */
        this.maxRangeIndex = {
            [AirspaceRangeType.ClassB]: Subject.create(19),
            [AirspaceRangeType.ClassC]: Subject.create(21),
            [AirspaceRangeType.ClassD]: Subject.create(20),
            [AirspaceRangeType.Restricted]: Subject.create(19),
            [AirspaceRangeType.MOA]: Subject.create(19),
            [AirspaceRangeType.Other]: Subject.create(19),
        };
    }
}

/**
 * Orientation types for a map.
 */
var MapOrientation;
(function (MapOrientation) {
    MapOrientation[MapOrientation["NorthUp"] = 0] = "NorthUp";
    MapOrientation[MapOrientation["TrackUp"] = 1] = "TrackUp";
    MapOrientation[MapOrientation["HeadingUp"] = 2] = "HeadingUp";
})(MapOrientation || (MapOrientation = {}));
/**
 * A module describing the map orientation.
 */
class MapOrientationModule {
    constructor() {
        /** The orientation of the map. */
        this.orientation = Subject.create(MapOrientation.HeadingUp);
        /** Whether auto-north-up is active. */
        this.autoNorthUpActive = Subject.create(true);
    }
}

/**
 * A module describing the map range compass.
 */
class MapRangeCompassModule {
    constructor() {
        /** Whether to show the range compass. */
        this.show = Subject.create(true);
    }
}

/**
 * A module describing the map range ring.
 */
class MapRangeRingModule {
    constructor() {
        /** Whether to show the range ring. */
        this.show = Subject.create(true);
    }
}

/**
 * Map terrain display mode.
 */
var MapTerrainMode;
(function (MapTerrainMode) {
    MapTerrainMode[MapTerrainMode["None"] = 0] = "None";
    MapTerrainMode[MapTerrainMode["Absolute"] = 1] = "Absolute";
    MapTerrainMode[MapTerrainMode["Relative"] = 2] = "Relative";
    MapTerrainMode[MapTerrainMode["Ground"] = 3] = "Ground";
})(MapTerrainMode || (MapTerrainMode = {}));
/**
 * A module describing the display of terrain.
 */
class MapTerrainModule {
    constructor() {
        /** The terrain display mode. */
        this.terrainMode = Subject.create(MapTerrainMode.Absolute);
        /** Whether to show the terrain scale. */
        this.showScale = Subject.create(false);
    }
}

/**
 * An abstract implementation of Waypoint.
 */
class AbstractWaypoint {
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(other) {
        return this.uid === other.uid;
    }
}
/**
 * A waypoint with custom defined lat/lon coordinates.
 */
class CustomWaypoint extends AbstractWaypoint {
    /**
     * Constructor.
     * @param lat The latitude of this waypoint.
     * @param lon The longitude of this waypoint.
     * @param uidPrefix The prefix of this waypoint's UID.
     */
    constructor(lat, lon, uidPrefix) {
        super();
        this._location = new GeoPoint(lat, lon);
        this._uid = `${uidPrefix}[${this.location.lat},${this.location.lon}]`;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get location() {
        return this._location.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get uid() {
        return this._uid;
    }
}
/**
 * A waypoint associated with a facility.
 */
class FacilityWaypoint extends AbstractWaypoint {
    /**
     * Constructor.
     * @param facility The facility associated with this waypoint.
     */
    constructor(facility) {
        super();
        this.facility = facility;
        this._location = new GeoPoint(facility.lat, facility.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get location() {
        return this._location.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get uid() {
        return this.facility.icao;
    }
}
/**
 * Airport size.
 */
var AirportSize;
(function (AirportSize) {
    AirportSize["Large"] = "Large";
    AirportSize["Medium"] = "Medium";
    AirportSize["Small"] = "Small";
})(AirportSize || (AirportSize = {}));
/**
 * A waypoint associated with an airport.
 */
class AirportWaypoint extends FacilityWaypoint {
    /**
     * Constructor.
     * @param airport The airport associated with this waypoint.
     */
    constructor(airport) {
        super(airport);
        this.longestRunway = AirportWaypoint.getLongestRunway(airport);
        this.size = AirportWaypoint.getAirportSize(airport, this.longestRunway);
    }
    /**
     * Gets the longest runway at an airport.
     * @param airport An airport.
     * @returns the longest runway at an airport, or null if the airport has no runways.
     */
    static getLongestRunway(airport) {
        if (airport.runways.length === 0) {
            return null;
        }
        return airport.runways.reduce((a, b) => a.length > b.length ? a : b);
    }
    /**
     * Gets the size of an airport.
     * @param airport An airport.
     * @param longestRunway The longest runway at the airport.
     * @returns the size of the airport.
     */
    static getAirportSize(airport, longestRunway) {
        if (!longestRunway) {
            return AirportSize.Small;
        }
        const longestRwyLengthFeet = UnitType.METER.convertTo(longestRunway.length, UnitType.FOOT);
        return longestRwyLengthFeet >= 8100 ? AirportSize.Large
            : (longestRwyLengthFeet >= 5000 || airport.towered) ? AirportSize.Medium
                : AirportSize.Small;
    }
}
/**
 * A flight path waypoint.
 */
class FlightPathWaypoint extends CustomWaypoint {
    /**
     * Constructor.
     * @param lat The latitude of this waypoint.
     * @param lon The longitude of this waypoint.
     * @param ident The ident string of this waypoint.
     */
    constructor(lat, lon, ident) {
        super(lat, lon, `${FlightPathWaypoint.UID_PREFIX}_${ident}`);
        this.ident = ident;
    }
}
FlightPathWaypoint.UID_PREFIX = 'FLPTH';
/**
 * A VNAV TOD/BOD waypoint.
 */
class VNavWaypoint extends AbstractWaypoint {
    /**
     * Constructor.
     * @param leg The leg that the VNAV waypoint is contained in.
     * @param distanceFromEnd The distance along the flight path from the end of the leg to the location of the waypoint,
     * in meters.
     * @param type The type of VNAV leg.
     */
    constructor(leg, distanceFromEnd, type) {
        super();
        this._uid = VNavWaypoint.uidMap[type];
        this._location = this.getWaypointLocation(leg, distanceFromEnd);
    }
    /**
     * Gets the waypoint's location in space.
     * @param leg The leg that the waypoint resides in.
     * @param distanceFromEnd The distance along the flight path from the end of the leg to the location of the waypoint,
     * in meters.
     * @returns The waypoint's location.
     */
    getWaypointLocation(leg, distanceFromEnd) {
        const out = new GeoPoint(0, 0);
        if (leg.calculated !== undefined) {
            let vectorIndex = leg.calculated.flightPath.length - 1;
            const ingressTurn = leg.calculated.ingressTurn;
            const egressTurn = leg.calculated.egressTurn;
            while (vectorIndex >= 0) {
                const vector = leg.calculated.flightPath[vectorIndex];
                const start = VNavWaypoint.vec3Cache[0];
                const end = VNavWaypoint.vec3Cache[1];
                if (vectorIndex === leg.calculated.flightPath.length - 1 && egressTurn.radius !== 0) {
                    if (egressTurn.distance >= distanceFromEnd) {
                        const egressCircle = FlightPathUtils.setGeoCircleFromVector(egressTurn, VNavWaypoint.geoCircleCache[0]);
                        const turnEnd = VNavWaypoint.geoPointCache[0].set(egressTurn.endLat, egressTurn.endLon);
                        return egressCircle.offsetDistanceAlong(turnEnd, UnitType.METER.convertTo(-distanceFromEnd, UnitType.GA_RADIAN), out);
                    }
                    else {
                        distanceFromEnd -= egressTurn.distance;
                        GeoPoint.sphericalToCartesian(egressTurn.startLat, egressTurn.startLon, end);
                    }
                }
                else {
                    GeoPoint.sphericalToCartesian(vector.endLat, vector.endLon, end);
                }
                if (vectorIndex === 0 && ingressTurn.radius !== 0) {
                    GeoPoint.sphericalToCartesian(ingressTurn.endLat, ingressTurn.endLon, start);
                }
                else {
                    GeoPoint.sphericalToCartesian(vector.startLat, vector.startLon, start);
                }
                const circle = FlightPathUtils.setGeoCircleFromVector(vector, VNavWaypoint.geoCircleCache[0]);
                const vectorDistance = UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end), UnitType.METER);
                if (vectorDistance >= distanceFromEnd) {
                    return circle.offsetDistanceAlong(end, UnitType.METER.convertTo(-distanceFromEnd, UnitType.GA_RADIAN), out);
                }
                else {
                    distanceFromEnd -= vectorDistance;
                }
                if (vectorIndex === 0) {
                    if (ingressTurn.radius !== 0) {
                        if (ingressTurn.distance >= distanceFromEnd) {
                            const ingressCircle = FlightPathUtils.setGeoCircleFromVector(ingressTurn, VNavWaypoint.geoCircleCache[0]);
                            const turnEnd = VNavWaypoint.geoPointCache[0].set(ingressTurn.endLat, ingressTurn.endLon);
                            return ingressCircle.offsetDistanceAlong(turnEnd, UnitType.METER.convertTo(-distanceFromEnd, UnitType.GA_RADIAN), new GeoPoint(0, 0));
                        }
                        else {
                            return out.set(ingressTurn.startLat, ingressTurn.startLon);
                        }
                    }
                    else {
                        return out.set(vector.startLat, vector.startLon);
                    }
                }
                vectorIndex--;
            }
        }
        return out;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get location() {
        return this._location.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get uid() {
        return this._uid;
    }
}
VNavWaypoint.uidMap = { 'tod': 'vnav-tod', 'bod': 'vnav-bod' };
VNavWaypoint.vec3Cache = [new Float64Array(3), new Float64Array(3)];
VNavWaypoint.geoPointCache = [new GeoPoint(0, 0)];
VNavWaypoint.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/**
 * A module describing the display of waypoints.
 */
class MapWaypointsModule {
    constructor() {
        /** Whether to show airports. */
        this.airportShow = {
            [AirportSize.Large]: Subject.create(true),
            [AirportSize.Medium]: Subject.create(true),
            [AirportSize.Small]: Subject.create(true)
        };
        /** Whether to show VORs. */
        this.vorShow = Subject.create(true);
        /** Whether to show NDBs. */
        this.ndbShow = Subject.create(true);
        /** Whether to show intersections. */
        this.intShow = Subject.create(true);
    }
}

/**
 * A module for map weather radar mode data.
 */
class MapNexradModule {
    constructor() {
        this.showNexrad = Subject.create(false);
    }
}

var MapDeclutterMode;
(function (MapDeclutterMode) {
    MapDeclutterMode[MapDeclutterMode["All"] = 0] = "All";
    MapDeclutterMode[MapDeclutterMode["Level3"] = 1] = "Level3";
    MapDeclutterMode[MapDeclutterMode["Level2"] = 2] = "Level2";
    MapDeclutterMode[MapDeclutterMode["Level1"] = 3] = "Level1";
})(MapDeclutterMode || (MapDeclutterMode = {}));
/**
 * A module describing the declutter mode.
 */
class MapDeclutterModule {
    constructor() {
        this.mode = Subject.create(MapDeclutterMode.All);
    }
}

/**
 * A module describing the map pointer.
 */
class MapPointerModule {
    constructor() {
        /** Whether the pointer is active. */
        this.isActive = Subject.create(false);
        /** The position of the pointer on the projected map, in pixel coordinates. */
        this.position = Vec2Subject.createFromVector(new Float64Array(2));
        /** The desired map target. */
        this.target = GeoPointSubject.createFromGeoPoint(new GeoPoint(0, 0));
    }
}

/**
 * A module for the map crosshair.
 */
class MapCrosshairModule {
    constructor() {
        this.show = Subject.create(false);
    }
}

/**
 * Class for creating navmap models.
 */
class NavMapModel {
    /**
     * Creates an instance of a navmap model.
     * @param tcas A TCAS to use to get traffic avoidance information.
     * @param options Initialization options for the new model.
     * @returns a navmap model instance.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static createModel(tcas, options) {
        const model = new MapModel();
        model.addModule('range', new MapIndexedRangeModule());
        model.addModule('orientation', new MapOrientationModule());
        model.addModule('declutter', new MapDeclutterModule());
        model.addModule('terrain', new MapTerrainModule());
        model.addModule('ownAirplaneProps', new MapOwnAirplanePropsModule());
        model.addModule('ownAirplaneIcon', new MapOwnAirplaneIconModule());
        model.addModule('rangeRing', new MapRangeRingModule());
        model.addModule('rangeCompass', new MapRangeCompassModule());
        model.addModule('waypoints', new MapWaypointsModule());
        model.addModule('airspace', new MapAirspaceModule());
        model.addModule('traffic', new MapTrafficModule(tcas));
        model.addModule('nexrad', new MapNexradModule());
        model.addModule('pointer', new MapPointerModule());
        model.addModule('crosshair', new MapCrosshairModule());
        return model;
    }
}

/**
 * A compass rose display component.
 */
class CompassRose extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.bearingPointerCircleElement = FSComponent.createRef();
    }
    /**
     * Builds the compass rose tick marks.
     * @returns A collection of rose tick line elements.
     */
    buildRose() {
        const lines = [];
        const half = this.props.size / 2;
        const roseRadius = half - this.props.margin;
        for (let i = 0; i < 360; i += 5) {
            const length = i % 10 == 0 ? 15 : 8;
            const startX = half + (roseRadius - length) * Math.cos(i * Math.PI / 180);
            const startY = half + (roseRadius - length) * Math.sin(i * Math.PI / 180);
            const endX = startX + (length * Math.cos(i * Math.PI / 180));
            const endY = startY + (length * Math.sin(i * Math.PI / 180));
            lines.push(FSComponent.buildComponent("line", { x1: startX, y1: startY, x2: endX, y2: endY, stroke: "white", "stroke-width": "1.8px" }));
        }
        return lines;
    }
    /**
     * Builds the compass rose letter markings.
     * @returns A collection of letter marking text elements.
     */
    buildRoseMarkings() {
        const half = this.props.size / 2;
        const texts = ['N', '3', '6', 'E', '12', '15', 'S', '21', '24', 'W', '30', '33'];
        const letters = [];
        let angle = 0;
        for (let i = 0; i < texts.length; i++) {
            const fontSize = i % 3 === 0 ? '26' : '20';
            const yValue = i % 3 === 0 ? (38 + this.props.margin).toFixed(0) : (32 + this.props.margin).toFixed(0);
            letters.push(FSComponent.buildComponent("text", { x: half, y: yValue, transform: `rotate(${angle}, ${half}, ${half})`, fill: "white", "text-anchor": "middle", "font-size": fontSize }, texts[i]));
            angle += 360 / texts.length;
        }
        return letters;
    }
    /**
     * Sets whether or not the bearing pointer circle is visible.
     * @param isVisible Whether or not the bearing pointer circle is visible.
     */
    setCircleVisible(isVisible) {
        this.bearingPointerCircleElement.instance.style.display = isVisible ? '' : 'none';
    }
    /**
     * Renders the component.
     * @returns The rendered VNode.
     */
    render() {
        const viewBox = `0 0 ${this.props.size} ${this.props.size}`;
        const half = `${this.props.size / 2}px`;
        const radius = `${(this.props.size / 2) - this.props.margin}px`;
        return (FSComponent.buildComponent("svg", { viewBox: viewBox },
            FSComponent.buildComponent("radialGradient", { id: "bgFill" },
                FSComponent.buildComponent("stop", { offset: "80%", "stop-color": "rgb(0,0,0)", "stop-opacity": "0.00" }),
                FSComponent.buildComponent("stop", { offset: "100%", "stop-color": "rgb(0,0,0)", "stop-opacity": "0.75" })),
            FSComponent.buildComponent("circle", { cx: half, cy: half, r: radius, fill: this.props.gradient ? 'url("#bgFill")' : 'rgba(0,0,0,.3)' }),
            FSComponent.buildComponent("circle", { ref: this.bearingPointerCircleElement, cx: half, cy: half, r: "82px", stroke: "white", "stroke-width": "1px", fill: "none" }),
            this.buildRose(),
            this.buildRoseMarkings()));
    }
}

/**
 * Animates course and bearing needle elements.
 */
class NeedleAnimator {
    /**
     * Creates an instance of a NeedleAnimator.
     * @param el The reference to the element to animate.
     */
    constructor(el) {
        this.el = el;
        this.currentValue = 0;
        this.targetValue = 0;
        /**
         * A callback called when the needle animation transtion ends.
         */
        this.onTransitionEnd = () => {
            this.el.instance.classList.remove('needle-transition');
            this.currentValue = this.targetValue;
            this.el.instance.style.transform = `rotate3d(0, 0, 1, ${this.targetValue}deg)`;
        };
        el.instance.addEventListener('transitionend', this.onTransitionEnd);
    }
    /**
     * Rotates the element to the supplied value in degrees.
     * @param val The value to rotate to.
     */
    rotateTo(val) {
        this.targetValue = val;
        const diff = Math.abs(NavMath.diffAngle(this.currentValue, this.targetValue));
        if (diff >= 2) {
            const turnDirection = NavMath.getTurnDirection(this.currentValue, this.targetValue);
            this.el.instance.classList.add('needle-transition');
            this.el.instance.style.transform = `rotate3d(0, 0, 1, ${this.currentValue + (diff * (turnDirection === 'right' ? 1 : -1))}deg)`;
        }
        else {
            this.currentValue = this.targetValue;
            this.el.instance.style.transform = `rotate3d(0, 0, 1, ${this.targetValue}deg)`;
        }
    }
}

/**
 * An interface that describes a course needle component.
 */
class CourseNeedleComponent extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.needleRef = new NodeReference();
        this.deviationRef = new NodeReference();
        this.toFromRef = new NodeReference();
        this.currentDeviation = 0;
    }
    /**
     * A callback called after rendering completes.
     */
    onAfterRender() {
        this.animator = new NeedleAnimator(this.needleRef);
    }
    /**
     * Sets the rotation of the course needle.
     * @param rotation The rotation of the course needle.
     */
    setRotation(rotation) {
        this.animator && this.animator.rotateTo(rotation);
    }
    /**
     * Sets the deviation of the course needle.
     * @param deviation The deviation of the course needle.
     */
    setDeviation(deviation) {
        this.currentDeviation = deviation;
        const deviationPercent = this.currentDeviation;
        const deviationPixels = NavMath.clamp(deviationPercent, -1, 1) * 80;
        this.deviationRef.instance.style.transform = `translate3d(${deviationPixels}px, 0px, 0px)`;
    }
    /**
     * Sets whether or not the course needle is visible.
     * @param isVisible The visibility of the course needle.
     */
    setVisible(isVisible) {
        this.needleRef.instance.style.display = isVisible ? '' : 'none';
    }
    /**
     * Sets whether or not the course deviation indicator is visible.
     * @param isVisible The visibility of the course deviation indicator.
     */
    setDeviationVisible(isVisible) {
        this.deviationRef.instance.style.display = isVisible ? '' : 'none';
        this.toFromRef.instance.style.display = isVisible ? '' : 'none';
    }
    /**
     * Sets whether the to/from flag should indicate to or from.
     * @param from a bool set to true when the flag should be set to FROM.
     */
    setFromFlag(from) {
        this.toFromRef.instance.style.transform = from ? 'rotate3d(0, 0, 1, 180deg)' : 'rotate3d(0, 0, 1, 0deg)';
    }
}

/**
 * A GPS course needle component.
 */
class GpsNeedle extends CourseNeedleComponent {
    /**
     * Renders the component.
     * @returns The rendered VNode.
     */
    render() {
        if (this.props.hsiMap) {
            return (FSComponent.buildComponent("div", { ref: this.needleRef, class: "hsi-map-needle" },
                FSComponent.buildComponent("svg", { viewBox: "0 0 386 340" },
                    FSComponent.buildComponent("path", { d: "M 173 48 l 0 -18 c 0.003 -0.811 -0.406 -1.62 -1.635 -1.619 l -6.885 0 c -1.62 0 -1.62 -0.81 -1.215 -1.215 l 10.935 -10.935 c 0 0 0.809 -0.812 1.62 0 l 10.935 10.935 c 0.405 0.405 0.405 1.215 -1.215 1.215 l -6.885 0 c -1.215 0 -1.62 0.81 -1.62 1.62 l 0 18 M 173 308 l 0 24.3 c 0 0.81 0.405 1.62 1.215 1.62 l 1.62 0 c 0.81 0 1.215 -0.81 1.215 -1.62 l 0 -24.3", fill: "magenta", stroke: "black", "stroke-width": "1.5px" }))));
        }
        else {
            return (FSComponent.buildComponent("div", { ref: this.needleRef, class: "hsi-rose-needle-group" },
                FSComponent.buildComponent("svg", { viewBox: "0 0 386 340" },
                    FSComponent.buildComponent("path", { d: "M 183 53 l -13.5 13.5 c -0.5 0.5 -0.5 1.5 1.5 1.5 l 8.5 0 c 1.5 0 2 1 2 2 l 0 46 c 0 1 0.5 2 1.5 2 l 2 0 c 1 0 1.5 -1 1.5 -2 l 0 -46 c 0 -1 0.5 -2 2 -2 l 8.5 0 c 2 0 2 -1 1.5 -1.5 l -13.5 -13.5 c -1 -1 -2 0 -2 0 z M 184 249 l -1 0 c -0.5 0 -1.5 0 -1.5 2 l 0 62 c 0 1 0.5 2 1.5 2 l 2 0 c 1 0 1.5 -1 1.5 -2 l 0 -62 c 0 -2 -1 -2 -1.5 -2 z", fill: "magenta", stroke: "black", "stroke-width": "1px" }),
                    FSComponent.buildComponent("circle", { cx: "120px", cy: "185px", r: "4px", stroke: "white", "stroke-width": "1.0px", fill: "none" }),
                    FSComponent.buildComponent("circle", { cx: "152px", cy: "185px", r: "4px", stroke: "white", "stroke-width": "1.0px", fill: "none" }),
                    FSComponent.buildComponent("circle", { cx: "216px", cy: "185px", r: "4px", stroke: "white", "stroke-width": "1.0px", fill: "none" }),
                    FSComponent.buildComponent("circle", { cx: "248px", cy: "185px", r: "4px", stroke: "white", "stroke-width": "1.0px", fill: "none" })),
                FSComponent.buildComponent("div", { ref: this.toFromRef, class: "hsi-rose-needle-group" },
                    FSComponent.buildComponent("svg", { viewBox: "0 0 386 340" },
                        FSComponent.buildComponent("path", { d: "M 184 113 l -12 12 l 24 0 l -12 -12 z", fill: "magenta", stroke: "black", "stroke-width": "1px" }))),
                FSComponent.buildComponent("div", { ref: this.deviationRef, class: "hsi-rose-needle-group" },
                    FSComponent.buildComponent("svg", { viewBox: "0 0 386 340" },
                        FSComponent.buildComponent("path", { d: "M 184 130 l -1 0 c -1 0 -1.5 1 -1.5 2 l 0 109 c 0 1 0.5 2 1.5 2 l 2 0 c 1 0 1.5 -1 1.5 -2 l 0 -109 c 0 -1 -0.5 -2 -1.5 -2 z", fill: "magenta", stroke: "black", "stroke-width": "1px" })))));
        }
    }
}

/**
 * A VOR1 course needle component.
 */
class Nav1Needle extends CourseNeedleComponent {
    /**
     * Renders the component.
     * @returns The rendered VNode.
     */
    render() {
        if (this.props.hsiMap) {
            return (FSComponent.buildComponent("div", { ref: this.needleRef, class: "hsi-map-needle" },
                FSComponent.buildComponent("svg", { viewBox: "0 0 386 340" },
                    FSComponent.buildComponent("path", { d: "M 173 48 l 0 -18 c 0.003 -0.811 -0.406 -1.62 -1.635 -1.619 l -6.885 0 c -1.62 0 -1.62 -0.81 -1.215 -1.215 l 10.935 -10.935 c 0 0 0.809 -0.812 1.62 0 l 10.935 10.935 c 0.405 0.405 0.405 1.215 -1.215 1.215 l -6.885 0 c -1.215 0 -1.62 0.81 -1.62 1.62 l 0 18 M 173 308 l 0 24.3 c 0 0.81 0.405 1.62 1.215 1.62 l 1.62 0 c 0.81 0 1.215 -0.81 1.215 -1.62 l 0 -24.3", fill: "rgb(0,255,0)", stroke: "black", "stroke-width": "1.5px" }))));
        }
        else {
            return (FSComponent.buildComponent("div", { ref: this.needleRef, class: "hsi-rose-needle-group" },
                FSComponent.buildComponent("svg", { viewBox: "0 0 386 340" },
                    FSComponent.buildComponent("path", { d: "M 183 53 l -13.5 13.5 c -0.5 0.5 -0.5 1.5 1.5 1.5 l 8.5 0 c 1.5 0 2 1 2 2 l 0 46 c 0 1 0.5 2 1.5 2 l 2 0 c 1 0 1.5 -1 1.5 -2 l 0 -46 c 0 -1 0.5 -2 2 -2 l 8.5 0 c 2 0 2 -1 1.5 -1.5 l -13.5 -13.5 c -1 -1 -2 0 -2 0 z M 184 249 l -1 0 c -0.5 0 -1.5 0 -1.5 2 l 0 62 c 0 1 0.5 2 1.5 2 l 2 0 c 1 0 1.5 -1 1.5 -2 l 0 -62 c 0 -2 -1 -2 -1.5 -2 z", fill: "rgb(0,255,0)", stroke: "black", "stroke-width": "1px" }),
                    FSComponent.buildComponent("circle", { cx: "120px", cy: "185px", r: "4px", stroke: "white", "stroke-width": "1.0px", fill: "none" }),
                    FSComponent.buildComponent("circle", { cx: "152px", cy: "185px", r: "4px", stroke: "white", "stroke-width": "1.0px", fill: "none" }),
                    FSComponent.buildComponent("circle", { cx: "216px", cy: "185px", r: "4px", stroke: "white", "stroke-width": "1.0px", fill: "none" }),
                    FSComponent.buildComponent("circle", { cx: "248px", cy: "185px", r: "4px", stroke: "white", "stroke-width": "1.0px", fill: "none" })),
                FSComponent.buildComponent("div", { ref: this.toFromRef, class: "hsi-rose-needle-group" },
                    FSComponent.buildComponent("svg", { viewBox: "0 0 386 340" },
                        FSComponent.buildComponent("path", { d: "M 184 113 l -12 12 l 24 0 l -12 -12 z", fill: "rgb(0,255,0)", stroke: "black", "stroke-width": "1px" }))),
                FSComponent.buildComponent("div", { ref: this.deviationRef, class: "hsi-rose-needle-group" },
                    FSComponent.buildComponent("svg", { viewBox: "0 0 386 340" },
                        FSComponent.buildComponent("path", { d: "M 184 130 l -1 0 c -1 0 -1.5 1 -1.5 2 l 0 109 c 0 1 0.5 2 1.5 2 l 2 0 c 1 0 1.5 -1 1.5 -2 l 0 -109 c 0 -1 -0.5 -2 -1.5 -2 z", fill: "rgb(0,255,0)", stroke: "black", "stroke-width": "1px" })))));
        }
    }
}

/**
 * A VOR2 course needle component.
 */
class Nav2Needle extends CourseNeedleComponent {
    /**
     * Renders the component.
     * @returns The rendered VNode.
     */
    render() {
        if (this.props.hsiMap) {
            return (FSComponent.buildComponent("div", { ref: this.needleRef, class: "hsi-map-needle" },
                FSComponent.buildComponent("svg", { viewBox: "0 0 386 340" },
                    FSComponent.buildComponent("path", { d: "M 173 48 l 0 -18 c 0.003 -0.811 -0.406 -1.62 -1.635 -1.619 l -6.885 0 c -1.62 0 -1.62 -0.81 -1.215 -1.215 l 10.935 -10.935 c 0 0 0.809 -0.812 1.62 0 l 10.935 10.935 c 0.405 0.405 0.405 1.215 -1.215 1.215 l -6.885 0 c -1.215 0 -1.62 0.81 -1.62 1.62 l 0 18 M 173 308 l 0 24.3 c 0 0.81 0.405 1.62 1.215 1.62 l 1.62 0 c 0.81 0 1.215 -0.81 1.215 -1.62 l 0 -24.3", fill: "none", stroke: "black", "stroke-width": "5px" }),
                    FSComponent.buildComponent("path", { d: "M 173 48 l 0 -18 c 0.003 -0.811 -0.406 -1.62 -1.635 -1.619 l -6.885 0 c -1.62 0 -1.62 -0.81 -1.215 -1.215 l 10.935 -10.935 c 0 0 0.809 -0.812 1.62 0 l 10.935 10.935 c 0.405 0.405 0.405 1.215 -1.215 1.215 l -6.885 0 c -1.215 0 -1.62 0.81 -1.62 1.62 l 0 18 M 173 308 l 0 24.3 c 0 0.81 0.405 1.62 1.215 1.62 l 1.62 0 c 0.81 0 1.215 -0.81 1.215 -1.62 l 0 -24.3", fill: "none", stroke: "rgb(0,255,0)", "stroke-width": "2px" }))));
        }
        else {
            return (FSComponent.buildComponent("div", { ref: this.needleRef, class: "hsi-rose-needle-group" },
                FSComponent.buildComponent("svg", { viewBox: "0 0 386 340" },
                    FSComponent.buildComponent("path", { d: "M 183 54 l -11.5 11.5 c -1.5 1.5 -0.5 1.5 1.5 1.5 l 6 0 c 1 0 2 1 2 2 l 0 47 c 0 1 0 2 2 2 l 2 0 c 2 0 2 -1 2 -2 l 0 -47 c 0 -1 1 -2 2 -2 l 7 0 c 1 0 2 0 0.5 -1.5 l -11.5 -11.5 c -1 -1 -1 -1 -2 0 M 184 249 l -1 0 c -2 0 -2 1 -2 2 l 0 62 c 0 1 0 2 2 2 l 2 0 c 2 0 2 -1 2 -2 l 0 -62 c 0 -1 0 -2 -2 -2 l -1 0", fill: "none", stroke: "black", "stroke-width": "4.5px" }),
                    FSComponent.buildComponent("path", { d: "M 183 54 l -11.5 11.5 c -1.5 1.5 -0.5 1.5 1.5 1.5 l 6 0 c 1 0 2 1 2 2 l 0 47 c 0 1 0 2 2 2 l 2 0 c 2 0 2 -1 2 -2 l 0 -47 c 0 -1 1 -2 2 -2 l 7 0 c 1 0 2 0 0.5 -1.5 l -11.5 -11.5 c -1 -1 -1 -1 -2 0 M 184 249 l -1 0 c -2 0 -2 1 -2 2 l 0 62 c 0 1 0 2 2 2 l 2 0 c 2 0 2 -1 2 -2 l 0 -62 c 0 -1 0 -2 -2 -2 l -1 0", fill: "none", stroke: "rgb(0,255,0)", "stroke-width": "2.5px" }),
                    FSComponent.buildComponent("circle", { cx: "120px", cy: "185px", r: "4px", stroke: "white", "stroke-width": "1.0px", fill: "none" }),
                    FSComponent.buildComponent("circle", { cx: "152px", cy: "185px", r: "4px", stroke: "white", "stroke-width": "1.0px", fill: "none" }),
                    FSComponent.buildComponent("circle", { cx: "216px", cy: "185px", r: "4px", stroke: "white", "stroke-width": "1.0px", fill: "none" }),
                    FSComponent.buildComponent("circle", { cx: "248px", cy: "185px", r: "4px", stroke: "white", "stroke-width": "1.0px", fill: "none" })),
                FSComponent.buildComponent("div", { ref: this.toFromRef, class: "hsi-rose-needle-group" },
                    FSComponent.buildComponent("svg", { viewBox: "0 0 386 340" },
                        FSComponent.buildComponent("path", { d: "M 184 113 l -12 12 l 24 0 l -12 -12 z", fill: "rgb(0,255,0)", stroke: "black", "stroke-width": "1px" }))),
                FSComponent.buildComponent("div", { ref: this.deviationRef, class: "hsi-rose-needle-group" },
                    FSComponent.buildComponent("svg", { viewBox: "0 0 386 340" },
                        FSComponent.buildComponent("path", { d: "M 184 130 l -1 0 c -2 0 -2 1 -2 2 l 0 109 c 0 1 0 2 2 2 l 2 0 c 2 0 2 -1 2 -2 l 0 -109 c 0 -1 0 -2 -2 -2 l -1 0", fill: "none", stroke: "black", "stroke-width": "4.5px" }),
                        FSComponent.buildComponent("path", { d: "M 184 130 l -1 0 c -2 0 -2 1 -2 2 l 0 109 c 0 1 0 2 2 2 l 2 0 c 2 0 2 -1 2 -2 l 0 -109 c 0 -1 0 -2 -2 -2 l -1 0", fill: "none", stroke: "rgb(0,255,0)", "stroke-width": "2.5px" })))));
        }
    }
}

/**
 * The course needles component on the HSI.
 */
class CourseNeedles extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.nav1Needle = new NodeReference();
        this.nav2Needle = new NodeReference();
        this.gpsNeedle = new NodeReference();
        this.el = new NodeReference();
        this.nav1Course = 0;
        this.nav2Course = 0;
        this.gpsDTK = 0;
        /**
         * Handles when the CDI source is selected.
         * @param source The CDI source event information.
         */
        this.onCDISelect = (source) => {
            if (source.type !== null) {
                switch (source.type) {
                    case NavSourceType.Nav:
                        this.setNavVisible(source.index);
                        break;
                    case NavSourceType.Gps:
                        this.setGpsVisible();
                        break;
                }
            }
        };
        /**
         * Handles when the OBS setting is changed.
         * @param setting The OBS setting to handle.
         */
        this.onOBSSet = (setting) => {
            if (setting.source.type == NavSourceType.Gps) ;
            else {
                switch (setting.source.index) {
                    case 1:
                        setting.heading !== null && (this.nav1Course = setting.heading);
                        break;
                    case 2:
                        setting.heading !== null && (this.nav1Course = setting.heading);
                        break;
                }
                setting.heading !== null && this.setNeedleRotations(setting.heading);
            }
        };
    }
    /**
     * A callback called after rendering is complete.
     */
    onAfterRender() {
        this.setDefaultVisibility();
    }
    /**
     * A method called from Hsi that commands an update to the format of the needles
     */
    updateSourceSensitivity() {
        this.onCDISelect(this.props.controller.navStates[this.props.controller.activeSourceIndex].source);
    }
    /**
     * A method called from Hsi that commands an update to the data driving the needles
     */
    updateData() {
        const dtk = this.props.controller.navStates[this.props.controller.activeSourceIndex].dtk_obs;
        if (dtk !== null) {
            this.setNeedleRotations(dtk);
        }
        if (!this.props.hsiMap) {
            const toFrom = this.props.controller.navStates[this.props.controller.activeSourceIndex].toFrom;
            if (toFrom !== null) {
                this.onToFrom(toFrom);
                const xtk = this.props.controller.navStates[this.props.controller.activeSourceIndex].deviation;
                switch (this.props.controller.navStates[this.props.controller.activeSourceIndex].source.type) {
                    case NavSourceType.Gps:
                        if (xtk !== null) {
                            this.gpsNeedle.instance.setDeviation(xtk);
                        }
                        break;
                    case NavSourceType.Nav:
                        if (this.props.controller.navStates[this.props.controller.activeSourceIndex].source.index == 1) {
                            if (xtk !== null) {
                                this.nav1Needle.instance.setDeviation(xtk);
                            }
                        }
                        else if (this.props.controller.navStates[this.props.controller.activeSourceIndex].source.index == 2) {
                            if (xtk !== null) {
                                this.nav2Needle.instance.setDeviation(xtk);
                            }
                        }
                        break;
                }
            }
        }
    }
    /**
     * Rotates the course needles component to the specified value in degrees.
     * @param val The value to rotate the course needles component to.
     */
    rotateComponent(val) {
        this.el.instance.style.transform = `rotate3d(0, 0, 1, ${-val}deg)`;
    }
    /**
     * Handles setting to/from flag and whether to display the deviation needle.
     * @param toFrom The value to rotate the course needles component to.
     */
    onToFrom(toFrom) {
        const source = this.props.controller.navStates[this.props.controller.activeSourceIndex];
        let showDeviationIndicator = true;
        let setFromFlag = false;
        switch (toFrom) {
            case VorToFrom.OFF:
                showDeviationIndicator = false;
                break;
            case VorToFrom.FROM:
                setFromFlag = true;
                break;
        }
        if (source.source.type === NavSourceType.Nav) {
            switch (this.props.controller.navStates[this.props.controller.activeSourceIndex].source.index) {
                case 1:
                    this.nav1Needle.instance.setDeviationVisible(showDeviationIndicator);
                    this.nav1Needle.instance.setFromFlag(setFromFlag);
                    break;
                case 2:
                    this.nav2Needle.instance.setDeviationVisible(showDeviationIndicator);
                    this.nav2Needle.instance.setFromFlag(setFromFlag);
                    break;
            }
        }
        else {
            this.gpsNeedle.instance.setDeviationVisible(showDeviationIndicator);
            this.gpsNeedle.instance.setFromFlag(setFromFlag);
        }
    }
    /**
     * Sets the default visibility of the course needles.
     */
    setDefaultVisibility() {
        this.nav1Needle.instance.setVisible(true);
        this.nav2Needle.instance.setVisible(false);
        this.gpsNeedle.instance.setVisible(false);
    }
    /**
     * Sets the rotations of the course needles.
     * @param val The heading value to set the rotation to.
     */
    setNeedleRotations(val) {
        this.nav1Needle.instance.setRotation(val);
        this.nav2Needle.instance.setRotation(val);
        this.gpsNeedle.instance.setRotation(val);
    }
    /**
     * Sets a nav needle as visible.
     * @param index The nav radio index to set visible.
     */
    setNavVisible(index) {
        this.gpsNeedle.instance.setVisible(false);
        if (index === 1) {
            this.nav1Needle.instance.setVisible(true);
            this.nav2Needle.instance.setVisible(false);
        }
        else {
            this.nav1Needle.instance.setVisible(false);
            this.nav2Needle.instance.setVisible(true);
        }
        const dtk = this.props.controller.navStates[this.props.controller.activeSourceIndex].dtk_obs;
        setTimeout(() => {
            if (dtk !== null) {
                this.setNeedleRotations(dtk);
            }
        });
    }
    /**
     * Sets the GPS needle as visible.
     */
    setGpsVisible() {
        this.nav1Needle.instance.setVisible(false);
        this.nav2Needle.instance.setVisible(false);
        this.gpsNeedle.instance.setVisible(true);
        const dtk = this.props.controller.navStates[this.props.controller.activeSourceIndex].dtk_obs;
        setTimeout(() => {
            if (dtk !== null) {
                this.setNeedleRotations(dtk);
            }
            if (!this.props.hsiMap) {
                this.gpsNeedle.instance.setDeviationVisible(this.props.controller.isLnavCalculating.get());
            }
        });
    }
    /**
     * Renders the course needles component.
     * @returns The rendered VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "course-needles-rotating", ref: this.el },
            FSComponent.buildComponent(Nav1Needle, { ref: this.nav1Needle, hsiMap: this.props.hsiMap }),
            FSComponent.buildComponent(Nav2Needle, { ref: this.nav2Needle, hsiMap: this.props.hsiMap }),
            FSComponent.buildComponent(GpsNeedle, { ref: this.gpsNeedle, hsiMap: this.props.hsiMap })));
    }
}

/**
 * The course needles component on the HSI.
 */
class HSIMapCourseDeviation extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.el = FSComponent.createRef();
        this.diamondIndicatorDiv = FSComponent.createRef();
        this.triangleIndicatorDiv = FSComponent.createRef();
        this.diamondIndicatorPath = FSComponent.createRef();
        this.triangleIndicatorPath = FSComponent.createRef();
        this.hsiMapDeviation = FSComponent.createRef();
        this.hideableObjects = FSComponent.createRef();
        this.noSignalDiv = FSComponent.createRef();
        this.suspDiv = FSComponent.createRef();
        this.currentDeviation = 0;
        this.noSignalStr = Subject.create('SIGNAL');
        this.xtkStr = Subject.create('0');
        this.xtkUnit = Subject.create('NM');
        this.sensitivityStr = Subject.create('ENR');
        this.sensitivityRef = FSComponent.createRef();
        this.sourceStr = Subject.create('GPS');
        this.sourceRef = FSComponent.createRef();
    }
    /**
     * A callback called after rendering is complete.
     */
    onAfterRender() {
        this.setVisible(this.triangleIndicatorDiv, false);
        this.setVisible(this.diamondIndicatorDiv, false);
        this.setVisible(this.noSignalDiv, false);
    }
    /**
     * A method called from Hsi Controller that commands an update on a change in any relevant value
     */
    updateData() {
        const xtk = this.props.controller.navStates[this.props.controller.activeSourceIndex].deviation;
        if (xtk !== null) {
            this.setDeviation(xtk);
        }
        this.setFromTo(this.props.controller.navStates[this.props.controller.activeSourceIndex].toFrom);
    }
    /**
     * Sets the deviation indicator when there is no DTK.
     * @param value is a bool of whether to set 'no dtk' or remove 'no dtk'
     */
    setNoSignal(value) {
        if (value) {
            this.setVisible(this.triangleIndicatorDiv, false);
            this.setVisible(this.diamondIndicatorDiv, false);
            this.setVisible(this.hideableObjects, false);
            this.setVisible(this.noSignalDiv, true);
            switch (this.sourceStr.get()) {
                case 'GPS':
                    this.noSignalStr.set('NO DTK');
                    break;
                case 'LOC1':
                case 'LOC2':
                    this.noSignalStr.set('NO LOC');
                    break;
                case 'VOR1':
                case 'VOR2':
                    this.noSignalStr.set('NO VOR');
                    break;
            }
        }
        else {
            this.setVisible(this.hideableObjects, true);
            this.setVisible(this.noSignalDiv, false);
            this.noSignalStr.set('SIGNAL');
            this.updateSourceSensitivity();
            this.updateData();
        }
    }
    /**
     * Sets the to/from orientation of the triangle.
     * @param toFrom is the to/from object to be processed
     */
    setFromTo(toFrom) {
        if (this.noSignalStr.get() != 'SIGNAL' && toFrom !== VorToFrom.OFF) {
            this.setNoSignal(false);
            return;
        }
        else if (this.noSignalStr.get() != 'SIGNAL') {
            switch (this.sourceStr.get()) {
                case 'GPS':
                    this.noSignalStr.set('NO DTK');
                    break;
                case 'LOC1':
                case 'LOC2':
                    this.noSignalStr.set('NO LOC');
                    break;
                case 'VOR1':
                case 'VOR2':
                    this.noSignalStr.set('NO VOR');
                    break;
            }
        }
        if (toFrom === VorToFrom.FROM) {
            this.triangleIndicatorDiv.instance.style.transform = 'rotate3d(0, 0, 1, 180deg)';
        }
        else {
            this.triangleIndicatorDiv.instance.style.transform = 'rotate3d(0, 0, 1, 0deg)';
            if (toFrom === VorToFrom.OFF) {
                this.setNoSignal(true);
            }
        }
    }
    /**
     * Sets the deviation of the course needle.
     * @param deviation The deviation of the course needle.
     */
    setDeviation(deviation) {
        this.currentDeviation = deviation;
        const deviationPercent = this.currentDeviation;
        const deviationPixels = NavMath.clamp(deviationPercent, -1, 1) * 90.5;
        if (this.currentDeviation >= -1) {
            this.hsiMapDeviation.instance.style.display = '';
            this.hsiMapDeviation.instance.style.transform = `translate3d(${deviationPixels}px, 0px, 0px)`;
        }
        else {
            this.hsiMapDeviation.instance.style.display = 'none';
        }
    }
    /**
     * Updates the Source and Sensitivity Fields.
     */
    updateSourceSensitivity() {
        switch (this.props.controller.navStates[this.props.controller.activeSourceIndex].source.type) {
            case NavSourceType.Nav:
                if (this.props.controller.navStates[this.props.controller.activeSourceIndex].isLocalizer) {
                    this.sourceStr.set(`LOC${this.props.controller.navStates[this.props.controller.activeSourceIndex].source.index}`);
                    this.setVisible(this.triangleIndicatorDiv, false);
                    this.setVisible(this.diamondIndicatorDiv, true);
                    this.diamondIndicatorPath.instance.setAttribute('fill', 'rgb(0,255,0)');
                }
                else {
                    this.sourceStr.set(`VOR${this.props.controller.navStates[this.props.controller.activeSourceIndex].source.index}`);
                    this.setVisible(this.triangleIndicatorDiv, true);
                    this.setVisible(this.diamondIndicatorDiv, false);
                    this.triangleIndicatorPath.instance.setAttribute('fill', 'rgb(0,255,0)');
                }
                this.sensitivityRef.instance.style.display = 'none';
                this.sensitivityStr.set('');
                this.sourceRef.instance.style.color = '#00ff00';
                this.suspDiv.instance.style.display = 'none';
                this.suspDiv.instance.textContent = '';
                break;
            case NavSourceType.Gps:
                this.sensitivityRef.instance.style.display = '';
                this.sensitivityStr.set(`${this.props.controller.activeSensitivity}`);
                this.sourceRef.instance.style.color = 'magenta';
                this.sourceStr.set('GPS');
                this.setVisible(this.noSignalDiv, false);
                this.setVisible(this.hideableObjects, true);
                switch (this.props.controller.activeSensitivity) {
                    case NavSensitivity.LNAV:
                    case NavSensitivity.LP:
                    case NavSensitivity.LPV:
                    case NavSensitivity.LVNAV:
                    case NavSensitivity.VIS:
                        this.diamondIndicatorPath.instance.setAttribute('fill', 'magenta');
                        this.setVisible(this.triangleIndicatorDiv, false);
                        this.setVisible(this.diamondIndicatorDiv, true);
                        break;
                    default:
                        this.triangleIndicatorPath.instance.setAttribute('fill', 'magenta');
                        this.setVisible(this.triangleIndicatorDiv, true);
                        this.setVisible(this.diamondIndicatorDiv, false);
                        break;
                }
                switch (this.props.controller.obsSuspMode) {
                    case ObsSuspModes.SUSP:
                        this.suspDiv.instance.textContent = 'SUSP';
                        this.suspDiv.instance.style.display = '';
                        break;
                    case ObsSuspModes.OBS:
                        this.suspDiv.instance.textContent = 'OBS';
                        this.suspDiv.instance.style.display = '';
                        break;
                    default:
                        this.suspDiv.instance.style.display = 'none';
                        this.suspDiv.instance.textContent = '';
                        break;
                }
                break;
        }
    }
    /**
     * Sets whether or not the course needle is visible.
     * @param ref is the node reference to adjust
     * @param isVisible The visibility of the course needle.
     */
    setVisible(ref, isVisible) {
        if (ref && ref.instance !== null) {
            ref.instance.style.display = isVisible ? '' : 'none';
        }
    }
    /**
     * Renders the course needles component.
     * @returns The rendered VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { ref: this.el },
            FSComponent.buildComponent("div", { class: "hsi-map-nav-src", ref: this.sourceRef }, this.sourceStr),
            FSComponent.buildComponent("div", { class: 'hsi-map-coursedev-objects hsi-map-coursedev-objects-boxstyle' },
                FSComponent.buildComponent("svg", null,
                    FSComponent.buildComponent("circle", { cx: "20", cy: "10.5", r: "3", stroke: "white", "stroke-width": "1px", fill: "none" }),
                    FSComponent.buildComponent("circle", { cx: "161", cy: "10.5", r: "3", stroke: "white", "stroke-width": "1px", fill: "none" }))),
            FSComponent.buildComponent("div", { class: 'hsi-map-coursedev-objects', ref: this.hideableObjects },
                FSComponent.buildComponent("svg", null,
                    FSComponent.buildComponent("line", { x1: "90.5", y1: "1", x2: "90.5", y2: "22", stroke: "gray", "stroke-width": "1px" }),
                    FSComponent.buildComponent("circle", { cx: "55", cy: "11.5", r: "3", stroke: "white", "stroke-width": "1px", fill: "none" }),
                    FSComponent.buildComponent("circle", { cx: "126", cy: "11.5", r: "3", stroke: "white", "stroke-width": "1px", fill: "none" })),
                FSComponent.buildComponent("div", { class: "hsi-map-deviation", ref: this.hsiMapDeviation },
                    FSComponent.buildComponent("div", { class: "hsi-map-triangle-deviation", ref: this.triangleIndicatorDiv },
                        FSComponent.buildComponent("svg", null,
                            FSComponent.buildComponent("path", { ref: this.triangleIndicatorPath, d: "M 9.5 0 L 0 18 L 18 18 z", fill: "magenta", stroke: "black", "stroke-width": "1px" }))),
                    FSComponent.buildComponent("div", { class: "hsi-map-diamond-deviation", ref: this.diamondIndicatorDiv },
                        FSComponent.buildComponent("svg", null,
                            FSComponent.buildComponent("path", { ref: this.diamondIndicatorPath, d: "M 9.5 1 l -8 8 l 8 8 l 8 -8 z", fill: "rgb(0,255,0)", stroke: "black", "stroke-width": "1px" }))))),
            FSComponent.buildComponent("div", { class: 'hsi-map-coursedev-nosignal-text', ref: this.noSignalDiv }, this.noSignalStr),
            FSComponent.buildComponent("div", { class: "hsi-map-gps-xtrack" },
                this.xtkStr,
                FSComponent.buildComponent("span", { class: "size12" }, this.xtkUnit)),
            FSComponent.buildComponent("div", { class: "hsi-map-nav-sensitivity", ref: this.sensitivityRef }, this.sensitivityStr),
            FSComponent.buildComponent("div", { class: "hsi-map-nav-susp", ref: this.suspDiv }, "SUSP")));
    }
}

/**
 * The HSI turn rate indicator component.
 */
class TurnRateIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.rateElement = new NodeReference();
        this.arrowElement = new NodeReference();
    }
    /**
     * Updates the rate of turn indicator above the HSI when the rate of turn changes.
     * @param turnRate is the input rate of turn in degrees per second.
     */
    setTurnRate(turnRate) {
        const lengthFactor = this.props.hsiMap ? 20 / 22.5 : 1;
        const radius = this.props.hsiMap ? 176 : 146;
        const arcLength = turnRate < 0 ? lengthFactor * Math.max(turnRate * 6, -22.5) : lengthFactor * Math.min(turnRate * 6, 22.5);
        const arcX = radius * Math.cos((Math.PI / 180) * (90 - arcLength));
        const arcY = radius - (radius * Math.sin((Math.PI / 180) * (90 - arcLength)));
        const lineX = 6 * Math.cos((Math.PI / 180) * (90 - arcLength));
        const lineY = 0 - (6 * Math.sin((Math.PI / 180) * (90 - arcLength)));
        const sweepFlag1 = arcLength >= 0 ? 0 : 1;
        const sweepFlag2 = arcLength >= 0 ? 1 : 0;
        if (this.props.hsiMap) {
            this.rateElement.instance.setAttribute('d', `M 175 246 m 0 -176 a 176 176 0 0 ${sweepFlag2} ${arcX} ${arcY} l ${lineX} ${lineY} A 182 182 0 0 ${sweepFlag1} 175 64`);
        }
        else {
            this.rateElement.instance.setAttribute('d', `M 183 185 m 0 -146 a 146 146 0 0 ${sweepFlag2} ${arcX} ${arcY} l ${lineX} ${lineY} A 152 152 0 0 ${sweepFlag1} 183 33`);
        }
        if (Math.abs(turnRate) * 6 >= 22.5) {
            const direction = turnRate < 0 ? 1 : -1;
            if (this.props.hsiMap) {
                //M 175 246 m -61.22 -168.2 l -3.08 -8.46 l -14.16 15.78 l 20.32 1.13 z
                this.arrowElement.instance.setAttribute('d', `M 175 246 m ${direction * -61.22} -168.2 l ${direction * -3.08} -8.46 l ${direction * -14.16} 15.78 l ${direction * 20.32} 1.13 z`);
            }
            else {
                this.arrowElement.instance.setAttribute('d', `M 183 185 m ${direction * -57.02} -137.66 l ${direction * -3.06} -7.39 l ${direction * -10.94} 12.99 l ${direction * 17.07} 1.79 z`);
            }
            this.arrowElement.instance.setAttribute('fill', 'magenta');
            this.arrowElement.instance.setAttribute('stroke', 'black');
            this.arrowElement.instance.setAttribute('stroke-width', '.5px');
            this.arrowElement.instance.style.display = '';
        }
        else {
            this.arrowElement.instance.style.display = 'none';
        }
    }
    /**
     * Renders the turn rate component.
     * @returns The rendered component VNode.
     */
    render() {
        if (this.props.hsiMap) {
            return (FSComponent.buildComponent("div", { class: "turn-rate-indicator-hsimap" },
                FSComponent.buildComponent("svg", null,
                    FSComponent.buildComponent("path", { d: "M 175 246 m 0 -175 a 175 175 0 0 0 -59.85 10.55 l -8.21 -22.55 a 199 199 0 0 1 136.12 0 l -8.21 22.55 a 175 175 0 0 0 -59.85 -10.55", fill: "rgba(0,0,0,.3)" }),
                    FSComponent.buildComponent("path", { d: "M 175 246 m -20.66 -176.8 l -1.97 -16.89 z M 175 246 m -41.05 -173.2 l -3.92 -16.54 z M 175 246 m 20.66 -176.8 l 1.97 -16.89 z M 175 246 m 41.05 -173.2 l 3.92 -16.54 z", stroke: "white", "stroke-width": "1.8px" }),
                    FSComponent.buildComponent("path", { ref: this.rateElement, d: "M 175 246 m 0 -176 a 176 176 0 0 0 0 0 l 0 0 A 182 182 0 0 1 175 64 z", fill: "magenta", stroke: "black", "stroke-width": ".5px" }),
                    FSComponent.buildComponent("path", { ref: this.arrowElement, d: "M 175 246 m -61.22 -168.2 l -3.08 -8.46 l -14.16 15.78 l 20.32 1.13 z", fill: "magenta", stroke: "black", "stroke-width": ".5px", style: "display: none" }),
                    FSComponent.buildComponent("path", { d: "M 175 84 l 10 -25 l -20 0 z", fill: "white", stroke: "grey", "stroke-width": ".5px" }))));
        }
        else {
            return (FSComponent.buildComponent("div", { class: "turn-rate-indicator-rose" },
                FSComponent.buildComponent("svg", { viewBox: "111 16 147 40" },
                    FSComponent.buildComponent("path", { d: "M 183 185 m 0 -145 a 145 145 0 0 0 -55.49 11.04 l -9.18 -22.17 a 169 169 0 0 1 129.35 0 l -9.18 22.17 a 145 145 0 0 0 -55.49 -11.04", fill: "rgba(0,0,0,.3)" }),
                    FSComponent.buildComponent("path", { d: "M 183 185 m -23.15 -146.17 l -2.65 -16.79 z M 183 185 m -45.59 -140.33 l -5.25 -16.17 z M 183 185 m 23.15 -146.17 l 2.65 -16.79 z M 183 185 m 45.59 -140.33 l 5.25 -16.17 z", stroke: "white", "stroke-width": "1.8px" }),
                    FSComponent.buildComponent("path", { ref: this.rateElement, d: "M 183 185 m 0 -146 a 146 146 0 0 0 0 0 l 0 0 A 152 152 0 0 1 183 33 z", fill: "magenta", stroke: "black", "stroke-width": ".5px" }),
                    FSComponent.buildComponent("path", { ref: this.arrowElement, d: "M 183 185 m -57.02 -137.66 l -3.44 -8.31 l -10.56 13.91 l 17.45 2.71 z", fill: "magenta", stroke: "black", "stroke-width": ".5px", style: "display: none" }))));
        }
    }
}

/**
 * Displays a map detail level indication.
 */
class MapDetailIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.rootRef = FSComponent.createRef();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        this.props.declutterMode.sub(this.onDeclutterModeChanged.bind(this), true);
    }
    /**
     * A callback which is called when the declutter mode setting value changes.
     * @param mode The new declutter mode setting value.
     */
    onDeclutterModeChanged(mode) {
        this.rootRef.instance.classList.remove('detail-4', 'detail-3', 'detail-2', 'detail-1');
        this.rootRef.instance.classList.add(MapDetailIndicator.MODE_CLASSES[mode]);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent("div", { ref: this.rootRef, class: 'map-detail' },
            this.props.showTitle ? FSComponent.buildComponent("div", null, "Detail") : null,
            FSComponent.buildComponent("div", { class: 'map-detail-icon' },
                FSComponent.buildComponent("div", { class: 'map-detail-block map-detail-top' }),
                FSComponent.buildComponent("div", { class: 'map-detail-block map-detail-middle' }),
                FSComponent.buildComponent("div", { class: 'map-detail-block map-detail-bottom' }),
                FSComponent.buildComponent("div", { class: 'map-detail-clip' }))));
    }
}
MapDetailIndicator.MODE_CLASSES = {
    [MapDeclutterMode.All]: 'detail-4',
    [MapDeclutterMode.Level3]: 'detail-3',
    [MapDeclutterMode.Level2]: 'detail-2',
    [MapDeclutterMode.Level1]: 'detail-1',
};

var AirspaceRenderType;
(function (AirspaceRenderType) {
    AirspaceRenderType[AirspaceRenderType["ClassB"] = 0] = "ClassB";
    AirspaceRenderType[AirspaceRenderType["ClassC"] = 1] = "ClassC";
    AirspaceRenderType[AirspaceRenderType["ClassD"] = 2] = "ClassD";
    AirspaceRenderType[AirspaceRenderType["Restricted"] = 3] = "Restricted";
    AirspaceRenderType[AirspaceRenderType["MOA"] = 4] = "MOA";
    AirspaceRenderType[AirspaceRenderType["Other"] = 5] = "Other";
    AirspaceRenderType[AirspaceRenderType["Null"] = 6] = "Null";
})(AirspaceRenderType || (AirspaceRenderType = {}));
/**
 * An airspace render manager which renders Garmin-style airspaces.
 */
class AirspaceRenderManager extends AbstractAirspaceRenderManager {
    /**
     * Constructor.
     */
    constructor() {
        super();
        this.renderers = [];
        this.initRenderers();
    }
    /**
     * Initializes this manager's airspace renderers.
     */
    initRenderers() {
        this.renderers[AirspaceRenderType.ClassB] = new SingleLineAirspaceRenderer(1.5, '#3080ff', []);
        this.renderers[AirspaceRenderType.ClassC] = new SingleLineAirspaceRenderer(1.5, '#4a0045', []);
        this.renderers[AirspaceRenderType.ClassD] = new SingleLineAirspaceRenderer(1.5, '#3080ff', [5, 5]);
        this.renderers[AirspaceRenderType.Restricted] = new CombedAirspaceRenderer('#3080ff', 1.5, false, 6, [1.5, 2.5]);
        this.renderers[AirspaceRenderType.MOA] = new CombedAirspaceRenderer('#4a0045', 1.5, false, 6, [1.5, 2.5]);
        this.renderers[AirspaceRenderType.Null] = new NullAirspaceRenderer();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    getRenderOrder(a, b) {
        return 0;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getAirspaceRenderer(airspace) {
        switch (airspace.type) {
            case AirspaceType.ClassB:
                return this.renderers[AirspaceRenderType.ClassB];
            case AirspaceType.ClassC:
                return this.renderers[AirspaceRenderType.ClassC];
            case AirspaceType.ClassD:
                return this.renderers[AirspaceRenderType.ClassD];
            case AirspaceType.Restricted:
                return this.renderers[AirspaceRenderType.Restricted];
            case AirspaceType.MOA:
                return this.renderers[AirspaceRenderType.MOA];
            default:
                return this.renderers[AirspaceRenderType.Null];
        }
    }
}
/**
 * Renders airspace boundaries with a comb-like pattern.
 */
class CombedAirspaceRenderer extends MultiLineAirspaceRenderer {
    /**
     * Constructor.
     * @param color The color of the rendered airspace.
     * @param baseLineWidth The stroke width of the base line that is drawn on the airspace boundary.
     * @param teethOutside Whether the teeth should appear on the outside of the boundary.
     * @param teethWidth The width of the teeth.
     * @param teethDash The dash of the teeth.
     */
    constructor(color, baseLineWidth, teethOutside, teethWidth, teethDash) {
        super();
        this.color = color;
        this.baseLineWidth = baseLineWidth;
        this.teethOutside = teethOutside;
        this.teethWidth = teethWidth;
        this.teethDash = teethDash;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    renderLines(context, vertexArray, vertexNormals, length, isClosed) {
        // render base line
        this.renderLine(context, vertexArray, vertexNormals, length, isClosed, 0, this.baseLineWidth, this.color, CombedAirspaceRenderer.emptyDash);
        // render teeth
        this.renderLine(context, vertexArray, vertexNormals, length, isClosed, this.teethWidth / 2 * (this.teethOutside ? -1 : 1), this.teethWidth, this.color, this.teethDash);
    }
}
CombedAirspaceRenderer.emptyDash = [];

/**
 * Render roles for MapWaypointRenderer.
 */
var MapWaypointRenderRole;
(function (MapWaypointRenderRole) {
    /** A highlighted waypoint. */
    MapWaypointRenderRole[MapWaypointRenderRole["Highlight"] = 1] = "Highlight";
    /** A waypoint which is the active waypoint in a flight plan. */
    MapWaypointRenderRole[MapWaypointRenderRole["FlightPlanActive"] = 2] = "FlightPlanActive";
    /** A waypoint in a flight plan which is not the active waypoint. */
    MapWaypointRenderRole[MapWaypointRenderRole["FlightPlanInactive"] = 4] = "FlightPlanInactive";
    /** A normally displayed waypoint. */
    MapWaypointRenderRole[MapWaypointRenderRole["Normal"] = 8] = "Normal";
    /** A waypoint in an airway. */
    MapWaypointRenderRole[MapWaypointRenderRole["Airway"] = 16] = "Airway";
    /** A VNAV waypoint. */
    MapWaypointRenderRole[MapWaypointRenderRole["VNav"] = 32] = "VNav";
})(MapWaypointRenderRole || (MapWaypointRenderRole = {}));
/**
 * A renderer that draws waypoints. Waypoints can be rendered in one of multiple roles: normal, as part of an airway,
 * as part of a flight plan, as the active waypoint in a flight plan, and as a highlighted waypoint. For the renderer
 * to draw a waypoint, the waypoint must first be registered with the renderer. Waypoints may be registered under
 * multiple render roles. However, a waypoint will only be rendered in one role at any point in time, chosen based on
 * the following order of precedence: highlighted > active flight plan > flight plan > normal > airway.
 */
class MapWaypointRenderer {
    /**
     * Constructor.
     * @param textManager The text manager to use for waypoint labels.
     */
    constructor(textManager) {
        this.textManager = textManager;
        this.registered = new Map();
        this.toCleanUp = new Set();
        this.roleInfos = {
            [MapWaypointRenderRole.Highlight]: Object.assign({}, MapWaypointRenderer.DEFAULT_ROLE_INFO),
            [MapWaypointRenderRole.FlightPlanActive]: Object.assign({}, MapWaypointRenderer.DEFAULT_ROLE_INFO),
            [MapWaypointRenderRole.FlightPlanInactive]: Object.assign({}, MapWaypointRenderer.DEFAULT_ROLE_INFO),
            [MapWaypointRenderRole.Normal]: Object.assign({}, MapWaypointRenderer.DEFAULT_ROLE_INFO),
            [MapWaypointRenderRole.Airway]: Object.assign({}, MapWaypointRenderer.DEFAULT_ROLE_INFO),
            [MapWaypointRenderRole.VNav]: Object.assign({}, MapWaypointRenderer.DEFAULT_ROLE_INFO)
        };
        this.allRoles = Object.keys(this.roleInfos);
    }
    /**
     * Sets the factory to use to create waypoint icons for a render role.
     * @param role A render role.
     * @param factory A waypoint icon factory.
     */
    setIconFactory(role, factory) {
        this.roleInfos[role].iconFactory = factory;
    }
    /**
     * Sets the factory to use to create waypoint labels for a render role.
     * @param role A render role.
     * @param factory A waypoint label factory.
     */
    setLabelFactory(role, factory) {
        this.roleInfos[role].labelFactory = factory;
    }
    /**
     * Sets the canvas rendering context for a render role.
     * @param role A render role.
     * @param context - a canvas 2D rendering context.
     */
    setCanvasContext(role, context) {
        this.roleInfos[role].canvasContext = context;
    }
    /**
     * Sets the handler that determines if a waypoint should visible for a render role.
     * @param role A render role.
     * @param handler A function that determines if a waypoint should be visible.
     */
    setVisibilityHandler(role, handler) {
        this.roleInfos[role].visibilityHandler = handler;
    }
    /**
     * Checks if a waypoint is registered with this renderer. A role or roles can be optionally specified such that the
     * method will only return true if the waypoint is registered under those specific roles.
     * @param waypoint A waypoint.
     * @param role The specific role(s) to check.
     * @returns whether the waypoint is registered with this renderer.
     */
    isRegistered(waypoint, role) {
        if (!waypoint) {
            return false;
        }
        const entry = this.registered.get(waypoint.uid);
        if (!entry) {
            return false;
        }
        if (role === undefined) {
            return true;
        }
        return entry.isAllRoles(role);
    }
    /**
     * Registers a waypoint with this renderer under a specific role or roles. Registered waypoints will be drawn as
     * appropriate the next time this renderer's update() method is called. Registering a waypoint under a role under
     * which it is already registered has no effect unless the source of the registration is different.
     * @param waypoint The waypoint to register.
     * @param role The role(s) under which the waypoint should be registered.
     * @param sourceId A unique string ID for the source of the registration.
     */
    register(waypoint, role, sourceId) {
        if (role === 0 || sourceId === '') {
            return;
        }
        let entry = this.registered.get(waypoint.uid);
        if (!entry) {
            entry = new MapWaypointRenderer.MapWaypointRendererEntry(this, waypoint);
            this.registered.set(waypoint.uid, entry);
        }
        entry.addRole(role, sourceId);
    }
    /**
     * Removes a registration for a waypoint for a specific role or roles. Once all of a waypoint's registrations for a
     * role are removed, it will no longer be rendered in that role the next this renderer's update() method is called.
     * @param waypoint The waypoint to deregister.
     * @param role The role(s) from which the waypoint should be deregistered.
     * @param sourceId The unique string ID for the source of the registration to remove.
     */
    deregister(waypoint, role, sourceId) {
        if (role === 0 || sourceId === '') {
            return;
        }
        const entry = this.registered.get(waypoint.uid);
        if (!entry) {
            return;
        }
        entry.removeRole(role, sourceId);
        if (entry.roles === 0) {
            this.deleteEntry(entry);
        }
    }
    /**
     * Deletes and cleans up a registered waypoint entry.
     * @param entry The entry to delete.
     */
    deleteEntry(entry) {
        this.registered.delete(entry.waypoint.uid);
        this.toCleanUp.add(entry);
    }
    /**
     * Redraws waypoints registered with this renderer.
     * @param mapProjection The map projection to use.
     */
    update(mapProjection) {
        this.toCleanUp.forEach(entry => {
            entry.destroy();
        });
        this.toCleanUp.clear();
        const entriesToDrawIcon = [];
        this.registered.forEach(entry => {
            entry.update(mapProjection);
            if (entry.icon) {
                entriesToDrawIcon.push(entry);
            }
        });
        const projectedSize = mapProjection.getProjectedSize();
        const len = this.allRoles.length;
        for (let i = 0; i < len; i++) {
            const context = this.roleInfos[this.allRoles[i]].canvasContext;
            if (context) {
                context.clearRect(0, 0, projectedSize[0], projectedSize[1]);
            }
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        entriesToDrawIcon.sort((a, b) => a.icon.priority - b.icon.priority);
        const len2 = entriesToDrawIcon.length;
        for (let i = 0; i < len2; i++) {
            const entry = entriesToDrawIcon[i];
            const icon = entry.icon;
            const context = this.roleInfos[entry.lastShownRole].canvasContext;
            if (context) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                icon.draw(context, mapProjection);
            }
        }
    }
}
MapWaypointRenderer.DEFAULT_ROLE_INFO = {
    iconFactory: null,
    labelFactory: null,
    canvasContext: null,
    visibilityHandler: () => true
};
/**
 * An entry for a waypoint registered with MapWaypointRenderer.
 */
MapWaypointRenderer.MapWaypointRendererEntry = class {
    /**
     * Constructor.
     * @param renderer The renderer to which this entry belongs.
     * @param waypoint The waypoint associated with this entry.
     */
    constructor(renderer, waypoint) {
        this.renderer = renderer;
        this.waypoint = waypoint;
        this.registrations = {
            [MapWaypointRenderRole.Highlight]: new Set(),
            [MapWaypointRenderRole.FlightPlanActive]: new Set(),
            [MapWaypointRenderRole.FlightPlanInactive]: new Set(),
            [MapWaypointRenderRole.Normal]: new Set(),
            [MapWaypointRenderRole.Airway]: new Set(),
            [MapWaypointRenderRole.VNav]: new Set(),
        };
        this._roles = 0;
        this._icon = null;
        this._label = null;
        this._lastShownRole = 0;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The render role(s) assigned to this entry. */
    get roles() {
        return this._roles;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The role under which this entry was last rendered, or 0 if this entry has not yet been rendered. */
    get lastShownRole() {
        return this._lastShownRole;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This entry's waypoint icon. */
    get icon() {
        return this._icon;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This entry's waypoint label. */
    get label() {
        return this._label;
    }
    /**
     * Checks whether this entry is assigned any of the specified render roles. Optionally, this method can also check
     * if this entry was last rendered in any of the specified roles instead.
     * @param roles The render roles against which to check.
     * @param useLastShown Whether to check the role in which this entry was last rendered instead of the current roles
     * assigned to this entry. False by default.
     * @returns whether the check passed.
     */
    isAnyRole(roles, useLastShown = false) {
        let toCompare;
        if (useLastShown) {
            toCompare = this.lastShownRole;
        }
        else {
            toCompare = this.roles;
        }
        return BitFlags.isAny(toCompare, roles);
    }
    /**
     * Checks whether this entry is assigned only the specified render role(s). Optionally, this method can also check
     * if this entry was last rendered in only the specified role(s) instead.
     * @param roles The render roles against which to check.
     * @param lastShown Whether to check the role in which this entry was last rendered instead of the current roles
     * assigned to this entry. False by default.
     * @returns whether the check passed.
     */
    isOnlyRole(roles, lastShown = false) {
        let toCompare;
        if (lastShown) {
            toCompare = this.lastShownRole;
        }
        else {
            toCompare = this.roles;
        }
        return toCompare === roles;
    }
    /**
     * Checks whether this entry is assigned all the specified render role(s). Optionally, this method can also check
     * if this entry was last rendered in all the specified role(s) instead.
     * @param roles - the render role(s) against which to check.
     * @param lastShown Whether to check the role in which this entry was last rendered instead of the current roles
     * assigned to this entry. False by default.
     * @returns whether the check passed.
     */
    isAllRoles(roles, lastShown = false) {
        let toCompare;
        if (lastShown) {
            toCompare = this.lastShownRole;
        }
        else {
            toCompare = this.roles;
        }
        return BitFlags.isAll(toCompare, roles);
    }
    /**
     * Assigns one or more render roles to this entry.
     * @param roles The render role(s) to assign.
     * @param sourceId The unique string ID of the source of the assignment.
     */
    addRole(roles, sourceId) {
        BitFlags.forEach(roles, (value, index) => { this.registrations[1 << index].add(sourceId); }, true, 0, 6);
        this._roles = this._roles | roles;
    }
    /**
     * Removes one or more render roles from this entry.
     * @param roles The render role(s) to remove.
     * @param sourceId The unique string ID of the soruce of the de-assignment.
     */
    removeRole(roles, sourceId) {
        BitFlags.forEach(roles, (value, index) => {
            const role = 1 << index;
            const registrations = this.registrations[role];
            registrations.delete(sourceId);
            if (registrations.size === 0) {
                this._roles = this._roles & ~role;
            }
        }, true, 0, 6);
    }
    /**
     * Prepares this entry for rendering.
     * @param showRole The role in which this entry should be rendered.
     * @param iconFactory The factory to use to get a waypoint icon.
     * @param labelFactory The factory to use to get a waypoint label.
     */
    prepareRender(showRole, iconFactory, labelFactory) {
        var _a, _b;
        if (showRole === this._lastShownRole) {
            return;
        }
        this._icon = (_a = iconFactory === null || iconFactory === void 0 ? void 0 : iconFactory.getIcon(this.waypoint)) !== null && _a !== void 0 ? _a : null;
        const label = (_b = labelFactory === null || labelFactory === void 0 ? void 0 : labelFactory.getLabel(this.waypoint)) !== null && _b !== void 0 ? _b : null;
        if (this._label && this._label !== label) {
            this.renderer.textManager.deregister(this._label);
        }
        if (label && label !== this._label) {
            this.renderer.textManager.register(label);
        }
        this._label = label;
        this._lastShownRole = showRole;
    }
    /**
     * Updates this entry. An appropriate render role is selected, then the icon and label are updated as appropriate
     * for the chosen role. If the waypoint's label should be visible, it is added to the appropriate text manager.
     * Of note, this method will not draw the waypoint icon to a canvas element; it will simply ensure the .showIcon
     * property contains the correct value depending on whether the icon should be visible.
     * @param mapProjection The map projection to use.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    update(mapProjection) {
        var _a, _b, _c, _d;
        let showRole = 0;
        if (this.isAnyRole(MapWaypointRenderRole.Highlight)
            && this.renderer.roleInfos[MapWaypointRenderRole.Highlight].visibilityHandler(this.waypoint)) {
            showRole = MapWaypointRenderRole.Highlight;
        }
        else if (this.isAnyRole(MapWaypointRenderRole.FlightPlanActive)
            && this.renderer.roleInfos[MapWaypointRenderRole.FlightPlanActive].visibilityHandler(this.waypoint)) {
            showRole = MapWaypointRenderRole.FlightPlanActive;
        }
        else if (this.isAnyRole(MapWaypointRenderRole.FlightPlanInactive)
            && this.renderer.roleInfos[MapWaypointRenderRole.FlightPlanInactive].visibilityHandler(this.waypoint)) {
            showRole = MapWaypointRenderRole.FlightPlanInactive;
        }
        else if (this.isAnyRole(MapWaypointRenderRole.Normal)
            && this.renderer.roleInfos[MapWaypointRenderRole.Normal].visibilityHandler(this.waypoint)) {
            showRole = MapWaypointRenderRole.Normal;
        }
        else if (this.isAnyRole(MapWaypointRenderRole.Airway)
            && this.renderer.roleInfos[MapWaypointRenderRole.Airway].visibilityHandler(this.waypoint)) {
            showRole = MapWaypointRenderRole.Airway;
        }
        else if (this.isAnyRole(MapWaypointRenderRole.VNav)
            && this.renderer.roleInfos[MapWaypointRenderRole.VNav].visibilityHandler(this.waypoint)) {
            showRole = MapWaypointRenderRole.VNav;
        }
        const iconFactory = (_b = (_a = this.renderer.roleInfos[showRole]) === null || _a === void 0 ? void 0 : _a.iconFactory) !== null && _b !== void 0 ? _b : null;
        const labelFactory = (_d = (_c = this.renderer.roleInfos[showRole]) === null || _c === void 0 ? void 0 : _c.labelFactory) !== null && _d !== void 0 ? _d : null;
        this.prepareRender(showRole, iconFactory, labelFactory);
    }
    /**
     * Destroys this entry. Any label from this entry currently registered with the text manager will be deregistered.
     */
    destroy() {
        if (this._label) {
            this.renderer.textManager.deregister(this._label);
        }
    }
};

/**
 * Provides utility functions for working with Garmin maps.
 */
class MapUtils {
    /**
     * Creates a full Bing component earth color array for no terrain colors.
     * @returns a full Bing component earth color array for no terrain colors.
     */
    static createNoTerrainEarthColors() {
        return BingComponent.createEarthColorsArray('#000049', [
            {
                elev: 0,
                color: '#000000'
            },
            {
                elev: 60000,
                color: '#000000'
            }
        ]);
    }
    /**
     * Creates a full Bing component earth color array for absolute terrain colors.
     * @returns a full Bing component earth color array for absolute terrain colors.
     */
    static createAbsoluteTerrainEarthColors() {
        return BingComponent.createEarthColorsArray('#000049', [
            {
                elev: 0,
                color: '#427238'
            },
            {
                elev: 500,
                color: '#456821'
            },
            {
                elev: 2000,
                color: '#d0aa43'
            },
            {
                elev: 3000,
                color: '#c58f45'
            },
            {
                elev: 6000,
                color: '#9d6434'
            },
            {
                elev: 8000,
                color: '#904f25'
            },
            {
                elev: 10500,
                color: '#904522'
            },
            {
                elev: 27000,
                color: '#939393'
            },
            {
                elev: 29000,
                color: '#c8c8c8'
            }
        ]);
    }
    /**
     * Creates a full Bing component earth color array for relative terrain colors.
     * @returns a full Bing component earth color array for relative terrain colors.
     */
    static createRelativeTerrainEarthColors() {
        return BingComponent.createEarthColorsArray('#000049', [
            {
                elev: 0,
                color: '#ff0000'
            },
            {
                elev: 99,
                color: '#ff0000'
            },
            {
                elev: 100,
                color: '#ffff00'
            },
            {
                elev: 999,
                color: '#ffff00'
            },
            {
                elev: 1000,
                color: '#00ff00'
            },
            {
                elev: 1999,
                color: '#00ff00'
            },
            {
                elev: 2000,
                color: '#000000'
            }
        ]);
    }
}

/**
 * A map layer which displays the Bing map.
 */
class MapBingLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.bingLayerRef = FSComponent.createRef();
        this.earthColorsSub = ArraySubject.create(MapBingLayer.ABSOLUTE_TERRAIN_COLORS.slice());
        this.referenceSub = Subject.create(EBingReference.SEA);
        this.wxrModeSub = Subject.create({ mode: EWeatherRadar.OFF, arcRadians: 2 });
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAttached() {
        var _a;
        this.props.model.getModule('terrain').terrainMode.sub(this.onTerrainModeChanged.bind(this), true);
        (_a = this.props.model.getModule('nexrad')) === null || _a === void 0 ? void 0 : _a.showNexrad.sub(on => this.wxrModeSub.set({ mode: on ? EWeatherRadar.TOPVIEW : EWeatherRadar.OFF, arcRadians: 2 }), true);
        this.bingLayerRef.instance.onAttached();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onWake() {
        this.bingLayerRef.instance.onWake();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onSleep() {
        this.bingLayerRef.instance.onSleep();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.bingLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        this.bingLayerRef.instance.onUpdated(time, elapsed);
    }
    /**
     * A callback which is called when the terrain mode changes.
     * @param mode The new terrain mode.
     */
    onTerrainModeChanged(mode) {
        let colors = MapBingLayer.NO_TERRAIN_COLORS;
        let reference = EBingReference.SEA;
        switch (mode) {
            case MapTerrainMode.Absolute:
                colors = MapBingLayer.ABSOLUTE_TERRAIN_COLORS;
                break;
            case MapTerrainMode.Relative:
                colors = MapBingLayer.RELATIVE_TERRAIN_COLORS;
                reference = EBingReference.PLANE;
                break;
        }
        this.earthColorsSub.set(colors);
        this.referenceSub.set(reference);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent(MapBingLayer$1, { ref: this.bingLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, bingId: this.props.bingId, earthColors: this.earthColorsSub, reference: this.referenceSub, class: this.props.class, wxrMode: this.wxrModeSub }));
    }
}
MapBingLayer.NO_TERRAIN_COLORS = MapUtils.createNoTerrainEarthColors();
MapBingLayer.ABSOLUTE_TERRAIN_COLORS = MapUtils.createAbsoluteTerrainEarthColors();
MapBingLayer.RELATIVE_TERRAIN_COLORS = MapUtils.createRelativeTerrainEarthColors();

/**
 * A cache of facility waypoints.
 */
class FacilityWaypointCache {
    /**
     * Constructor.
     * @param size The maximum size of this cache.
     */
    constructor(size) {
        this.size = size;
        this.cache = new Map();
    }
    /**
     * Gets a waypoint from the cache for a specific facility. If one does not exist, a new waypoint will be created.
     * @param facility The facility for which to get a waypoint.
     * @returns A waypoint.
     */
    get(facility) {
        let existing = this.cache.get(facility);
        if (!existing) {
            if (ICAO.getFacilityType(facility.icao) === FacilityType.Airport) {
                existing = new AirportWaypoint(facility);
            }
            else {
                existing = new FacilityWaypoint(facility);
            }
            this.addToCache(facility, existing);
        }
        return existing;
    }
    /**
     * Adds a waypoint to this cache. If the size of the cache is greater than the maximum after the new waypoint is
     * added, a waypoint will be removed from the cache in FIFO order.
     * @param facility The facility associated with the waypoint to add.
     * @param waypoint The waypoint to add.
     */
    addToCache(facility, waypoint) {
        this.cache.set(facility, waypoint);
        if (this.cache.size > this.size) {
            this.cache.delete(this.cache.keys().next().value);
        }
    }
    /**
     * Gets a FacilityWaypointCache instance.
     * @returns A FacilityWaypointCache instance.
     */
    static getCache() {
        var _a;
        return (_a = FacilityWaypointCache.INSTANCE) !== null && _a !== void 0 ? _a : (FacilityWaypointCache.INSTANCE = new FacilityWaypointCache(1000));
    }
}

/**
 * The image cache specific to this instrument.
 * @class GImageCache
 * @augments {ImageCache}
 */
class WaypointIconImageCache extends ImageCache {
    /**
     * Initializes the icons used in this instrument.
     * @static
     */
    static init() {
        WaypointIconImageCache.addToCache('AIRPORT_PRIVATE', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/airport_r.png');
        WaypointIconImageCache.addToCache('AIRPORT_UNKNOWN', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/airport_q.png');
        WaypointIconImageCache.addToCache('AIRPORT_NONTOWERED_SERVICED', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/airport_large_magenta.png');
        WaypointIconImageCache.addToCache('AIRPORT_TOWERED_NONSERVICED', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/airport_med_blue.png');
        WaypointIconImageCache.addToCache('AIRPORT_TOWERED_SERVICED', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/airport_large_blue.png');
        WaypointIconImageCache.addToCache('AIRPORT_NONTOWERED_NON_SERVICED', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/airport_med_magenta.png');
        WaypointIconImageCache.addToCache('AIRPORT_SMALL_NONSERVICED', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/airport_small_a.png');
        WaypointIconImageCache.addToCache('AIRPORT_SMALL_SERVICED', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/airport_small_b.png');
        WaypointIconImageCache.addToCache('INTERSECTION_CYAN', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/intersection_cyan.png');
        WaypointIconImageCache.addToCache('VOR', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/vor.png');
        WaypointIconImageCache.addToCache('VORDME', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/vor_dme.png');
        WaypointIconImageCache.addToCache('DME', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/dme.png');
        WaypointIconImageCache.addToCache('VORVORTAC', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/vor_vortac.png');
        // TODO TACAN icon
        WaypointIconImageCache.addToCache('NDB', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/ndb.png');
        WaypointIconImageCache.addToCache('USER', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/user.png');
        WaypointIconImageCache.addToCache('FPLN_WAYPOINT', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/map_icon_flight_path_waypoint.png');
        WaypointIconImageCache.addToCache('VNAV', 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map/vnav.png');
    }
    /**
     * Maps the airport type to the right icon.
     * @param fac The airport facility to get the icon for.
     * @returns The image element used for this type of airport.
     */
    static getAirportIcon(fac) {
        // HINT class 1 airports are always assumed serviced
        const serviced = (fac.fuel1 !== '' || fac.fuel2 !== '') || fac.airportClass === 1;
        if (fac.airportPrivateType !== AirportPrivateType.Public) {
            return WaypointIconImageCache.get('AIRPORT_PRIVATE');
        }
        else if (serviced && fac.towered) {
            return WaypointIconImageCache.get('AIRPORT_TOWERED_SERVICED');
        }
        else if (serviced && !fac.towered) {
            if (fac.airportClass === 1) {
                return WaypointIconImageCache.get('AIRPORT_NONTOWERED_SERVICED');
            }
            else {
                return WaypointIconImageCache.get('AIRPORT_SMALL_SERVICED');
            }
        }
        else if (!serviced && fac.towered) {
            return WaypointIconImageCache.get('AIRPORT_TOWERED_NONSERVICED');
        }
        else if (!serviced && !fac.towered) {
            if (fac.airportClass === 1) {
                return WaypointIconImageCache.get('AIRPORT_NONTOWERED_NONSERVICED');
            }
            else {
                return WaypointIconImageCache.get('AIRPORT_SMALL_NONSERVICED');
            }
        }
        else {
            return WaypointIconImageCache.get('AIRPORT_UNKNOWN');
        }
    }
    /**
     * Maps the vor type to the right icon.
     * @param type The vor type enum to get the icon for.
     * @returns The image elements used for this  type of vor.
     */
    static getVorIcon(type) {
        switch (type) {
            case VorType.DME:
                return WaypointIconImageCache.get('DME');
            case VorType.ILS:
            case VorType.VORDME:
                return WaypointIconImageCache.get('VORDME');
            case VorType.VORTAC:
            case VorType.TACAN:
                return WaypointIconImageCache.get('VORVORTAC');
            default:
                return WaypointIconImageCache.get('VOR');
        }
    }
}

/**
 * A blank waypoint icon.
 */
class MapBlankWaypointIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     */
    constructor(waypoint, priority) {
        this.waypoint = waypoint;
        this.priority = priority;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    draw(context, mapProjection) {
        // noop
    }
}
/**
 * An abstract implementation of MapWaypointIcon which supports an arbitrary anchor point and offset.
 */
class AbstractMapWaypointIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param width The width at which this icon should be rendered, in pixels.
     * @param height The height at which this icon should be rendered, in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, width, height, options) {
        this.waypoint = waypoint;
        this.priority = priority;
        this.width = width;
        this.height = height;
        /**
         * The anchor point of this icon, expressed relative to its width and height. [0, 0] is the top-left corner, and
         * [1, 1] is the bottom-right corner.
         */
        this.anchor = new Float64Array([0.5, 0.5]);
        /** The offset of this icon from the projected position of its associated waypoint, in pixels. */
        this.offset = new Float64Array(2);
        (options === null || options === void 0 ? void 0 : options.anchor) && this.anchor.set(options.anchor);
        (options === null || options === void 0 ? void 0 : options.offset) && this.offset.set(options.offset);
        this.totalOffsetX = this.offset[0] - this.anchor[0] * this.width;
        this.totalOffsetY = this.offset[1] - this.anchor[1] * this.height;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    draw(context, mapProjection) {
        const projected = mapProjection.project(this.waypoint.location, MapWaypointImageIcon.tempVec2);
        const left = projected[0] + this.totalOffsetX;
        const top = projected[1] + this.totalOffsetY;
        this.drawIconAt(context, mapProjection, left, top);
    }
}
AbstractMapWaypointIcon.tempVec2 = new Float64Array(2);
/**
 * A waypoint icon with an image as the icon's graphic source.
 */
class MapWaypointImageIcon extends AbstractMapWaypointIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param img This icon's image.
     * @param width The width at which this icon should be rendered, in pixels.
     * @param height The height at which this icon should be rendered, in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, img, width, height, options) {
        super(waypoint, priority, width, height, options);
        this.img = img;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    drawIconAt(context, mapProjection, left, top) {
        context.drawImage(this.img, left, top, this.width, this.height);
    }
}
/**
 * A waypoint icon with a sprite as the icon's graphic source.
 */
class MapWaypointSpriteIcon extends AbstractMapWaypointIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param img This icon's sprite's image source.
     * @param frameWidth The frame width of the sprite, in pixels.
     * @param frameHeight The frame height of the sprite, in pixels.
     * @param width The width at which this icon should be rendered, in pixels.
     * @param height The height at which this icon should be rendered, in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, img, frameWidth, frameHeight, width, height, options) {
        super(waypoint, priority, width, height, options);
        this.img = img;
        this.frameWidth = frameWidth;
        this.frameHeight = frameHeight;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    drawIconAt(context, mapProjection, left, top) {
        const spriteIndex = this.getSpriteFrame(mapProjection);
        const rowCount = Math.floor(this.img.naturalHeight / this.frameHeight);
        const colCount = Math.floor(this.img.naturalWidth / this.frameWidth);
        const row = Math.min(rowCount - 1, Math.floor(spriteIndex / colCount));
        const col = Math.min(colCount - 1, spriteIndex % colCount);
        const spriteLeft = col * this.frameWidth;
        const spriteTop = row * this.frameHeight;
        context.drawImage(this.img, spriteLeft, spriteTop, this.frameWidth, this.frameHeight, left, top, this.width, this.height);
    }
}
/**
 * An airport icon.
 */
class MapAirportIcon extends MapWaypointSpriteIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param width The width at which this icon should be rendered, in pixels.
     * @param height The height at which this icon should be rendered, in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, width, height, options) {
        super(waypoint, priority, WaypointIconImageCache.getAirportIcon(waypoint.facility), 32, 32, width, height, options);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getSpriteFrame(mapProjection) {
        if (!this.waypoint.longestRunway) {
            return 0;
        }
        const mapRotationDeg = mapProjection.getRotation() * Avionics.Utils.RAD2DEG;
        return Math.round(NavMath.normalizeHeading((this.waypoint.longestRunway.direction + mapRotationDeg)) / 22.5) % 8;
    }
}
/**
 * A VOR icon.
 */
class MapVorIcon extends MapWaypointImageIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param width The width at which this icon should be rendered, in pixels.
     * @param height The height at which this icon should be rendered, in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, width, height, options) {
        super(waypoint, priority, WaypointIconImageCache.getVorIcon(waypoint.facility.type), width, height, options);
    }
}
/**
 * An intersection icon.
 */
class MapNdbIcon extends MapWaypointImageIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param width The width at which this icon should be rendered, in pixels.
     * @param height The height at which this icon should be rendered, in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, width, height, options) {
        super(waypoint, priority, WaypointIconImageCache.get('NDB'), width, height, options);
    }
}
/**
 * An intersection icon.
 */
class MapIntersectionIcon extends MapWaypointImageIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param width The width at which this icon should be rendered, in pixels.
     * @param height The height at which this icon should be rendered, in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, width, height, options) {
        super(waypoint, priority, WaypointIconImageCache.get('INTERSECTION_CYAN'), width, height, options);
    }
}
/**
 * A runway waypoint icon.
 */
class MapRunwayWaypointIcon extends MapWaypointImageIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param width The width at which this icon should be rendered, in pixels.
     * @param height The height at which this icon should be rendered, in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, width, height, options) {
        super(waypoint, priority, WaypointIconImageCache.get('INTERSECTION_CYAN'), width, height, options);
    }
}
/**
 * A user waypoint icon.
 */
class MapUserWaypointIcon extends MapWaypointImageIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param width The width at which this icon should be rendered, in pixels.
     * @param height The height at which this icon should be rendered, in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, width, height, options) {
        super(waypoint, priority, WaypointIconImageCache.get('USER'), width, height, options);
    }
}
/**
 * A flight path waypoint icon.
 */
class MapFlightPathWaypointIcon extends MapWaypointImageIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param width The width at which this icon should be rendered, in pixels.
     * @param height The height at which this icon should be rendered, in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, width, height, options) {
        super(waypoint, priority, WaypointIconImageCache.get('FPLN_WAYPOINT'), width, height, options);
    }
}
/**
 * A VNAV waypoint icon.
 */
class MapVNavWaypointIcon extends MapWaypointImageIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param width The width at which this icon should be rendered, in pixels.
     * @param height The height at which this icon should be rendered, in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, width, height, options) {
        super(waypoint, priority, WaypointIconImageCache.get('VNAV'), width, height, options);
    }
}

// TODO: This entire layer (and how the map renders waypoints) will need to be refactored eventually.
/**
 * The map layer showing waypoints.
 */
class MapWaypointsLayer extends MapSyncedCanvasLayer {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.facLoader = new FacilityLoader(FacilityRespository.getRepository(this.props.bus), this.onFacilityLoaderInitialized.bind(this));
        this.facWaypointCache = FacilityWaypointCache.getCache();
        this.searchRadius = 0;
        this.searchMargin = 0;
        this.icaosToShow = new Set();
        this.isAirportVisible = {
            [AirportSize.Large]: false,
            [AirportSize.Medium]: false,
            [AirportSize.Small]: false
        };
        this.isVorVisible = false;
        this.isNdbVisible = false;
        this.isIntersectionVisible = false;
        this.iconFactory = new WaypointIconFactory$1({
            airportIconPriority: Object.assign({}, this.props.styles.airportIconPriority),
            vorIconPriority: this.props.styles.vorIconPriority,
            ndbIconPriority: this.props.styles.ndbIconPriority,
            intIconPriority: this.props.styles.intIconPriority,
            airportIconSize: Object.assign({}, this.props.styles.airportIconSize),
            vorIconSize: this.props.styles.vorIconSize,
            ndbIconSize: this.props.styles.ndbIconSize,
            intIconSize: this.props.styles.intIconSize,
        });
        this.labelFactory = new WaypointLabelFactory$1({
            airportLabelPriority: Object.assign({}, this.props.styles.airportLabelPriority),
            vorLabelPriority: this.props.styles.vorLabelPriority,
            ndbLabelPriority: this.props.styles.ndbLabelPriority,
            intLabelPriority: this.props.styles.intLabelPriority,
            airportLabelOptions: {
                [AirportSize.Large]: Object.assign({}, this.props.styles.airportLabelOptions[AirportSize.Large]),
                [AirportSize.Medium]: Object.assign({}, this.props.styles.airportLabelOptions[AirportSize.Medium]),
                [AirportSize.Small]: Object.assign({}, this.props.styles.airportLabelOptions[AirportSize.Small])
            },
            vorLabelOptions: Object.assign({}, this.props.styles.vorLabelOptions),
            ndbLabelOptions: Object.assign({}, this.props.styles.ndbLabelOptions),
            intLabelOptions: Object.assign({}, this.props.styles.intLabelOptions)
        });
    }
    /**
     * A callback called when the facility loaded finishes initialization.
     */
    onFacilityLoaderInitialized() {
        Promise.all([
            this.facLoader.startNearestSearchSession(FacilitySearchType.Airport),
            this.facLoader.startNearestSearchSession(FacilitySearchType.Vor),
            this.facLoader.startNearestSearchSession(FacilitySearchType.Ndb),
            this.facLoader.startNearestSearchSession(FacilitySearchType.Intersection)
        ]).then((value) => {
            const [airportSession, vorSession, ndbSession, intSession] = value;
            const callback = this.processSearchResults.bind(this);
            this.facilitySearches = {
                airport: new MapWaypointsLayer.NearestSearch(airportSession, MapWaypointsLayer.SEARCH_AIRPORT_LIMIT, callback),
                vor: new MapWaypointsLayer.NearestSearch(vorSession, MapWaypointsLayer.SEARCH_VOR_LIMIT, callback),
                ndb: new MapWaypointsLayer.NearestSearch(ndbSession, MapWaypointsLayer.SEARCH_NDB_LIMIT, callback),
                intersection: new MapWaypointsLayer.NearestSearch(intSession, MapWaypointsLayer.SEARCH_INTERSECTION_LIMIT, callback)
            };
            if (this.isInit) {
                this.tryRefreshAllSearches(this.props.mapProjection.getCenter(), this.searchRadius);
            }
        });
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAttached() {
        super.onAttached();
        this.isInit = false;
        this.initVisibilityFlags();
        this.initWaypointRenderer();
        this.updateSearchRadius();
        this.isInit = true;
        this.tryRefreshAllSearches(this.props.mapProjection.getCenter(), this.searchRadius);
    }
    /**
     * Initializes waypoint visibility flags and listeners.
     */
    initVisibilityFlags() {
        const waypointsModule = this.props.model.getModule('waypoints');
        waypointsModule.airportShow[AirportSize.Large].sub(this.updateAirportVisibility.bind(this, AirportSize.Large), true);
        waypointsModule.airportShow[AirportSize.Medium].sub(this.updateAirportVisibility.bind(this, AirportSize.Medium), true);
        waypointsModule.airportShow[AirportSize.Small].sub(this.updateAirportVisibility.bind(this, AirportSize.Small), true);
        waypointsModule.vorShow.sub(this.updateVorVisibility.bind(this), true);
        waypointsModule.ndbShow.sub(this.updateNdbVisibility.bind(this), true);
        waypointsModule.intShow.sub(this.updateIntersectionVisibility.bind(this), true);
    }
    /**
     * Updates airport waypoint visibility.
     * @param size The airport size class to update.
     */
    updateAirportVisibility(size) {
        const waypointsModule = this.props.model.getModule('waypoints');
        const wasAnyAirportVisible = this.isAirportVisible[AirportSize.Large]
            || this.isAirportVisible[AirportSize.Medium]
            || this.isAirportVisible[AirportSize.Small];
        this.isAirportVisible[size] = waypointsModule.airportShow[size].get();
        if (!wasAnyAirportVisible && this.isAirportVisible[size]) {
            this.tryRefreshIntersectionSearch(this.props.mapProjection.getCenter(), this.searchRadius);
        }
    }
    /**
     * Updates VOR waypoint visibility.
     */
    updateVorVisibility() {
        const waypointsModule = this.props.model.getModule('waypoints');
        this.isVorVisible = waypointsModule.vorShow.get();
        if (this.isVorVisible) {
            this.tryRefreshVorSearch(this.props.mapProjection.getCenter(), this.searchRadius);
        }
    }
    /**
     * Updates NDB waypoint visibility.
     */
    updateNdbVisibility() {
        const waypointsModule = this.props.model.getModule('waypoints');
        this.isNdbVisible = waypointsModule.ndbShow.get();
        if (this.isNdbVisible) {
            this.tryRefreshNdbSearch(this.props.mapProjection.getCenter(), this.searchRadius);
        }
    }
    /**
     * Updates intersection waypoint visibility.
     */
    updateIntersectionVisibility() {
        const waypointsModule = this.props.model.getModule('waypoints');
        this.isIntersectionVisible = waypointsModule.intShow.get();
        if (this.isIntersectionVisible) {
            this.tryRefreshIntersectionSearch(this.props.mapProjection.getCenter(), this.searchRadius);
        }
    }
    /**
     * Initializes the waypoint renderer.
     */
    initWaypointRenderer() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.props.waypointRenderer.setCanvasContext(MapWaypointRenderRole.Normal, this.display.context);
        this.props.waypointRenderer.setIconFactory(MapWaypointRenderRole.Normal, this.iconFactory);
        this.props.waypointRenderer.setLabelFactory(MapWaypointRenderRole.Normal, this.labelFactory);
        this.props.waypointRenderer.setVisibilityHandler(MapWaypointRenderRole.Normal, this.isWaypointVisible.bind(this));
    }
    /**
     * Checks whether a waypoint is visible.
     * @param waypoint A waypoint.
     * @returns whether the waypoint is visible.
     */
    isWaypointVisible(waypoint) {
        if (waypoint instanceof FacilityWaypoint) {
            switch (ICAO.getFacilityType(waypoint.facility.icao)) {
                case FacilityType.Airport:
                    return this.isAirportVisible[waypoint.size];
                case FacilityType.VOR:
                    return this.isVorVisible;
                case FacilityType.NDB:
                    return this.isNdbVisible;
                case FacilityType.Intersection:
                    return this.isIntersectionVisible;
            }
        }
        return false;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        super.onMapProjectionChanged(mapProjection, changeFlags);
        if (BitFlags.isAny(changeFlags, MapProjectionChangeType.Range | MapProjectionChangeType.ProjectedSize)) {
            this.updateSearchRadius();
            this.tryRefreshAllSearches(mapProjection.getCenter(), this.searchRadius);
        }
        else if (BitFlags.isAll(changeFlags, MapProjectionChangeType.Center)) {
            this.tryRefreshAllSearches(mapProjection.getCenter(), this.searchRadius);
        }
    }
    /**
     * Updates the desired nearest facility search radius based on the current map projection.
     */
    updateSearchRadius() {
        const mapHalfDiagRange = Vec2Math.abs(this.props.mapProjection.getProjectedSize()) * this.props.mapProjection.getProjectedResolution() / 2;
        this.searchRadius = mapHalfDiagRange * MapWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR;
        this.searchMargin = mapHalfDiagRange * (MapWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR - 1);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        this.updateSearches(elapsed);
    }
    /**
     * Updates this layer's facility searches.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    updateSearches(elapsed) {
        if (!this.facilitySearches) {
            return;
        }
        this.facilitySearches.airport.update(elapsed);
        this.facilitySearches.vor.update(elapsed);
        this.facilitySearches.ndb.update(elapsed);
        this.facilitySearches.intersection.update(elapsed);
    }
    /**
     * Attempts to refresh all of the nearest facility searches.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     */
    tryRefreshAllSearches(center, radius) {
        this.tryRefreshAirportSearch(center, radius);
        this.tryRefreshVorSearch(center, radius);
        this.tryRefreshNdbSearch(center, radius);
        this.tryRefreshIntersectionSearch(center, radius);
    }
    /**
     * Attempts to refresh the nearest airport search. The search will only be refreshed if at least one size class of
     * airport is currently visible and the desired search radius is different from the last refreshed search radius or
     * the desired search center is outside of the margin of the last refreshed search center.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     */
    tryRefreshAirportSearch(center, radius) {
        if (!this.facilitySearches
            || !(this.isAirportVisible[AirportSize.Large] || this.isAirportVisible[AirportSize.Medium] || this.isAirportVisible[AirportSize.Small])) {
            return;
        }
        const search = this.facilitySearches.airport;
        if (search.lastRadius !== radius || search.lastCenter.distance(center) >= this.searchMargin) {
            search.scheduleRefresh(center, radius, MapWaypointsLayer.SEARCH_DEBOUNCE_DELAY);
        }
    }
    /**
     * Attempts to refresh the nearest VOR search. The search will only be refreshed if VORs are currently visible and
     * the desired search radius is different from the last refreshed search radius or the desired search center is
     * outside of the margin of the last refreshed search center.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     */
    tryRefreshVorSearch(center, radius) {
        if (!this.facilitySearches || !this.isVorVisible) {
            return;
        }
        const search = this.facilitySearches.vor;
        if (search.lastRadius !== radius || search.lastCenter.distance(center) >= this.searchMargin) {
            search.scheduleRefresh(center, radius, MapWaypointsLayer.SEARCH_DEBOUNCE_DELAY);
        }
    }
    /**
     * Attempts to refresh the nearest NDB search. The search will only be refreshed if NDB are currently visible and
     * the desired search radius is different from the last refreshed search radius or the desired search center is
     * outside of the margin of the last refreshed search center.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     */
    tryRefreshNdbSearch(center, radius) {
        if (!this.facilitySearches || !this.isNdbVisible) {
            return;
        }
        const search = this.facilitySearches.ndb;
        if (search.lastRadius !== radius || search.lastCenter.distance(center) >= this.searchMargin) {
            search.scheduleRefresh(center, radius, MapWaypointsLayer.SEARCH_DEBOUNCE_DELAY);
        }
    }
    /**
     * Attempts to refresh the nearest intersection search. The search will only be refreshed if intersections are
     * currently visible and the desired search radius is different from the last refreshed search radius or the desired
     * search center is outside of the margin of the last refreshed search center.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     */
    tryRefreshIntersectionSearch(center, radius) {
        if (!this.facilitySearches || !this.isIntersectionVisible) {
            return;
        }
        const search = this.facilitySearches.intersection;
        if (search.lastRadius !== radius || search.lastCenter.distance(center) >= this.searchMargin) {
            search.scheduleRefresh(center, radius, MapWaypointsLayer.SEARCH_DEBOUNCE_DELAY);
        }
    }
    /**
     * Processes nearest facility search results. New facilities are registered, while removed facilities are deregistered.
     * @param results Nearest facility search results.
     */
    processSearchResults(results) {
        if (!results) {
            return;
        }
        const numAdded = results.added.length;
        for (let i = 0; i < numAdded; i++) {
            const icao = results.added[i];
            if (icao === undefined || icao === ICAO.emptyIcao) {
                continue;
            }
            this.registerFacility(icao);
        }
        const numRemoved = results.removed.length;
        for (let i = 0; i < numRemoved; i++) {
            const icao = results.removed[i];
            if (icao === undefined || icao === ICAO.emptyIcao) {
                continue;
            }
            this.deregisterFacility(icao);
        }
    }
    /**
     * Registers a facility with this layer. Registered facilities are drawn to this layer using a waypoint renderer.
     * @param icao The ICAO string of the facility to register.
     */
    registerFacility(icao) {
        this.icaosToShow.add(icao);
        this.facLoader.getFacility(ICAO.getFacilityType(icao), icao).then(facility => {
            if (!this.icaosToShow.has(icao)) {
                return;
            }
            const waypoint = this.facWaypointCache.get(facility);
            this.props.waypointRenderer.register(waypoint, MapWaypointRenderRole.Normal, 'waypoints-layer');
        });
    }
    /**
     * Deregisters a facility from this layer.
     * @param icao The ICAO string of the facility to deregister.
     */
    deregisterFacility(icao) {
        this.icaosToShow.delete(icao);
        this.facLoader.getFacility(ICAO.getFacilityType(icao), icao).then(facility => {
            if (this.icaosToShow.has(icao)) {
                return;
            }
            const waypoint = this.facWaypointCache.get(facility);
            this.props.waypointRenderer.deregister(waypoint, MapWaypointRenderRole.Normal, 'waypoints-layer');
        });
    }
}
MapWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR = Math.SQRT2;
MapWaypointsLayer.SEARCH_AIRPORT_LIMIT = 500;
MapWaypointsLayer.SEARCH_VOR_LIMIT = 250;
MapWaypointsLayer.SEARCH_NDB_LIMIT = 250;
MapWaypointsLayer.SEARCH_INTERSECTION_LIMIT = 500;
MapWaypointsLayer.SEARCH_DEBOUNCE_DELAY = 500; // milliseconds
/**
 * A nearest facility search for MapWaypointLayer.
 */
MapWaypointsLayer.NearestSearch = class {
    /**
     * Constructor.
     * @param session The session used by this search.
     * @param maxSearchItems The maximum number of items this search returns.
     * @param refreshCallback A callback which is called every time the search refreshes.
     */
    constructor(session, maxSearchItems, refreshCallback) {
        this.session = session;
        this.maxSearchItems = maxSearchItems;
        this.refreshCallback = refreshCallback;
        this._lastCenter = new GeoPoint(0, 0);
        this._lastRadius = 0;
        this.refreshDebounceTimer = 0;
        this.isRefreshScheduled = false;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The center of this search's last refresh.
     */
    get lastCenter() {
        return this._lastCenter.readonly;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The radius of this search's last refresh, in great-arc radians.
     */
    get lastRadius() {
        return this._lastRadius;
    }
    /**
     * Schedules a refresh of this search.  If a refresh was previously scheduled but not yet executed, this new
     * scheduled refresh will replace the old one.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     * @param delay The delay, in milliseconds, before the refresh is executed.
     */
    scheduleRefresh(center, radius, delay) {
        this._lastCenter.set(center);
        this._lastRadius = radius;
        this.refreshDebounceTimer = delay;
        this.isRefreshScheduled = true;
    }
    /**
     * Updates this search. Executes any pending refreshes if their delay timers have expired.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    update(elapsed) {
        if (!this.isRefreshScheduled) {
            return;
        }
        this.refreshDebounceTimer = Math.max(0, this.refreshDebounceTimer - elapsed);
        if (this.refreshDebounceTimer === 0) {
            this.refresh();
            this.isRefreshScheduled = false;
        }
    }
    /**
     * Refreshes this search.
     * @returns a Promise which is fulfilled with the search results when the refresh completes.
     */
    async refresh() {
        const results = await this.session.searchNearest(this._lastCenter.lat, this._lastCenter.lon, UnitType.GA_RADIAN.convertTo(this._lastRadius, UnitType.METER), this.maxSearchItems);
        this.refreshCallback(results);
    }
};
/**
 * A waypoint icon factory.
 */
class WaypointIconFactory$1 {
    /**
     * Constructor.
     * @param styles Icon styling options used by this factory.
     */
    constructor(styles) {
        this.styles = styles;
        this.cache = new Map();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getIcon(waypoint) {
        let existing = this.cache.get(waypoint.uid);
        if (!existing) {
            existing = this.createIcon(waypoint);
            this.cache.set(waypoint.uid, existing);
        }
        return existing;
    }
    /**
     * Creates a new icon for a waypoint.
     * @param waypoint The waypoint for which to create an icon.
     * @returns a waypoint icon.
     */
    createIcon(waypoint) {
        if (waypoint instanceof AirportWaypoint) {
            return new MapAirportIcon(waypoint, this.styles.airportIconPriority[waypoint.size], this.styles.airportIconSize[waypoint.size], this.styles.airportIconSize[waypoint.size]);
        }
        else if (waypoint instanceof FacilityWaypoint) {
            switch (ICAO.getFacilityType(waypoint.facility.icao)) {
                case FacilityType.VOR:
                    return new MapVorIcon(waypoint, this.styles.vorIconPriority, this.styles.vorIconSize, this.styles.vorIconSize);
                case FacilityType.NDB:
                    return new MapNdbIcon(waypoint, this.styles.ndbIconPriority, this.styles.ndbIconSize, this.styles.ndbIconSize);
                case FacilityType.Intersection:
                    return new MapIntersectionIcon(waypoint, this.styles.intIconPriority, this.styles.intIconSize, this.styles.intIconSize);
            }
        }
        return new MapBlankWaypointIcon(waypoint, 0);
    }
}
/**
 * A waypoint label factory.
 */
class WaypointLabelFactory$1 {
    /**
     * Constructor.
     * @param styles Icon styling options used by this factory.
     */
    constructor(styles) {
        this.styles = styles;
        this.cache = new Map();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getLabel(waypoint) {
        let existing = this.cache.get(waypoint.uid);
        if (!existing) {
            existing = this.createLabel(waypoint);
            this.cache.set(waypoint.uid, existing);
        }
        return existing;
    }
    /**
     * Creates a new icon for a waypoint.
     * @param waypoint The waypoint for which to create an icon.
     * @returns a waypoint icon.
     */
    createLabel(waypoint) {
        let text = '';
        let priority = 0;
        let options;
        if (waypoint instanceof FacilityWaypoint) {
            text = ICAO.getIdent(waypoint.facility.icao);
            switch (ICAO.getFacilityType(waypoint.facility.icao)) {
                case FacilityType.Airport:
                    priority = this.styles.airportLabelPriority[waypoint.size];
                    options = this.styles.airportLabelOptions[waypoint.size];
                    break;
                case FacilityType.VOR:
                    priority = this.styles.vorLabelPriority;
                    options = this.styles.vorLabelOptions;
                    break;
                case FacilityType.NDB:
                    priority = this.styles.ndbLabelPriority;
                    options = this.styles.ndbLabelOptions;
                    break;
                case FacilityType.Intersection:
                    priority = this.styles.intLabelPriority;
                    options = this.styles.intLabelOptions;
                    break;
            }
        }
        return new MapCullableLocationTextLabel(text, priority, waypoint.location, false, options);
    }
}

/**
 * A layer which draws airspaces.
 */
class MapAirspaceLayer extends MapCachedCanvasLayer {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.searchedAirspaces = [];
        this.lastSearchCenter = new GeoPoint(0, 0);
        this.lastScheduledSearchTime = 0;
        this.activeRenderProcess = null;
        this.searchDebounceTimer = 0;
        this.isSearchScheduled = false;
        this.renderDebounceTimer = 0;
        this.isRenderScheduled = false;
        this.needRefilterAirspaces = false;
        this.renderTaskQueueHandler = {
            // eslint-disable-next-line jsdoc/require-jsdoc
            onStarted() {
                // noop
            },
            // eslint-disable-next-line jsdoc/require-jsdoc
            canContinue(elapsedFrameCount, dispatchedTaskCount, timeElapsed) {
                return timeElapsed < MapAirspaceLayer.RENDER_TIME_BUDGET;
            },
            // eslint-disable-next-line jsdoc/require-jsdoc
            onPaused: this.onRenderPaused.bind(this),
            // eslint-disable-next-line jsdoc/require-jsdoc
            onFinished: this.onRenderFinished.bind(this),
            // eslint-disable-next-line jsdoc/require-jsdoc
            onAborted: this.onRenderAborted.bind(this)
        };
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.initModuleListeners();
        this.scheduleSearchAirspaces(0);
    }
    /**
     * Initializes this layer's airspace module property listeners.
     */
    initModuleListeners() {
        const rangeModule = this.props.model.getModule('range');
        rangeModule.nominalRange.sub(this.onNominalRangeChanged.bind(this));
        rangeModule.nominalRanges.sub(this.onNominalRangeArrayChanged.bind(this));
        const airspaceModule = this.props.model.getModule('airspace');
        airspaceModule.show.sub(this.onShowChanged.bind(this));
        for (const type of Object.values(AirspaceRangeType)) {
            airspaceModule.maxRangeIndex[type].sub(this.onMaxRangeIndexChanged.bind(this, type));
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        super.onMapProjectionChanged(mapProjection, changeFlags);
        const distance = mapProjection.getCenter().distance(this.lastSearchCenter);
        // sometimes the search will return no airspaces even when it should (usually at the very beginning of a flight),
        // so if the last search results were empty we will refresh the search periodically regardless of how far the last
        // search center is from the current map center.
        if ((this.searchedAirspaces.length === 0 && Date.now() - this.lastScheduledSearchTime >= MapAirspaceLayer.MIN_SEARCH_INTERVAL)
            || (MapAirspaceLayer.SEARCH_DISTANCE_THRESHOLD.compare(distance, UnitType.GA_RADIAN) <= 0)) {
            this.scheduleSearchAirspaces(MapAirspaceLayer.SEARCH_DEBOUNCE_DELAY);
        }
    }
    /**
     * Schedules an airspace search after a specified delay. If a search was previously scheduled but not yet executed,
     * this new scheduled search will replace the old one.
     * @param delay The delay, in milliseconds, before the search is executed.
     */
    scheduleSearchAirspaces(delay) {
        this.searchDebounceTimer = delay;
        this.isSearchScheduled = true;
        this.lastScheduledSearchTime = Date.now();
    }
    /**
     * Schedules a render. If a render was previously scheduled but not yet executed, this new scheduled search will
     * replace the old one.
     * @param delay The delay, in milliseconds, before the search is executed.
     */
    scheduleRender(delay) {
        this.renderDebounceTimer = delay;
        this.isRenderScheduled = true;
    }
    /**
     * Searches for airspaces around the map center. After the search is complete, the list of search results is filtered
     * and, if necessary, rendered.
     */
    async searchAirspaces() {
        const center = this.props.mapProjection.getCenter();
        this.lastSearchCenter.set(center);
        this.searchedAirspaces = await this.props.airspaceSearcher.search(center);
        this.refilterAirspaces();
    }
    /**
     * Filters the list of airspace search results to those that should be rendered and if necessary, renders the
     * filtered airspaces.
     */
    refilterAirspaces() {
        const airspaceModule = this.props.model.getModule('airspace');
        let needRender;
        if (airspaceModule.show.get()) {
            const mapRangeIndex = this.props.model.getModule('range').nominalRangeIndex.get();
            const airspaceMaxRangeIndex = airspaceModule.maxRangeIndex;
            const filteredAirspaces = this.searchedAirspaces.filter(airspace => {
                switch (airspace.type) {
                    case AirspaceType.ClassB:
                        return mapRangeIndex <= airspaceMaxRangeIndex[AirspaceRangeType.ClassB].get();
                    case AirspaceType.ClassC:
                        return mapRangeIndex <= airspaceMaxRangeIndex[AirspaceRangeType.ClassC].get();
                    case AirspaceType.ClassD:
                        return mapRangeIndex <= airspaceMaxRangeIndex[AirspaceRangeType.ClassD].get();
                    case AirspaceType.Restricted:
                        return mapRangeIndex <= airspaceMaxRangeIndex[AirspaceRangeType.Restricted].get();
                    case AirspaceType.MOA:
                        return mapRangeIndex <= airspaceMaxRangeIndex[AirspaceRangeType.MOA].get();
                    default:
                        return false;
                }
            });
            needRender = this.props.airspaceRenderManager.replaceRegisteredAirspaces(filteredAirspaces);
        }
        else {
            needRender = this.props.airspaceRenderManager.clearRegisteredAirspaces();
        }
        if (needRender && !this.isRenderScheduled) {
            this.scheduleRender(0);
        }
        this.needRefilterAirspaces = false;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        super.onUpdated(time, elapsed);
        this.updateFromInvalidation();
        this.updateRefilter();
        this.updateScheduledSearch(time, elapsed);
        this.updateScheduledRender(elapsed);
    }
    /**
     * Checks if the display and buffer canvases have been invalidated, and if so, clears them and schedules a render.
     */
    updateFromInvalidation() {
        const display = this.display;
        const buffer = this.buffer;
        const shouldScheduleRender = display.isInvalid || (buffer.isInvalid && this.activeRenderProcess);
        if (display.isInvalid) {
            display.clear();
            display.syncWithMapProjection(this.props.mapProjection, this.getReferenceMargin());
        }
        if (buffer.isInvalid) {
            buffer.clear();
            buffer.syncWithMapProjection(this.props.mapProjection, this.getReferenceMargin());
        }
        if (shouldScheduleRender) {
            this.scheduleRender(MapAirspaceLayer.RENDER_DEBOUNCE_DELAY);
        }
    }
    /**
     * Checks if airspaces need to be refiltered, and if so, executes a refilter.
     */
    updateRefilter() {
        if (!this.needRefilterAirspaces) {
            return;
        }
        this.refilterAirspaces();
    }
    /**
     * If a search is scheduled, decrements the delay timer and if necessary, executes the search.
     * @param time The current time, as a UNIX timestamp.
     * @param elapsed The time elapsed, in milliseconds, since the last update.
     */
    updateScheduledSearch(time, elapsed) {
        if (!this.isSearchScheduled) {
            return;
        }
        this.searchDebounceTimer = Math.max(0, this.searchDebounceTimer - elapsed);
        if (this.searchDebounceTimer === 0) {
            this.searchAirspaces();
            this.isSearchScheduled = false;
        }
    }
    /**
     * If a render is scheduled, decrements the delay timer and if necessary, executes the render.
     * @param elapsed The time elapsed, in milliseconds, since the last update.
     */
    updateScheduledRender(elapsed) {
        if (!this.isRenderScheduled) {
            return;
        }
        this.renderDebounceTimer = Math.max(0, this.renderDebounceTimer - elapsed);
        if (this.renderDebounceTimer === 0) {
            this.startRenderProcess(true);
            this.isRenderScheduled = false;
        }
    }
    /**
     * Syncs this layer's display canvas instance with the current map projection and renders this layer's airspaces to
     * the display.
     * @param clearDisplay Whether to clear the display canvas before rendering.
     */
    startRenderProcess(clearDisplay) {
        const display = this.display;
        if (clearDisplay) {
            display.clear();
        }
        if (this.activeRenderProcess) {
            this.activeRenderProcess.abort();
        }
        const buffer = this.buffer;
        buffer.clear();
        buffer.syncWithMapProjection(this.props.mapProjection, this.getReferenceMargin());
        display.syncWithCanvasInstance(buffer);
        this.activeRenderProcess = this.props.airspaceRenderManager.prepareRenderProcess(display.geoProjection, buffer.context, this.renderTaskQueueHandler);
        this.activeRenderProcess.start();
    }
    /**
     * Cleans up the active render process.
     */
    cleanUpRender() {
        this.buffer.reset();
        this.activeRenderProcess = null;
    }
    /**
     * Renders airspaces from the buffer to the display.
     */
    renderAirspacesToDisplay() {
        this.display.clear();
        this.copyBufferToDisplay();
    }
    /**
     * This method is called when the airspace render process pauses.
     */
    onRenderPaused() {
        this.renderAirspacesToDisplay();
    }
    /**
     * This method is called when the airspace render process finishes.
     */
    onRenderFinished() {
        this.renderAirspacesToDisplay();
        this.cleanUpRender();
    }
    /**
     * This method is called when the airspace render process is aborted.
     */
    onRenderAborted() {
        this.cleanUpRender();
    }
    /**
     * This method is called when the nominal map range changes.
     */
    onNominalRangeChanged() {
        this.needRefilterAirspaces = true;
    }
    /**
     * This method is called when the array of nominal map ranges changes.
     */
    onNominalRangeArrayChanged() {
        this.needRefilterAirspaces = true;
    }
    /**
     * This method is called when the show airspace property changes.
     */
    onShowChanged() {
        this.needRefilterAirspaces = true;
    }
    /**
     * This method is called when an airspace maximum range index property changes.
     */
    onMaxRangeIndexChanged() {
        this.needRefilterAirspaces = true;
    }
}
/**
 * The minimum distance between the current map center and the last search center required to initiate a new search.
 */
MapAirspaceLayer.SEARCH_DISTANCE_THRESHOLD = UnitType.NMILE.createNumber(10);
MapAirspaceLayer.MIN_SEARCH_INTERVAL = 5000; // milliseconds
MapAirspaceLayer.RENDER_TIME_BUDGET = 0.2; // milliseconds per frame
MapAirspaceLayer.SEARCH_DEBOUNCE_DELAY = 500; // milliseconds
MapAirspaceLayer.RENDER_DEBOUNCE_DELAY = 500; // milliseconds

/**
 * A map layer which displays a flight plan.
 */
class MapFlightPlanLayer extends MapLayer {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.flightPathLayerRef = FSComponent.createRef();
        this.waypointLayerRef = FSComponent.createRef();
        this.resampler = new GeodesicResampler(Math.PI / 12, 1, 8);
        this.facLoader = new FacilityLoader(FacilityRespository.getRepository(this.props.bus));
        this.facWaypointCache = FacilityWaypointCache.getCache();
        this.legWaypointRecords = new Map();
        this.isRefreshWaypointsBusy = false;
        this.isObsActive = false;
        this.obsCourse = 0;
        this.needDrawRoute = false;
        this.needRefreshWaypoints = false;
        this.needRepickWaypoints = false;
        this.iconFactoryInactive = this.createWaypointIconFactory(this.props.inactiveWaypointStyles);
        this.labelFactoryInactive = this.createWaypointLabelFactory(this.props.inactiveWaypointStyles);
        this.iconFactoryActive = this.createWaypointIconFactory(this.props.activeWaypointStyles);
        this.labelFactoryActive = this.createWaypointLabelFactory(this.props.activeWaypointStyles);
        this.vnavIconFactory = new VNavWaypointIconFactory();
        this.vnavLabelFactory = new VNavWaypointLabelFactory();
    }
    /**
     * Creates a waypoint icon factory.
     * @param styles Styles the factory should use.
     * @returns a waypoint icon factory.
     */
    createWaypointIconFactory(styles) {
        return new WaypointIconFactory({
            airportIconPriority: Object.assign({}, styles.airportIconPriority),
            vorIconPriority: styles.vorIconPriority,
            ndbIconPriority: styles.ndbIconPriority,
            intIconPriority: styles.intIconPriority,
            rwyIconPriority: styles.rwyIconPriority,
            userIconPriority: styles.userIconPriority,
            fpIconPriority: styles.fpIconPriority,
            airportIconSize: Object.assign({}, styles.airportIconSize),
            vorIconSize: styles.vorIconSize,
            ndbIconSize: styles.ndbIconSize,
            intIconSize: styles.intIconSize,
            rwyIconSize: styles.rwyIconSize,
            userIconSize: styles.userIconSize,
            fpIconSize: styles.fpIconSize,
        });
    }
    /**
     * Creates a waypoint label factory.
     * @param styles Styles the factory should use.
     * @returns a waypoint label factory.
     */
    createWaypointLabelFactory(styles) {
        return new WaypointLabelFactory({
            airportLabelPriority: Object.assign({}, styles.airportLabelPriority),
            vorLabelPriority: styles.vorLabelPriority,
            ndbLabelPriority: styles.ndbLabelPriority,
            intLabelPriority: styles.intLabelPriority,
            rwyLabelPriority: styles.rwyLabelPriority,
            userLabelPriority: styles.userLabelPriority,
            fpLabelPriority: styles.fpLabelPriority,
            airportLabelOptions: {
                [AirportSize.Large]: Object.assign({}, styles.airportLabelOptions[AirportSize.Large]),
                [AirportSize.Medium]: Object.assign({}, styles.airportLabelOptions[AirportSize.Medium]),
                [AirportSize.Small]: Object.assign({}, styles.airportLabelOptions[AirportSize.Small])
            },
            vorLabelOptions: Object.assign({}, styles.vorLabelOptions),
            ndbLabelOptions: Object.assign({}, styles.ndbLabelOptions),
            intLabelOptions: Object.assign({}, styles.intLabelOptions),
            rwyLabelOptions: Object.assign({}, styles.rwyLabelOptions),
            userLabelOptions: Object.assign({}, styles.userLabelOptions),
            fpLabelOptions: Object.assign({}, styles.fpLabelOptions)
        });
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.flightPathLayerRef.instance.onAttached();
        this.waypointLayerRef.instance.onAttached();
        this.initWaypointRenderer();
        this.initFlightPlanHandlers();
    }
    /**
     * Initializes the waypoint renderer.
     */
    initWaypointRenderer() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.props.waypointRenderer.setCanvasContext(MapWaypointRenderRole.FlightPlanInactive, this.waypointLayerRef.instance.display.context);
        this.props.waypointRenderer.setIconFactory(MapWaypointRenderRole.FlightPlanInactive, this.iconFactoryInactive);
        this.props.waypointRenderer.setLabelFactory(MapWaypointRenderRole.FlightPlanInactive, this.labelFactoryInactive);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.props.waypointRenderer.setCanvasContext(MapWaypointRenderRole.FlightPlanActive, this.waypointLayerRef.instance.display.context);
        this.props.waypointRenderer.setIconFactory(MapWaypointRenderRole.FlightPlanActive, this.iconFactoryActive);
        this.props.waypointRenderer.setLabelFactory(MapWaypointRenderRole.FlightPlanActive, this.labelFactoryActive);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.props.waypointRenderer.setCanvasContext(MapWaypointRenderRole.VNav, this.waypointLayerRef.instance.display.context);
        this.props.waypointRenderer.setIconFactory(MapWaypointRenderRole.VNav, this.vnavIconFactory);
        this.props.waypointRenderer.setLabelFactory(MapWaypointRenderRole.VNav, this.vnavLabelFactory);
    }
    /**
     * Initializes handlers to respond to flight plan events.
     */
    initFlightPlanHandlers() {
        this.props.drawEntirePlan.sub(() => { this.scheduleUpdates(true, true, true); });
        this.props.dataProvider.plan.sub(() => { this.scheduleUpdates(true, true, true); }, true);
        this.props.dataProvider.planModified.on(() => { this.scheduleUpdates(false, true, true); });
        this.props.dataProvider.planCalculated.on(() => {
            this.scheduleUpdates(true, true, false);
            this.onTodBodChanged();
        });
        this.props.dataProvider.activeLateralLegIndex.sub(() => { this.scheduleUpdates(true, true, true); });
        this.props.dataProvider.activeLNavLegVectorIndex.sub(() => { this.scheduleUpdates(true, false, false); });
        this.props.dataProvider.isLNavSuspended.sub(() => { this.scheduleUpdates(true, false, false); });
        this.props.dataProvider.vnavTodLegIndex.sub(() => { this.onTodBodChanged(); });
        this.props.dataProvider.vnavTodLegDistance.sub(() => { this.onTodBodChanged(); });
        this.props.dataProvider.vnavBodLegIndex.sub(() => { this.onTodBodChanged(); });
        this.props.dataProvider.obsCourse.sub((course) => {
            const isActive = course !== undefined;
            const needFullUpdate = isActive !== this.isObsActive;
            this.isObsActive = isActive;
            this.obsCourse = course !== null && course !== void 0 ? course : this.obsCourse;
            this.scheduleUpdates(this.isObsActive, needFullUpdate, needFullUpdate);
        });
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.flightPathLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        this.waypointLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        this.flightPathLayerRef.instance.onUpdated(time, elapsed);
        this.updateFromFlightPathLayerInvalidation();
        this.updateRedrawRoute();
        this.updateRefreshWaypoints();
    }
    /**
     * Checks if the flight path layer's display canvas has been invalidated, and if so, clears it and schedules a redraw.
     */
    updateFromFlightPathLayerInvalidation() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const display = this.flightPathLayerRef.instance.display;
        this.needDrawRoute || (this.needDrawRoute = display.isInvalid);
        if (display.isInvalid) {
            display.clear();
            display.syncWithMapProjection(this.props.mapProjection, this.flightPathLayerRef.instance.getReferenceMargin());
        }
    }
    /**
     * Redraws the flight path if a redraw is scheduled.
     */
    updateRedrawRoute() {
        if (this.needDrawRoute) {
            this.drawRoute();
            this.needDrawRoute = false;
        }
    }
    /**
     * Refreshes this layer's flight plan leg waypoint records if a refresh is scheduled.
     */
    updateRefreshWaypoints() {
        if (this.needRefreshWaypoints && !this.isRefreshWaypointsBusy) {
            this.refreshWaypoints();
            this.needRefreshWaypoints = false;
            this.needRepickWaypoints = false;
        }
    }
    /**
     * Draws the flight path route.
     */
    drawRoute() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const display = this.flightPathLayerRef.instance.display;
        const context = display.context;
        display.clear();
        const flightPlan = this.props.dataProvider.plan.get();
        if (!flightPlan) {
            return;
        }
        const activeLegIndex = this.props.dataProvider.activeLateralLegIndex.get();
        const baseRouteInitialIndex = this.props.drawEntirePlan.get()
            ? 0
            : activeLegIndex >= 0
                ? this.isObsActive ? activeLegIndex : activeLegIndex - 1
                : flightPlan.length;
        this.drawBaseRoute(flightPlan, baseRouteInitialIndex, context);
        if (this.isObsActive) {
            this.drawObs(flightPlan, context);
        }
        else {
            this.drawRouteWithTurns(flightPlan, context);
        }
    }
    /**
     * Draws the flight plan route, including leg to leg turns.
     * @param flightPlan The flight plan to draw.
     * @param context The context to draw to.
     */
    drawRouteWithTurns(flightPlan, context) {
        var _a, _b;
        let legIndex = 0;
        const activeLegIndex = this.props.dataProvider.activeLateralLegIndex.get();
        const drawnActiveLegIndex = activeLegIndex >= 0 ? activeLegIndex : flightPlan.length;
        const firstIndex = this.props.drawEntirePlan.get() ? 0 : drawnActiveLegIndex - 1;
        let isInMissedApproach = false;
        const isMissedApproachActive = drawnActiveLegIndex < flightPlan.length && flightPlan.getLeg(drawnActiveLegIndex).isInMissedApproachSequence;
        context.beginPath();
        context.lineWidth = MapFlightPlanLayer.ROUTE_PRIOR_STROKE_WIDTH;
        context.strokeStyle = MapFlightPlanLayer.ROUTE_PRIOR_STROKE_COLOR;
        let activeLeg = null;
        for (const leg of flightPlan.legs()) {
            if (legIndex >= firstIndex && (!leg.isInDirectToSequence || legIndex === drawnActiveLegIndex)) {
                if (legIndex < drawnActiveLegIndex) {
                    if (leg.leg.type === LegType.HM || ((leg.leg.type === LegType.HF || leg.leg.type === LegType.HA) && ((_b = (_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.flightPath.length) !== null && _b !== void 0 ? _b : 0) > 4)) {
                        this.drawLegWithTurns(leg, context, false, false, leg.calculated ? leg.calculated.flightPath.length - 4 : 0);
                    }
                    else {
                        this.drawLegWithTurns(leg, context);
                    }
                }
                else if (legIndex > drawnActiveLegIndex) {
                    if (!isInMissedApproach && !isMissedApproachActive && leg.isInMissedApproachSequence) {
                        context.stroke();
                        context.beginPath();
                        context.lineWidth = MapFlightPlanLayer.ROUTE_MISSED_APPROACH_STROKE_WIDTH;
                        context.strokeStyle = MapFlightPlanLayer.ROUTE_PRIOR_STROKE_COLOR;
                        isInMissedApproach = true;
                    }
                    if (leg.leg.type === LegType.HM) {
                        this.drawHold(leg, activeLeg, context);
                    }
                    else {
                        this.drawLegWithTurns(leg, context);
                    }
                }
                else {
                    context.stroke();
                    context.beginPath();
                    context.lineWidth = MapFlightPlanLayer.ROUTE_STROKE_WIDTH;
                    context.strokeStyle = 'white';
                    activeLeg = leg;
                }
            }
            legIndex++;
        }
        if (activeLeg) {
            context.stroke();
            context.beginPath();
            context.lineWidth = MapFlightPlanLayer.ROUTE_STROKE_WIDTH;
            context.strokeStyle = 'magenta';
            if (activeLeg.leg.type === LegType.HM) {
                this.drawHold(activeLeg, activeLeg, context);
            }
            else {
                this.drawLegWithTurns(activeLeg, context);
            }
        }
        context.stroke();
    }
    /**
     * Draws a flight plan leg, including leg to leg turns.
     * @param leg The leg to draw.
     * @param context The context to draw to.
     * @param skipIngress Skips drawing the ingress leg.
     * @param skipEgress Skips drawing the egress leg.
     * @param startIndex The index to start drawing the leg at.
     */
    drawLegWithTurns(leg, context, skipIngress = false, skipEgress = false, startIndex = 0) {
        const calculated = leg.calculated;
        if (calculated) {
            for (let i = startIndex; i < calculated.flightPath.length; i++) {
                const vector = calculated.flightPath[i];
                if (i === 0 && calculated.ingressTurn.radius !== 0) {
                    if (i === calculated.flightPath.length - 1 && calculated.egressTurn.radius !== 0) {
                        this.drawVectorSegment(vector, context, skipIngress ? undefined : calculated.ingressTurn, skipEgress ? undefined : calculated.egressTurn);
                    }
                    else {
                        this.drawVectorSegment(vector, context, skipIngress ? undefined : calculated.ingressTurn);
                    }
                }
                else if (i === calculated.flightPath.length - 1 && calculated.egressTurn.radius !== 0) {
                    this.drawVectorSegment(vector, context, undefined, skipEgress ? undefined : calculated.egressTurn);
                }
                else {
                    this.drawVectorSegment(vector, context);
                }
            }
        }
    }
    /**
     * Draws a hold leg.
     * @param leg The hold leg to draw.
     * @param activeLeg The current active leg.
     * @param context The context to draw to.
     */
    drawHold(leg, activeLeg, context) {
        var _a, _b;
        const inHold = leg.calculated !== undefined && this.props.dataProvider.activeLNavLegVectorIndex.get() >= leg.calculated.flightPath.length - 4;
        const isActiveLeg = leg === activeLeg;
        if (!isActiveLeg) {
            this.drawLegWithTurns(leg, context, false, true);
        }
        else {
            if (inHold && !this.props.dataProvider.isLNavSuspended.get()) {
                const startIndex = leg.calculated !== undefined ? ((_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.flightPath.length) - 4 : 0;
                this.drawLegWithTurns(leg, context, true, false, startIndex);
            }
            else if (inHold) {
                const startIndex = leg.calculated !== undefined ? ((_b = leg.calculated) === null || _b === void 0 ? void 0 : _b.flightPath.length) - 4 : 0;
                this.drawLegWithTurns(leg, context, true, true, startIndex);
            }
            else {
                this.drawLegWithTurns(leg, context, false, true);
            }
        }
    }
    /**
     * Draws the flight plan route, without any leg to leg turns.
     * @param flightPlan The flight plan to draw.
     * @param initialIndex The index of the first flight plan leg to draw.
     * @param context The context to draw to.
     */
    drawBaseRoute(flightPlan, initialIndex, context) {
        context.beginPath();
        context.lineWidth = MapFlightPlanLayer.BASE_ROUTE_STROKE_WIDTH;
        context.strokeStyle = MapFlightPlanLayer.BASE_ROUTE_STROKE_COLOR;
        let legIndex = 0;
        for (const leg of flightPlan.legs()) {
            if (legIndex >= initialIndex && (!leg.isInDirectToSequence || legIndex === flightPlan.activeLateralLeg)) {
                this.drawLegWithoutTurns(leg, context);
            }
            legIndex++;
        }
        context.stroke();
    }
    /**
     * Draws the OBS route.
     * @param flightPlan The active flight plan.
     * @param context The context to draw to.
     */
    drawObs(flightPlan, context) {
        var _a, _b;
        const activeLegIndex = this.props.dataProvider.activeLateralLegIndex.get();
        const activeLeg = activeLegIndex >= 0 && activeLegIndex < flightPlan.length
            ? flightPlan.getLeg(flightPlan.activeLateralLeg)
            : null;
        if (((_a = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.calculated) === null || _a === void 0 ? void 0 : _a.endLat) === undefined || ((_b = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.calculated) === null || _b === void 0 ? void 0 : _b.endLon) === undefined) {
            return;
        }
        context.lineWidth = MapFlightPlanLayer.ROUTE_STROKE_WIDTH;
        const obsFix = MapFlightPlanLayer.geoPointCache[0].set(activeLeg.calculated.endLat, activeLeg.calculated.endLon);
        const obsLat = obsFix.lat;
        const obsLon = obsFix.lon;
        const obsCourseTrue = MagVar.magneticToTrue(this.obsCourse, obsLat, obsLon);
        const obsPath = MapFlightPlanLayer.geoCircleCache[0].setAsGreatCircle(obsFix, obsCourseTrue);
        const start = obsPath.offsetDistanceAlong(obsFix, UnitType.NMILE.convertTo(-500, UnitType.GA_RADIAN), MapFlightPlanLayer.geoPointCache[1]);
        const startLat = start.lat;
        const startLon = start.lon;
        const end = obsPath.offsetDistanceAlong(obsFix, UnitType.NMILE.convertTo(500, UnitType.GA_RADIAN), MapFlightPlanLayer.geoPointCache[1]);
        const endLat = end.lat;
        const endLon = end.lon;
        context.strokeStyle = 'magenta';
        context.beginPath();
        this.drawTrack(startLat, startLon, obsLat, obsLon, context);
        context.stroke();
        context.strokeStyle = 'white';
        context.beginPath();
        this.drawTrack(obsLat, obsLon, endLat, endLon, context);
        context.stroke();
    }
    /**
     * Draws a flight plan leg, excluding leg to leg turns.
     * @param leg The leg to draw.
     * @param context The context to draw to.
     */
    drawLegWithoutTurns(leg, context) {
        const calculated = leg.calculated;
        if (calculated !== undefined) {
            for (let i = 0; i < calculated.flightPath.length; i++) {
                const vector = calculated.flightPath[i];
                this.drawVectorSegment(vector, context);
            }
        }
    }
    /**
     * Refreshes this layer's flight plan leg waypoint records, keeping them up to date with the active flight plan.
     */
    async refreshWaypoints() {
        this.isRefreshWaypointsBusy = true;
        const flightPlan = this.props.dataProvider.plan.get();
        if (!flightPlan) {
            // Remove all waypoint records.
            for (const record of this.legWaypointRecords.values()) {
                record.destroy();
            }
            this.legWaypointRecords.clear();
            this.isRefreshWaypointsBusy = false;
            return;
        }
        const activeLegIndex = this.props.dataProvider.activeLateralLegIndex.get();
        const activeLeg = activeLegIndex >= 0 && activeLegIndex < flightPlan.length
            ? flightPlan.getLeg(activeLegIndex)
            : null;
        if (this.needRepickWaypoints) {
            const legsToDisplay = new Set();
            // Gather all legs to display.
            const firstLegIndex = this.props.drawEntirePlan.get()
                ? 0
                : activeLegIndex >= 0
                    ? this.isObsActive ? activeLegIndex : activeLegIndex - 2
                    : flightPlan.length;
            let legIndex = 0;
            for (const leg of flightPlan.legs()) {
                if (legIndex >= firstLegIndex && (!leg.isInDirectToSequence || legIndex === flightPlan.activeLateralLeg)) {
                    legsToDisplay.add(leg);
                }
                legIndex++;
            }
            // Remove records of legs that are no longer in the set of legs to display.
            for (const record of this.legWaypointRecords.values()) {
                if (legsToDisplay.has(record.leg)) {
                    legsToDisplay.delete(record.leg);
                }
                else {
                    record.destroy();
                    this.legWaypointRecords.delete(record.leg);
                }
            }
            // Create new records for legs to display that don't already have records.
            for (const leg of legsToDisplay) {
                const record = this.createLegWaypointsRecord(leg);
                this.legWaypointRecords.set(leg, record);
            }
        }
        const waypointRefreshes = [];
        for (const record of this.legWaypointRecords.values()) {
            waypointRefreshes.push(record.refresh(record.leg === activeLeg));
        }
        await Promise.all(waypointRefreshes);
        this.isRefreshWaypointsBusy = false;
    }
    /**
     * Creates a FlightPlanLegWaypointsRecord for a specified flight plan leg.
     * @param leg A flight plan leg.
     * @returns A FlightPlanLegWaypointsRecord for the specified flight plan leg.
     */
    createLegWaypointsRecord(leg) {
        switch (leg.leg.type) {
            case LegType.CD:
            case LegType.VD:
            case LegType.CR:
            case LegType.VR:
            case LegType.FC:
            case LegType.FD:
            case LegType.FA:
            case LegType.CA:
            case LegType.VA:
            case LegType.FM:
            case LegType.VM:
            case LegType.CI:
            case LegType.VI:
                return new FlightPathTerminatorWaypointsRecord(leg, this.props.waypointRenderer, this.facLoader);
            case LegType.PI:
                return new ProcedureTurnLegWaypointsRecord(leg, this.props.waypointRenderer, this.facLoader, this.facWaypointCache);
            default:
                return new FixIcaoWaypointsRecord(leg, this.props.waypointRenderer, this.facLoader, this.facWaypointCache);
        }
    }
    /**
     * Draws a segment of a vector to the flight plan layer.
     * @param vector The vector to draw.
     * @param context The canvas context to draw to.
     * @param turnBefore A turn to draw before the vector, if any.
     * @param turnAfter A turn to draw after the vector, if any.
     */
    drawVectorSegment(vector, context, turnBefore, turnAfter) {
        let currentLat = vector.startLat;
        let currentLon = vector.startLon;
        if (turnBefore !== undefined) {
            const turnCircle = FlightPathUtils.setGeoCircleFromVector(turnBefore, MapFlightPlanLayer.geoCircleCache[0]);
            const turnCenter = FlightPathUtils.getTurnCenterFromCircle(turnCircle, MapFlightPlanLayer.geoPointCache[0]);
            this.drawArc(turnBefore.startLat, turnBefore.startLon, turnBefore.endLat, turnBefore.endLon, turnCenter.lat, turnCenter.lon, FlightPathUtils.getTurnDirectionFromCircle(turnCircle), context);
            currentLat = turnBefore.endLat;
            currentLon = turnBefore.endLon;
        }
        let endLat = vector.endLat;
        let endLon = vector.endLon;
        if (turnAfter !== undefined) {
            endLat = turnAfter.startLat;
            endLon = turnAfter.startLon;
        }
        const circle = FlightPathUtils.setGeoCircleFromVector(vector, MapFlightPlanLayer.geoCircleCache[0]);
        if (FlightPathUtils.isVectorGreatCircle(vector)) {
            const distanceRad = UnitType.METER.convertTo(vector.distance, UnitType.GA_RADIAN);
            if (distanceRad >= Math.PI - GeoPoint.EQUALITY_TOLERANCE) {
                const startPoint = GeoPoint.sphericalToCartesian(vector.startLat, vector.startLon, MapFlightPlanLayer.vec3Cache[0]);
                const midPoint = circle.offsetDistanceAlong(startPoint, distanceRad, MapFlightPlanLayer.geoPointCache[0]);
                const midLat = midPoint.lat;
                const midLon = midPoint.lon;
                this.drawTrack(currentLat, currentLon, midLat, midLon, context);
                this.drawTrack(midLat, midLon, endLat, endLon, context);
            }
            else {
                this.drawTrack(currentLat, currentLon, endLat, endLon, context);
            }
        }
        else {
            const turnCenter = FlightPathUtils.getTurnCenterFromCircle(circle, MapFlightPlanLayer.geoPointCache[0]);
            this.drawArc(currentLat, currentLon, endLat, endLon, turnCenter.lat, turnCenter.lon, FlightPathUtils.getTurnDirectionFromCircle(circle), context);
        }
        if (turnAfter !== undefined) {
            const turnCircle = FlightPathUtils.setGeoCircleFromVector(turnAfter, MapFlightPlanLayer.geoCircleCache[0]);
            const turnCenter = FlightPathUtils.getTurnCenterFromCircle(turnCircle, MapFlightPlanLayer.geoPointCache[0]);
            this.drawArc(turnAfter.startLat, turnAfter.startLon, turnAfter.endLat, turnAfter.endLon, turnCenter.lat, turnCenter.lon, FlightPathUtils.getTurnDirectionFromCircle(turnCircle), context);
        }
    }
    /**
     * Draws a track vector.
     * @param sLat The starting lat.
     * @param sLon The starting lon.
     * @param eLat The ending lat.
     * @param eLon The ending lon.
     * @param context The context to draw to.
     */
    drawTrack(sLat, sLon, eLat, eLon, context) {
        const start = MapFlightPlanLayer.geoPointCache[0].set(sLat, sLon);
        const end = MapFlightPlanLayer.geoPointCache[1].set(eLat, eLon);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.resampler.resample(this.flightPathLayerRef.instance.display.geoProjection, start, end, this.drawResampledTrack.bind(this, context));
    }
    /**
     * Draws the path for a resampled point along a track vector.
     * @param context The context to draw to.
     * @param point The resampled point to draw.
     * @param projected The projected resampled point to draw.
     * @param index The index of the resampled point.
     */
    drawResampledTrack(context, point, projected, index) {
        if (index === 0) {
            context.moveTo(projected[0], projected[1]);
        }
        else {
            context.lineTo(projected[0], projected[1]);
        }
    }
    /**
     * Draws an arc vector.
     * @param sLat The starting lat.
     * @param sLon The starting lon.
     * @param eLat The ending lat.
     * @param eLon The ending lon.
     * @param cLat The center lat.
     * @param cLon The center lon.
     * @param turnDirection The turn direction of the arc.
     * @param context The context to draw to.
     */
    drawArc(sLat, sLon, eLat, eLon, cLat, cLon, turnDirection, context) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const projection = this.flightPathLayerRef.instance.display.geoProjection;
        const start = MapFlightPlanLayer.geoPointCache[0].set(sLat, sLon);
        const startProjected = projection.project(start, MapFlightPlanLayer.vec2Cache[0]);
        const x1 = startProjected[0];
        const y1 = startProjected[1];
        const end = MapFlightPlanLayer.geoPointCache[0].set(eLat, eLon);
        const endProjected = projection.project(end, MapFlightPlanLayer.vec2Cache[0]);
        const x2 = endProjected[0];
        const y2 = endProjected[1];
        const center = MapFlightPlanLayer.geoPointCache[0].set(cLat, cLon);
        const centerProjected = projection.project(center, MapFlightPlanLayer.vec2Cache[0]);
        const cx = centerProjected[0];
        const cy = centerProjected[1];
        const radiusPixels = Math.sqrt(Math.pow(cx - x1, 2) + Math.pow(cy - y1, 2));
        const startRadians = Math.atan2(y1 - cy, x1 - cx);
        const endRadians = Math.atan2(y2 - cy, x2 - cx);
        context.moveTo(x1, y1);
        context.arc(cx, cy, radiusPixels, startRadians, endRadians, turnDirection === 'left');
    }
    /**
     * Schedules flight plan drawing updates.
     * @param scheduleRedrawRoute Whether to schedule a redraw of the flight path.
     * @param scheduleRefreshWaypoints Whether to schedule a refresh of waypoints records.
     * @param scheduleRepickWaypoints Whether to schedule a repick of waypoints records.
     */
    scheduleUpdates(scheduleRedrawRoute, scheduleRefreshWaypoints, scheduleRepickWaypoints) {
        this.needDrawRoute || (this.needDrawRoute = scheduleRedrawRoute);
        this.needRefreshWaypoints || (this.needRefreshWaypoints = scheduleRefreshWaypoints);
        this.needRepickWaypoints || (this.needRepickWaypoints = scheduleRepickWaypoints);
    }
    /**
     * Recreates the TOD and BOD leg indexes when any values change.
     */
    onTodBodChanged() {
        const plan = this.props.dataProvider.plan.get();
        if (!plan) {
            this.todWaypoint && this.props.waypointRenderer.deregister(this.todWaypoint, MapWaypointRenderRole.VNav, 'flightplan-layer');
            this.bodWaypoint && this.props.waypointRenderer.deregister(this.bodWaypoint, MapWaypointRenderRole.VNav, 'flightplan-layer');
            this.todWaypoint = undefined;
            this.bodWaypoint = undefined;
            return;
        }
        const vnavPathMode = this.props.dataProvider.vnavPathMode.get();
        const todLegIndex = this.props.dataProvider.vnavTodLegIndex.get();
        const todLegEndDistance = this.props.dataProvider.vnavTodLegDistance.get();
        const bodLegIndex = this.props.dataProvider.vnavBodLegIndex.get();
        let registerNewTodBod = true;
        if (plan.segmentCount < 1 || plan.getSegment(0).segmentType === FlightPlanSegmentType.RandomDirectTo) {
            registerNewTodBod = false;
        }
        if (todLegIndex >= 0) {
            this.todWaypoint && this.props.waypointRenderer.deregister(this.todWaypoint, MapWaypointRenderRole.VNav, 'flightplan-layer');
            if (registerNewTodBod && isFinite(todLegEndDistance.number) && todLegIndex >= 0 && vnavPathMode !== VNavPathMode.PathActive && plan.length > 0) {
                try {
                    const leg = plan.getLeg(todLegIndex);
                    this.todWaypoint = new VNavWaypoint(leg, todLegEndDistance.asUnit(UnitType.METER), 'tod');
                    this.props.waypointRenderer.register(this.todWaypoint, MapWaypointRenderRole.VNav, 'flightplan-layer');
                }
                catch (_a) {
                    console.warn(`Invalid tod leg at: ${todLegIndex}`);
                }
            }
            else if (!isFinite(todLegEndDistance.number)) {
                this.todWaypoint = undefined;
                console.warn(`Invalid TOD leg end distance: ${todLegEndDistance}`);
            }
        }
        if (bodLegIndex >= 0) {
            this.bodWaypoint && this.props.waypointRenderer.deregister(this.bodWaypoint, MapWaypointRenderRole.VNav, 'flightplan-layer');
            if (registerNewTodBod && bodLegIndex >= 0 && plan.length > 0) {
                try {
                    const leg = plan.getLeg(bodLegIndex);
                    this.bodWaypoint = new VNavWaypoint(leg, 0, 'bod');
                    this.props.waypointRenderer.register(this.bodWaypoint, MapWaypointRenderRole.VNav, 'flightplan-layer');
                }
                catch (_b) {
                    console.warn(`Invalid bod leg at: ${bodLegIndex}`);
                }
            }
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { style: 'position: absolute; left: 0; top: 0; width: 100%; height: 100%;' },
            FSComponent.buildComponent(MapCachedCanvasLayer, { ref: this.flightPathLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, useBuffer: true, overdrawFactor: Math.SQRT2 }),
            FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.waypointLayerRef, model: this.props.model, mapProjection: this.props.mapProjection })));
    }
}
MapFlightPlanLayer.BASE_ROUTE_STROKE_WIDTH = 2;
MapFlightPlanLayer.BASE_ROUTE_STROKE_COLOR = 'rgba(204, 204, 204, 0.5)';
MapFlightPlanLayer.ROUTE_PRIOR_STROKE_WIDTH = 2;
MapFlightPlanLayer.ROUTE_PRIOR_STROKE_COLOR = '#cccccc';
MapFlightPlanLayer.ROUTE_STROKE_WIDTH = 4;
MapFlightPlanLayer.ROUTE_MISSED_APPROACH_STROKE_WIDTH = 1;
MapFlightPlanLayer.vec2Cache = [new Float64Array(2)];
MapFlightPlanLayer.vec3Cache = [new Float64Array(3)];
MapFlightPlanLayer.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
MapFlightPlanLayer.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
/**
 * An abstract implementation of FlightPlanLegWaypointsRecord.
 */
class AbstractFlightPlanLegWaypointsRecord {
    /**
     * Constructor.
     * @param leg The flight plan leg associated with this record.
     * @param waypointRenderer The renderer used to render this record's waypoints.
     * @param facLoader The facility loader used by this waypoint.
     */
    constructor(leg, waypointRenderer, facLoader) {
        this.leg = leg;
        this.waypointRenderer = waypointRenderer;
        this.facLoader = facLoader;
        this.uid = `flightplan-layer-wptrecord-${AbstractFlightPlanLegWaypointsRecord.uidSource++}`;
        this.isActive = false;
    }
    /**
     * Registers a waypoint with this record's waypoint renderer.
     * @param waypoint A waypoint.
     * @param role The role(s) under which the waypoint should be registered.
     */
    registerWaypoint(waypoint, role) {
        this.waypointRenderer.register(waypoint, role, this.uid);
    }
    /**
     * Removes a registration for a waypoint from this record's waypoint renderer.
     * @param waypoint A waypoint.
     * @param role The role(s) from which the waypoint should be deregistered.
     */
    deregisterWaypoint(waypoint, role) {
        this.waypointRenderer.deregister(waypoint, role, this.uid);
    }
}
AbstractFlightPlanLegWaypointsRecord.uidSource = 0;
/**
 * A record with a single waypoint based on its flight plan leg's fixIcao property.
 */
class FixIcaoWaypointsRecord extends AbstractFlightPlanLegWaypointsRecord {
    /**
     * Constructor.
     * @param leg The flight plan leg associated with this record.
     * @param waypointRenderer The renderer used to render this record's waypoints.
     * @param facLoader The facility loader used by this waypoint.
     * @param facWaypointCache The facility waypoint cache used by this record.
     */
    constructor(leg, waypointRenderer, facLoader, facWaypointCache) {
        super(leg, waypointRenderer, facLoader);
        this.facWaypointCache = facWaypointCache;
        this._waypoint = null;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * This record's waypoint.
     */
    get waypoint() {
        return this._waypoint;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    async refresh(isActive) {
        const icao = this.leg.leg.fixIcao;
        if (!this._waypoint && icao !== '' && icao !== ICAO.emptyIcao) {
            this._waypoint = await this.getFacilityWaypoint(icao);
            if (this._waypoint) {
                this.registerWaypoint(this._waypoint, MapWaypointRenderRole.FlightPlanInactive);
                if (this.isActive) {
                    this.registerWaypoint(this._waypoint, MapWaypointRenderRole.FlightPlanActive);
                }
            }
        }
        if (isActive !== this.isActive) {
            if (this._waypoint) {
                isActive
                    ? this.registerWaypoint(this._waypoint, MapWaypointRenderRole.FlightPlanActive)
                    : this.deregisterWaypoint(this._waypoint, MapWaypointRenderRole.FlightPlanActive);
            }
            this.isActive = isActive;
        }
    }
    /**
     * Gets a facility waypoint from an ICAO string.
     * @param icao A facility ICAO string.
     * @returns a facility waypoint, or null if one could not be created.
     */
    async getFacilityWaypoint(icao) {
        try {
            const facility = await this.facLoader.getFacility(ICAO.getFacilityType(icao), icao);
            return this.facWaypointCache.get(facility);
        }
        catch (e) {
            // noop
        }
        return null;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    destroy() {
        if (!this._waypoint) {
            return;
        }
        this.deregisterWaypoint(this._waypoint, MapWaypointRenderRole.FlightPlanInactive);
        this.isActive && this.deregisterWaypoint(this._waypoint, MapWaypointRenderRole.FlightPlanActive);
    }
}
/**
 * A record with a single flight path waypoint representing its flight plan leg's terminator fix.
 */
class FlightPathTerminatorWaypointsRecord extends AbstractFlightPlanLegWaypointsRecord {
    constructor() {
        super(...arguments);
        this._waypoint = null;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * This record's flight path waypoint.
     */
    get waypoint() {
        return this._waypoint;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    async refresh(isActive) {
        var _a, _b;
        const lastVector = (_a = this.leg.calculated) === null || _a === void 0 ? void 0 : _a.flightPath[this.leg.calculated.flightPath.length - 1];
        if (lastVector) {
            if (!this._waypoint || !this._waypoint.location.equals(lastVector.endLat, lastVector.endLon)) {
                this.cleanUpWaypoint();
                this._waypoint = new FlightPathWaypoint(lastVector.endLat, lastVector.endLon, (_b = this.leg.name) !== null && _b !== void 0 ? _b : '');
                this.registerWaypoint(this._waypoint, MapWaypointRenderRole.FlightPlanInactive);
                if (this.isActive) {
                    this.registerWaypoint(this._waypoint, MapWaypointRenderRole.FlightPlanActive);
                }
            }
        }
        else {
            this.cleanUpWaypoint();
        }
        if (isActive !== this.isActive) {
            if (this._waypoint) {
                isActive
                    ? this.registerWaypoint(this._waypoint, MapWaypointRenderRole.FlightPlanActive)
                    : this.deregisterWaypoint(this._waypoint, MapWaypointRenderRole.FlightPlanActive);
            }
            this.isActive = isActive;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    destroy() {
        this.cleanUpWaypoint();
    }
    /**
     * Deregisters this record's waypoint, if it exists, from the waypoint renderer.
     */
    cleanUpWaypoint() {
        if (!this._waypoint) {
            return;
        }
        this.deregisterWaypoint(this._waypoint, MapWaypointRenderRole.FlightPlanInactive);
        this.isActive && this.deregisterWaypoint(this._waypoint, MapWaypointRenderRole.FlightPlanActive);
    }
}
/**
 * A record for procedure turn (PI) legs. Maintains two waypoints, both located at the PI leg's origin fix. The first
 * waypoint is a standard FacilityWaypoint which is never rendered in an active flight plan waypoint role. The second
 * is a ProcedureTurnWaypoint with an ident string equal to the PI leg's given name and which can be rendered in an
 * active flight plan waypoint role.
 */
class ProcedureTurnLegWaypointsRecord extends AbstractFlightPlanLegWaypointsRecord {
    /**
     * Constructor.
     * @param leg The flight plan leg associated with this record.
     * @param waypointRenderer The renderer used to render this record's waypoints.
     * @param facLoader The facility loader used by this waypoint.
     * @param facWaypointCache The facility waypoint cache used by this record.
     */
    constructor(leg, waypointRenderer, facLoader, facWaypointCache) {
        super(leg, waypointRenderer, facLoader);
        this.ptWaypoint = null;
        this.fixIcaoRecord = new FixIcaoWaypointsRecord(leg, waypointRenderer, facLoader, facWaypointCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    async refresh(isActive) {
        var _a;
        await this.fixIcaoRecord.refresh(false);
        if (!this.ptWaypoint && this.fixIcaoRecord.waypoint) {
            this.ptWaypoint = new ProcedureTurnLegWaypoint(this.fixIcaoRecord.waypoint.location.lat, this.fixIcaoRecord.waypoint.location.lon, (_a = this.leg.name) !== null && _a !== void 0 ? _a : '');
            this.registerWaypoint(this.ptWaypoint, MapWaypointRenderRole.FlightPlanInactive);
            if (this.isActive) {
                this.deregisterWaypoint(this.ptWaypoint, MapWaypointRenderRole.FlightPlanActive);
            }
        }
        if (isActive !== this.isActive) {
            if (this.ptWaypoint) {
                isActive
                    ? this.registerWaypoint(this.ptWaypoint, MapWaypointRenderRole.FlightPlanActive)
                    : this.deregisterWaypoint(this.ptWaypoint, MapWaypointRenderRole.FlightPlanActive);
            }
            this.isActive = isActive;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    destroy() {
        this.fixIcaoRecord.destroy();
        if (!this.ptWaypoint) {
            return;
        }
        this.deregisterWaypoint(this.ptWaypoint, MapWaypointRenderRole.FlightPlanInactive);
        this.isActive && this.deregisterWaypoint(this.ptWaypoint, MapWaypointRenderRole.FlightPlanActive);
    }
}
/**
 * A waypoint marking a procedure turn leg.
 */
class ProcedureTurnLegWaypoint extends CustomWaypoint {
    /**
     * Constructor.
     * @param lat The latitude of this waypoint.
     * @param lon The longitude of this waypoint.
     * @param ident The ident string of this waypoint.
     */
    constructor(lat, lon, ident) {
        super(lat, lon, `${ProcedureTurnLegWaypoint.UID_PREFIX}_${ident}`);
        this.ident = ident;
    }
}
ProcedureTurnLegWaypoint.UID_PREFIX = 'PI';
/**
 * A waypoint icon factory.
 */
class WaypointIconFactory {
    /**
     * Constructor.
     * @param styles Icon styling options used by this factory.
     */
    constructor(styles) {
        this.styles = styles;
        this.cache = new Map();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getIcon(waypoint) {
        let existing = this.cache.get(waypoint.uid);
        if (!existing) {
            existing = this.createIcon(waypoint);
            this.cache.set(waypoint.uid, existing);
        }
        return existing;
    }
    /**
     * Creates a new icon for a waypoint.
     * @param waypoint The waypoint for which to create an icon.
     * @returns a waypoint icon.
     */
    createIcon(waypoint) {
        if (waypoint instanceof AirportWaypoint) {
            return new MapAirportIcon(waypoint, this.styles.airportIconPriority[waypoint.size], this.styles.airportIconSize[waypoint.size], this.styles.airportIconSize[waypoint.size]);
        }
        else if (waypoint instanceof FacilityWaypoint) {
            switch (ICAO.getFacilityType(waypoint.facility.icao)) {
                case FacilityType.VOR:
                    return new MapVorIcon(waypoint, this.styles.vorIconPriority, this.styles.vorIconSize, this.styles.vorIconSize);
                case FacilityType.NDB:
                    return new MapNdbIcon(waypoint, this.styles.ndbIconPriority, this.styles.ndbIconSize, this.styles.ndbIconSize);
                case FacilityType.Intersection:
                    return new MapIntersectionIcon(waypoint, this.styles.intIconPriority, this.styles.intIconSize, this.styles.intIconSize);
                case FacilityType.USR:
                    return new MapUserWaypointIcon(waypoint, this.styles.userIconPriority, this.styles.userIconSize, this.styles.userIconSize);
                case FacilityType.RWY:
                    return new MapRunwayWaypointIcon(waypoint, this.styles.rwyIconPriority, this.styles.rwyIconSize, this.styles.rwyIconSize);
                case FacilityType.VIS:
                    return new MapFlightPathWaypointIcon(waypoint, this.styles.fpIconPriority, this.styles.fpIconSize, this.styles.fpIconSize);
            }
        }
        else if (waypoint instanceof FlightPathWaypoint) {
            return new MapFlightPathWaypointIcon(waypoint, this.styles.fpIconPriority, this.styles.fpIconSize, this.styles.fpIconSize);
        }
        return new MapBlankWaypointIcon(waypoint, 0);
    }
}
/**
 * A waypoint label factory.
 */
class WaypointLabelFactory {
    /**
     * Constructor.
     * @param styles Icon styling options used by this factory.
     */
    constructor(styles) {
        this.styles = styles;
        this.cache = new Map();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getLabel(waypoint) {
        let existing = this.cache.get(waypoint.uid);
        if (!existing) {
            existing = this.createLabel(waypoint);
            this.cache.set(waypoint.uid, existing);
        }
        return existing;
    }
    /**
     * Creates a new icon for a waypoint.
     * @param waypoint The waypoint for which to create an icon.
     * @returns a waypoint icon.
     */
    createLabel(waypoint) {
        let text = '';
        let priority = 0;
        let options;
        if (waypoint instanceof FacilityWaypoint) {
            text = ICAO.getIdent(waypoint.facility.icao);
            switch (ICAO.getFacilityType(waypoint.facility.icao)) {
                case FacilityType.Airport:
                    priority = this.styles.airportLabelPriority[waypoint.size];
                    options = this.styles.airportLabelOptions[waypoint.size];
                    break;
                case FacilityType.VOR:
                    priority = this.styles.vorLabelPriority;
                    options = this.styles.vorLabelOptions;
                    break;
                case FacilityType.NDB:
                    priority = this.styles.ndbLabelPriority;
                    options = this.styles.ndbLabelOptions;
                    break;
                case FacilityType.Intersection:
                    priority = this.styles.intLabelPriority;
                    options = this.styles.intLabelOptions;
                    break;
                case FacilityType.USR:
                    priority = this.styles.userLabelPriority;
                    options = this.styles.userLabelOptions;
                    break;
                case FacilityType.RWY:
                    priority = this.styles.rwyLabelPriority;
                    options = this.styles.rwyLabelOptions;
                    break;
                case FacilityType.VIS:
                    priority = this.styles.intLabelPriority;
                    options = this.styles.intLabelOptions;
                    break;
            }
        }
        else if (waypoint instanceof FlightPathWaypoint || waypoint instanceof ProcedureTurnLegWaypoint) {
            text = waypoint.ident;
            priority = this.styles.fpLabelPriority;
            options = this.styles.fpLabelOptions;
        }
        return new MapCullableLocationTextLabel(text, priority, waypoint.location, true, options);
    }
}
/**
 * A waypoint icon factory for VNAV waypoints.
 */
class VNavWaypointIconFactory {
    // eslint-disable-next-line jsdoc/require-jsdoc
    getIcon(waypoint) {
        return new MapVNavWaypointIcon(waypoint, 4, 32, 32);
    }
}
/**
 * A waypoint label factory for VNAV waypoints.
 */
class VNavWaypointLabelFactory {
    // eslint-disable-next-line jsdoc/require-jsdoc
    getLabel(waypoint) {
        return new MapCullableLocationTextLabel(waypoint.uid === 'vnav-tod' ? 'TOD' : 'BOD', 1, waypoint.location, true, { anchor: new Float64Array([-0.2, -0.2]), fontSize: 16 });
    }
}

/**
 * A map flight plan layer data provider which provides a displayed flight plan from a flight planner.
 */
class MapFlightPlannerPlanDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param planner The flight planner.
     */
    constructor(bus, planner) {
        this.bus = bus;
        this.planner = planner;
        this.planSub = Subject.create(null);
        this.plan = this.planSub;
        this.planModified = new SubEvent();
        this.planCalculated = new SubEvent();
        this.activeLegIndexSub = Subject.create(0);
        this.activeLateralLegIndex = this.activeLegIndexSub;
        this.activeLNavLegVectorIndexSub = Subject.create(0);
        this.activeLNavLegVectorIndex = this.activeLNavLegVectorIndexSub;
        this.isLNavSuspendedSub = Subject.create(false);
        this.isLNavSuspended = this.isLNavSuspendedSub;
        this.vnavPathModeSub = Subject.create(VNavPathMode.None);
        this.vnavPathMode = this.vnavPathModeSub;
        this.vnavTodLegIndexSub = Subject.create(-1);
        this.vnavTodLegIndex = this.vnavTodLegIndexSub;
        this.vnavTodLegDistanceSub = NumberUnitSubject.createFromNumberUnit(UnitType.METER.createNumber(0));
        this.vnavTodLegDistance = this.vnavTodLegDistanceSub;
        this.vnavBodLegIndexSub = Subject.create(-1);
        this.vnavBodLegIndex = this.vnavBodLegIndexSub;
        this.obsCourseSub = Subject.create(undefined);
        this.obsCourse = this.obsCourseSub;
        this.planIndex = -1;
        this.activeLNavLegVectorIndexValue = 0;
        this.isLNavSuspendedValue = false;
        this.vnavPathModeValue = VNavPathMode.None;
        this.vnavTodLegIndexValue = -1;
        this.vnavTodLegDistanceMeters = 0;
        this.vnavBodLegIndexValue = -1;
        this.isObsActive = false;
        this.obsCourseValue = 0;
        const plannerEvents = bus.getSubscriber();
        plannerEvents.on('fplCreated').handle(data => { data.planIndex === this.planIndex && this.updatePlan(); });
        plannerEvents.on('fplDeleted').handle(data => { data.planIndex === this.planIndex && this.updatePlan(); });
        plannerEvents.on('fplLoaded').handle(data => { data.planIndex === this.planIndex && this.updatePlan(); });
        plannerEvents.on('fplIndexChanged').handle(() => { this.updateActivePlanRelatedSubs(); });
        plannerEvents.on('fplLegChange').handle(data => { data.planIndex === this.planIndex && this.planModified.notify(this); });
        plannerEvents.on('fplSegmentChange').handle(data => { data.planIndex === this.planIndex && this.planModified.notify(this); });
        plannerEvents.on('fplOriginDestChanged').handle(data => { data.planIndex === this.planIndex && this.planModified.notify(this); });
        plannerEvents.on('fplActiveLegChange').handle(data => { data.planIndex === this.planIndex && data.type === ActiveLegType.Lateral && this.updateActiveLegIndex(); });
        plannerEvents.on('fplCalculated').handle(data => { data.planIndex === this.planIndex && this.planCalculated.notify(this); });
        const lnavEvents = bus.getSubscriber();
        lnavEvents.on('lnavCurrentVector').whenChanged().handle(index => {
            this.activeLNavLegVectorIndexValue = index;
            this.updateActiveLNavLegVectorIndex();
        });
        lnavEvents.on('suspChanged').whenChanged().handle(isSuspended => {
            this.isLNavSuspendedValue = isSuspended;
            this.updateIsLNavSuspended();
        });
        const vnavEvents = bus.getSubscriber();
        vnavEvents.on('vnavPathMode').whenChanged().handle(mode => {
            this.vnavPathModeValue = mode;
            this.updateVNavPathMode();
        });
        vnavEvents.on('vnavTodLegIndex').whenChanged().handle(legIndex => {
            this.vnavTodLegIndexValue = legIndex;
            this.updateVNavTodLegIndex();
        });
        vnavEvents.on('vnavTodLegDistance').withPrecision(0).handle(distance => {
            this.vnavTodLegDistanceMeters = distance;
            this.updateVNavTodLegDistance();
        });
        vnavEvents.on('vnavBodLegIndex').whenChanged().handle(legIndex => {
            this.vnavBodLegIndexValue = legIndex;
            this.updateVNavBodLegIndex();
        });
        const navEvents = this.bus.getSubscriber();
        navEvents.on('gps_obs_active').whenChanged().handle(isActive => {
            this.isObsActive = isActive;
            this.updateObsCourse();
        });
        navEvents.on('gps_obs_value').whenChanged().handle(course => {
            this.obsCourseValue = course;
            this.updateObsCourse();
        });
    }
    /**
     * Sets the index of the displayed plan.
     * @param index The index of the displayed plan.
     */
    setPlanIndex(index) {
        if (index === this.planIndex) {
            return;
        }
        this.planIndex = index;
        this.updatePlan();
        this.updateActivePlanRelatedSubs();
    }
    /**
     * Updates the displayed plan.
     */
    updatePlan() {
        if (this.planner.hasFlightPlan(this.planIndex)) {
            this.planSub.set(this.planner.getFlightPlan(this.planIndex));
        }
        else {
            this.planSub.set(null);
        }
    }
    /**
     * Updates subjects related to the active plan.
     */
    updateActivePlanRelatedSubs() {
        this.updateActiveLegIndex();
        this.updateActiveLNavLegVectorIndex();
        this.updateIsLNavSuspended();
        this.updateVNavPathMode();
        this.updateVNavTodLegIndex();
        this.updateVNavTodLegDistance();
        this.updateVNavBodLegIndex();
        this.updateObsCourse();
    }
    /**
     * Updates the active leg index.
     */
    updateActiveLegIndex() {
        const plan = this.plan.get();
        this.activeLegIndexSub.set(plan && this.planIndex === this.planner.activePlanIndex ? plan.activeLateralLeg : -1);
    }
    /**
     * Updates the active LNAV leg vector index.
     */
    updateActiveLNavLegVectorIndex() {
        this.activeLNavLegVectorIndexSub.set(this.planIndex === this.planner.activePlanIndex ? this.activeLNavLegVectorIndexValue : 0);
    }
    /**
     * Updates whether LNAV sequencing is suspended.
     */
    updateIsLNavSuspended() {
        this.isLNavSuspendedSub.set(this.planIndex === this.planner.activePlanIndex && this.isLNavSuspendedValue);
    }
    /**
     * Updates the current VNAV path mode.
     */
    updateVNavPathMode() {
        this.vnavPathModeSub.set(this.planIndex === this.planner.activePlanIndex ? this.vnavPathModeValue : VNavPathMode.None);
    }
    /**
     * Updates the index of the VNAV top-of-descent leg.
     */
    updateVNavTodLegIndex() {
        this.vnavTodLegIndexSub.set(this.planIndex === this.planner.activePlanIndex ? this.vnavTodLegIndexValue : -1);
    }
    /**
     * Updates the distance from the VNAV top-of-descent point to the end of the top-of-descent leg.
     */
    updateVNavTodLegDistance() {
        this.vnavTodLegDistanceSub.set(this.planIndex === this.planner.activePlanIndex ? this.vnavTodLegDistanceMeters : 0, UnitType.METER);
    }
    /**
     * Updates the index of the VNAV bottom-of-descent leg.
     */
    updateVNavBodLegIndex() {
        this.vnavBodLegIndexSub.set(this.planIndex === this.planner.activePlanIndex ? this.vnavBodLegIndexValue : -1);
    }
    /**
     * Updates the OBS course.
     */
    updateObsCourse() {
        this.obsCourseSub.set(this.planIndex === this.planner.activePlanIndex && this.isObsActive ? this.obsCourseValue : undefined);
    }
}

/**
 * A map flight plan layer data provider which provides the active flight plan to be displayed.
 */
class MapActiveFlightPlanDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param planner The flight planner.
     */
    constructor(bus, planner) {
        this.bus = bus;
        this.planner = planner;
        this.provider = new MapFlightPlannerPlanDataProvider(this.bus, this.planner);
        this.plan = this.provider.plan;
        this.planModified = this.provider.planModified;
        this.planCalculated = this.provider.planCalculated;
        this.activeLateralLegIndex = this.provider.activeLateralLegIndex;
        this.activeLNavLegVectorIndex = this.provider.activeLNavLegVectorIndex;
        this.isLNavSuspended = this.provider.isLNavSuspended;
        this.vnavPathMode = this.provider.vnavPathMode;
        this.vnavTodLegIndex = this.provider.vnavTodLegIndex;
        this.vnavTodLegDistance = this.provider.vnavTodLegDistance;
        this.vnavBodLegIndex = this.provider.vnavBodLegIndex;
        this.obsCourse = this.provider.obsCourse;
        const plannerEvents = bus.getSubscriber();
        plannerEvents.on('fplIndexChanged').handle(data => { this.provider.setPlanIndex(data.planIndex); });
        this.provider.setPlanIndex(planner.activePlanIndex);
    }
}

var MapTrafficIntruderOffScaleIndicatorMode;
(function (MapTrafficIntruderOffScaleIndicatorMode) {
    MapTrafficIntruderOffScaleIndicatorMode[MapTrafficIntruderOffScaleIndicatorMode["Off"] = 0] = "Off";
    MapTrafficIntruderOffScaleIndicatorMode[MapTrafficIntruderOffScaleIndicatorMode["TA"] = 1] = "TA";
    MapTrafficIntruderOffScaleIndicatorMode[MapTrafficIntruderOffScaleIndicatorMode["RA"] = 2] = "RA";
})(MapTrafficIntruderOffScaleIndicatorMode || (MapTrafficIntruderOffScaleIndicatorMode = {}));
/**
 * Displays a traffic off-scale indication.
 */
class MapTrafficIntruderOffScaleIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
        this.textSub = this.props.mode.map(mode => {
            return MapTrafficIntruderOffScaleIndicator.TEXT[mode];
        });
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        this.props.mode.sub(this.onModeChanged.bind(this), true);
    }
    /**
     * A callback which is called when the indicator mode changes.
     * @param mode The new mode.
     */
    onModeChanged(mode) {
        this.ref.instance.classList.remove(...Object.values(MapTrafficIntruderOffScaleIndicator.CLASSES));
        this.ref.instance.classList.add(MapTrafficIntruderOffScaleIndicator.CLASSES[mode]);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent("div", { ref: this.ref, class: 'map-traffic-offscale' }, this.textSub));
    }
}
MapTrafficIntruderOffScaleIndicator.CLASSES = {
    [MapTrafficIntruderOffScaleIndicatorMode.Off]: 'offscale-mode-off',
    [MapTrafficIntruderOffScaleIndicatorMode.TA]: 'offscale-mode-ta',
    [MapTrafficIntruderOffScaleIndicatorMode.RA]: 'offscale-mode-ra'
};
MapTrafficIntruderOffScaleIndicator.TEXT = {
    [MapTrafficIntruderOffScaleIndicatorMode.Off]: '',
    [MapTrafficIntruderOffScaleIndicatorMode.TA]: 'TA OFF SCALE',
    [MapTrafficIntruderOffScaleIndicatorMode.RA]: 'RA OFF SCALE'
};

/**
 * A map layer which displays traffic intruders.
 */
class MapTrafficIntruderLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.iconLayerRef = FSComponent.createRef();
        this.trafficModule = this.props.model.getModule('traffic');
        this.intruderViews = {
            [TCASAlertLevel.None]: new Map(),
            [TCASAlertLevel.ProximityAdvisory]: new Map(),
            [TCASAlertLevel.TrafficAdvisory]: new Map(),
            [TCASAlertLevel.ResolutionAdvisory]: new Map()
        };
        this.isInit = false;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onVisibilityChanged(isVisible) {
        var _a;
        if (!isVisible) {
            (_a = this.props.offScaleIndicatorMode) === null || _a === void 0 ? void 0 : _a.set(MapTrafficIntruderOffScaleIndicatorMode.Off);
            if (this.isInit) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.iconLayerRef.instance.display.clear();
            }
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAttached() {
        this.iconLayerRef.instance.onAttached();
        this.trafficModule.operatingMode.sub(this.updateVisibility.bind(this));
        this.trafficModule.show.sub(this.updateVisibility.bind(this), true);
        this.initCanvasStyles();
        this.initIntruders();
        this.initTCASHandlers();
        this.isInit = true;
    }
    /**
     * Initializes canvas styles.
     */
    initCanvasStyles() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const iconContext = this.iconLayerRef.instance.display.context;
        iconContext.textAlign = 'center';
        iconContext.font = `${this.props.fontSize}px Roboto-Bold`;
    }
    /**
     * Initializes all currently existing TCAS intruders.
     */
    initIntruders() {
        const intruders = this.trafficModule.tcas.getIntruders();
        const len = intruders.length;
        for (let i = 0; i < len; i++) {
            this.onIntruderAdded(intruders[i]);
        }
    }
    /**
     * Initializes handlers to respond to TCAS events.
     */
    initTCASHandlers() {
        const tcasSub = this.props.bus.getSubscriber();
        tcasSub.on('tcas_intruder_added').handle(this.onIntruderAdded.bind(this));
        tcasSub.on('tcas_intruder_removed').handle(this.onIntruderRemoved.bind(this));
        tcasSub.on('tcas_intruder_alert_changed').handle(this.onIntruderAlertLevelChanged.bind(this));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.iconLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.initCanvasStyles();
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        if (!this.isVisible()) {
            return;
        }
        this.redrawIntruders();
    }
    /**
     * Redraws all tracked intruders.
     */
    redrawIntruders() {
        const showLabel = this.trafficModule.showIntruderLabel.get();
        const offScaleRange = this.props.useOuterRangeMaxScale ?
            this.props.model.getModule('range').nominalRanges.get()[this.trafficModule.outerRangeIndex.get()]
            : undefined;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const iconDisplay = this.iconLayerRef.instance.display;
        iconDisplay.clear();
        let offScaleRACount = 0;
        let offScaleTACount = 0;
        this.intruderViews[TCASAlertLevel.None].forEach(view => {
            view.draw(this.props.mapProjection, iconDisplay.context, showLabel, offScaleRange);
        });
        this.intruderViews[TCASAlertLevel.ProximityAdvisory].forEach(view => {
            view.draw(this.props.mapProjection, iconDisplay.context, showLabel, offScaleRange);
        });
        this.intruderViews[TCASAlertLevel.TrafficAdvisory].forEach(view => {
            view.draw(this.props.mapProjection, iconDisplay.context, showLabel, offScaleRange);
            if (view.isOffScale) {
                offScaleTACount++;
            }
        });
        this.intruderViews[TCASAlertLevel.ResolutionAdvisory].forEach(view => {
            view.draw(this.props.mapProjection, iconDisplay.context, showLabel, offScaleRange);
            if (view.isOffScale) {
                offScaleRACount++;
            }
        });
        if (this.props.offScaleIndicatorMode) {
            if (offScaleRACount > 0) {
                this.props.offScaleIndicatorMode.set(MapTrafficIntruderOffScaleIndicatorMode.RA);
            }
            else if (offScaleTACount > 0) {
                this.props.offScaleIndicatorMode.set(MapTrafficIntruderOffScaleIndicatorMode.TA);
            }
            else {
                this.props.offScaleIndicatorMode.set(MapTrafficIntruderOffScaleIndicatorMode.Off);
            }
        }
    }
    /**
     * Updates this layer's visibility.
     */
    updateVisibility() {
        this.setVisible(this.trafficModule.tcas.getOperatingMode() !== TCASOperatingMode.Standby && this.trafficModule.show.get());
    }
    /**
     * A callback which is called when a TCAS intruder is added.
     * @param intruder The new intruder.
     */
    onIntruderAdded(intruder) {
        const view = new MapTrafficIntruderView(intruder, this.props.model.getModule('ownAirplaneProps'), this.trafficModule, this.props.fontSize, this.props.iconSize);
        this.intruderViews[intruder.alertLevel.get()].set(intruder, view);
    }
    /**
     * A callback which is called when a TCAS intruder is removed.
     * @param intruder The removed intruder.
     */
    onIntruderRemoved(intruder) {
        this.intruderViews[intruder.alertLevel.get()].delete(intruder);
    }
    /**
     * A callback which is called when the alert level of a TCAS intruder is changed.
     * @param intruder The intruder.
     */
    onIntruderAlertLevelChanged(intruder) {
        let oldAlertLevel;
        let view = this.intruderViews[oldAlertLevel = TCASAlertLevel.None].get(intruder);
        view !== null && view !== void 0 ? view : (view = this.intruderViews[oldAlertLevel = TCASAlertLevel.ProximityAdvisory].get(intruder));
        view !== null && view !== void 0 ? view : (view = this.intruderViews[oldAlertLevel = TCASAlertLevel.TrafficAdvisory].get(intruder));
        view !== null && view !== void 0 ? view : (view = this.intruderViews[oldAlertLevel = TCASAlertLevel.ResolutionAdvisory].get(intruder));
        if (view) {
            this.intruderViews[oldAlertLevel].delete(intruder);
            this.intruderViews[intruder.alertLevel.get()].set(intruder, view);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.iconLayerRef, model: this.props.model, mapProjection: this.props.mapProjection }));
    }
}
/**
 * A view representation of a TCAS intruder for MapTrafficIntruderLayer.
 */
class MapTrafficIntruderView {
    /**
     * Constructor.
     * @param intruder This view's associated intruder.
     * @param ownAirplaneProps The own airplane properties module for this view's parent map.
     * @param trafficModule The traffic module for this view's parent map.
     * @param fontSize This view's font size, in pixels.
     * @param iconSize This view's icon size, in pixels.
     */
    constructor(intruder, ownAirplaneProps, trafficModule, fontSize, iconSize) {
        this.intruder = intruder;
        this.ownAirplaneProps = ownAirplaneProps;
        this.trafficModule = trafficModule;
        this.fontSize = fontSize;
        this.iconSize = iconSize;
        this.projectedPos = new Float64Array(2);
        this._isOffScale = false;
        this.isVisible = false;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether this view is off-scale. */
    get isOffScale() {
        return this._isOffScale;
    }
    /**
     * Draws this view.
     * @param projection The map projection.
     * @param context The canvas rendering context to which to draw this view.
     * @param showLabel Whether to show this view's label.
     * @param offScaleRange The maximum distance from the own airplane this view's intruder can be before it is
     * considered off-scale. If not defined, the map projection boundaries will be used to determine whether this view's
     * intruder is off-scale.
     */
    draw(projection, context, showLabel, offScaleRange) {
        this.updatePosition(projection, offScaleRange);
        this.updateVisibility(!!offScaleRange);
        if (this.isVisible) {
            this.drawIcon(context, projection, showLabel);
        }
    }
    /**
     * Updates this view's intruder's projected position and off-scale status.
     * @param projection The map projection.
     * @param offScaleRange The maximum distance from the own airplane this view's intruder can be before it is
     * considered off-scale. If not defined, the map projection boundaries will be used to determine whether this view's
     * intruder is off-scale.
     */
    updatePosition(projection, offScaleRange) {
        const ownAirplanePos = this.ownAirplaneProps.position.get();
        if (offScaleRange) {
            this.handleOffScaleRange(projection, ownAirplanePos, offScaleRange);
        }
        else {
            this.handleOffScaleMapProjection(projection);
        }
    }
    /**
     * Updates this view's intruder's projected position and off-scale status using the map projection boundaries to
     * define off-scale.
     * @param projection The map projection.
     */
    handleOffScaleMapProjection(projection) {
        projection.project(this.intruder.position, this.projectedPos);
        this._isOffScale = !projection.isInProjectedBounds(this.projectedPos);
    }
    /**
     * Updates this view's intruder's projected position and off-scale status using a specific range from the own
     * airplane to define off-scale.
     * @param projection The map projection.
     * @param ownAirplanePos The position of the own airplane.
     * @param offScaleRange The maximum distance from the own airplane this intruder can be before it is considered
     * off-scale.
     */
    handleOffScaleRange(projection, ownAirplanePos, offScaleRange) {
        const intruderPos = this.intruder.position;
        const horizontalSeparation = intruderPos.distance(ownAirplanePos);
        const offscaleRangeRad = offScaleRange.asUnit(UnitType.GA_RADIAN);
        if (horizontalSeparation > offscaleRangeRad) {
            this._isOffScale = true;
            projection.project(ownAirplanePos.offset(ownAirplanePos.bearingTo(intruderPos), offscaleRangeRad, MapTrafficIntruderView.geoPointCache[0]), this.projectedPos);
        }
        else {
            this._isOffScale = false;
            projection.project(intruderPos, this.projectedPos);
        }
    }
    /**
     * Updates the visibility of this view.
     * @param useOffScaleRange Whether off-scale is defined by distance from the own airplane.
     */
    updateVisibility(useOffScaleRange) {
        let isVisible = false;
        const alertLevel = this.intruder.alertLevel.get();
        const alertLevelMode = this.trafficModule.alertLevelMode.get();
        switch (alertLevel) {
            case TCASAlertLevel.ResolutionAdvisory:
                isVisible = true;
                break;
            case TCASAlertLevel.TrafficAdvisory:
                if (alertLevelMode === MapTrafficAlertLevelMode.TA_RA) {
                    isVisible = true;
                    break;
                }
            // eslint-disable-next-line no-fallthrough
            case TCASAlertLevel.ProximityAdvisory:
                if (alertLevelMode === MapTrafficAlertLevelMode.Advisories) {
                    isVisible = true;
                    break;
                }
            // eslint-disable-next-line no-fallthrough
            case TCASAlertLevel.None:
                if (alertLevelMode === MapTrafficAlertLevelMode.All) {
                    isVisible = true;
                }
        }
        if (alertLevel === TCASAlertLevel.ResolutionAdvisory || alertLevel === TCASAlertLevel.TrafficAdvisory) {
            isVisible && (isVisible = useOffScaleRange || !this._isOffScale);
        }
        else {
            const altitudeMeters = this.intruder.relativePositionVec[2];
            const isWithinAltitude = altitudeMeters <= this.trafficModule.altitudeRestrictionAbove.get().asUnit(UnitType.METER)
                && altitudeMeters >= -this.trafficModule.altitudeRestrictionBelow.get().asUnit(UnitType.METER);
            isVisible && (isVisible = !this._isOffScale && isWithinAltitude);
        }
        this.isVisible = isVisible;
    }
    /**
     * Draws this view's icon.
     * @param context The canvas rendering context to which to draw the icon.
     * @param projection The map projection.
     * @param showLabel Whether to show the icon label.
     */
    drawIcon(context, projection, showLabel) {
        const alertLevel = this.intruder.alertLevel.get();
        context.translate(this.projectedPos[0], this.projectedPos[1]);
        if (showLabel) {
            this.drawIconVSArrow(context, alertLevel);
            this.drawIconAltitudeLabel(context, alertLevel);
        }
        this.drawMotionVector(context, projection);
        this.drawIconBackground(context, projection, alertLevel);
        this.drawIconArrow(context, projection, alertLevel);
        context.resetTransform();
    }
    /**
     * Draws the icon's background.
     * @param context The canvas rendering context to which to draw the icon.
     * @param projection The map projection.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawIconBackground(context, projection, alertLevel) {
        if (alertLevel === TCASAlertLevel.None || alertLevel === TCASAlertLevel.ProximityAdvisory) {
            return;
        }
        context.strokeStyle = '#1a1d21';
        context.fillStyle = alertLevel === TCASAlertLevel.ResolutionAdvisory ? MapTrafficIntruderView.RA_COLOR : MapTrafficIntruderView.TA_COLOR;
        context.beginPath();
        context.arc(0, 0, 0.45 * this.iconSize, 0, 2 * Math.PI);
        context.fill();
        context.stroke();
        if (this._isOffScale) {
            const projectedAngle = Vec2Math.theta(Vec2Math.sub(this.projectedPos, projection.getTargetProjected(), MapTrafficIntruderView.vec2Cache[0]));
            context.beginPath();
            context.arc(0, 0, 0.45 * this.iconSize, projectedAngle - Math.PI / 2, projectedAngle + Math.PI / 2);
            context.fillStyle = 'black';
            context.fill();
        }
    }
    /**
     * Draws the icon's directional arrow.
     * @param context The canvas rendering context to which to draw the icon.
     * @param projection The map projection.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawIconArrow(context, projection, alertLevel) {
        context.save();
        context.rotate(this.intruder.groundTrack * Avionics.Utils.DEG2RAD + projection.getRotation());
        this.drawIconArrowBackground(context, alertLevel);
        this.drawIconArrowOutline(context, alertLevel);
        context.restore();
    }
    /**
     * Draws the icon's directional arrow background.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawIconArrowBackground(context, alertLevel) {
        switch (alertLevel) {
            case TCASAlertLevel.None:
            case TCASAlertLevel.ProximityAdvisory:
                context.fillStyle = 'black';
                break;
            case TCASAlertLevel.TrafficAdvisory:
                context.fillStyle = MapTrafficIntruderView.TA_COLOR;
                break;
            case TCASAlertLevel.ResolutionAdvisory:
                context.fillStyle = MapTrafficIntruderView.RA_COLOR;
                break;
        }
        context.beginPath();
        context.moveTo(0, -0.3 * this.iconSize * 1.4);
        context.lineTo(0.212 * this.iconSize * 1.4, 0.212 * this.iconSize * 1.4);
        context.lineTo(0, 0.1 * this.iconSize * 1.4);
        context.lineTo(-0.212 * this.iconSize * 1.4, 0.212 * this.iconSize * 1.4);
        context.closePath();
        context.fill();
    }
    /**
     * Draws the icon's directional arrow outline.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawIconArrowOutline(context, alertLevel) {
        context.lineWidth = Math.max(1, this.iconSize * 0.05);
        switch (alertLevel) {
            case TCASAlertLevel.None:
                context.strokeStyle = 'white';
                context.fillStyle = 'black';
                break;
            case TCASAlertLevel.ProximityAdvisory:
                context.strokeStyle = 'transparent';
                context.fillStyle = 'white';
                break;
            case TCASAlertLevel.TrafficAdvisory:
                context.strokeStyle = 'black';
                context.fillStyle = MapTrafficIntruderView.TA_COLOR;
                break;
            case TCASAlertLevel.ResolutionAdvisory:
                context.strokeStyle = 'black';
                context.fillStyle = MapTrafficIntruderView.RA_COLOR;
                break;
        }
        context.beginPath();
        context.moveTo(0, -0.3 * this.iconSize);
        context.lineTo(0.212 * this.iconSize, 0.212 * this.iconSize);
        context.lineTo(0, 0.1 * this.iconSize);
        context.lineTo(-0.212 * this.iconSize, 0.212 * this.iconSize);
        context.closePath();
        context.fill();
        context.stroke();
    }
    /**
     * Draws the icon's vertical speed indicator arrow.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawIconVSArrow(context, alertLevel) {
        const showArrow = MapTrafficIntruderView.VERTICAL_SPEED_THRESHOLD.compare(Math.abs(this.intruder.velocityVec[2]), UnitType.MPS) <= 0;
        if (!showArrow) {
            return;
        }
        const vsSign = Math.sign(this.intruder.velocityVec[2]);
        context.beginPath();
        context.moveTo(0.67 * this.iconSize, -0.16 * this.iconSize * vsSign);
        context.lineTo(0.67 * this.iconSize, 0.16 * this.iconSize * vsSign);
        context.moveTo(0.55 * this.iconSize, -0.04 * this.iconSize * vsSign);
        context.lineTo(0.67 * this.iconSize, -0.18 * this.iconSize * vsSign);
        context.lineTo(0.79 * this.iconSize, -0.04 * this.iconSize * vsSign);
        context.lineWidth = Math.max(1, this.iconSize * 0.125);
        context.strokeStyle = 'black';
        context.stroke();
        context.lineWidth = Math.max(1, this.iconSize * 0.075);
        switch (alertLevel) {
            case TCASAlertLevel.None:
            case TCASAlertLevel.ProximityAdvisory:
                context.strokeStyle = 'white';
                break;
            case TCASAlertLevel.TrafficAdvisory:
                context.strokeStyle = MapTrafficIntruderView.TA_COLOR;
                break;
            case TCASAlertLevel.ResolutionAdvisory:
                context.strokeStyle = MapTrafficIntruderView.RA_COLOR;
                break;
        }
        context.stroke();
    }
    /**
     * Draws the icon's altitude label.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawIconAltitudeLabel(context, alertLevel) {
        const isRelative = this.trafficModule.isAltitudeRelative.get();
        const isAltitudeAbove = this.intruder.relativePositionVec[2] >= 0;
        const altitudeFeet = this.trafficModule.isAltitudeRelative.get()
            ? UnitType.METER.convertTo(this.intruder.relativePositionVec[2], UnitType.FOOT)
            : this.intruder.altitude.asUnit(UnitType.FOOT);
        const altitudeRounded = Math.round(altitudeFeet / 100);
        const altitudeAbs = Math.abs(altitudeRounded);
        const prefix = altitudeRounded < 0 ? '−'
            : isRelative ? '+' : '';
        const altitudeText = `${prefix}${altitudeAbs}`;
        const textWidth = context.measureText(altitudeText).width;
        const textHeight = this.fontSize;
        // draw background
        context.fillStyle = 'black';
        if (isAltitudeAbove) {
            context.fillRect(-textWidth / 2 - 2, -0.5 * this.iconSize - textHeight - 2, textWidth + 4, textHeight + 2);
        }
        else {
            context.fillRect(-textWidth / 2 - 2, 0.5 * this.iconSize, textWidth + 4, textHeight + 2);
        }
        // draw text
        switch (alertLevel) {
            case TCASAlertLevel.None:
            case TCASAlertLevel.ProximityAdvisory:
                context.fillStyle = 'white';
                break;
            case TCASAlertLevel.TrafficAdvisory:
                context.fillStyle = MapTrafficIntruderView.TA_COLOR;
                break;
            case TCASAlertLevel.ResolutionAdvisory:
                context.fillStyle = MapTrafficIntruderView.RA_COLOR;
                break;
        }
        if (isAltitudeAbove) {
            context.textBaseline = 'bottom';
            context.fillText(altitudeText, 0, -0.5 * this.iconSize);
        }
        else {
            context.textBaseline = 'top';
            context.fillText(altitudeText, 0, 0.5 * this.iconSize);
        }
    }
    /**
     * Draws this view's motion vector.
     * @param context The canvas rendering context to which to draw the vector.
     * @param projection The map projection.
     */
    drawMotionVector(context, projection) {
        const vectorMode = this.trafficModule.motionVectorMode.get();
        if (vectorMode === MapTrafficMotionVectorMode.Off) {
            return;
        }
        const vector = vectorMode === MapTrafficMotionVectorMode.Absolute
            ? this.intruder.velocityVec
            : this.intruder.relativeVelocityVec;
        const alertLevel = this.intruder.alertLevel.get();
        if (alertLevel === TCASAlertLevel.None || alertLevel === TCASAlertLevel.ProximityAdvisory) {
            const color = vectorMode === MapTrafficMotionVectorMode.Absolute
                ? MapTrafficIntruderView.VECTOR_ABS_COLOR
                : MapTrafficIntruderView.VECTOR_REL_COLOR;
            this.drawNormalVector(projection, context, color, vector);
        }
        else {
            const color = alertLevel === TCASAlertLevel.ResolutionAdvisory ? MapTrafficIntruderView.RA_COLOR : MapTrafficIntruderView.TA_COLOR;
            this.drawTCAVector(projection, context, color, vector);
        }
    }
    /**
     * Draws a normal motion vector.
     * @param projection The map projection.
     * @param context The canvas rendering context to which to draw the vector.
     * @param color The color of the vector.
     * @param vector The vector to draw.
     */
    drawNormalVector(projection, context, color, vector) {
        context.lineWidth = MapTrafficIntruderView.VECTOR_STROKE_WIDTH;
        context.strokeStyle = color;
        context.setLineDash(MapTrafficIntruderView.VECTOR_EMPTY_LINE_DASH);
        context.beginPath();
        const distance = Vec2Math.abs(vector) * this.trafficModule.motionVectorLookahead.get().asUnit(UnitType.SECOND);
        const distanceView = distance / UnitType.GA_RADIAN.convertTo(projection.getProjectedResolution(), UnitType.METER);
        const track = -Vec2Math.theta(vector);
        const angle = track + projection.getRotation();
        const end = Vec2Math.setFromPolar(distanceView, angle, MapTrafficIntruderView.vec2Cache[0]);
        context.moveTo(0, 0);
        context.lineTo(end[0], end[1]);
        context.stroke();
    }
    /**
     * Draws a motion vector projected to TCA.
     * @param projection The map projection.
     * @param context The canvas rendering context to which to draw the vector.
     * @param color The color of the vector.
     * @param vector The vector to draw.
     */
    drawTCAVector(projection, context, color, vector) {
        const distanceToEnd = Vec2Math.abs(projection.getProjectedSize());
        if (distanceToEnd > 0) {
            context.lineWidth = MapTrafficIntruderView.VECTOR_STROKE_WIDTH;
            context.strokeStyle = color;
            context.setLineDash(MapTrafficIntruderView.VECTOR_LINE_DASH);
            context.beginPath();
            const track = -Vec2Math.theta(vector);
            const angle = track + projection.getRotation();
            const end = Vec2Math.setFromPolar(distanceToEnd, angle, MapTrafficIntruderView.vec2Cache[0]);
            context.moveTo(0, 0);
            context.lineTo(end[0], end[1]);
            context.stroke();
            context.setLineDash(MapTrafficIntruderView.VECTOR_EMPTY_LINE_DASH);
            const distanceToTCA = Vec2Math.abs(vector) * this.intruder.tca.asUnit(UnitType.SECOND);
            const distanceToTCAProjected = distanceToTCA / UnitType.GA_RADIAN.convertTo(projection.getProjectedResolution(), UnitType.METER);
            if (distanceToTCAProjected > 0) {
                context.beginPath();
                const tca = Vec2Math.setFromPolar(distanceToTCAProjected, angle, MapTrafficIntruderView.vec2Cache[0]);
                context.moveTo(0, 0);
                context.lineTo(tca[0], tca[1]);
                context.stroke();
            }
        }
    }
}
MapTrafficIntruderView.VERTICAL_SPEED_THRESHOLD = UnitType.FPM.createNumber(500);
MapTrafficIntruderView.TA_COLOR = '#ffdc24';
MapTrafficIntruderView.RA_COLOR = 'red';
MapTrafficIntruderView.VECTOR_STROKE_WIDTH = 2;
MapTrafficIntruderView.VECTOR_ABS_COLOR = 'white';
MapTrafficIntruderView.VECTOR_REL_COLOR = '#4ecc3d';
MapTrafficIntruderView.VECTOR_LINE_DASH = [5, 5];
MapTrafficIntruderView.VECTOR_EMPTY_LINE_DASH = [];
MapTrafficIntruderView.geoPointCache = [new GeoPoint(0, 0)];
MapTrafficIntruderView.vec2Cache = [new Float64Array(2)];

/**
 * A map layer which displays a pointer.
 */
class MapPointerLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.pointerRef = FSComponent.createRef();
        this.pointerModule = this.props.model.getModule('pointer');
        this.positionHandler = () => { this.needRepositionPointer = true; };
        this.needRepositionPointer = false;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        this.pointerRef.getOrDefault() && this.updateFromVisibility();
    }
    /**
     * Updates this layer according to its current visibility.
     */
    updateFromVisibility() {
        const isVisible = this.isVisible();
        this.pointerRef.instance.style.display = isVisible ? '' : 'none';
        if (isVisible) {
            this.pointerModule.position.sub(this.positionHandler, true);
        }
        else {
            this.pointerModule.position.unsub(this.positionHandler);
        }
    }
    /** @inheritdoc */
    onAttached() {
        this.updateFromVisibility();
        this.pointerModule.isActive.sub(isActive => this.setVisible(isActive), true);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        if (!this.needRepositionPointer) {
            return;
        }
        this.repositionPointer();
        this.needRepositionPointer = false;
    }
    /**
     * Repositions this layer's pointer.
     */
    repositionPointer() {
        const position = this.pointerModule.position.get();
        this.pointerRef.instance.style.transform = `translate3d(${position[0]}px, ${position[1]}px, 0)`;
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("svg", { ref: this.pointerRef, class: 'map-pointer', viewBox: '0 0 100 100', style: 'position: absolute; left: 0; top: 0; transform: translate3d(0, 0, 0);' },
            FSComponent.buildComponent("polygon", { points: '78.93 95.46 49.48 66.01 41.18 84.57 4.54 4.54 84.57 41.18 66.01 49.48 95.46 78.93 78.93 95.46' })));
    }
}

/**
 * A map layer which displays a crosshair at the projected position of the map target.
 */
class MapCrosshairLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.crosshairRef = FSComponent.createRef();
        this.needReposition = true;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        this.crosshairRef.getOrDefault() && this.updateFromVisibility();
    }
    /**
     * Updates this layer according to its current visibility.
     */
    updateFromVisibility() {
        this.crosshairRef.instance.style.display = this.isVisible() ? '' : 'none';
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.model.getModule('crosshair').show.sub(show => { this.setVisible(show); }, true);
        this.updateFromVisibility();
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.needReposition || (this.needReposition = BitFlags.isAny(changeFlags, MapProjectionChangeType.TargetProjected));
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        if (!this.needReposition || !this.isVisible()) {
            return;
        }
        this.repositionCrosshair();
        this.needReposition = false;
    }
    /**
     * Repositions this layer's crosshair.
     */
    repositionCrosshair() {
        const position = this.props.mapProjection.getTargetProjected();
        this.crosshairRef.instance.style.transform = `translate(-50%, -50%) translate3d(${position[0]}px, ${position[1]}px, 0)`;
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("svg", { ref: this.crosshairRef, class: 'map-crosshair', viewBox: '0 0 100 100', style: 'position: absolute; left: 0; top: 0; transform: translate(-50%, -50%) translate3d(0, 0, 0);' },
            FSComponent.buildComponent("line", { class: 'map-crosshair-outline', x1: '50', y1: '0', x2: '50', y2: '100' }),
            FSComponent.buildComponent("line", { class: 'map-crosshair-outline', x1: '0', y1: '50', x2: '100', y2: '50' }),
            FSComponent.buildComponent("line", { class: 'map-crosshair-stroke', x1: '50', y1: '0', x2: '50', y2: '100' }),
            FSComponent.buildComponent("line", { class: 'map-crosshair-stroke', x1: '0', y1: '50', x2: '100', y2: '50' })));
    }
}

/**
 * A utility class for generating Garmin-based waypoint styles.
 */
class MapWaypointStyles {
    /**
     * Gets styles for waypoints rendered in a normal role.
     * @param baseIconPriority The base waypoint icon render priority. Icon priorities are guaranteed to fall in the
     * range `[baseIconPriority, baseIconPriority + 1)`.
     * @param baseLabelPriority The base waypoint label render priority. Label priorities are guaranteed to fall in the
     * range `[baseLabelPriority, baseLabelPriority + 1)`.
     * @param scale The linear scale of the styles. The larger the value, the larger the rendered icons and labels.
     * Defaults to 1.
     * @returns styles for waypoints rendered in a normal role.
     */
    static getNormalStyles(baseIconPriority, baseLabelPriority, scale = 1) {
        return {
            airportIconPriority: {
                [AirportSize.Large]: baseIconPriority + 0.8,
                [AirportSize.Medium]: baseIconPriority + 0.79,
                [AirportSize.Small]: baseIconPriority + 0.78
            },
            vorIconPriority: baseIconPriority + 0.7,
            ndbIconPriority: baseIconPriority + 0.6,
            intIconPriority: baseIconPriority + 0.5,
            airportIconSize: {
                [AirportSize.Large]: 26 * scale,
                [AirportSize.Medium]: 26 * scale,
                [AirportSize.Small]: 26 * scale
            },
            vorIconSize: 32 * scale,
            ndbIconSize: 32 * scale,
            intIconSize: 32 * scale,
            airportLabelPriority: {
                [AirportSize.Large]: baseLabelPriority + 0.8,
                [AirportSize.Medium]: baseLabelPriority + 0.79,
                [AirportSize.Small]: baseLabelPriority + 0.78
            },
            vorLabelPriority: baseLabelPriority + 0.7,
            ndbLabelPriority: baseLabelPriority + 0.6,
            intLabelPriority: baseLabelPriority + 0.5,
            airportLabelOptions: {
                [AirportSize.Large]: MapWaypointStyles.createNormalLabelOptions(new Float64Array([0, -12 * scale]), 20 * scale),
                [AirportSize.Medium]: MapWaypointStyles.createNormalLabelOptions(new Float64Array([0, -12 * scale]), 16 * scale),
                [AirportSize.Small]: MapWaypointStyles.createNormalLabelOptions(new Float64Array([0, -12 * scale]), 16 * scale)
            },
            vorLabelOptions: MapWaypointStyles.createNormalLabelOptions(new Float64Array([0, -8 * scale]), 16 * scale),
            ndbLabelOptions: MapWaypointStyles.createNormalLabelOptions(new Float64Array([0, -8 * scale]), 16 * scale),
            intLabelOptions: MapWaypointStyles.createNormalLabelOptions(new Float64Array([0, -5 * scale]), 16 * scale),
        };
    }
    /**
     * Creates initialization options for waypoint labels rendered in a normal role.
     * @param offset The label offset, in pixels.
     * @param fontSize The font size of the label, in pixels.
     * @returns initialization options for waypoint labels rendered in a normal role.
     */
    static createNormalLabelOptions(offset, fontSize) {
        return {
            anchor: new Float64Array([0.5, 1]),
            offset,
            fontSize,
            fontOutlineWidth: 6
        };
    }
    /**
     * Gets styles for waypoints rendered as part of a flight plan.
     * @param active Whether to get styles for active waypoints.
     * @param baseIconPriority The base waypoint icon render priority. Icon priorities are guaranteed to fall in the
     * range `[baseIconPriority, baseIconPriority + 1)`.
     * @param baseLabelPriority The base waypoint label render priority. Label priorities are guaranteed to fall in the
     * range `[baseLabelPriority, baseLabelPriority + 1)`.
     * @param scale The linear scale of the styles. The larger the value, the larger the rendered icons and labels.
     * Defaults to 1.
     * @returns styles for waypoints rendered as part of a flight plan.
     */
    static getFlightPlanStyles(active, baseIconPriority, baseLabelPriority, scale = 1) {
        const createLabelOptions = active
            ? MapWaypointStyles.createFlightPlanActiveLabelOptions.bind(this)
            : MapWaypointStyles.createFlightPlanInactiveLabelOptions.bind(this);
        return {
            airportIconPriority: {
                [AirportSize.Large]: baseIconPriority + 0.8,
                [AirportSize.Medium]: baseIconPriority + 0.79,
                [AirportSize.Small]: baseIconPriority + 0.78
            },
            vorIconPriority: baseIconPriority + 0.7,
            ndbIconPriority: baseIconPriority + 0.6,
            intIconPriority: baseIconPriority + 0.5,
            rwyIconPriority: baseIconPriority + 0.4,
            userIconPriority: baseIconPriority + 0.9,
            fpIconPriority: baseIconPriority + 0.1,
            airportIconSize: {
                [AirportSize.Large]: 26 * scale,
                [AirportSize.Medium]: 26 * scale,
                [AirportSize.Small]: 26 * scale
            },
            vorIconSize: 32 * scale,
            ndbIconSize: 32 * scale,
            intIconSize: 32 * scale,
            rwyIconSize: 32 * scale,
            userIconSize: 32 * scale,
            fpIconSize: 8 * scale,
            airportLabelPriority: {
                [AirportSize.Large]: baseLabelPriority + 0.8,
                [AirportSize.Medium]: baseLabelPriority + 0.79,
                [AirportSize.Small]: baseLabelPriority + 0.78
            },
            vorLabelPriority: baseLabelPriority + 0.7,
            ndbLabelPriority: baseLabelPriority + 0.6,
            intLabelPriority: baseLabelPriority + 0.5,
            rwyLabelPriority: baseLabelPriority + 0.4,
            userLabelPriority: baseLabelPriority + 0.9,
            fpLabelPriority: baseLabelPriority + 0.1,
            airportLabelOptions: {
                [AirportSize.Large]: createLabelOptions(new Float64Array([0, -15 * scale]), 20 * scale),
                [AirportSize.Medium]: createLabelOptions(new Float64Array([0, -15 * scale]), 16 * scale),
                [AirportSize.Small]: createLabelOptions(new Float64Array([0, -15 * scale]), 16 * scale)
            },
            vorLabelOptions: createLabelOptions(new Float64Array([0, -11 * scale]), 16 * scale),
            ndbLabelOptions: createLabelOptions(new Float64Array([0, -11 * scale]), 16 * scale),
            intLabelOptions: createLabelOptions(new Float64Array([0, -8 * scale]), 16 * scale),
            rwyLabelOptions: createLabelOptions(new Float64Array([0, -8 * scale]), 16 * scale),
            userLabelOptions: createLabelOptions(new Float64Array([0, -12 * scale]), 16 * scale),
            fpLabelOptions: createLabelOptions(new Float64Array([0, -8 * scale]), 16 * scale),
        };
    }
    /**
     * Creates initialization options for labels for inactive waypoints rendered as part of a flight plan.
     * @param offset The label offset, in pixels.
     * @param fontSize The font size of the label, in pixels.
     * @returns initialization options for labels for inactive waypoints rendered as part of a flight plan.
     */
    static createFlightPlanInactiveLabelOptions(offset, fontSize) {
        return {
            anchor: new Float64Array([0.5, 1]),
            offset,
            font: 'Roboto-Bold',
            fontSize,
            fontColor: 'black',
            fontOutlineWidth: 0,
            showBg: true,
            bgPadding: [1, 1, 1, 1],
            bgColor: 'white',
            bgOutlineWidth: 1,
            bgOutlineColor: 'black'
        };
    }
    /**
     * Creates initialization options for labels for inactive waypoints rendered as part of a flight plan.
     * @param offset The label offset, in pixels.
     * @param fontSize The font size of the label, in pixels.
     * @returns initialization options for labels for inactive waypoints rendered as part of a flight plan.
     */
    static createFlightPlanActiveLabelOptions(offset, fontSize) {
        return {
            anchor: new Float64Array([0.5, 1]),
            offset,
            font: 'Roboto-Bold',
            fontSize,
            fontColor: 'magenta',
            fontOutlineWidth: 0,
            showBg: true,
            bgPadding: [1, 1, 1, 1],
            bgOutlineWidth: 1
        };
    }
    /**
     * Gets styles for waypoints rendered as highlighted.
     * @param baseIconPriority The base waypoint icon render priority. Icon priorities are guaranteed to fall in the
     * range `[baseIconPriority, baseIconPriority + 1)`.
     * @param baseLabelPriority The base waypoint label render priority. Label priorities are guaranteed to fall in the
     * range `[baseLabelPriority, baseLabelPriority + 1)`.
     * @param scale The linear scale of the styles. The larger the value, the larger the rendered icons and labels.
     * Defaults to 1.
     * @returns styles for waypoints rendered as highlighted.
     */
    static getHighlightStyles(baseIconPriority, baseLabelPriority, scale = 1) {
        return {
            highlightRingRadiusBuffer: 0,
            highlightRingStrokeWidth: 2,
            highlightRingStrokeColor: 'white',
            highlightRingOutlineWidth: 0,
            highlightRingOutlineColor: 'black',
            highlightBgColor: '#3c3c3c',
            airportIconPriority: {
                [AirportSize.Large]: baseIconPriority + 0.8,
                [AirportSize.Medium]: baseIconPriority + 0.79,
                [AirportSize.Small]: baseIconPriority + 0.78
            },
            vorIconPriority: baseIconPriority + 0.7,
            ndbIconPriority: baseIconPriority + 0.6,
            intIconPriority: baseIconPriority + 0.5,
            userIconPriority: baseIconPriority + 0.9,
            airportIconSize: {
                [AirportSize.Large]: 26 * scale,
                [AirportSize.Medium]: 26 * scale,
                [AirportSize.Small]: 26 * scale
            },
            vorIconSize: 32 * scale,
            ndbIconSize: 32 * scale,
            intIconSize: 32 * scale,
            userIconSize: 32 * scale,
            airportLabelPriority: {
                [AirportSize.Large]: baseLabelPriority + 0.8,
                [AirportSize.Medium]: baseLabelPriority + 0.79,
                [AirportSize.Small]: baseLabelPriority + 0.78
            },
            vorLabelPriority: baseLabelPriority + 0.7,
            ndbLabelPriority: baseLabelPriority + 0.6,
            intLabelPriority: baseLabelPriority + 0.5,
            userLabelPriority: baseLabelPriority + 0.9,
            airportLabelOptions: {
                [AirportSize.Large]: MapWaypointStyles.createHighlightLabelOptions(new Float64Array([0, -17 * scale]), 20 * scale),
                [AirportSize.Medium]: MapWaypointStyles.createHighlightLabelOptions(new Float64Array([0, -17 * scale]), 16 * scale),
                [AirportSize.Small]: MapWaypointStyles.createHighlightLabelOptions(new Float64Array([0, -17 * scale]), 16 * scale)
            },
            vorLabelOptions: MapWaypointStyles.createHighlightLabelOptions(new Float64Array([0, -17 * scale]), 16 * scale),
            ndbLabelOptions: MapWaypointStyles.createHighlightLabelOptions(new Float64Array([0, -17 * scale]), 16 * scale),
            intLabelOptions: MapWaypointStyles.createHighlightLabelOptions(new Float64Array([0, -17 * scale]), 16 * scale),
            userLabelOptions: MapWaypointStyles.createHighlightLabelOptions(new Float64Array([0, -17 * scale]), 16 * scale)
        };
    }
    /**
     * Creates initialization options for labels for highlighted waypoints.
     * @param offset The label offset, in pixels.
     * @param fontSize The font size of the label, in pixels.
     * @returns initialization options for labels for highlighted waypoints.
     */
    static createHighlightLabelOptions(offset, fontSize) {
        return {
            anchor: new Float64Array([0.5, 1]),
            offset,
            font: 'Roboto-Bold',
            fontSize,
            fontColor: 'black',
            fontOutlineWidth: 0,
            showBg: true,
            bgPadding: [1, 1, 1, 1],
            bgColor: 'white',
            bgOutlineWidth: 1,
            bgOutlineColor: 'black'
        };
    }
}

/**
 * A component which displays a number with units.
 */
class AbstractNumberUnitDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.valueChangedHandler = this.onValueChanged.bind(this);
        this.displayUnitChangedHandler = this.onDisplayUnitChanged.bind(this);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.value.sub(this.valueChangedHandler, true);
        this.props.displayUnit.sub(this.displayUnitChangedHandler, true);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    destroy() {
        this.props.value.unsub(this.valueChangedHandler);
        this.props.displayUnit.unsub(this.displayUnitChangedHandler);
    }
}

/**
 * A component which displays lat/lon coordinates.
 */
class LatLonDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.locationChangedHandler = this.onLocationChanged.bind(this);
        this.latPrefixSub = Subject.create('');
        this.latNumSub = Subject.create('');
        this.lonPrefixSub = Subject.create('');
        this.lonNumSub = Subject.create('');
        this.formatter = new DmsFormatter();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        this.props.location.sub(this.locationChangedHandler, true);
    }
    /**
     * A callback which is called when this component's bound location changes.
     * @param location The new location.
     */
    onLocationChanged(location) {
        if (isNaN(location.lat) || isNaN(location.lon)) {
            this.clearDisplay();
        }
        else {
            this.setDisplay(location);
        }
    }
    /**
     * Displays the formatted lat/lon coordinates of a location.
     * @param location A location.
     */
    setDisplay(location) {
        this.setCoordSub(this.latPrefixSub, this.latNumSub, this.formatter.parseLat(location.lat), 2);
        this.setCoordSub(this.lonPrefixSub, this.lonNumSub, this.formatter.parseLon(location.lon), 3);
    }
    /**
     * Sets coordinate subjects for a given set of coordinate values.
     * @param prefixSub The coordinate prefix subject.
     * @param numSub The coordinate number subject.
     * @param coordValues The DMS values of the coordinate.
     * @param padDeg The number of digits to which to pad the degrees value.
     */
    setCoordSub(prefixSub, numSub, coordValues, padDeg) {
        const prefix = coordValues.direction;
        let deg = coordValues.degrees;
        let minutes = Math.round((coordValues.minutes + coordValues.seconds / 60) * 100) / 100;
        if (minutes === 60) {
            // need to increment up degrees if minutes was rounded up to 60 from 59.xx.
            deg++;
            minutes = 0;
        }
        prefixSub.set(prefix);
        numSub.set(`${deg.toString().padStart(padDeg, '0')}°${minutes.toFixed(2)}'`);
    }
    /**
     * Displays the blank default value.
     */
    clearDisplay() {
        this.latPrefixSub.set('_');
        this.latNumSub.set('__°__.__\'');
        this.lonPrefixSub.set('_');
        this.lonNumSub.set('___°__.__\'');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' },
            FSComponent.buildComponent("div", { class: 'latlon-coord latlon-lat' },
                FSComponent.buildComponent("div", { class: 'latlon-prefix' }, this.latPrefixSub),
                FSComponent.buildComponent("div", { class: 'latlon-num', style: 'white-space: nowrap;' }, this.latNumSub)),
            FSComponent.buildComponent("div", { class: 'latlon-coord latlon-lon' },
                FSComponent.buildComponent("div", { class: 'latlon-prefix' }, this.lonPrefixSub),
                FSComponent.buildComponent("div", { class: 'latlon-num', style: 'white-space: nowrap;' }, this.lonNumSub))));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    destroy() {
        this.props.location.unsub(this.locationChangedHandler);
    }
}

var DurationDisplayFormat;
(function (DurationDisplayFormat) {
    /** hh:mm:ss. */
    DurationDisplayFormat[DurationDisplayFormat["hh_mm_ss"] = 0] = "hh_mm_ss";
    /** hh:mm. */
    DurationDisplayFormat[DurationDisplayFormat["hh_mm"] = 1] = "hh_mm";
    /** mm:ss. */
    DurationDisplayFormat[DurationDisplayFormat["mm_ss"] = 2] = "mm_ss";
    /** hh:mm if value is greater or equal to 1 hour, otherwise mm:ss. */
    DurationDisplayFormat[DurationDisplayFormat["hh_mm_or_mm_ss"] = 3] = "hh_mm_or_mm_ss";
})(DurationDisplayFormat || (DurationDisplayFormat = {}));
var DurationDisplayDelim;
(function (DurationDisplayDelim) {
    /** Colon (`:`). */
    DurationDisplayDelim[DurationDisplayDelim["Colon"] = 0] = "Colon";
    /** `:` if hh:mm:ss or mm:ss, `+` if hh:mm. */
    DurationDisplayDelim[DurationDisplayDelim["ColonOrCross"] = 1] = "ColonOrCross";
    /** Space (` `). */
    DurationDisplayDelim[DurationDisplayDelim["Space"] = 2] = "Space";
})(DurationDisplayDelim || (DurationDisplayDelim = {}));
/**
 * A component which displays duration values.
 */
class DurationDisplay extends DisplayComponent {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.valueChangedHandler = this.onValueChanged.bind(this);
        this.options = Object.assign({}, DurationDisplay.DEFAULT_OPTIONS, this.props.options);
        this.textSub = Subject.create('');
        switch (this.options.delim) {
            case DurationDisplayDelim.Colon:
                this.delim = ':';
                break;
            case DurationDisplayDelim.Space:
                this.delim = ' ';
                break;
            default:
                this.delim = '';
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        this.props.value.sub(this.valueChangedHandler);
    }
    /**
     * A callback which is called when this component's bound value changes.
     * @param value The new value.
     */
    onValueChanged(value) {
        this.setDisplay(value);
    }
    /**
     * Displays this component's current value.
     * @param value The current value.
     */
    setDisplay(value) {
        let text;
        if (value.isNaN()) {
            text = this.options.nanString;
        }
        else {
            let hrText = '';
            let minText = '';
            let secText = '';
            let hrUnitText = '';
            let minUnitText = '';
            let secUnitText = '';
            let hrDelim = '';
            let minDelim = '';
            const hours = Math.floor(value.asUnit(UnitType.HOUR));
            if (this.options.format != DurationDisplayFormat.mm_ss && !(this.options.format === DurationDisplayFormat.hh_mm_or_mm_ss && hours == 0)) {
                hrText = hours.toFixed(0);
                if (this.options.delim === DurationDisplayDelim.ColonOrCross) {
                    if (this.options.format === DurationDisplayFormat.hh_mm_or_mm_ss || this.options.format === DurationDisplayFormat.hh_mm) {
                        hrDelim = '+';
                    }
                    else {
                        hrDelim = ':';
                    }
                }
                else {
                    hrDelim = this.delim;
                }
            }
            let minutes;
            let seconds;
            if (this.options.format === DurationDisplayFormat.hh_mm || (this.options.format === DurationDisplayFormat.hh_mm_or_mm_ss && hours !== 0)) {
                minutes = value.asUnit(UnitType.MINUTE) % 60;
                minText = this.options.numberFormatter(minutes);
            }
            else {
                minutes = Math.floor(value.asUnit(UnitType.MINUTE) - hours * 60);
                minText = minutes.toFixed(0);
                minDelim = this.options.delim === DurationDisplayDelim.ColonOrCross ? ':' : this.delim;
                seconds = value.asUnit(UnitType.SECOND) % 60;
                secText = this.options.numberFormatter(seconds);
            }
            if (secText && secText.replace(/\b0+/, '').substring(0, 2) === '60') {
                secText = this.options.numberFormatter(parseFloat(secText) - 60);
                minText = `${minutes + 1}`;
            }
            if (minText && minText.replace(/\b0+/, '').substring(0, 2) === '60' && hrText) {
                if (secText) {
                    minText = '00';
                }
                else {
                    minText = this.options.numberFormatter(parseFloat(minText) - 60);
                }
                hrText = `${(hours + 1)}`;
            }
            // pad parts with leading zeroes
            if (hrText) {
                hrText = hrText.padStart(this.options.pad, '0');
                if (secText) {
                    minText = minText.padStart(2, '0');
                    secText = DurationDisplay.padIntegerPart(secText.replace(/^0+/, ''), 2, '0');
                }
                else {
                    minText = DurationDisplay.padIntegerPart(minText.replace(/^0+/, ''), 2, '0');
                }
            }
            else {
                minText = minText.padStart(this.options.pad, '0');
                secText = DurationDisplay.padIntegerPart(secText.replace(/^0+/, ''), 2, '0');
            }
            // format units
            if (this.options.showUnits) {
                hrText && (hrUnitText = this.options.unitFormatter(parseFloat(hrText), UnitType.HOUR));
                minUnitText = this.options.unitFormatter(parseFloat(minText), UnitType.MINUTE);
                secText && (secUnitText = this.options.unitFormatter(parseFloat(secText), UnitType.SECOND));
            }
            text = `${hrText}${hrUnitText}${hrDelim}${minText}${minUnitText}${minDelim}${secText}${secUnitText}`;
        }
        this.textSub.set(text);
    }
    /**
     * Pads the integer part of a string which represents a number.
     * @param str A string which represents a number.
     * @param maxLength The length to which the integer part of the string will be padded.
     * @param fillString The string with which to pad the original string.
     * @returns a new string which is the result of padding the original string.
     */
    static padIntegerPart(str, maxLength, fillString) {
        const decimalIndex = str.indexOf('.');
        return str.padStart(decimalIndex < 0 ? maxLength : str.length - decimalIndex + maxLength, fillString);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', style: 'white-space: nowrap;' }, this.textSub));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    destroy() {
        this.props.value.unsub(this.valueChangedHandler);
    }
}
/** Default formatting options. */
DurationDisplay.DEFAULT_OPTIONS = {
    pad: 0,
    format: DurationDisplayFormat.hh_mm_ss,
    delim: DurationDisplayDelim.Colon,
    showUnits: false,
    numberFormatter: (value) => value.toFixed(0),
    unitFormatter: (value, unit) => unit.name[0],
    nanString: ''
};

/**
 * A component which displays a number with units.
 */
class NumberUnitDisplay extends AbstractNumberUnitDisplay {
    constructor() {
        super(...arguments);
        this.unitTextBigRef = FSComponent.createRef();
        this.numberTextSub = Subject.create('');
        this.unitTextBigSub = Subject.create('');
        this.unitTextSmallSub = Subject.create('');
    }
    /** @inheritdoc */
    onAfterRender() {
        super.onAfterRender();
        // We have to hide the "big" unit text when empty because an empty string will get rendered as a space.
        this.unitTextBigSub.sub((text) => { this.unitTextBigRef.instance.style.display = text === '' ? 'none' : ''; }, true);
    }
    /** @inheritdoc */
    onValueChanged(value) {
        this.setDisplay(value, this.props.displayUnit.get());
    }
    /** @inheritdoc */
    onDisplayUnitChanged(displayUnit) {
        this.setDisplay(this.props.value.get(), displayUnit);
    }
    /**
     * Displays this component's current value.
     * @param value The current value.
     * @param displayUnit The current display unit.
     */
    setDisplay(value, displayUnit) {
        var _a;
        if (!displayUnit || !value.unit.canConvert(displayUnit)) {
            displayUnit = value.unit;
        }
        const numberText = this.props.formatter(value.asUnit(displayUnit));
        this.numberTextSub.set(numberText);
        const unitText = (_a = (NumberUnitDisplay.UNIT_TEXT[displayUnit.family] ? NumberUnitDisplay.UNIT_TEXT[displayUnit.family][displayUnit.name] : undefined)) !== null && _a !== void 0 ? _a : '';
        if (unitText[0] === '°') {
            this.unitTextBigSub.set('°');
            this.unitTextSmallSub.set(unitText.substring(1));
        }
        else {
            this.unitTextBigSub.set('');
            this.unitTextSmallSub.set(unitText);
        }
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', style: 'white-space: nowrap;' },
            FSComponent.buildComponent("span", { class: 'numberunit-num' }, this.numberTextSub),
            FSComponent.buildComponent("span", { ref: this.unitTextBigRef, class: 'numberunit-unit-big' }, this.unitTextBigSub),
            FSComponent.buildComponent("span", { class: 'numberunit-unit-small' }, this.unitTextSmallSub)));
    }
}
NumberUnitDisplay.UNIT_TEXT = {
    [UnitFamily.DISTANCE]: {
        [UnitType.METER.name]: 'M',
        [UnitType.FOOT.name]: 'FT',
        [UnitType.KILOMETER.name]: 'KM',
        [UnitType.NMILE.name]: 'NM'
    },
    [UnitFamily.ANGLE]: {
        [UnitType.DEGREE.name]: '°',
        [UnitType.RADIAN.name]: 'rad'
    },
    [UnitFamily.DURATION]: {
        [UnitType.SECOND.name]: 'S',
        [UnitType.MINUTE.name]: 'M',
        [UnitType.HOUR.name]: 'H'
    },
    [UnitFamily.WEIGHT]: {
        [UnitType.KILOGRAM.name]: 'KG',
        [UnitType.POUND.name]: 'LB',
        [UnitType.LITER_FUEL.name]: 'L',
        [UnitType.GALLON_FUEL.name]: 'GAL'
    },
    [UnitFamily.VOLUME]: {
        [UnitType.LITER.name]: 'L',
        [UnitType.GALLON.name]: 'GAL'
    },
    [UnitFamily.PRESSURE]: {
        [UnitType.HPA.name]: 'HPA',
        [UnitType.IN_HG.name]: 'INHG'
    },
    [UnitFamily.TEMP]: {
        [UnitType.CELSIUS.name]: '°C',
        [UnitType.FAHRENHEIT.name]: '°F'
    },
    [UnitType.KNOT.family]: {
        [UnitType.KNOT.name]: 'KT',
        [UnitType.KPH.name]: 'KH',
        [UnitType.MPM.name]: 'MPM',
        [UnitType.FPM.name]: 'FPM'
    },
    [UnitType.LPH_FUEL.family]: {
        [UnitType.KGH.name]: 'KGH',
        [UnitType.PPH.name]: 'PPH',
        [UnitType.LPH_FUEL.name]: 'LPH',
        [UnitType.GPH_FUEL.name]: 'GPH'
    }
};

/**
 * The map layer showing the range display.
 */
class MapRangeDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.displayUnitSub = Subject.create(null);
        this.autoSubject = Subject.create('false');
        this.autoOverrideSubject = Subject.create('false');
        this.displayUnitHandler = this.updateDisplayUnit.bind(this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        this.props.range.sub(this.displayUnitHandler);
        this.props.displayUnit.sub(this.displayUnitHandler, true);
    }
    /**
     * Updates this component's display unit.
     */
    updateDisplayUnit() {
        const nominalDisplayUnit = this.props.displayUnit.get();
        const range = this.props.range.get();
        let displayUnit;
        if (nominalDisplayUnit && nominalDisplayUnit.equals(UnitType.NMILE)) {
            if (range.asUnit(UnitType.FOOT) <= 2501) {
                displayUnit = UnitType.FOOT;
            }
            else {
                displayUnit = UnitType.NMILE;
            }
        }
        else if (nominalDisplayUnit && nominalDisplayUnit.equals(UnitType.KILOMETER)) {
            if (range.asUnit(UnitType.METER) < 999) {
                displayUnit = UnitType.METER;
            }
            else {
                displayUnit = UnitType.KILOMETER;
            }
        }
        else {
            displayUnit = nominalDisplayUnit;
        }
        this.displayUnitSub.set(displayUnit);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent("div", { class: `map-range-display${this.props.class ? ` ${this.props.class}` : ''}`, auto: this.autoSubject, "auto-override": this.autoOverrideSubject, style: 'display: flex; flex-flow: column nowrap; align-items: center;' },
            FSComponent.buildComponent("div", { class: 'map-range-display-auto', style: 'display: none;' }, "AUTO"),
            FSComponent.buildComponent(NumberUnitDisplay, { value: this.props.range, displayUnit: this.displayUnitSub, formatter: NumberFormatter.create({ precision: 0.01, forceDecimalZeroes: false, maxDigits: 3 }) })));
    }
}

/**
 *
 */
class MapTrafficStatusIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.rootRef = FSComponent.createRef();
        this.disabledRef = FSComponent.createRef();
        this.altitudeRestrictionTextSub = this.props.altitudeRestrictionMode.map(mode => {
            return MapTrafficStatusIndicator.ALT_RESTRICTION_TEXT[mode];
        });
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        this.props.show.sub(show => {
            this.rootRef.instance.style.display = show ? '' : 'none';
        }, true);
        this.props.operatingMode.sub(mode => {
            this.disabledRef.instance.style.display = mode === TCASOperatingMode.Standby ? 'inherit' : 'none';
        }, true);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent("div", { ref: this.rootRef, class: 'map-traffic-status' },
            this.props.showAltitudeRestrictionMode ? FSComponent.buildComponent("div", { class: 'traffic-status-alt' }, this.altitudeRestrictionTextSub) : null,
            FSComponent.buildComponent("svg", { class: 'traffic-status-symbol', viewBox: '0 0 150 100' },
                FSComponent.buildComponent("path", { d: 'M 50 5 L 95 50 L 50 95 L 5 50 Z' }),
                FSComponent.buildComponent("path", { d: 'M 115 10 L 135 35 L 122.5 35 L 122.5 80 L 107.5 80 L 107.5 35 L 95 35 Z' }),
                FSComponent.buildComponent("g", { ref: this.disabledRef, class: 'traffic-status-disabled' },
                    FSComponent.buildComponent("path", { class: 'traffic-status-disabledcross traffic-status-disabledcross-outline', d: 'M 10 10 L 140 90 M 10 90 L 140 10' }),
                    FSComponent.buildComponent("path", { class: 'traffic-status-disabledcross traffic-status-disabledcross-stroke', d: 'M 10 10 L 140 90 M 10 90 L 140 10' })))));
    }
}
MapTrafficStatusIndicator.ALT_RESTRICTION_TEXT = {
    [MapTrafficAltitudeRestrictionMode.Unrestricted]: 'UNRES',
    [MapTrafficAltitudeRestrictionMode.Above]: 'ABOVE',
    [MapTrafficAltitudeRestrictionMode.Normal]: 'NORM',
    [MapTrafficAltitudeRestrictionMode.Below]: 'BELOW'
};

/**
 * Utility class for retrieving map range setting managers.
 */
class MapRangeSettings {
    /**
     * Retrieves a manager for map range setting.
     * @param bus The event bus.
     * @returns a manager for map range setting.
     */
    static getManager(bus) {
        var _a;
        return (_a = MapRangeSettings.INSTANCE) !== null && _a !== void 0 ? _a : (MapRangeSettings.INSTANCE = new DefaultUserSettingManager(bus, [
            {
                name: 'pfdMapRangeIndex',
                defaultValue: 11
            },
            {
                name: 'mfdMapRangeIndex',
                defaultValue: 11
            },
        ]));
    }
}
MapRangeSettings.DEFAULT_RANGES = [
    ...[
        250,
        400,
        500,
        750,
        1000,
        1500,
        2500
    ].map(value => UnitType.FOOT.createNumber(value)),
    ...[
        0.5,
        0.75,
        1,
        1.5,
        2.5,
        4,
        5,
        7.5,
        10,
        15,
        25,
        40,
        50,
        75,
        100,
        150,
        250,
        400,
        500,
        750,
        1000
    ].map(value => UnitType.NMILE.createNumber(value))
];

/**
 * Controls the declutter mode of a map.
 */
class MapDeclutterController {
    /**
     * Creates an instance of the MapDeclutterController.
     * @param declutterModule The declutter module of the map associated with this controller.
     * @param settingManager The user settings manager for map settings.
     */
    constructor(declutterModule, settingManager) {
        this.declutterModule = declutterModule;
        this.settingManager = settingManager;
        this.declutterSettingConsumer = null;
        this.handler = this.onSettingChanged.bind(this);
        this.isInit = false;
        this.declutterSetting = settingManager.getSetting('mapDeclutter');
    }
    /**
     * Initializes this controller. Once initialized, this controller will automatically update the map declutter mode.
     */
    init() {
        if (this.isInit) {
            return;
        }
        this.declutterSettingConsumer = this.settingManager.whenSettingChanged(this.declutterSetting.definition.name);
        this.declutterSettingConsumer.handle(this.handler);
        this.isInit = true;
    }
    /**
     * A callback which is called when the map declutter setting value changes.
     * @param mode The new mp declutter setting mode.
     */
    onSettingChanged(mode) {
        this.declutterModule.mode.set(MapDeclutterController.MODE_MAP[mode]);
    }
    /**
     * Destroys this controller, freeing up resources associated with it. Once destroyed, this controller will no longer
     * automatically update the map declutter mode.
     */
    destroy() {
        var _a;
        (_a = this.declutterSettingConsumer) === null || _a === void 0 ? void 0 : _a.off(this.handler);
        this.declutterSettingConsumer = null;
    }
}
MapDeclutterController.MODE_MAP = {
    [MapDeclutterSettingMode.All]: MapDeclutterMode.All,
    [MapDeclutterSettingMode.Level3]: MapDeclutterMode.Level3,
    [MapDeclutterSettingMode.Level2]: MapDeclutterMode.Level2,
    [MapDeclutterSettingMode.Level1]: MapDeclutterMode.Level1,
};

/**
 * Controls the terrain mode and terrain scale of a map.
 */
class MapTerrainController {
    /**
     * Constructor.
     * @param mapModel The model of the map associated with this controller.
     * @param settingManager This controller's map settings manager.
     * @param allowRelative Whether this controller allows relative terrain colors to be displayed.
     */
    constructor(mapModel, settingManager, allowRelative = true) {
        this.settingManager = settingManager;
        this.allowRelative = allowRelative;
        this.modeSettingConsumer = null;
        this.rangeIndexSettingConsumer = null;
        this.showScaleSettingConsumer = null;
        this.colorsHandler = this.updateColors.bind(this);
        this.showScaleHandler = this.updateShowScale.bind(this);
        this.isInit = false;
        this.rangeModule = mapModel.getModule('range');
        this.ownAirplaneModule = mapModel.getModule('ownAirplaneProps');
        this.terrainModule = mapModel.getModule('terrain');
        this.modeSetting = settingManager.getSetting('mapTerrainMode');
        this.rangeIndexSetting = settingManager.getSetting('mapTerrainRangeIndex');
        this.showScaleSetting = settingManager.getSetting('mapTerrainScaleShow');
    }
    /**
     * Initializes this controller. Once initialized, this controller will automatically update the map terrain mode and scale.
     */
    init() {
        if (this.isInit) {
            return;
        }
        this.modeSettingConsumer = this.settingManager.whenSettingChanged(this.modeSetting.definition.name);
        this.rangeIndexSettingConsumer = this.settingManager.whenSettingChanged(this.rangeIndexSetting.definition.name);
        this.showScaleSettingConsumer = this.settingManager.whenSettingChanged(this.showScaleSetting.definition.name);
        this.modeSettingConsumer.handle(this.colorsHandler);
        this.rangeIndexSettingConsumer.handle(this.colorsHandler);
        this.rangeModule.nominalRangeIndex.sub(this.colorsHandler, true);
        this.ownAirplaneModule.isOnGround.sub(this.colorsHandler, true);
        this.showScaleSettingConsumer.handle(this.showScaleHandler);
        this.isInit = true;
    }
    /**
     * Updates the terrain mode.
     */
    updateColors() {
        let mode = MapTerrainMode.None;
        if (this.rangeModule.nominalRangeIndex.get() <= this.rangeIndexSetting.value) {
            switch (this.modeSetting.value) {
                case MapTerrainSettingMode.Absolute:
                    mode = MapTerrainMode.Absolute;
                    break;
                case MapTerrainSettingMode.Relative:
                    if (this.allowRelative && !this.ownAirplaneModule.isOnGround.get()) {
                        mode = MapTerrainMode.Relative;
                    }
                    break;
            }
        }
        this.terrainModule.terrainMode.set(mode);
    }
    /**
     * Updates whether to show the terrain scale.
     * @param show Whether to show the terrain scale.
     */
    updateShowScale(show) {
        this.terrainModule.showScale.set(show);
    }
    /**
     * Destroys this controller, freeing up resources associated with it. Once destroyed, this controller will no longer
     * automatically update the map terrain mode and scale.
     */
    destroy() {
        var _a, _b, _c;
        (_a = this.modeSettingConsumer) === null || _a === void 0 ? void 0 : _a.off(this.colorsHandler);
        (_b = this.rangeIndexSettingConsumer) === null || _b === void 0 ? void 0 : _b.off(this.colorsHandler);
        this.rangeModule.nominalRangeIndex.unsub(this.colorsHandler);
        this.ownAirplaneModule.isOnGround.unsub(this.colorsHandler);
        (_c = this.showScaleSettingConsumer) === null || _c === void 0 ? void 0 : _c.off(this.showScaleHandler);
        this.modeSettingConsumer = null;
        this.rangeIndexSettingConsumer = null;
        this.showScaleSettingConsumer = null;
    }
}

/**
 * Controls the visibility of a specific type of map symbol whose visibility is dependent on its own show and maximum
 * range index settings as well as the global map declutter setting.
 */
class MapSymbolVisController {
    /**
     * Constructor.
     * @param rangeModule The range module of the map associated with this controller.
     * @param declutterModule The declutter module of the map associated with this controller.
     * @param settingManager This controller's map settings manager.
     * @param showSettingName The name of the show setting associated with this controller.
     * @param rangeIndexSettingName The name of the range index setting associated with this controller.
     * @param declutterLevel The highest global declutter level at which the symbol controlled by this controller remains
     * visible.
     * @param setVisibilityFunc A function which sets the visibility of the symbol controlled by this controller.
     */
    constructor(rangeModule, declutterModule, settingManager, showSettingName, rangeIndexSettingName, declutterLevel, setVisibilityFunc) {
        this.rangeModule = rangeModule;
        this.declutterModule = declutterModule;
        this.settingManager = settingManager;
        this.declutterLevel = declutterLevel;
        this.setVisibilityFunc = setVisibilityFunc;
        this.showSettingConsumer = null;
        this.rangeIndexSettingConsumer = null;
        this.handler = this.updateVisibility.bind(this);
        this.isInit = false;
        this.showSetting = settingManager.getSetting(showSettingName);
        this.rangeIndexSetting = settingManager.getSetting(rangeIndexSettingName);
    }
    /**
     * Initializes this controller. Once initialized, this controller will automatically adjust the visibility of its
     * associated map symbol.
     */
    init() {
        if (this.isInit) {
            return;
        }
        this.showSettingConsumer = this.settingManager.whenSettingChanged(this.showSetting.definition.name);
        this.rangeIndexSettingConsumer = this.settingManager.whenSettingChanged(this.rangeIndexSetting.definition.name);
        this.showSettingConsumer.handle(this.handler);
        this.rangeIndexSettingConsumer.handle(this.handler);
        this.rangeModule.nominalRangeIndex.sub(this.handler);
        this.declutterModule.mode.sub(this.handler, true);
        this.isInit = true;
    }
    /**
     * Updates the visibility of this controller's associated map symbol.
     */
    updateVisibility() {
        let show = false;
        if (this.showSetting.value && this.declutterModule.mode.get() <= this.declutterLevel) {
            show = this.rangeModule.nominalRangeIndex.get() <= this.rangeIndexSetting.value;
        }
        this.setVisibilityFunc(show);
    }
    /**
     * Destroys this controller, freeing up resources associated with it. Once destroyed, this controller will no longer
     * automatically adjust the visibility of its associated map symbol.
     */
    destroy() {
        var _a, _b;
        (_a = this.showSettingConsumer) === null || _a === void 0 ? void 0 : _a.off(this.handler);
        (_b = this.rangeIndexSettingConsumer) === null || _b === void 0 ? void 0 : _b.off(this.handler);
        this.rangeModule.nominalRangeIndex.unsub(this.handler);
        this.declutterModule.mode.unsub(this.handler);
        this.showSettingConsumer = null;
        this.rangeIndexSettingConsumer = null;
    }
}

/**
 * Controls the visibility of map waypoint symbols.
 */
class MapWaypointsVisController {
    /**
     * Constructor.
     * @param mapModel The model of the map associated with this controller.
     * @param settingManager This controller's map settings manager.
     */
    constructor(mapModel, settingManager) {
        const rangeModule = mapModel.getModule('range');
        const declutterModule = mapModel.getModule('declutter');
        const waypointsModule = mapModel.getModule('waypoints');
        this.airportVisControllers = {
            [AirportSize.Large]: new MapSymbolVisController(rangeModule, declutterModule, settingManager, 'mapAirportLargeShow', 'mapAirportLargeRangeIndex', MapDeclutterMode.Level2, visibility => { waypointsModule.airportShow[AirportSize.Large].set(visibility); }),
            [AirportSize.Medium]: new MapSymbolVisController(rangeModule, declutterModule, settingManager, 'mapAirportMediumShow', 'mapAirportMediumRangeIndex', MapDeclutterMode.Level2, visibility => { waypointsModule.airportShow[AirportSize.Medium].set(visibility); }),
            [AirportSize.Small]: new MapSymbolVisController(rangeModule, declutterModule, settingManager, 'mapAirportSmallShow', 'mapAirportSmallRangeIndex', MapDeclutterMode.Level2, visibility => { waypointsModule.airportShow[AirportSize.Small].set(visibility); })
        };
        this.vorVisController = new MapSymbolVisController(rangeModule, declutterModule, settingManager, 'mapVorShow', 'mapVorRangeIndex', MapDeclutterMode.Level3, visibility => { waypointsModule.vorShow.set(visibility); });
        this.ndbVisController = new MapSymbolVisController(rangeModule, declutterModule, settingManager, 'mapNdbShow', 'mapNdbRangeIndex', MapDeclutterMode.Level3, visibility => { waypointsModule.ndbShow.set(visibility); });
        this.intersectionVisController = new MapSymbolVisController(rangeModule, declutterModule, settingManager, 'mapIntersectionShow', 'mapIntersectionRangeIndex', MapDeclutterMode.Level3, visibility => { waypointsModule.intShow.set(visibility); });
    }
    /**
     * Initializes this controller. Once initialized, this controller will automatically adjust the visibility of the map
     * waypoint symbols.
     */
    init() {
        this.airportVisControllers[AirportSize.Large].init();
        this.airportVisControllers[AirportSize.Medium].init();
        this.airportVisControllers[AirportSize.Small].init();
        this.vorVisController.init();
        this.ndbVisController.init();
        this.intersectionVisController.init();
    }
    /**
     * Destroys this controller, freeing up resources associated with it. Once destroyed, this controller will no longer
     * automatically adjust the visibility of the map waypoint symbols.
     */
    destroy() {
        this.airportVisControllers[AirportSize.Large].destroy();
        this.airportVisControllers[AirportSize.Medium].destroy();
        this.airportVisControllers[AirportSize.Small].destroy();
        this.vorVisController.destroy();
        this.ndbVisController.destroy();
        this.intersectionVisController.destroy();
    }
}

/** A controller for displaying NEXRAD. */
class MapNexradController {
    /**
     * Creates an instance of the MapNexradController.
     * @param mapModel The nav map data model.
     * @param settingManager The user settings manager for map settings.
     */
    constructor(mapModel, settingManager) {
        this.settingManager = settingManager;
        const nexradModule = mapModel.getModule('nexrad');
        const rangeModule = mapModel.getModule('range');
        const declutterModule = mapModel.getModule('declutter');
        this.nexradVisController = new MapSymbolVisController(rangeModule, declutterModule, settingManager, 'mapNexradShow', 'mapNexradRangeIndex', MapDeclutterMode.Level2, visibility => { nexradModule.showNexrad.set(visibility); });
    }
    /**
     * Initializes the NEXRAD controller.
     */
    init() {
        this.nexradVisController.init();
    }
    /**
     * Destroys this controller, freeing up resources associated with it. Once destroyed, this controller will no longer
     * automatically update the map terrain mode and scale.
     */
    destroy() {
        this.nexradVisController.destroy();
    }
}

/**
 * Displays a map orientation indication.
 */
class MapOrientationIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.rootRef = FSComponent.createRef();
        this.textSub = this.props.orientation.map(mode => {
            return this.props.text[mode];
        });
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.isVisible.sub(isVisible => { this.rootRef.instance.style.visibility = isVisible ? '' : 'hidden'; });
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { ref: this.rootRef, class: 'map-orientation' }, this.textSub));
    }
}

var TrafficOperatingModeSetting;
(function (TrafficOperatingModeSetting) {
    TrafficOperatingModeSetting[TrafficOperatingModeSetting["Standby"] = 0] = "Standby";
    TrafficOperatingModeSetting[TrafficOperatingModeSetting["Operating"] = 1] = "Operating";
    TrafficOperatingModeSetting[TrafficOperatingModeSetting["Test"] = 2] = "Test";
})(TrafficOperatingModeSetting || (TrafficOperatingModeSetting = {}));
var TrafficAltitudeModeSetting;
(function (TrafficAltitudeModeSetting) {
    TrafficAltitudeModeSetting[TrafficAltitudeModeSetting["Below"] = 0] = "Below";
    TrafficAltitudeModeSetting[TrafficAltitudeModeSetting["Normal"] = 1] = "Normal";
    TrafficAltitudeModeSetting[TrafficAltitudeModeSetting["Above"] = 2] = "Above";
    TrafficAltitudeModeSetting[TrafficAltitudeModeSetting["Unrestricted"] = 3] = "Unrestricted";
})(TrafficAltitudeModeSetting || (TrafficAltitudeModeSetting = {}));
var TrafficMotionVectorModeSetting;
(function (TrafficMotionVectorModeSetting) {
    TrafficMotionVectorModeSetting[TrafficMotionVectorModeSetting["Off"] = 0] = "Off";
    TrafficMotionVectorModeSetting[TrafficMotionVectorModeSetting["Absolute"] = 1] = "Absolute";
    TrafficMotionVectorModeSetting[TrafficMotionVectorModeSetting["Relative"] = 2] = "Relative";
})(TrafficMotionVectorModeSetting || (TrafficMotionVectorModeSetting = {}));
/**
 *
 */
class TrafficUserSettings extends DefaultUserSettingManager {
    /**
     * Gets an instance of the traffic user settings manager.
     * @param bus The event bus.
     * @returns An instance of the traffic user settings manager.
     */
    static getManager(bus) {
        var _a;
        return (_a = TrafficUserSettings.INSTANCE) !== null && _a !== void 0 ? _a : (TrafficUserSettings.INSTANCE = new DefaultUserSettingManager(bus, [
            {
                name: 'trafficOperatingMode',
                defaultValue: TrafficOperatingModeSetting.Standby
            },
            {
                name: 'trafficAltitudeMode',
                defaultValue: TrafficAltitudeModeSetting.Unrestricted
            },
            {
                name: 'trafficMotionVectorMode',
                defaultValue: TrafficMotionVectorModeSetting.Off
            },
            {
                name: 'trafficMotionVectorLookahead',
                defaultValue: 60
            }
        ]));
    }
}

/**
 * Controls the display of traffic on a map.
 */
class MapTrafficController {
    /**
     * Constructor.
     * @param mapModel The model of the map associated with this controller.
     * @param settingManager This controller's traffic settings manager.
     */
    constructor(mapModel, settingManager) {
        this.settingManager = settingManager;
        this.altitudeModeSettingConsumer = null;
        this.motionVectorModeSettingConsumer = null;
        this.motionVectorLookaheadSettingConsumer = null;
        this.altitudeModeHandler = this.updateAltitudeMode.bind(this);
        this.motionVectorModeHandler = this.updateMotionVectorMode.bind(this);
        this.motionVectorLookaheadHandler = this.updateMotionVectorLookahead.bind(this);
        this.isInit = false;
        this.trafficModule = mapModel.getModule('traffic');
        this.altitudeModeSetting = settingManager.getSetting('trafficAltitudeMode');
        this.motionVectorModeSetting = settingManager.getSetting('trafficMotionVectorMode');
        this.motionVectorLookaheadSetting = settingManager.getSetting('trafficMotionVectorLookahead');
    }
    /**
     * Initializes this controller. Once initialized, this controller will automatically update the map traffic module.
     */
    init() {
        if (this.isInit) {
            return;
        }
        this.altitudeModeSettingConsumer = this.settingManager.whenSettingChanged(this.altitudeModeSetting.definition.name);
        this.motionVectorModeSettingConsumer = this.settingManager.whenSettingChanged(this.motionVectorModeSetting.definition.name);
        this.motionVectorLookaheadSettingConsumer = this.settingManager.whenSettingChanged(this.motionVectorLookaheadSetting.definition.name);
        this.altitudeModeSettingConsumer.handle(this.altitudeModeHandler);
        this.motionVectorModeSettingConsumer.handle(this.motionVectorModeHandler);
        this.motionVectorLookaheadSettingConsumer.handle(this.motionVectorLookaheadHandler);
    }
    /**
     * Updates the traffic altitude restriction mode.
     */
    updateAltitudeMode() {
        this.trafficModule.altitudeRestrictionMode.set(MapTrafficController.ALT_MODE_MAP[this.altitudeModeSetting.value]);
    }
    /**
     * Updates the traffic motion vector mode.
     */
    updateMotionVectorMode() {
        this.trafficModule.motionVectorMode.set(MapTrafficController.MOTION_VECTOR_MODE_MAP[this.motionVectorModeSetting.value]);
    }
    /**
     * Updates the traffic motion vector lookahead time.
     */
    updateMotionVectorLookahead() {
        this.trafficModule.motionVectorLookahead.set(this.motionVectorLookaheadSetting.value, UnitType.SECOND);
    }
    /**
     * Destroys this controller, freeing up resources associated with it. Once destroyed, this controller will no longer
     * automatically update the map traffic module.
     */
    destroy() {
        var _a, _b, _c;
        (_a = this.altitudeModeSettingConsumer) === null || _a === void 0 ? void 0 : _a.handle(this.altitudeModeHandler);
        (_b = this.motionVectorModeSettingConsumer) === null || _b === void 0 ? void 0 : _b.handle(this.altitudeModeHandler);
        (_c = this.motionVectorLookaheadSettingConsumer) === null || _c === void 0 ? void 0 : _c.handle(this.motionVectorLookaheadHandler);
        this.altitudeModeSettingConsumer = null;
        this.motionVectorModeSettingConsumer = null;
        this.motionVectorLookaheadSettingConsumer = null;
    }
}
MapTrafficController.ALT_MODE_MAP = {
    [TrafficAltitudeModeSetting.Above]: MapTrafficAltitudeRestrictionMode.Above,
    [TrafficAltitudeModeSetting.Below]: MapTrafficAltitudeRestrictionMode.Below,
    [TrafficAltitudeModeSetting.Normal]: MapTrafficAltitudeRestrictionMode.Normal,
    [TrafficAltitudeModeSetting.Unrestricted]: MapTrafficAltitudeRestrictionMode.Unrestricted
};
MapTrafficController.MOTION_VECTOR_MODE_MAP = {
    [TrafficMotionVectorModeSetting.Off]: MapTrafficMotionVectorMode.Off,
    [TrafficMotionVectorModeSetting.Absolute]: MapTrafficMotionVectorMode.Absolute,
    [TrafficMotionVectorModeSetting.Relative]: MapTrafficMotionVectorMode.Relative
};

/**
 * Controls the display of traffic on a navigation map.
 */
class NavMapTrafficController extends MapTrafficController {
    /**
     * Constructor.
     * @param mapModel The model of the map associated with this controller.
     * @param trafficSettingManager This controller's traffic settings manager.
     * @param mapSettingManager This controller's map settings manager.
     */
    constructor(mapModel, trafficSettingManager, mapSettingManager) {
        super(mapModel, trafficSettingManager);
        this.mapSettingManager = mapSettingManager;
        this.showSettingConsumer = null;
        this.rangeIndexSettingConsumer = null;
        this.labelShowSettingConsumer = null;
        this.labelRangeIndexSettingConsumer = null;
        this.alertLevelModeSettingConsumer = null;
        this.showHandler = this.updateShow.bind(this);
        this.showLabelHandler = this.updateShowLabel.bind(this);
        this.alertLevelModeHandler = this.updateAlertLevelMode.bind(this);
        this.rangeModule = mapModel.getModule('range');
        this.showSetting = mapSettingManager.getSetting('mapTrafficShow');
        this.rangeIndexSetting = mapSettingManager.getSetting('mapTrafficRangeIndex');
        this.labelShowSetting = mapSettingManager.getSetting('mapTrafficLabelShow');
        this.labelRangeIndexSetting = mapSettingManager.getSetting('mapTrafficLabelRangeIndex');
        this.alertLevelModeSetting = mapSettingManager.getSetting('mapTrafficAlertLevelMode');
    }
    /**
     * Initializes this controller. Once initialized, this controller will automatically update the map traffic module.
     */
    init() {
        if (this.isInit) {
            return;
        }
        super.init();
        this.showSettingConsumer = this.mapSettingManager.whenSettingChanged(this.showSetting.definition.name);
        this.rangeIndexSettingConsumer = this.mapSettingManager.whenSettingChanged(this.rangeIndexSetting.definition.name);
        this.labelShowSettingConsumer = this.mapSettingManager.whenSettingChanged(this.labelShowSetting.definition.name);
        this.labelRangeIndexSettingConsumer = this.mapSettingManager.whenSettingChanged(this.labelRangeIndexSetting.definition.name);
        this.alertLevelModeSettingConsumer = this.mapSettingManager.whenSettingChanged(this.alertLevelModeSetting.definition.name);
        this.showSettingConsumer.handle(this.showHandler);
        this.rangeIndexSettingConsumer.handle(this.showHandler);
        this.rangeModule.nominalRangeIndex.sub(this.showHandler, true);
        this.labelShowSettingConsumer.handle(this.showLabelHandler);
        this.labelRangeIndexSettingConsumer.handle(this.showLabelHandler);
        this.rangeModule.nominalRangeIndex.sub(this.showLabelHandler, true);
        this.alertLevelModeSettingConsumer.handle(this.alertLevelModeHandler);
    }
    /**
     * Updates whether to show traffic.
     */
    updateShow() {
        this.trafficModule.show.set(this.showSetting.value && this.rangeModule.nominalRangeIndex.get() <= this.rangeIndexSetting.value);
    }
    /**
     * Updates whether to show traffic intruder labels.
     */
    updateShowLabel() {
        this.trafficModule.showIntruderLabel.set(this.labelShowSetting.value && this.rangeModule.nominalRangeIndex.get() <= this.labelRangeIndexSetting.value);
    }
    /**
     * Updates the traffic alert level mode.
     * @param mode The new alert level mode.
     */
    updateAlertLevelMode(mode) {
        this.trafficModule.alertLevelMode.set(mode);
    }
    /**
     * Destroys this controller, freeing up resources associated with it. Once destroyed, this controller will no longer
     * automatically update the map traffic module.
     */
    destroy() {
        var _a, _b, _c, _d, _e;
        super.destroy();
        (_a = this.showSettingConsumer) === null || _a === void 0 ? void 0 : _a.handle(this.showHandler);
        (_b = this.rangeIndexSettingConsumer) === null || _b === void 0 ? void 0 : _b.handle(this.showHandler);
        this.rangeModule.nominalRangeIndex.unsub(this.showHandler);
        (_c = this.labelShowSettingConsumer) === null || _c === void 0 ? void 0 : _c.handle(this.showLabelHandler);
        (_d = this.labelRangeIndexSettingConsumer) === null || _d === void 0 ? void 0 : _d.handle(this.showLabelHandler);
        this.rangeModule.nominalRangeIndex.unsub(this.showLabelHandler);
        (_e = this.alertLevelModeSettingConsumer) === null || _e === void 0 ? void 0 : _e.handle(this.alertLevelModeHandler);
        this.showSettingConsumer = null;
        this.rangeIndexSettingConsumer = null;
        this.labelShowSettingConsumer = null;
        this.labelRangeIndexSettingConsumer = null;
        this.alertLevelModeSettingConsumer = null;
    }
}

/**
 * Controls the map crosshair. Shows the crosshair when the map pointer is active, and hides the crosshair otherwise.
 */
class MapCrosshairController {
    /**
     * Constructor.
     * @param mapModel The model of the map associated with this controller.
     */
    constructor(mapModel) {
        this.mapModel = mapModel;
        this.handler = this.updateCrosshairShow.bind(this);
        this.isInit = false;
    }
    /**
     * Initializes this controller. Once initialized, this controller will automatically update the map crosshair
     * visibility.
     */
    init() {
        if (this.isInit) {
            return;
        }
        this.initListeners();
        this.updateCrosshairShow();
        this.isInit = true;
    }
    /**
     * Initializes this controller's listeners.
     */
    initListeners() {
        this.mapModel.getModule('pointer').isActive.sub(this.handler);
    }
    /**
     * Updates whether to show this controller's map crosshair.
     */
    updateCrosshairShow() {
        this.mapModel.getModule('crosshair').show.set(this.mapModel.getModule('pointer').isActive.get());
    }
    /**
     * Destroys this controller, freeing up resources associated with it. Once destroyed, this controller will no longer
     * automatically update the map crosshair visibility.
     */
    destroy() {
        this.mapModel.getModule('pointer').isActive.unsub(this.handler);
    }
}

/// <reference types="msfstypes/JS/Avionics" />
/**
 * A G1000 navigation map component.
 */
class NavMapComponent extends MapComponent {
    /**
     * Creates an instance of a NavMap.
     * @param props The properties of the nav map.
     */
    constructor(props) {
        super(props);
        this.rootRef = FSComponent.createRef();
        this.bingLayerRef = FSComponent.createRef();
        this.airspaceLayerRef = FSComponent.createRef();
        this.flightPlanLayerRef = FSComponent.createRef();
        this.navAidsLayerRef = FSComponent.createRef();
        this.textLayerRef = FSComponent.createRef();
        this.crosshairLayerRef = FSComponent.createRef();
        this.trafficIntruderLayerRef = FSComponent.createRef();
        this.ownAirplaneLayerRef = FSComponent.createRef();
        this.pointerLayerRef = FSComponent.createRef();
        this.deadZone = new Float64Array(4);
        this.pointerBoundsSub = VecNSubject.createFromVector(new Float64Array([0, 0, this.props.projectedWidth, this.props.projectedHeight]));
        this.textManager = new MapCullableTextLabelManager();
        this.waypointRenderer = new MapWaypointRenderer(this.textManager);
        this.trafficOffScaleModeSub = Subject.create(MapTrafficIntruderOffScaleIndicatorMode.Off);
        this.rangeSettingManager = MapRangeSettings.getManager(this.props.bus);
        this.declutterController = new MapDeclutterController(this.props.model.getModule('declutter'), this.props.settingManager);
        this.terrainColorController = new MapTerrainController(this.props.model, this.props.settingManager);
        this.waypointsVisController = new MapWaypointsVisController(this.props.model, this.props.settingManager);
        this.trafficController = new NavMapTrafficController(this.props.model, TrafficUserSettings.getManager(this.props.bus), this.props.settingManager);
        this.nexradController = new MapNexradController(this.props.model, this.props.settingManager);
        this.crosshairController = new MapCrosshairController(this.props.model);
        if (this.props.deadZone) {
            this.deadZone.set(this.props.deadZone);
        }
        this.updatePointerBounds();
        this.rangeTargetRotationController = this.createRangeTargetRotationController();
    }
    /**
     * Gets the size of the dead zone around this map's projected window, which is displayed but excluded in map range
     * calculations. Expressed as [left, top, right, bottom] in pixels.
     * @returns the size of the dead zone around this map's projected window.
     */
    getDeadZone() {
        return this.deadZone;
    }
    /**
     * Sets the size of the dead zone around this map's projected window. The dead zone is displayed but excluded in map
     * range calculations.
     * @param deadZone The new dead zone, expressed as [left, top, right, bottom] in pixels.
     */
    setDeadZone(deadZone) {
        if (this.deadZone.every((value, index) => value === deadZone[index])) {
            return;
        }
        this.deadZone.set(deadZone);
        this.onDeadZoneChanged();
    }
    /**
     * This method is called when the size of this map's dead zone changes.
     */
    onDeadZoneChanged() {
        this.rangeTargetRotationController.setDeadZone(this.deadZone);
        this.updatePointerBounds();
    }
    /** @inheritdoc */
    onAfterRender() {
        super.onAfterRender();
        this.setRootSize(this.mapProjection.getProjectedSize());
        this.initEventBusHandlers();
        this.rangeTargetRotationController.init();
        this.initControllers();
        this.initLayers();
    }
    /**
     * Sets the size of this map's root HTML element.
     * @param size The new size, in pixels.
     */
    setRootSize(size) {
        this.rootRef.instance.style.width = `${size[0]}px`;
        this.rootRef.instance.style.height = `${size[1]}px`;
    }
    /**
     * Initializes event bus handlers.
     */
    initEventBusHandlers() {
        this.props.model.getModule('ownAirplaneProps').beginSync(this.props.bus, this.props.updateFreq);
    }
    /**
     * Initializes model controllers.
     */
    initControllers() {
        this.declutterController.init();
        this.terrainColorController.init();
        this.waypointsVisController.init();
        this.trafficController.init();
        this.nexradController.init();
        this.crosshairController.init();
    }
    /**
     * Initializes this map's layers.
     */
    initLayers() {
        this.attachLayer(this.bingLayerRef.instance);
        this.attachLayer(this.airspaceLayerRef.instance);
        this.attachLayer(this.navAidsLayerRef.instance);
        this.attachLayer(this.flightPlanLayerRef.instance);
        this.attachLayer(this.textLayerRef.instance);
        this.attachLayer(this.crosshairLayerRef.instance);
        this.attachLayer(this.ownAirplaneLayerRef.instance);
        this.attachLayer(this.trafficIntruderLayerRef.instance);
        this.attachLayer(this.pointerLayerRef.instance);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onProjectedSizeChanged() {
        this.setRootSize(this.mapProjection.getProjectedSize());
        this.updatePointerBounds();
    }
    /**
     * Updates this map's pointer bounds.
     */
    updatePointerBounds() {
        const size = this.mapProjection.getProjectedSize();
        const minX = this.deadZone[0];
        const minY = this.deadZone[1];
        const maxX = size[0] - this.deadZone[2];
        const maxY = size[1] - this.deadZone[3];
        const width = maxX - minX;
        const height = maxY - minY;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        this.pointerBoundsSub.set(Math.min(centerX, minX + width * 0.1), Math.min(centerY, minY + height * 0.1), Math.max(centerX, maxX - height * 0.1), Math.max(centerY, maxY - height * 0.1));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        this.updateRangeTargetRotationController();
        this.waypointRenderer.update(this.mapProjection);
        super.onUpdated(time, elapsed);
    }
    /**
     * Updates this map's range/target/rotation controller.
     */
    updateRangeTargetRotationController() {
        this.rangeTargetRotationController.update();
    }
    /** @inheritdoc */
    render() {
        var _a;
        let className = 'nav-map-container';
        if (this.props.class !== undefined) {
            className += ` ${this.props.class}`;
        }
        return (FSComponent.buildComponent("div", { ref: this.rootRef, class: className },
            FSComponent.buildComponent(MapBingLayer, { ref: this.bingLayerRef, model: this.props.model, mapProjection: this.mapProjection, bingId: (_a = this.props.bingId) !== null && _a !== void 0 ? _a : this.props.id }),
            FSComponent.buildComponent(MapAirspaceLayer, { ref: this.airspaceLayerRef, model: this.props.model, mapProjection: this.mapProjection, useBuffer: true, overdrawFactor: 1.2, airspaceSearcher: this.props.airspaceSearcher, airspaceRenderManager: new AirspaceRenderManager() }),
            FSComponent.buildComponent(MapWaypointsLayer, { ref: this.navAidsLayerRef, model: this.props.model, mapProjection: this.mapProjection, bus: this.props.bus, waypointRenderer: this.waypointRenderer, textManager: this.textManager, styles: this.getWaypointsLayerStyles() }),
            this.renderFlightPlanLayer(),
            FSComponent.buildComponent(MapCullableTextLayer, { ref: this.textLayerRef, model: this.props.model, mapProjection: this.mapProjection, manager: this.textManager }),
            this.renderRangeRingLayer(),
            this.renderRangeCompassLayer(),
            FSComponent.buildComponent(MapCrosshairLayer, { ref: this.crosshairLayerRef, model: this.props.model, mapProjection: this.mapProjection }),
            FSComponent.buildComponent(MapTrafficIntruderLayer, { ref: this.trafficIntruderLayerRef, model: this.props.model, mapProjection: this.mapProjection, bus: this.props.bus, fontSize: this.props.trafficIntruderLayerProps.fontSize, iconSize: this.props.trafficIntruderLayerProps.iconSize, useOuterRangeMaxScale: false, offScaleIndicatorMode: this.trafficOffScaleModeSub }),
            FSComponent.buildComponent(MapOwnAirplaneLayer, { ref: this.ownAirplaneLayerRef, model: this.props.model, mapProjection: this.mapProjection, imageFilePath: this.props.ownAirplaneLayerProps.imageFilePath, iconSize: this.props.ownAirplaneLayerProps.iconSize, iconAnchor: this.props.ownAirplaneLayerProps.iconAnchor }),
            this.renderMiniCompassLayer(),
            this.renderPointerInfoLayer(),
            this.renderIndicatorGroups(),
            FSComponent.buildComponent(MapPointerLayer, { ref: this.pointerLayerRef, model: this.props.model, mapProjection: this.mapProjection })));
    }
    /**
     * Gets styles for the waypoints layer.
     * @returns styles for the waypoints layer.
     */
    getWaypointsLayerStyles() {
        return MapWaypointStyles.getNormalStyles(1, 10);
    }
    /**
     * Gets inactive waypoint styles for the flight plan layer.
     * @returns inactive waypoint styles for the flight plan layer.
     */
    getFlightPlanLayerInactiveWaypointsStyles() {
        return MapWaypointStyles.getFlightPlanStyles(false, 1, 20);
    }
    /**
     * Gets active waypoint styles for the flight plan layer.
     * @returns active waypoint styles for the flight plan layer.
     */
    getFlightPlanLayerActiveWaypointsStyles() {
        return MapWaypointStyles.getFlightPlanStyles(true, 2, 21);
    }
    /**
     * Renders this map's indicator groups.
     * @returns an array of this map's indicator groups.
     */
    renderIndicatorGroups() {
        return [
            this.renderTopLeftIndicatorGroup(),
            this.renderBottomLeftIndicatorGroup(),
            this.renderBottomRightIndicatorGroup()
        ];
    }
    /**
     * Renders the top-left indicator group.
     * @returns the top-left indicator group.
     */
    renderTopLeftIndicatorGroup() {
        return (FSComponent.buildComponent("div", { class: 'navmap-indicators-top-left' }, this.renderTopLeftIndicators()));
    }
    /**
     * Renders indicators in the top-left indicator group.
     * @returns indicators in the top-left indicator group.
     */
    renderTopLeftIndicators() {
        return [
            this.renderOrientationIndicator()
        ];
    }
    /**
     * Renders the bottom-left indicator group.
     * @returns the bottom-left indicator group.
     */
    renderBottomLeftIndicatorGroup() {
        return (FSComponent.buildComponent("div", { class: 'navmap-indicators-bottom-left' }, this.renderBottomLeftIndicators()));
    }
    /**
     * Renders indicators in the bottom-left indicator group.
     * @returns indicators in the bottom-left indicator group.
     */
    renderBottomLeftIndicators() {
        return [
            this.renderDetailIndicator(),
            this.renderTrafficOffScaleIndicator()
        ];
    }
    /**
     * Renders the bottom-right indicator group.
     * @returns the bottom-right indicator group.
     */
    renderBottomRightIndicatorGroup() {
        return (FSComponent.buildComponent("div", { class: 'navmap-indicators-bottom-right' }, this.renderBottomRightIndicators()));
    }
    /**
     * Renders indicators in the bottom-right indicator group.
     * @returns indicators in the bottom-right indicator group.
     */
    renderBottomRightIndicators() {
        return [
            this.renderTrafficStatusIndicator(true),
            this.renderTerrainScaleIndicator()
        ];
    }
    /**
     * Renders the flight plan layer.
     * @returns The rendered flight plan layer, as a VNode.
     */
    renderFlightPlanLayer() {
        return (FSComponent.buildComponent(MapFlightPlanLayer, { ref: this.flightPlanLayerRef, model: this.props.model, mapProjection: this.mapProjection, bus: this.props.bus, dataProvider: new MapActiveFlightPlanDataProvider(this.props.bus, this.props.flightPlanner), drawEntirePlan: this.props.drawEntireFlightPlan, waypointRenderer: this.waypointRenderer, textManager: this.textManager, inactiveWaypointStyles: this.getFlightPlanLayerInactiveWaypointsStyles(), activeWaypointStyles: this.getFlightPlanLayerActiveWaypointsStyles() }));
    }
    /**
     * Renders the range indicator.
     * @returns The range indicator.
     */
    renderRangeIndicator() {
        // TODO: Add customizable display unit support.
        const rangeModule = this.props.model.getModule('range');
        return (FSComponent.buildComponent(MapRangeDisplay, { range: rangeModule.nominalRange, displayUnit: Subject.create(UnitType.NMILE) }));
    }
    /**
     * Renders the orientation indicator.
     * @returns The orientation indicator.
     */
    renderOrientationIndicator() {
        const orientationModule = this.props.model.getModule('orientation');
        return (FSComponent.buildComponent(MapOrientationIndicator, { orientation: orientationModule.orientation, text: {
                [MapOrientation.NorthUp]: 'NORTH UP',
                [MapOrientation.TrackUp]: 'TRK UP',
                [MapOrientation.HeadingUp]: 'HDG UP'
            }, isVisible: this.props.model.getModule('pointer').isActive.map(isActive => !isActive) }));
    }
    /**
     * Renders the detail indicator.
     * @returns The detail indicator.
     */
    renderDetailIndicator() {
        return (FSComponent.buildComponent(MapDetailIndicator, { declutterMode: this.props.model.getModule('declutter').mode, showTitle: true }));
    }
    /**
     * Renders the traffic status indicator.
     * @param showAltitudeRestrictionMode Whether the indicator should show the altitude restriction mode.
     * @returns The traffic status indicator.
     */
    renderTrafficStatusIndicator(showAltitudeRestrictionMode) {
        const trafficModule = this.props.model.getModule('traffic');
        return (FSComponent.buildComponent(MapTrafficStatusIndicator, { showAltitudeRestrictionMode: showAltitudeRestrictionMode, show: trafficModule.show, operatingMode: trafficModule.operatingMode, altitudeRestrictionMode: trafficModule.altitudeRestrictionMode }));
    }
    /**
     * Renders the traffic off-scale indicator.
     * @returns The traffic off-scale indicator.
     */
    renderTrafficOffScaleIndicator() {
        return (FSComponent.buildComponent(MapTrafficIntruderOffScaleIndicator, { mode: this.trafficOffScaleModeSub }));
    }
}
/**
 * A controller for handling map range, target, and rotation changes.
 */
class NavMapRangeTargetRotationController {
    /**
     * Creates an instance of a MapRangeController.
     * @param mapModel The map model.
     * @param mapProjection The map projection.
     * @param deadZone The dead zone around the edge of the map projection window.
     * @param mapRanges An array of valid map ranges.
     * @param settingManager This controller's map settings manager.
     * @param rangeSettingManager This controller's map range settings manager.
     * @param rangeSettingName The name of this controller's map range setting.
     * @param pointerBounds A subscribable which provides the bounds of the area accessible to the map pointer. The
     * bounds should be expressed as `[left, top, right, bottom]` in pixels.
     */
    constructor(mapModel, mapProjection, deadZone, mapRanges, settingManager, rangeSettingManager, rangeSettingName, pointerBounds) {
        this.mapModel = mapModel;
        this.mapProjection = mapProjection;
        this.mapRanges = mapRanges;
        this.settingManager = settingManager;
        this.rangeSettingManager = rangeSettingManager;
        this.rangeSettingName = rangeSettingName;
        this.pointerBounds = pointerBounds;
        this.deadZone = new Float64Array(4);
        this.currentMapRangeIndex = NavMapRangeTargetRotationController.DEFAULT_MAP_RANGE_INDEX;
        this.needUpdateProjection = false;
        this.needUpdatePointerScroll = false;
        this.currentMapParameters = {
            range: 0,
            target: new GeoPoint(0, 0),
            targetProjectedOffset: new Float64Array(2),
            rotation: 0
        };
        this.airplanePropsModule = this.mapModel.getModule('ownAirplaneProps');
        this.orientationModule = this.mapModel.getModule('orientation');
        this.pointerModule = this.mapModel.getModule('pointer');
        this.rangeSetting = this.rangeSettingManager.getSetting(this.rangeSettingName);
        this.orientationSetting = this.settingManager.getSetting('mapOrientation');
        this.autoNorthUpActiveSetting = this.settingManager.getSetting('mapAutoNorthUpActive');
        this.autoNorthUpRangeIndexSetting = this.settingManager.getSetting('mapAutoNorthUpRangeIndex');
        this.airplanePositionChangedHandler = this.onAirplanePositionChanged.bind(this);
        this.airplaneOnGroundChangedHandler = this.onAirplaneOnGroundChanged.bind(this);
        this.airplaneRotationChangedHandler = this.onAirplaneRotationChanged.bind(this);
        this.pointerPositionChangedHandler = this.onPointerPositionChanged.bind(this);
        this.pointerTargetChangedHandler = this.onPointerTargetChanged.bind(this);
        this.pointerBoundsChangedHandler = this.onPointerBoundsChanged.bind(this);
        this.areAirplanePositionListenersActive = false;
        this.currentAirplaneRotationSub = null;
        this.deadZone.set(deadZone);
    }
    /**
     * Executes this controller's first-run initialization code.
     */
    init() {
        this.mapModel.getModule('range').nominalRanges.set(this.mapRanges);
        this.updateRangeFromIndex();
        this.mapProjection.addChangeListener(this.onMapProjectionChanged.bind(this));
        this.initSettingsListeners();
        this.initModuleListeners();
        this.initState();
        this.scheduleProjectionUpdate();
    }
    /**
     * Initializes settings listeners.
     */
    initSettingsListeners() {
        this.rangeSettingManager.whenSettingChanged(this.rangeSettingName).handle(this.onRangeSettingChanged.bind(this));
        this.settingManager.whenSettingChanged('mapOrientation').handle(this.onOrientationSettingChanged.bind(this));
        this.settingManager.whenSettingChanged('mapAutoNorthUpActive').handle(this.onAutoNorthUpSettingChanged.bind(this));
        this.settingManager.whenSettingChanged('mapAutoNorthUpRangeIndex').handle(this.onAutoNorthUpSettingChanged.bind(this));
    }
    /**
     * Initializes module listeners.
     */
    initModuleListeners() {
        this.orientationModule.orientation.sub(this.onOrientationChanged.bind(this), true);
        this.pointerModule.isActive.sub(this.onPointerActiveChanged.bind(this), true);
    }
    /**
     * Initializes this controller's state.
     */
    initState() {
        this.updateTargetFromPPos();
        this.updateTargetOffset();
    }
    /**
     * Sets the size of this controller's dead zone. The dead zone is the area around the edges of the map excluded in
     * range calculations.
     * @param deadZone The new dead zone, expressed as [left, top, right, bottom] in pixels.
     */
    setDeadZone(deadZone) {
        if (this.deadZone.every((value, index) => value === deadZone[index])) {
            return;
        }
        this.deadZone.set(deadZone);
        this.onDeadZoneChanged();
    }
    /**
     * This method is called when the size of the dead zone changes.
     */
    onDeadZoneChanged() {
        this.updateRangeFromIndex();
        this.updateTargetOffset();
        this.scheduleProjectionUpdate();
    }
    /**
     * Updates the range index.
     */
    updateRangeIndex() {
        const newIndex = Utils.Clamp(this.rangeSetting.value, 0, this.mapRanges.length - 1);
        if (newIndex !== this.currentMapRangeIndex) {
            this.currentMapRangeIndex = newIndex;
            if (this.autoNorthUpActiveSetting.value) {
                this.updateOrientation();
            }
            this.updateRangeFromIndex();
            this.scheduleProjectionUpdate();
        }
    }
    /**
     * Updates the current range from the current range index.
     */
    updateRangeFromIndex() {
        const nominalRange = this.mapRanges[this.currentMapRangeIndex];
        this.currentMapParameters.range = this.convertToTrueRange(nominalRange);
    }
    /**
     * Updates the map target based on the airplane's present position.
     */
    updateTargetFromPPos() {
        const ppos = this.mapModel.getModule('ownAirplaneProps').position.get();
        this.currentMapParameters.target.set(ppos);
    }
    /**
     * Updates the target offset.
     */
    updateTargetOffset() {
        this.currentMapParameters.targetProjectedOffset.set(this.getDesiredTargetOffset());
    }
    /**
     * Updates the map orientation.
     */
    updateOrientation() {
        const orientationSettingMode = this.orientationSetting.value;
        let orientation;
        if (orientationSettingMode === MapOrientationSettingMode.NorthUp
            || (this.autoNorthUpActiveSetting.value && this.currentMapRangeIndex > this.autoNorthUpRangeIndexSetting.value)) {
            orientation = MapOrientation.NorthUp;
        }
        else if (orientationSettingMode === MapOrientationSettingMode.TrackUp && !this.airplanePropsModule.isOnGround.get()) {
            orientation = MapOrientation.TrackUp;
        }
        else {
            orientation = MapOrientation.HeadingUp;
        }
        this.orientationModule.orientation.set(orientation);
    }
    /**
     * Responds to map projection changes.
     * @param mapProjection The map projection that changed.
     * @param changeFlags The types of changes made to the projection.
     */
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.onProjectedSizeChanged();
        }
    }
    /**
     * Responds to projected map window size changes.
     */
    onProjectedSizeChanged() {
        this.updateRangeFromIndex();
        this.updateTargetOffset();
        this.scheduleProjectionUpdate();
    }
    /**
     * Responds to range setting changes.
     */
    onRangeSettingChanged() {
        this.updateRangeIndex();
    }
    /**
     * Responds to orientation setting changes.
     */
    onOrientationSettingChanged() {
        this.updateOrientation();
    }
    /**
     * Responds to auto north up setting changes.
     */
    onAutoNorthUpSettingChanged() {
        this.updateOrientation();
    }
    /**
     * Responds to airplane position changes.
     */
    onAirplanePositionChanged() {
        this.updateTargetFromPPos();
        this.scheduleProjectionUpdate();
    }
    /**
     * Responds to airplane rotation changes.
     * @param angle The airplane rotation angle, in degrees.
     */
    onAirplaneRotationChanged(angle) {
        this.currentMapParameters.rotation = -angle * Avionics.Utils.DEG2RAD;
        this.scheduleProjectionUpdate();
    }
    /**
     * Responds to when the airplane is on the ground changes.
     */
    onAirplaneOnGroundChanged() {
        this.updateOrientation();
    }
    /**
     * Responds to map orientation changes.
     * @param orientation The map orientation.
     */
    onOrientationChanged(orientation) {
        if (orientation === MapOrientation.NorthUp) {
            this.currentMapParameters.rotation = 0;
        }
        this.updateAirplaneRotationListeners();
        this.updateRangeFromIndex();
        this.updateTargetOffset();
        this.scheduleProjectionUpdate();
    }
    /**
     * Responds to map pointer activation changes.
     * @param isActive Whether the map pointer is active.
     */
    onPointerActiveChanged(isActive) {
        this.updateAirplanePositionListeners();
        this.updateAirplaneRotationListeners();
        this.updatePointerListeners();
        this.scheduleProjectionUpdate();
        if (isActive) {
            this.onPointerActivated();
        }
        else {
            this.onPointerDeactivated();
        }
    }
    /**
     * Responds to map pointer activation.
     */
    onPointerActivated() {
        // noop
    }
    /**
     * Responds to map pointer deactivation.
     */
    onPointerDeactivated() {
        // noop
    }
    /**
     * Responds to map pointer position changes.
     */
    onPointerPositionChanged() {
        this.schedulePointerScrollUpdate();
    }
    /**
     * Responds to map pointer desired target changes.
     * @param target The desired target.
     */
    onPointerTargetChanged(target) {
        this.currentMapParameters.target.set(target);
        this.scheduleProjectionUpdate();
    }
    /**
     * Responds to map pointer bounds changes.
     */
    onPointerBoundsChanged() {
        const position = this.pointerModule.position.get();
        const bounds = this.pointerBounds.get();
        const clampedPositionX = Utils.Clamp(position[0], bounds[0], bounds[2]);
        const clampedPositionY = Utils.Clamp(position[1], bounds[1], bounds[3]);
        this.pointerModule.position.set(clampedPositionX, clampedPositionY);
    }
    /**
     * Updates listeners for airplane position and on ground status.
     */
    updateAirplanePositionListeners() {
        this.setAirplanePositionListenersActive(!this.pointerModule.isActive.get());
    }
    /**
     * Activates or deactivates airplane position listeners.
     * @param value Whether to activate airplane position listeners.
     */
    setAirplanePositionListenersActive(value) {
        if (value === this.areAirplanePositionListenersActive) {
            return;
        }
        if (value) {
            this.airplanePropsModule.position.sub(this.airplanePositionChangedHandler, true);
            this.airplanePropsModule.isOnGround.sub(this.airplaneOnGroundChangedHandler, true);
        }
        else {
            this.airplanePropsModule.position.unsub(this.airplanePositionChangedHandler);
            this.airplanePropsModule.isOnGround.unsub(this.airplaneOnGroundChangedHandler);
        }
        this.areAirplanePositionListenersActive = value;
    }
    /**
     * Updates listeners for airplane heading and ground track.
     */
    updateAirplaneRotationListeners() {
        var _a;
        if (this.currentAirplaneRotationSub) {
            this.currentAirplaneRotationSub.unsub(this.airplaneRotationChangedHandler);
            this.currentAirplaneRotationSub = null;
        }
        if (!this.pointerModule.isActive.get()) {
            const orientation = this.orientationModule.orientation.get();
            switch (orientation) {
                case MapOrientation.TrackUp:
                    this.currentAirplaneRotationSub = this.airplanePropsModule.trackTrue;
                    break;
                case MapOrientation.HeadingUp:
                    this.currentAirplaneRotationSub = this.airplanePropsModule.hdgTrue;
                    break;
            }
            (_a = this.currentAirplaneRotationSub) === null || _a === void 0 ? void 0 : _a.sub(this.airplaneRotationChangedHandler, true);
        }
    }
    /**
     * Updates the pointer position listener.
     */
    updatePointerListeners() {
        if (this.pointerModule.isActive.get()) {
            this.pointerBounds.sub(this.pointerBoundsChangedHandler);
            this.pointerModule.position.sub(this.pointerPositionChangedHandler);
            this.pointerModule.target.sub(this.pointerTargetChangedHandler, true);
        }
        else {
            this.pointerBounds.unsub(this.pointerBoundsChangedHandler);
            this.pointerModule.position.unsub(this.pointerPositionChangedHandler);
            this.pointerModule.target.unsub(this.pointerTargetChangedHandler);
        }
    }
    /**
     * Schedules an update to the map projection.
     */
    scheduleProjectionUpdate() {
        this.needUpdateProjection = true;
    }
    /**
     * Schedules an update to scrolling due to the pointer.
     */
    schedulePointerScrollUpdate() {
        this.needUpdatePointerScroll = true;
    }
    /**
     * Updates this controller.
     */
    update() {
        this.updateModules();
        this.updatePointerScroll();
        this.updateMapProjection();
    }
    /**
     * Updates map model modules.
     */
    updateModules() {
        this.mapModel.getModule('range').setNominalRangeIndex(this.currentMapRangeIndex);
    }
    /**
     * Updates the map projection with the latest range, target, and rotation values.
     */
    updateMapProjection() {
        if (!this.needUpdateProjection) {
            return;
        }
        this.mapProjection.set(this.currentMapParameters);
        this.needUpdateProjection = false;
    }
    /**
     * Updates scrolling due to the pointer.
     */
    updatePointerScroll() {
        if (!this.needUpdatePointerScroll) {
            return;
        }
        const position = this.pointerModule.position.get();
        const bounds = this.pointerBounds.get();
        const clampedPositionX = Utils.Clamp(position[0], bounds[0], bounds[2]);
        const clampedPositionY = Utils.Clamp(position[1], bounds[1], bounds[3]);
        const scrollDeltaX = position[0] - clampedPositionX;
        const scrollDeltaY = position[1] - clampedPositionY;
        if (scrollDeltaX === 0 && scrollDeltaY === 0) {
            return;
        }
        this.pointerModule.position.set(clampedPositionX, clampedPositionY);
        const newTargetProjected = Vec2Math.add(this.mapProjection.getTargetProjected(), Vec2Math.set(scrollDeltaX, scrollDeltaY, NavMapRangeTargetRotationController.vec2Cache[0]), NavMapRangeTargetRotationController.vec2Cache[0]);
        this.mapProjection.invert(newTargetProjected, this.currentMapParameters.target);
        this.scheduleProjectionUpdate();
        this.needUpdatePointerScroll = false;
    }
}
NavMapRangeTargetRotationController.DEFAULT_MAP_RANGES = MapRangeSettings.DEFAULT_RANGES;
NavMapRangeTargetRotationController.DEFAULT_MAP_RANGE_INDEX = 11;
NavMapRangeTargetRotationController.vec2Cache = [new Float64Array(2)];

/**
 * The PFD HSI map.
 */
class HSINavMapComponent extends NavMapComponent {
    // eslint-disable-next-line jsdoc/require-jsdoc
    createRangeTargetRotationController() {
        return new HSINavMapRangeTargetRotationController(this.props.model, this.mapProjection, this.deadZone, NavMapRangeTargetRotationController.DEFAULT_MAP_RANGES, this.props.settingManager, this.rangeSettingManager, 'pfdMapRangeIndex', this.pointerBoundsSub);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    renderIndicatorGroups() {
        return [
            this.renderBottomLeftIndicatorGroup(),
            this.renderBottomCenterIndicatorGroup()
        ];
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    renderBottomLeftIndicators() {
        return [
            this.renderDetailIndicator(),
            this.renderRangeIndicator()
        ];
    }
    /**
     * Renders the bottom-left indicator group.
     * @returns the bottom-left indicator group.
     */
    renderBottomCenterIndicatorGroup() {
        return (FSComponent.buildComponent("div", { class: 'hsimap-indicators-bottom-center' },
            this.renderTrafficOffScaleIndicator(),
            this.renderTrafficStatusIndicator(false)));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    renderOrientationDisplayLayer() {
        return null;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    renderMiniCompassLayer() {
        return null;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    renderRangeRingLayer() {
        return null;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    renderRangeCompassLayer() {
        return null;
    }
    /** @inheritdoc */
    renderPointerInfoLayer() {
        return null;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    renderDetailIndicator() {
        return (FSComponent.buildComponent(MapDetailIndicator, { declutterMode: this.props.model.getModule('declutter').mode, showTitle: false }));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    renderTerrainScaleIndicator() {
        return null;
    }
}
/**
 * A controller for handling map range, target, and rotation changes for the MFD navigation map.
 */
class HSINavMapRangeTargetRotationController extends NavMapRangeTargetRotationController {
    // eslint-disable-next-line jsdoc/require-jsdoc
    convertToTrueRange(nominalRange) {
        const projectedHeight = this.mapProjection.getProjectedSize()[1];
        const correctedHeight = projectedHeight - this.deadZone[1] - this.deadZone[3];
        return nominalRange.asUnit(UnitType.GA_RADIAN) * projectedHeight / correctedHeight * 2;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getDesiredTargetOffset() {
        return HSINavMapRangeTargetRotationController.TARGET_OFFSET;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    updateOrientation() {
        // noop
    }
}
HSINavMapRangeTargetRotationController.TARGET_OFFSET = new Float64Array(2);

/**
 * An HSI component with a moving map.
 */
class HSIMap extends DisplayComponent {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.el = new NodeReference();
        this.rotatingEl = new NodeReference();
        this.compassRoseComponent = FSComponent.createRef();
        this.headingElement = FSComponent.createRef();
        this.turnRateIndicator = FSComponent.createRef();
        this.headingBugElement = FSComponent.createRef();
        this.courseNeedlesElement = FSComponent.createRef();
        this.bearingPointer1Element = FSComponent.createRef();
        this.bearingPointer2Element = FSComponent.createRef();
        this.deviationElement = FSComponent.createRef();
        this.mapRef = FSComponent.createRef();
        this.mapModel = NavMapModel.createModel(this.props.tas);
        this.mapRangeSettingManager = MapRangeSettings.getManager(this.props.bus);
        this.mapRangeSetting = this.mapRangeSettingManager.getSetting('pfdMapRangeIndex');
        /**
         * Updates the rotating elements container.
         * @param heading The heading to rotate to.
         */
        this.updateRotatingElements = (heading) => {
            this.rotatingEl.instance.style.transform = `rotate3d(0, 0, 1, ${-heading}deg)`;
            if (this.headingElement.instance !== null) {
                const hdg = Math.round(heading) == 0 ? 360 : Math.round(heading);
                this.headingElement.instance.textContent = `${hdg}°`.padStart(4, '0');
            }
        };
        this.mapModel.getModule('orientation').orientation.set(MapOrientation.HeadingUp);
    }
    /**
     * A callback called when the component finishes rendering.
     */
    onAfterRender() {
        this.setVisible(false);
        this.registerWithController();
        const adc = this.props.bus.getSubscriber();
        const ap = this.props.bus.getSubscriber();
        const hEvents = this.props.bus.getSubscriber();
        adc.on('hdg_deg')
            .withPrecision(1)
            .handle(this.updateRotatingElements);
        ap.on('heading_select')
            .withPrecision(0)
            .handle(this.updateSelectedHeadingDisplay.bind(this));
        adc.on('delta_heading_rate')
            .withPrecision(1)
            .handle(rate => this.turnRateIndicator.instance.setTurnRate(rate));
        hEvents.on('hEvent').handle(this.onInteractionEvent.bind(this));
        if (this.bearingPointer1Element.instance !== null) {
            this.bearingPointer1Element.instance.style.display = 'none';
        }
        if (this.bearingPointer2Element.instance !== null) {
            this.bearingPointer2Element.instance.style.display = 'none';
        }
        if (this.compassRoseComponent.getOrDefault() !== null) {
            this.compassRoseComponent.instance.setCircleVisible(false);
        }
    }
    /**
     * A callback which is called when an interaction event occurs.
     * @param hEvent An interaction event.
     */
    onInteractionEvent(hEvent) {
        if (!this.mapRef.instance.isAwake) {
            return;
        }
        switch (hEvent) {
            case 'AS1000_PFD_RANGE_INC':
                this.changeMapRangeIndex(1);
                break;
            case 'AS1000_PFD_RANGE_DEC':
                this.changeMapRangeIndex(-1);
                break;
        }
    }
    /**
     * Changes the MFD map range index setting.
     * @param delta The change in index to apply.
     */
    changeMapRangeIndex(delta) {
        const newIndex = Utils.Clamp(this.mapRangeSetting.value + delta, 0, MapRangeSettings.DEFAULT_RANGES.length - 1);
        this.mapRangeSetting.value = newIndex;
    }
    /**
     * Updates the heading indicator when the heading changes.
     * @param selHdg deg The new heading value.
     */
    updateSelectedHeadingDisplay(selHdg) {
        if (this.headingBugElement.instance !== null) {
            this.headingBugElement.instance.style.transform = `rotate3d(0, 0, 1, ${selHdg}deg)`;
        }
    }
    /**
     * Sets whether or not the HSI with map is visible.
     * @param isVisible Whether or not the component is visible.
     */
    setVisible(isVisible) {
        this.el.instance.style.display = isVisible ? '' : 'none';
        isVisible ? this.mapRef.instance.wake() : this.mapRef.instance.sleep();
    }
    /**
     * Registers the course needles instance with the HSI Controller.
     */
    registerWithController() {
        this.props.controller.courseNeedleRefs.hsiMap = this.courseNeedlesElement;
        this.props.controller.hsiMapDeviationRef = this.deviationElement;
    }
    /**
     * Renders the HSIMap component.
     * @returns The rendered component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "hsi-map-container", ref: this.el },
            FSComponent.buildComponent(HSINavMapComponent, { ref: this.mapRef, model: this.mapModel, bus: this.props.bus, updateFreq: 5, projectedWidth: 350, projectedHeight: 350, flightPlanner: this.props.flightPlanner, airspaceSearcher: this.props.airspaceSearcher, id: 'pfd_hsi_map', bingId: 'pfd_map', ownAirplaneLayerProps: {
                    imageFilePath: 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/own_airplane_icon.svg',
                    iconSize: 30,
                    iconAnchor: new Float64Array([0.5, 0])
                }, trafficIntruderLayerProps: {
                    fontSize: 16,
                    iconSize: 30
                }, drawEntireFlightPlan: Subject.create(false), class: 'pfd-hsimap', settingManager: MapUserSettings.getPfdManager(this.props.bus) }),
            FSComponent.buildComponent(HSIMapCourseDeviation, { ref: this.deviationElement, controller: this.props.controller }),
            FSComponent.buildComponent("div", { class: "hsi-map-hdg-box" },
                FSComponent.buildComponent("span", { ref: this.headingElement }, "360")),
            FSComponent.buildComponent("div", { class: 'hsi-map-rotating-elements', ref: this.rotatingEl },
                FSComponent.buildComponent(CompassRose, { ref: this.compassRoseComponent, size: 350, margin: 0, gradient: true }),
                FSComponent.buildComponent("div", { class: 'hsi-map-bearing-pointer', ref: this.bearingPointer1Element },
                    FSComponent.buildComponent("svg", { viewBox: "0 0 386 340" },
                        FSComponent.buildComponent("path", { d: "M 175 20 l 0 7 l -16 16 M 175 27 l 16 16 M 175 27 l 0 25 z M 175 290 l 0 40", fill: "none", stroke: "cyan", "stroke-width": "2px" }))),
                FSComponent.buildComponent("div", { class: 'hsi-map-bearing-pointer', ref: this.bearingPointer2Element },
                    FSComponent.buildComponent("svg", { viewBox: "0 0 386 340" },
                        FSComponent.buildComponent("path", { d: "M 175 20 l 0 7 l -16 16 M 175 27 l 16 16 M 170 32 l 0 20 M 180 32 l 0 20 M 170 290 l 0 32 l 10 0 l 0 -32 M 175 322 l 0 8", fill: "none", stroke: "cyan", "stroke-width": "2px" }))),
                FSComponent.buildComponent("div", { class: "hsi-map-hdg-bug", ref: this.headingBugElement },
                    FSComponent.buildComponent("svg", null,
                        FSComponent.buildComponent("path", { d: "M 175 175 m 0 -160 l 4 -9 l 8 0 l 0 12 l -24 0 l 0 -12 l 8 0 l 4 9 z", fill: "cyan", stroke: "black", "stroke-width": "1px" }))),
                FSComponent.buildComponent(CourseNeedles, { hsiMap: true, ref: this.courseNeedlesElement, controller: this.props.controller })),
            FSComponent.buildComponent(TurnRateIndicator, { hsiMap: true, ref: this.turnRateIndicator })));
    }
}

/**
 * The HSI component of the PFD.
 */
class HSIRose extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.el = FSComponent.createRef();
        this.compassRoseComponent = FSComponent.createRef();
        this.headingElement = FSComponent.createRef();
        this.headingRotateElement = FSComponent.createRef();
        this.courseNeedlesElement = FSComponent.createRef();
        this.headingBugElement = FSComponent.createRef();
        this.turnRateIndicator = FSComponent.createRef();
        this.bearingPointer1Element = FSComponent.createRef();
        this.bearingPointer2Element = FSComponent.createRef();
        this.navSourceText = FSComponent.createRef();
        this.navSensitivity = FSComponent.createRef();
        this.susp = FSComponent.createRef();
        this.trackBug = FSComponent.createRef();
        this.onGround = true;
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        this.registerWithController();
        this.props.bus.getSubscriber().on('track_deg_magnetic')
            .withPrecision(1)
            .handle((trk) => {
            if (!this.onGround) {
                this.updateTrackBug(trk);
            }
        });
        const adc = this.props.bus.getSubscriber();
        adc.on('hdg_deg')
            .withPrecision(1)
            .handle(this.updateHeadingRotation.bind(this));
        adc.on('delta_heading_rate')
            .withPrecision(1)
            .handle(rate => this.turnRateIndicator.instance.setTurnRate(rate));
        adc.on('on_ground').handle((v) => {
            this.onGround = v;
        });
        this.props.bus.getSubscriber().on('heading_select')
            .withPrecision(0)
            .handle(this.updateSelectedHeadingDisplay.bind(this));
        if (this.bearingPointer1Element.instance !== null) {
            this.bearingPointer1Element.instance.style.display = 'none';
        }
        if (this.bearingPointer2Element.instance !== null) {
            this.bearingPointer2Element.instance.style.display = 'none';
        }
        if (this.compassRoseComponent.getOrDefault() !== null) {
            this.compassRoseComponent.instance.setCircleVisible(false);
        }
    }
    /**
     * Sets whether or not the standard HSI is visible.
     * @param isVisible Whether or not the HSI is visible.
     */
    setVisible(isVisible) {
        this.el.instance.style.display = isVisible ? '' : 'none';
    }
    /**
     * Updates the HSI indicator rotation when the heading changes.
     * @param hdgDeg deg The new heading value.
     */
    updateHeadingRotation(hdgDeg) {
        if (this.headingRotateElement.instance !== null) {
            this.headingRotateElement.instance.style.transform = `rotate3d(0, 0, 1, ${-hdgDeg}deg)`;
        }
        if (this.headingElement.instance !== null) {
            const hdg = Math.round(hdgDeg) == 0 ? 360 : Math.round(hdgDeg);
            this.headingElement.instance.textContent = `${hdg}°`.padStart(4, '0');
        }
        if (this.onGround) {
            this.updateTrackBug(hdgDeg);
        }
    }
    /**
     * Updates the heading indicator when the heading changes.
     * @param selHdg deg The new heading value.
     */
    updateSelectedHeadingDisplay(selHdg) {
        if (this.headingBugElement.instance !== null) {
            this.headingBugElement.instance.style.transform = `rotate3d(0, 0, 1, ${selHdg}deg)`;
        }
    }
    /**
     * Updates the ground track bug.
     * @param trkDeg The ground track in degrees magnetic.
     */
    updateTrackBug(trkDeg) {
        this.trackBug.instance.style.transform = `rotate3d(0, 0, 1, ${trkDeg}deg)`;
    }
    /**
     * Builds the 4 tick marks on the outside of the compass rose.
     * @param radius The radius of the circle to build around.
     * @returns A collection of tick mark line elements.
     */
    buildRoseOuterTicks(radius = 149) {
        const lines = [];
        for (let i = 0; i < 360; i += 45) {
            if ((i == 0 || i >= 180) && i != 270) {
                const length = 16;
                const startX = 184 + (radius) * Math.cos(i * Math.PI / 180);
                const startY = 185 + (radius) * Math.sin(i * Math.PI / 180);
                const endX = startX + (length * Math.cos(i * Math.PI / 180));
                const endY = startY + (length * Math.sin(i * Math.PI / 180));
                lines.push(FSComponent.buildComponent("line", { x1: startX, y1: startY, x2: endX, y2: endY, stroke: "white", "stroke-width": "3px" }));
            }
        }
        return lines;
    }
    /**
     * Updates the Source and Sensitivity Fields.
     */
    updateSourceSensitivity() {
        switch (this.props.controller.navStates[this.props.controller.activeSourceIndex].source.type) {
            case NavSourceType.Nav:
                if (this.props.controller.navStates[this.props.controller.activeSourceIndex].isLocalizer) {
                    this.navSourceText.instance.textContent = `LOC${this.props.controller.navStates[this.props.controller.activeSourceIndex].source.index}`;
                }
                else {
                    this.navSourceText.instance.textContent = `VOR${this.props.controller.navStates[this.props.controller.activeSourceIndex].source.index}`;
                }
                this.navSourceText.instance.style.color = '#00ff00';
                this.navSensitivity.instance.textContent = '';
                break;
            case NavSourceType.Gps:
                this.navSourceText.instance.textContent = 'GPS';
                this.navSourceText.instance.style.color = 'magenta';
                this.navSensitivity.instance.textContent = `${this.props.controller.activeSensitivity}`;
                switch (this.props.controller.obsSuspMode) {
                    case ObsSuspModes.SUSP:
                        this.susp.instance.textContent = 'SUSP';
                        break;
                    case ObsSuspModes.OBS:
                        this.susp.instance.textContent = 'OBS';
                        break;
                    default:
                        this.susp.instance.textContent = '';
                        break;
                }
                break;
        }
    }
    /**
     * Registers the course needles instance with the HSI Controller.
     */
    registerWithController() {
        this.props.controller.courseNeedleRefs.hsiRose = this.courseNeedlesElement;
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "hsi-rose-container", ref: this.el },
            FSComponent.buildComponent("div", { class: "hsi-rose-hdg-box" },
                FSComponent.buildComponent("span", { ref: this.headingElement }, "360")),
            FSComponent.buildComponent("div", { ref: this.headingRotateElement, class: "hsi-rose-rotating" },
                FSComponent.buildComponent("div", { class: "hsi-track-bug", ref: this.trackBug },
                    FSComponent.buildComponent("svg", null,
                        FSComponent.buildComponent("path", { d: "M 170 50 l 4 -9 l 0 -2 l -4 -9 l -4 9 l 0 2 z", fill: "magenta", stroke: "black", "stroke-width": "1px" }))),
                FSComponent.buildComponent(CompassRose, { ref: this.compassRoseComponent, size: 386, margin: 40 }),
                FSComponent.buildComponent("div", { class: "hsi-rose-brg-ptr", ref: this.bearingPointer1Element },
                    FSComponent.buildComponent("svg", { viewBox: "0 0 386 340" },
                        FSComponent.buildComponent("path", { d: "M 183 70 l 0 7 l -16 16 M 183 77 l 16 16 M 183 77 l 0 30 z M 183 264 l 0 44", fill: "none", stroke: "cyan", "stroke-width": "2px" }))),
                FSComponent.buildComponent("div", { class: "hsi-rose-brg-ptr", ref: this.bearingPointer2Element },
                    FSComponent.buildComponent("svg", { viewBox: "0 0 386 340" },
                        FSComponent.buildComponent("path", { d: "M 183 70 l 0 7 l -16 16 M 183 77 l 16 16 M 178 82 l 0 25 M 188 82 l 0 25 M 178 264 l 0 36 l 10 0 l 0 -36 M 183 300 l 0 8", fill: "none", stroke: "cyan", "stroke-width": "2px" }))),
                FSComponent.buildComponent("div", { class: "hsi-rose-hdg-bug", ref: this.headingBugElement },
                    FSComponent.buildComponent("svg", null,
                        FSComponent.buildComponent("path", { d: "M 183 185 m 0 -133 l 4 -9 l 7 0 l 0 12 l -22 0 l 0 -12 l 7 0 l 4 9 z", fill: "cyan", stroke: "black", "stroke-width": "1px" }))),
                FSComponent.buildComponent(CourseNeedles, { hsiMap: false, ref: this.courseNeedlesElement, controller: this.props.controller })),
            FSComponent.buildComponent("div", { class: "hsi-rose-static" },
                FSComponent.buildComponent("div", { class: "hsi-outer-ticks" },
                    FSComponent.buildComponent("svg", { viewBox: "0 0 386 340" },
                        FSComponent.buildComponent("path", { d: "m 184 185 m -20 1 l 0 -4 l 16 -7 l 0 -10 l 4 -3 l 4 3 l 0 10 l 16 7 l 0 4 l -16 0 l 0 12 l 5 5 l 0 2 l -18 0 l 0 -2 l 5 -5 l 0 -12 l -16 0 z", fill: "white" }),
                        this.buildRoseOuterTicks())),
                FSComponent.buildComponent("div", { class: "hsi-index-pointer" },
                    FSComponent.buildComponent("svg", null,
                        FSComponent.buildComponent("path", { d: "M 8 20 l 8 -20 l -16 0 l 8 20 z", fill: "white", stroke: "grey", "stroke-width": ".5px" }))),
                FSComponent.buildComponent(TurnRateIndicator, { hsiMap: false, ref: this.turnRateIndicator }),
                FSComponent.buildComponent("div", { class: "hsi-nav-source", ref: this.navSourceText }, "VOR1"),
                FSComponent.buildComponent("div", { class: "hsi-nav-sensitivity", ref: this.navSensitivity }, "ENR"),
                FSComponent.buildComponent("div", { class: "hsi-nav-susp", ref: this.susp }),
                FSComponent.buildComponent("div", { class: "hsi-gps-xtrack" }))));
    }
}

/**
 * The HSI component of the PFD.
 */
class HSI extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.roseRef = new NodeReference();
        this.mapRef = new NodeReference();
        this.minimumsContainerRef = FSComponent.createRef();
        this.hsiController = this.props.navIndicatorController;
        this.headingSelectElement = FSComponent.createRef();
        this.dtkBoxLabel = FSComponent.createRef();
        this.dtkBoxValue = FSComponent.createRef();
        this.minimumsValue = Subject.create('');
        /**
         * Updates the dtk/obs-crs ref box.
         */
        this.updateDtkBox = () => {
            switch (this.hsiController.navStates[this.hsiController.activeSourceIndex].source.type) {
                case NavSourceType.Nav:
                    this.dtkBoxLabel.instance.textContent = 'CRS';
                    this.dtkBoxValue.instance.style.color = '#00ff00';
                    break;
                case NavSourceType.Gps:
                    if (this.hsiController.obsSuspMode === ObsSuspModes.OBS) {
                        this.dtkBoxLabel.instance.textContent = 'CRS';
                    }
                    else {
                        this.dtkBoxLabel.instance.textContent = 'DTK';
                    }
                    this.dtkBoxValue.instance.style.color = 'magenta';
                    break;
            }
            const dtk = this.hsiController.navStates[this.hsiController.activeSourceIndex].dtk_obs;
            if (dtk !== null) {
                const disDtk = Math.round(dtk) == 0 ? 360 : Math.round(dtk);
                this.dtkBoxValue.instance.textContent = `${disDtk}°`.padStart(4, '0');
            }
        };
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        this.hsiController.onUpdateDtkBox = this.updateDtkBox;
        this.registerComponents();
        const ap = this.props.bus.getSubscriber();
        const g1000 = this.props.bus.getSubscriber();
        ap.on('heading_select')
            .withPrecision(0)
            .handle(this.updateSelectedHeadingDisplay.bind(this));
        g1000.on('set_minimums')
            .handle((mins) => {
            this.minimumsValue.set(`${mins}`);
        });
        g1000.on('show_minimums')
            .handle((show) => {
            if (show) {
                this.minimumsContainerRef.instance.style.display = '';
            }
            else {
                this.minimumsContainerRef.instance.style.display = 'none';
            }
        });
        //init mins to display = none
        this.minimumsContainerRef.instance.style.display = 'none';
        PFDUserSettings.getManager(this.props.bus).whenSettingChanged('mapLayout').handle((mode) => {
            this.hsiController.onFormatChange(mode === PfdMapLayoutSettingMode.HSI);
            this.mapRef.instance.setVisible(mode === PfdMapLayoutSettingMode.HSI);
        });
    }
    /**
     * Updates the heading indicator when the heading changes.
     * @param selHdg deg The new heading value.
     */
    updateSelectedHeadingDisplay(selHdg) {
        if (this.headingSelectElement.instance !== null) {
            const hdg = selHdg == 0 ? 360 : selHdg;
            this.headingSelectElement.instance.textContent = `${hdg}°`.padStart(4, '0');
        }
    }
    /**
     * Registers the rose and map hsi components with the HSI Controller.
     */
    registerComponents() {
        this.hsiController.hsiRefs.hsiRose = this.roseRef;
        this.hsiController.hsiRefs.hsiMap = this.mapRef;
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { id: "HSI" },
            FSComponent.buildComponent("div", { class: "hdgcrs-container hdg-box" },
                "HDG ",
                FSComponent.buildComponent("span", { class: "cyan size20", ref: this.headingSelectElement }, "326\u00B0")),
            FSComponent.buildComponent("div", { class: "hdgcrs-container dtk-box" },
                FSComponent.buildComponent("span", { ref: this.dtkBoxLabel }),
                "\u00A0",
                FSComponent.buildComponent("span", { ref: this.dtkBoxValue, class: "size20" })),
            FSComponent.buildComponent("div", { class: "mins-temp-comp-container", ref: this.minimumsContainerRef },
                FSComponent.buildComponent("div", { class: "mins-temp-comp-upper-text size10" }, "BARO"),
                FSComponent.buildComponent("div", { class: "mins-temp-comp-lower-text size14" }, "MIN"),
                FSComponent.buildComponent("div", { class: "mins-temp-comp-value size18 cyan" },
                    this.minimumsValue,
                    FSComponent.buildComponent("span", { class: "size12" }, "FT"))),
            FSComponent.buildComponent(HSIRose, { ref: this.roseRef, bus: this.props.bus, controller: this.hsiController }),
            FSComponent.buildComponent(HSIMap, { ref: this.mapRef, bus: this.props.bus, flightPlanner: this.props.flightPlanner, controller: this.hsiController, airspaceSearcher: this.props.airspaceSearcher, tas: this.props.tas })));
    }
}

/**
 * The PFD vertical deviation indicator.
 */
class VerticalDeviation extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.vDevBoxDiv = FSComponent.createRef();
        this.diamondDiv = FSComponent.createRef();
        this.caretDiv = FSComponent.createRef();
        this.hideableObjectsDiv = FSComponent.createRef();
        this.sourceDiv = FSComponent.createRef();
        this.previewDiamondDiv = FSComponent.createRef();
        this.diamondPath = FSComponent.createRef();
        this.noStr = Subject.create('NO');
        this.gsgpStr = Subject.create('GS');
        this.deviationScale = 1;
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        this.registerComponent();
    }
    /**
     * A method called to update the deviation source and sensitivity.
     */
    updateSourceSensitivity() {
        const activeSource = this.props.navIndicatorController.navStates[this.props.navIndicatorController.activeSourceIndex];
        const vnavDisplayMode = this.props.navIndicatorController.vnavDisplayMode.get();
        const gpDisplayMode = this.props.navIndicatorController.gpDisplayMode.get();
        this.setVdevVisibility(activeSource, vnavDisplayMode, gpDisplayMode);
        this.setVnavVisibility(activeSource, vnavDisplayMode);
        this.setGlidepathVisibility(activeSource, gpDisplayMode);
        this.setPreviewGlidepathVisibility(activeSource, gpDisplayMode);
        this.setDeviationScale();
    }
    /**
     * A method called to update the deviation data.
     */
    updateDeviation() {
        const activeSource = this.props.navIndicatorController.navStates[this.props.navIndicatorController.activeSourceIndex];
        const vnavDisplayMode = this.props.navIndicatorController.vnavDisplayMode.get();
        const gpDisplayMode = this.props.navIndicatorController.gpDisplayMode.get();
        const vnavSource = this.props.navIndicatorController.navStates[2];
        if (vnavDisplayMode !== VNavDisplayMode.NONE) {
            const vnavDeviation = vnavSource.altDeviation;
            if (vnavDeviation !== null) {
                this.setVNavDeviation(vnavDeviation);
            }
        }
        if (activeSource.source.type === NavSourceType.Nav && activeSource.hasGlideslope && activeSource.gsDeviation !== null) {
            this.setDeviation(activeSource.gsDeviation);
        }
        else if (gpDisplayMode !== GPDisplayMode.NONE) {
            const lpvDeviation = vnavSource.gsDeviation;
            if (lpvDeviation !== null && lpvDeviation) {
                this.setDeviation(lpvDeviation);
            }
        }
    }
    /**
     * A method called to update the visibility of the entire VDEV Indicator.
     * @param activeSource The Active Source
     * @param vnavDisplayMode The VNAV Display Mode
     * @param gpDisplayMode The GP Display Mode
     */
    setVdevVisibility(activeSource, vnavDisplayMode, gpDisplayMode) {
        if (activeSource.source.type !== null && (vnavDisplayMode !== VNavDisplayMode.NONE || gpDisplayMode !== GPDisplayMode.NONE
            || (activeSource.source.type === NavSourceType.Nav && activeSource.isLocalizer))) {
            this.setSource(activeSource.source.type, vnavDisplayMode, gpDisplayMode);
            this.setVdevVisible(true);
            if (vnavDisplayMode === VNavDisplayMode.NONE && activeSource.source.type === NavSourceType.Nav && !activeSource.hasGlideslope) {
                this.setNoSignalVisible(true);
            }
            else {
                this.setNoSignalVisible(false);
            }
        }
        else {
            this.setVdevVisible(false);
            this.setNoSignalVisible(true);
        }
    }
    /**
     * A method called to update the vnav carrot visibility.
     * @param activeSource The Active Source
     * @param vnavDisplayMode The VNAV Display Mode
     */
    setVnavVisibility(activeSource, vnavDisplayMode) {
        if (vnavDisplayMode === VNavDisplayMode.PATH) {
            this.caretDiv.instance.style.display = '';
        }
        else {
            this.caretDiv.instance.style.display = 'none';
        }
    }
    /**
     * A method called to update the preview glidepath visibility.
     * @param activeSource The Active Source
     * @param gpDisplayMode The GP Display Mode
     */
    setPreviewGlidepathVisibility(activeSource, gpDisplayMode) {
        if (gpDisplayMode === GPDisplayMode.PREVIEW && activeSource.source.type === NavSourceType.Gps && activeSource.hasGlideslope) {
            this.previewDiamondDiv.instance.style.display = '';
        }
        else {
            this.previewDiamondDiv.instance.style.display = 'none';
        }
    }
    /**
     * A method called to update the active glideslope/glidepath visibility.
     * @param activeSource The Active Source
     * @param gpDisplayMode The GP Display Mode
     */
    setGlidepathVisibility(activeSource, gpDisplayMode) {
        if (gpDisplayMode === GPDisplayMode.ACTIVE && activeSource.hasGlideslope) {
            this.diamondPath.instance.setAttribute('fill', 'magenta');
            this.diamondDiv.instance.style.display = '';
        }
        else if (activeSource.source.type === NavSourceType.Nav && activeSource.hasGlideslope) {
            this.diamondPath.instance.setAttribute('fill', 'rgb(0,255,0)');
            this.diamondDiv.instance.style.display = '';
        }
        else {
            this.diamondDiv.instance.style.display = 'none';
        }
    }
    /**
     * Sets the vdev box visible.
     * @param visible is a bool whether to set this visible or not.
     */
    setVdevVisible(visible) {
        this.vDevBoxDiv.instance.style.display = visible ? '' : 'none';
    }
    /**
     * Sets the NO GS/NO GP display depending on if there is a signal.
     * @param visible is a bool whether to set this visible or not.
     */
    setNoSignalVisible(visible) {
        this.hideableObjectsDiv.instance.style.display = visible ? 'none' : '';
        this.diamondDiv.instance.style.display = visible ? 'none' : '';
        this.noStr.set(visible ? 'NO' : '');
        this.gsgpStr.set(visible ? 'GS' : '');
    }
    /**
     * Sets the source type indicator on the Vertical Deviation Indicator
     * @param source The Active Source
     * @param vnavDisplayMode The VNAV Display Mode
     * @param gpDisplayMode The GP Display Mode
     */
    setSource(source, vnavDisplayMode, gpDisplayMode) {
        if (vnavDisplayMode === VNavDisplayMode.PATH) {
            this.sourceDiv.instance.textContent = 'V';
            this.sourceDiv.instance.style.color = 'magenta';
        }
        else {
            this.sourceDiv.instance.textContent = 'G';
            if (gpDisplayMode !== GPDisplayMode.NONE && source === NavSourceType.Gps) {
                this.sourceDiv.instance.style.color = 'magenta';
            }
            else {
                this.sourceDiv.instance.style.color = 'rgb(0,255,0)';
            }
        }
    }
    /**
     * Sets the vdev scale.
     */
    setDeviationScale() {
        switch (this.props.navIndicatorController.activeSensitivity) {
            case NavSensitivity.ILS:
                this.deviationScale = 0.7;
                break;
            default:
                this.deviationScale = 1;
        }
    }
    /**
     * Sets the vdev deviation value
     * (sets both the preview and active deviation, since they do not appear at the same time).
     * @param vdev is a bool whether to set this visible or not.
     */
    setDeviation(vdev) {
        const deviation = 100 * (vdev / this.deviationScale);
        this.diamondDiv.instance.style.transform = `translate3d(0px, ${MathUtils.clamp(deviation, -100, 105)}px, 0px)`;
        this.previewDiamondDiv.instance.style.transform = `translate3d(0px, ${MathUtils.clamp(deviation, -100, 105)}px, 0px)`;
    }
    /**
     * Sets the vdev deviation value.
     * @param vdev is a bool whether to set this visible or not.
     */
    setVNavDeviation(vdev) {
        const deviation = 100 * (vdev / this.deviationScale);
        this.caretDiv.instance.style.transform = `translate3d(0px, ${MathUtils.clamp(deviation, -100, 105)}px, 0px)`;
    }
    /**
     * Registers the vertical deviation component with the NavIndicatorController.
     */
    registerComponent() {
        this.props.navIndicatorController.vdi = this;
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "verticaldev-box", ref: this.vDevBoxDiv },
            FSComponent.buildComponent("div", { class: "vertdev-background" },
                FSComponent.buildComponent("div", { class: "vertdev-static-circles" },
                    FSComponent.buildComponent("svg", { width: "24", height: "204px" },
                        FSComponent.buildComponent("circle", { cx: "12", cy: "20", r: "3", stroke: "white", "stroke-width": "1px", fill: "none" }),
                        FSComponent.buildComponent("circle", { cx: "12", cy: "180", r: "3", stroke: "white", "stroke-width": "1px", fill: "none" }))),
                FSComponent.buildComponent("div", { class: 'vertdev-objects', ref: this.hideableObjectsDiv },
                    FSComponent.buildComponent("svg", null,
                        FSComponent.buildComponent("line", { x1: "0", y1: "100", x2: "24", y2: "100", stroke: "gray", "stroke-width": "1px" }),
                        FSComponent.buildComponent("circle", { cx: "12", cy: "60", r: "3", stroke: "white", "stroke-width": "1px", fill: "none" }),
                        FSComponent.buildComponent("circle", { cx: "12", cy: "140", r: "3", stroke: "white", "stroke-width": "1px", fill: "none" }))),
                FSComponent.buildComponent("div", { class: "vertdev-diamond-deviation", ref: this.diamondDiv },
                    FSComponent.buildComponent("svg", null,
                        FSComponent.buildComponent("path", { ref: this.diamondPath, d: "M 12 0 l -8 10 l 8 10 l 8 -10 z", fill: "rgb(0,255,0)", stroke: "black", "stroke-linejoin": "round", "stroke-width": "1px" }))),
                FSComponent.buildComponent("div", { class: "vertdev-diamond-deviation", ref: this.previewDiamondDiv },
                    FSComponent.buildComponent("svg", null,
                        FSComponent.buildComponent("path", { d: "M 12 3 l -8 10 l 8 10 l 8 -10 z", stroke: "grey", "stroke-linejoin": "round", fill: "none", "stroke-width": "3px" }))),
                FSComponent.buildComponent("div", { class: "vertdev-vnav-deviation", ref: this.caretDiv },
                    FSComponent.buildComponent("svg", null,
                        FSComponent.buildComponent("path", { d: "M 20 0 l -19 10 l 19 10 l 0 -4 l -12 -6 l 12 -6 z", fill: "magenta", stroke: "black", "stroke-width": "1px" })))),
            FSComponent.buildComponent("div", { class: "vertdev-source", ref: this.sourceDiv }, "G"),
            FSComponent.buildComponent("div", { class: "NO" },
                FSComponent.buildComponent("span", null, this.noStr)),
            FSComponent.buildComponent("div", { class: "GSGP" },
                FSComponent.buildComponent("span", null, this.gsgpStr))));
    }
}

/**
 * The PFD vertical deviation indicator.
 */
class MarkerBeacon extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.mkrBcnBoxRef = FSComponent.createRef();
        this.textSub = ComputedSubject.create(MarkerBeaconState.Inactive, state => MarkerBeacon.TEXT[state]);
        /**
         * A method called when the marker beacon state has changed.
         * @param state is the marker beacon state.
         */
        this.onMarkerBeacon = (state) => {
            this.textSub.set(state);
            switch (state) {
                case MarkerBeaconState.Inactive:
                    this.mkrBcnBoxRef.instance.classList.remove('outer-animation', 'middle-animation', 'inner-animation');
                    break;
                case MarkerBeaconState.Outer:
                    this.mkrBcnBoxRef.instance.classList.remove('middle-animation', 'inner-animation');
                    this.mkrBcnBoxRef.instance.classList.add('outer-animation');
                    break;
                case MarkerBeaconState.Middle:
                    this.mkrBcnBoxRef.instance.classList.remove('outer-animation', 'inner-animation');
                    this.mkrBcnBoxRef.instance.classList.add('middle-animation');
                    break;
                case MarkerBeaconState.Inner:
                    this.mkrBcnBoxRef.instance.classList.remove('outer-animation', 'middle-animation');
                    this.mkrBcnBoxRef.instance.classList.add('inner-animation');
                    break;
            }
        };
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        const nav = this.props.bus.getSubscriber();
        nav.on('mkr_bcn_state').whenChanged().handle(this.onMarkerBeacon);
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "marker-beacon-box", ref: this.mkrBcnBoxRef }, this.textSub));
    }
}
MarkerBeacon.TEXT = {
    [MarkerBeaconState.Inactive]: '',
    [MarkerBeaconState.Outer]: 'O',
    [MarkerBeaconState.Middle]: 'M',
    [MarkerBeaconState.Inner]: 'I',
};

/** The state of the altitude alerter. */
var AltAlertState;
(function (AltAlertState) {
    /** Disabled Mode */
    AltAlertState[AltAlertState["DISABLED"] = 0] = "DISABLED";
    /** Armed Mode. */
    AltAlertState[AltAlertState["ARMED"] = 1] = "ARMED";
    /** Within 1000 feet of preselected altitude. */
    AltAlertState[AltAlertState["WITHIN_1000"] = 2] = "WITHIN_1000";
    /** Within 200 feet of preselected altitude. */
    AltAlertState[AltAlertState["WITHIN_200"] = 3] = "WITHIN_200";
    /** Captured the preselected altitude. */
    AltAlertState[AltAlertState["CAPTURED"] = 4] = "CAPTURED";
    /**Outside of the 200ft deviation zone */
    AltAlertState[AltAlertState["DEVIATION_200"] = 5] = "DEVIATION_200";
})(AltAlertState || (AltAlertState = {}));
/** Class to manage the altitude alerter on the PFD Altimeter */
class AltitudeAlertController {
    /**
     * Instantiates an instance of the AltitudeAlertController
     * @param bus is the event bus
     */
    constructor(bus) {
        this.bus = bus;
        this.isOnGround = false;
        this.alerterState = Subject.create(AltAlertState.DISABLED);
        this.approachActive = false;
        this.altitudeLocked = false;
        this.altitude = 0;
        this.selectedAltitude = 0;
        this.targetAltitude = 0;
        const adc = this.bus.getSubscriber();
        const ap = this.bus.getSubscriber();
        const vnav = this.bus.getSubscriber();
        const g1000 = this.bus.getSubscriber();
        adc.on('on_ground').handle((g) => { this.isOnGround = g; });
        vnav.on('vnavApproachMode').whenChanged().handle((mode) => {
            switch (mode) {
                case VNavApproachGuidanceMode.GSActive:
                case VNavApproachGuidanceMode.GPActive:
                    this.altitudeLocked = false;
                    this.approachActive = true;
                    break;
                default:
                    this.approachActive = false;
            }
        });
        vnav.on('vnavPathMode').whenChanged().handle((mode) => {
            if (mode === VNavPathMode.PathActive) {
                this.altitudeLocked = false;
                this.approachActive = false;
            }
        });
        // vnav.on('vnavAltCaptureType').whenChanged().handle(type => this.onVNavUpdate(this.vnavPathMode, type, this.approachMode));
        ap.on('ap_lock_set').whenChanged().handle((lock) => {
            switch (lock) {
                case APLockType.Alt:
                    this.altitudeLocked = true;
                    this.approachActive = false;
                    break;
                case APLockType.Flc:
                case APLockType.Vs:
                case APLockType.Glideslope:
                case APLockType.Pitch:
                    this.altitudeLocked = false;
                    this.approachActive = false;
                    break;
            }
        });
        ap.on('alt_select').whenChanged().handle(() => {
            this.alerterState.set(AltAlertState.ARMED);
        });
        g1000.on('alt_alert_cancel').handle((d) => {
            if (d) {
                this.alerterState.set(AltAlertState.DISABLED);
            }
        });
    }
    /**
     * A method called to update the altitude alerter
     */
    updateAltitudeAlerter() {
        if (this.isOnGround || this.approachActive) {
            this.alerterState.set(AltAlertState.DISABLED);
            return;
        }
        const state = this.alerterState.get();
        if (state === AltAlertState.ARMED) {
            this.targetAltitude = this.selectedAltitude;
        }
        const deltaAlt = Math.abs(this.targetAltitude - this.altitude);
        switch (state) {
            case AltAlertState.ARMED:
                if (deltaAlt < 210) {
                    this.alerterState.set(AltAlertState.WITHIN_200);
                }
                else if (deltaAlt < 1010) {
                    this.alerterState.set(AltAlertState.WITHIN_1000);
                }
                break;
            case AltAlertState.WITHIN_1000:
                if (this.targetAltitude != this.selectedAltitude) {
                    this.alerterState.set(AltAlertState.ARMED);
                }
                else if (deltaAlt < 210) {
                    this.alerterState.set(AltAlertState.WITHIN_200);
                }
                break;
            case AltAlertState.WITHIN_200:
                if (this.targetAltitude !== this.selectedAltitude) {
                    this.alerterState.set(AltAlertState.ARMED);
                }
                else if (deltaAlt < 100) {
                    this.alerterState.set(AltAlertState.CAPTURED);
                }
                break;
            case AltAlertState.CAPTURED:
                if (this.targetAltitude != this.selectedAltitude && !this.altitudeLocked) {
                    this.alerterState.set(AltAlertState.ARMED);
                }
                else if (deltaAlt > 210 && this.altitudeLocked) {
                    this.alerterState.set(AltAlertState.DEVIATION_200);
                }
                break;
            case AltAlertState.DEVIATION_200:
                if (this.targetAltitude != this.selectedAltitude && !this.altitudeLocked) {
                    this.alerterState.set(AltAlertState.ARMED);
                }
                else if (deltaAlt < 210) {
                    this.alerterState.set(AltAlertState.WITHIN_200);
                }
                break;
        }
    }
}

/**
 * The PFD airspeed indicator with speed tape.
 */
class Altimeter extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.controller = new AltitudeAlertController(this.props.bus);
        this.altitudeBoxElement = FSComponent.createRef();
        this.altitudeTenThousandsDataElement = FSComponent.createRef();
        this.altitudeThousandsDataElement = FSComponent.createRef();
        this.altitudeHundredsDataElement = FSComponent.createRef();
        this.altitudeTensDataElement = FSComponent.createRef();
        this.altitudeTapeTickElement = FSComponent.createRef();
        this.altitudeScrollerValues = [];
        this.altitudeScrollerZeroes = [];
        this.kohlsmanSetting = FSComponent.createRef();
        this.baroUnits = FSComponent.createRef();
        this.altitudeBugRef = FSComponent.createRef();
        this.minimumsBugRef = FSComponent.createRef();
        this.minimumsBugColor = FSComponent.createRef();
        this.altitudeTrendVector = FSComponent.createRef();
        this.selectedAltitudeTensSubject = Subject.create('');
        this.selectedAltitudeTensRef = FSComponent.createRef();
        this.selectedAltitudeHundredsSubject = Subject.create('- - - -');
        this.selectedAltitudeHundredsRef = FSComponent.createRef();
        this.vnavTargetAltSubject = Subject.create(0);
        this.vnavTargetAltRef = FSComponent.createRef();
        this.alerterBoxRef = FSComponent.createRef();
        this.alerterTextRef = FSComponent.createRef();
        this.alerterSVGBugRef = FSComponent.createRef();
        this.currentBaro = {
            units_hpa: false,
            standard: false,
            settingIn: 0
        };
        this.storedBaroIn = undefined;
        this.currentDrawnAlt = 0;
        this.minimumsAltitude = 0;
        /**
         * A method called when a minimums altitude value changes from the event bus.
         * @param mins The minimums altitude value.
         */
        this.updateMinimums = (mins) => {
            this.minimumsAltitude = Math.round(mins);
            this.updateMinimumsBug();
        };
        /**
         * A method called when a selected altitude value changes from the event bus.
         * @param alt The selected altitude value.
         */
        this.updateSelectedAltitude = (alt) => {
            this.controller.selectedAltitude = Math.round(alt);
            if (this.controller.selectedAltitude == 0) {
                this.selectedAltitudeHundredsRef.instance.classList.add('preselect-hundreds-small');
                this.selectedAltitudeTensRef.instance.classList.add('hidden-preselect-tens');
                this.selectedAltitudeHundredsSubject.set('0');
                this.selectedAltitudeTensSubject.set('00');
            }
            else {
                this.selectedAltitudeHundredsRef.instance.classList.remove('preselect-hundreds-small');
                this.selectedAltitudeTensRef.instance.classList.remove('hidden-preselect-tens');
                this.selectedAltitudeHundredsSubject.set(`${this.controller.selectedAltitude / 100}`);
                this.selectedAltitudeTensSubject.set('00');
                this.altitudeBugRef.instance.style.display = ''; //This initializes the bug so it doesn't show until the preselector has initially changed.
            }
            this.updateSelectedAltitudeBug();
        };
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        const adc = this.props.bus.getSubscriber();
        const ap = this.props.bus.getSubscriber();
        const vnav = this.props.bus.getSubscriber();
        const hEvtPub = this.props.bus.getSubscriber();
        const g1000ControlEvents = this.props.bus.getSubscriber();
        adc.on('alt')
            .withPrecision(1)
            .handle(this.updateAltitude.bind(this));
        ap.on('alt_select')
            .withPrecision(0)
            .handle(this.updateSelectedAltitude.bind(this));
        adc.on('kohlsman_setting_hg_1')
            .withPrecision(2)
            .handle(this.updateKohlsmanSetting.bind(this));
        adc.on('baro_units_hpa_1')
            .handle(this.updateBaroUnits.bind(this));
        adc.on('vs')
            .withPrecision(-1)
            .handle(this.updateVerticalSpeed.bind(this));
        hEvtPub.on('hEvent').handle(hEvent => {
            if (hEvent == 'AS1000_PFD_BARO_INC') {
                this.onbaroKnobTurn(true);
            }
            else if (hEvent == 'AS1000_PFD_BARO_DEC') {
                this.onbaroKnobTurn(false);
            }
        });
        PFDUserSettings.getManager(this.props.bus).whenSettingChanged('baroHpa').handle(this.updateBaroUnits.bind(this));
        g1000ControlEvents.on('std_baro_switch')
            .handle(this.updateBaroStd.bind(this));
        g1000ControlEvents.on('set_minimums')
            .handle(this.updateMinimums.bind(this));
        g1000ControlEvents.on('show_minimums')
            .handle((show) => {
            if (show) {
                this.minimumsBugRef.instance.style.display = '';
            }
            else {
                this.minimumsBugRef.instance.style.display = 'none';
            }
        });
        this.props.bus.getSubscriber().on('baro_set')
            .handle(() => this.handleBaroSetEvent());
        vnav.on('vnavConstraintAltitude').whenChanged().handle(alt => {
            if (alt > 0) {
                this.vnavTargetAltSubject.set(Math.round(alt));
                this.vnavTargetAltRef.instance.classList.remove('hidden');
            }
            else {
                this.vnavTargetAltRef.instance.classList.add('hidden');
            }
        });
        this.controller.alerterState.sub(this.onAlerterStateChanged.bind(this));
        //init minimums to display = none
        this.minimumsBugRef.instance.style.display = 'none';
        this.altitudeBugRef.instance.style.display = 'none';
    }
    /**
     * Set the Kohlsman setting directly.
     * @param baroMbar The new barometer setting in millibars.
     */
    static setKohlsmanMbar(baroMbar) {
        SimVar.SetSimVarValue('K:KOHLSMAN_SET', 'number', (baroMbar * 16));
    }
    /**
     * Convenience function to set the Kohlsman in inHg, since that's the main unit we use here.
     * @param baroIn The new barometer setting in inHg.
     */
    static setKohlsman(baroIn) {
        Altimeter.setKohlsmanMbar(UnitType.IN_HG.convertTo(baroIn, UnitType.HPA));
    }
    /**
     * Handle when the G1000 detects that the user pressed the 'B' key to set the barometric pressure.
     */
    handleBaroSetEvent() {
        const indicatedAltitude = this.controller.altitude;
        if (indicatedAltitude > 18000) {
            if (!this.currentBaro.standard) {
                this.props.g1000Publisher.publishEvent('std_baro_switch', true);
            }
        }
        else {
            if (this.currentBaro.standard) {
                this.storedBaroIn = undefined;
                this.props.g1000Publisher.publishEvent('std_baro_switch', false);
            }
        }
    }
    /**
     * A method called to update the location of the Minimums Bug on the altitude tape.
     */
    updateMinimumsBug() {
        var _a, _b, _c;
        const deltaBug = this.minimumsAltitude - this.controller.altitude;
        //53.5px per hundred ft
        // if (this.altitude < 20) {
        //   deltaBug = this.selectedAltitude < 20 ? 0 : this.selectedAltitude - 20;
        // } else if (this.altitude < 50) {
        //   deltaBug = Math.max(this.selectedAltitude - (this.ias - 20), -30);
        // }
        if (this.controller.altitude >= -2000 && this.controller.altitude <= 99900) {
            this.minimumsBugRef.instance.style.transform = `translate3d(0,${-0.5575 * Utils.Clamp(deltaBug, -300, 300)}px,0)`;
        }
        if (this.controller.altitude < this.minimumsAltitude) {
            (_a = this.minimumsBugColor.instance) === null || _a === void 0 ? void 0 : _a.setAttribute('fill', 'yellow');
        }
        else if (this.minimumsAltitude > (this.controller.altitude - 100) && this.controller.altitude >= this.minimumsAltitude) {
            (_b = this.minimumsBugColor.instance) === null || _b === void 0 ? void 0 : _b.setAttribute('fill', 'white');
        }
        else {
            (_c = this.minimumsBugColor.instance) === null || _c === void 0 ? void 0 : _c.setAttribute('fill', 'cyan');
        }
    }
    /**
     * A method called to update the location of the Selected Altitude Bug on the altitude tape.
     */
    updateSelectedAltitudeBug() {
        const deltaBug = this.controller.selectedAltitude - this.controller.altitude;
        if (this.controller.altitude >= -2000 && this.controller.altitude <= 99900) {
            this.altitudeBugRef.instance.style.transform = `translate3d(0,${-0.5575 * Utils.Clamp(deltaBug, -300, 300)}px,0)`;
        }
    }
    /**
     * A method called when the alt alerter state is changed.
     * @param state is the altitude alerter state
     */
    onAlerterStateChanged(state) {
        switch (state) {
            case AltAlertState.DISABLED:
            case AltAlertState.ARMED:
                this.alerterBoxRef.instance.classList.remove('thousand-flash', 'two-hundo-flash', 'yellow-flash');
                this.alerterTextRef.instance.classList.remove('thousand-flash', 'two-hundo-flash', 'yellow-flash');
                this.alerterSVGBugRef.instance.classList.remove('thousand-flash', 'two-hundo-flash', 'yellow-flash');
                break;
            case AltAlertState.WITHIN_1000:
                this.alerterBoxRef.instance.classList.add('thousand-flash');
                this.alerterTextRef.instance.classList.add('thousand-flash');
                this.alerterSVGBugRef.instance.classList.add('thousand-flash');
                break;
            case AltAlertState.WITHIN_200:
                this.alerterBoxRef.instance.classList.remove('thousand-flash', 'yellow-flash');
                this.alerterTextRef.instance.classList.remove('thousand-flash', 'yellow-flash');
                this.alerterSVGBugRef.instance.classList.remove('thousand-flash', 'yellow-flash');
                this.alerterBoxRef.instance.classList.add('two-hundo-flash');
                this.alerterTextRef.instance.classList.add('two-hundo-flash');
                this.alerterSVGBugRef.instance.classList.add('two-hundo-flash');
                break;
            case AltAlertState.CAPTURED:
                break;
            case AltAlertState.DEVIATION_200:
                this.alerterBoxRef.instance.classList.remove('two-hundo-flash');
                this.alerterTextRef.instance.classList.remove('two-hundo-flash');
                this.alerterSVGBugRef.instance.classList.remove('two-hundo-flash');
                this.alerterBoxRef.instance.classList.add('yellow-flash');
                this.alerterTextRef.instance.classList.add('yellow-flash');
                this.alerterSVGBugRef.instance.classList.add('yellow-flash');
                break;
        }
    }
    /**
     * Updates the kohlsman value based on knob input.
     * @param increase a bool to determine whether to increcement up or down the current baro setting.
     */
    onbaroKnobTurn(increase) {
        if (this.currentBaro.standard) {
            this.currentBaro.settingIn = 29.92;
            this.currentBaro.standard = false;
            this.props.g1000Publisher.publishEvent('std_baro_switch', this.currentBaro.standard);
        }
        if (increase) {
            if (this.currentBaro.units_hpa) {
                Altimeter.setKohlsman(this.currentBaro.settingIn + UnitType.HPA.convertTo(1, UnitType.IN_HG));
            }
            else {
                Altimeter.setKohlsman(this.currentBaro.settingIn + 0.01);
            }
        }
        else {
            if (this.currentBaro.units_hpa) {
                Altimeter.setKohlsman(this.currentBaro.settingIn - UnitType.HPA.convertTo(1, UnitType.IN_HG));
            }
            else {
                Altimeter.setKohlsman(this.currentBaro.settingIn - 0.01);
            }
        }
        this.updateBaroDisplay();
    }
    /**
     * Updates the kohlsman value when it changes.
     * @param baroUnits The new selected altitude value.
     */
    updateBaroUnits(baroUnits) {
        this.currentBaro.units_hpa = baroUnits;
        this.updateBaroDisplay();
    }
    /**
     * Updates the kohlsman value when it changes.
     * @param baroStd The new selected altitude value.
     */
    updateBaroStd(baroStd) {
        this.currentBaro.standard = baroStd;
        if (baroStd == true) {
            this.storedBaroIn = this.currentBaro.settingIn;
            this.currentBaro.settingIn = 29.92;
        }
        else if (this.storedBaroIn !== undefined) {
            this.currentBaro.settingIn = this.storedBaroIn;
            this.storedBaroIn = undefined;
        }
        Altimeter.setKohlsman(this.currentBaro.settingIn);
        this.updateBaroDisplay();
    }
    /**
     * Updates the kohlsman value when it changes.
     * @param kohlsmanSetting The new selected altitude value.
     */
    updateKohlsmanSetting(kohlsmanSetting) {
        this.currentBaro.settingIn = kohlsmanSetting;
        this.updateBaroDisplay();
    }
    /**
     * Updates the kohlsman display value.
     */
    updateBaroDisplay() {
        if (this.currentBaro.standard && this.kohlsmanSetting.instance !== null && this.baroUnits.instance !== null) {
            this.kohlsmanSetting.instance.textContent = 'STD BARO';
            this.baroUnits.instance.textContent = '';
        }
        else if (this.currentBaro.units_hpa && this.kohlsmanSetting.instance !== null && this.baroUnits.instance !== null) {
            this.kohlsmanSetting.instance.textContent = `${Math.round(33.864 * this.currentBaro.settingIn)}`;
            this.baroUnits.instance.textContent = 'HPA';
        }
        else if (this.kohlsmanSetting.instance !== null && this.baroUnits.instance !== null) {
            this.kohlsmanSetting.instance.textContent = `${(this.currentBaro.settingIn.toPrecision(4))}`;
            this.baroUnits.instance.textContent = 'IN';
        }
    }
    /**
     * Updates the altitude indicator when the altitude changes.
     * @param relativeAlt The new altitude value.
     */
    updateAltitude(relativeAlt) {
        this.controller.altitude = relativeAlt;
        const alt = Math.abs(relativeAlt);
        const altPrefix = relativeAlt < 0 ? -1 : 1;
        relativeAlt < 0 ? this.altitudeBoxElement.instance.classList.add('below-msl') : this.altitudeBoxElement.instance.classList.remove('below-msl');
        relativeAlt < 20 && relativeAlt > -20 ? this.altitudeBoxElement.instance.classList.add('trans-msl') : this.altitudeBoxElement.instance.classList.remove('trans-msl');
        const tens = alt % 100;
        const hundreds = (alt % 1000 - tens) / 100;
        const thousands = ((alt - (alt % 1000)) / 1000) % 10;
        const tenThousands = (alt - (alt % 10000)) / 10000;
        if (this.altitudeTenThousandsDataElement.instance !== null) {
            let newTranslation;
            if (relativeAlt < -980 || (relativeAlt < -2000 || relativeAlt > 99900)) {
                newTranslation = -660;
            }
            else {
                newTranslation = -300 + (tenThousands * 30) * altPrefix;
                if (thousands === 9 && hundreds == 9 && tens > 80) {
                    newTranslation += 1.5 * (tens - 80) * altPrefix;
                }
            }
            this.altitudeTenThousandsDataElement.instance.setAttribute('transform', `translate(0,${newTranslation})`);
        }
        if (this.altitudeThousandsDataElement.instance !== null) {
            (relativeAlt < 1000 && relativeAlt > -1000) ? this.altitudeThousandsDataElement.instance.classList.add('no-zero') : this.altitudeThousandsDataElement.instance.classList.remove('no-zero');
            let newTranslation;
            if ((relativeAlt > -980 && relativeAlt < -80) || (relativeAlt < -2000 || relativeAlt > 99900)) {
                newTranslation = -660;
            }
            else {
                newTranslation = -300 + (thousands * 30) * altPrefix;
                if (hundreds == 9 && tens > 80) {
                    newTranslation += 1.5 * (tens - 80) * altPrefix;
                }
            }
            this.altitudeThousandsDataElement.instance.setAttribute('transform', `translate(0,${newTranslation})`);
        }
        if (this.altitudeHundredsDataElement.instance !== null) {
            (relativeAlt < 100 && relativeAlt > -100) ? this.altitudeHundredsDataElement.instance.classList.add('no-zero') : this.altitudeHundredsDataElement.instance.classList.remove('no-zero');
            let newTranslation;
            if ((relativeAlt > -80 && relativeAlt < 0) || (relativeAlt < -2000 || relativeAlt > 99900)) {
                newTranslation = -660;
            }
            else {
                newTranslation = -300 + (hundreds * 30) * altPrefix;
                if (tens > 80) {
                    newTranslation += 1.5 * (tens - 80) * altPrefix;
                }
            }
            this.altitudeHundredsDataElement.instance.setAttribute('transform', `translate(0,${newTranslation})`);
        }
        if (this.altitudeTensDataElement.instance !== null) {
            const newTranslation = (relativeAlt < -2000 || relativeAlt > 99900) ? -399 : -191 + (tens * 1.3) * altPrefix;
            this.altitudeTensDataElement.instance.setAttribute('transform', `translate(0,${newTranslation})`);
        }
        if (this.altitudeTapeTickElement.instance !== null) {
            const offset = relativeAlt >= 0 ? -104 : -4;
            const newTranslation = (relativeAlt < -2000 || relativeAlt > 99900) ? -104 : offset + relativeAlt % 100;
            this.altitudeTapeTickElement.instance.style.transform = `translate3d(0px, ${newTranslation * 0.5575}px, 0px)`;
        }
        if ((relativeAlt / 100 >= this.currentDrawnAlt + 1 || relativeAlt / 100 < this.currentDrawnAlt) && (relativeAlt > -2000 || relativeAlt > 99900)) {
            this.currentDrawnAlt = Math.floor(relativeAlt / 100);
            for (let i = 0; i < this.altitudeScrollerValues.length; i++) {
                const scrollerValue = this.altitudeScrollerValues[i].instance;
                const zeroValue = this.altitudeScrollerZeroes[i].instance;
                if (scrollerValue !== null) {
                    if ((i - 4) + this.currentDrawnAlt === 0) {
                        scrollerValue.textContent = '';
                        zeroValue.textContent = '0';
                    }
                    else {
                        scrollerValue.textContent = ((i - 4) + this.currentDrawnAlt).toString();
                        zeroValue.textContent = '00';
                    }
                }
            }
        }
        this.updateSelectedAltitudeBug();
        this.updateMinimumsBug();
        this.controller.updateAltitudeAlerter();
    }
    /**
     * Updates the Altitude Trend Vector when the vertical speed changes.
     * @param vs The new vertical speed.
     */
    updateVerticalSpeed(vs) {
        const currentTrend = vs / 10;
        const verticalOffset = -104 - Math.max(0, currentTrend);
        this.altitudeTrendVector.instance.setAttribute('y', verticalOffset.toString());
        this.altitudeTrendVector.instance.setAttribute('height', Math.abs(currentTrend).toString());
    }
    /**
     * Builds a numerical scroller with dual numbers for the altimeter window.
     * @param startYValue The starting Y value in the svg to start number at.
     * @returns A collection of text elements for the numerical scroller.
     */
    buildDoubleScroller(startYValue = 78) {
        const scroller = [];
        let yValue = startYValue;
        for (let i = 0; i < 15; i++) {
            const number = i < 7 ? (220 - i * 20) : i * 20 - 20;
            const numberText = i == 13 ? ' ' : i == 14 ? '- -' : number.toString().slice(-2);
            let className = numberText == '00' ? 'zero-digit' : 'normal-digit';
            if (i == 5 || i == 7) {
                const altClassName = i == 5 ? className + ' top show-below-msl' : className + ' bottom show-above-msl';
                const altNumberText = (100 - number % 100).toString().slice(-2);
                scroller.push(FSComponent.buildComponent("text", { x: '15', y: yValue, class: altClassName, fill: "white", "text-anchor": "middle", "font-size": '26' }, altNumberText));
                className += i == 5 ? ' top show-above-msl' : ' bottom show-below-msl';
            }
            scroller.push(FSComponent.buildComponent("text", { x: '15', y: yValue, class: className, fill: "white", "text-anchor": "middle", "font-size": '26' }, numberText));
            yValue += 26;
        }
        return scroller;
    }
    /**
     * Builds a numerical scroller for the altimeter window.
     * @param startYValue The starting Y value in the svg to start number at.
     * @returns A collection of text elements for the numerical scroller.
     */
    buildSingleScroller(startYValue = -3) {
        const scroller = [];
        let yValue = startYValue;
        for (let i = 0; i < 24; i++) {
            const number = i < 12 ? (11 - i) : i - 11;
            const numberText = i == 23 ? '-' : number.toString().slice(-1);
            let className = number === 0 ? 'zero-digit' : 'normal-digit';
            if (i == 10 || i == 12) {
                const altClassName = i == 10 ? className + ' top show-below-msl' : className + ' bottom show-above-msl';
                const altNumber = 10 - number;
                const altNumberText = altNumber.toString();
                scroller.push(FSComponent.buildComponent("text", { x: '8', y: yValue, class: altClassName, fill: "white", "text-anchor": "middle", "font-size": '26' }, altNumberText));
                className += i == 10 ? ' top show-above-msl' : ' bottom show-below-msl';
            }
            scroller.push(FSComponent.buildComponent("text", { x: '8', y: yValue, class: className, fill: "white", "text-anchor": "middle", "font-size": '26' }, numberText));
            yValue += 30;
        }
        return scroller;
    }
    /**
     * Builds the tick marks on the altitude tape.
     * @returns A collection of tick mark line elements.
     */
    buildAltitudeTapeTicks() {
        const ticks = [];
        for (let i = 0; i < 41; i++) {
            const length = i === 0 || i % 5 === 0 ? 30 : 15;
            const startX = 1;
            const startY = 400 - (i * 20);
            const endX = startX + length;
            const endY = startY;
            ticks.push(FSComponent.buildComponent("line", { x1: startX, y1: startY, x2: endX, y2: endY, stroke: "rgb(203,203,203)", "stroke-width": "3px" }));
        }
        return ticks;
    }
    /**
     * Builds the altitude numbers for the altimeter tape.
     * @returns A collection of airspeed number text elements.
     */
    buildAltitudeTapeNumbers() {
        const text = [];
        let altStart = -4;
        for (let i = 0; i < 9; i++) {
            const startX = 133;
            const startY = 415 - (i * 100);
            const numberText = altStart.toString();
            const textElement = FSComponent.createRef();
            text.push(FSComponent.buildComponent("text", { x: startX, y: startY, fill: "rgb(203,203,203)", "text-anchor": "end", "font-size": '44', ref: textElement }, numberText));
            this.altitudeScrollerValues.push(textElement);
            altStart++;
        }
        return text;
    }
    /**
     * Builds the zeroes for the altitude tape.
     * @returns A collection of zeroes text elements.
     */
    buildAltitudeTapeZeros() {
        const zeros = [];
        for (let i = 0; i < 9; i++) {
            const startX = 175;
            const startY = 415 - (i * 100);
            const zeroElement = FSComponent.createRef();
            zeros.push(FSComponent.buildComponent("text", { x: startX, y: startY, fill: "rgb(203,203,203)", "text-anchor": "end", "font-size": '38', ref: zeroElement }, "00"));
            this.altitudeScrollerZeroes.push(zeroElement);
        }
        return zeros;
    }
    /**
     * Render the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "altimeter" },
            FSComponent.buildComponent("div", { class: "altimeter-middle-border" }),
            FSComponent.buildComponent("div", { class: "altitude-tick-marks" },
                FSComponent.buildComponent("div", { style: "height: 446px; width: 100px;", ref: this.altitudeTapeTickElement },
                    FSComponent.buildComponent("svg", { height: "446", width: "100", viewBox: "0 -400 179 800" },
                        FSComponent.buildComponent("g", { class: "AltitudeTape", transform: "translate(0,0)" },
                            this.buildAltitudeTapeTicks(),
                            this.buildAltitudeTapeZeros(),
                            this.buildAltitudeTapeNumbers())))),
            FSComponent.buildComponent("div", { class: "altitude-trend-vector" },
                FSComponent.buildComponent("svg", { height: "446", width: "100", viewBox: "0 -400 179 800" },
                    FSComponent.buildComponent("rect", { ref: this.altitudeTrendVector, x: "1", y: "-104", width: "7", height: "0", stroke: "white", "stroke-width": "1px", fill: "magenta" }))),
            FSComponent.buildComponent("div", { class: "altitude-box", ref: this.altitudeBoxElement },
                FSComponent.buildComponent("svg", null,
                    FSComponent.buildComponent("path", { d: "M 4 50 l 8 -5 l 0 -12 c 0 -1 1 -2 2 -2 l 54 0 l 0 -13 c 0 -1 1 -2 2 -2 l 30 0 c 1 0 2 1 2 2 l 0 63 c 0 1 -1 2 -2 2 l -30 0 c -1 0 -2 -1 -2 -2 l 0 -13 l -54 0 c -1 0 -2 -1 -2 -2 l 0 -12 l -8 -4 z", fill: "black", stroke: "whitesmoke", "stroke-width": "1" })),
                FSComponent.buildComponent("div", { class: "alt-ten-thousands-scroller altitude-scroller-background no-zero" },
                    FSComponent.buildComponent("svg", { height: "35", width: "17" },
                        FSComponent.buildComponent("g", { ref: this.altitudeTenThousandsDataElement, transform: "translate(0,0)" }, this.buildSingleScroller()))),
                FSComponent.buildComponent("div", { class: "alt-thousands-scroller altitude-scroller-background" },
                    FSComponent.buildComponent("svg", { height: "35", width: "17" },
                        FSComponent.buildComponent("g", { ref: this.altitudeThousandsDataElement, transform: "translate(0,0)" }, this.buildSingleScroller()))),
                FSComponent.buildComponent("div", { class: "alt-hundreds-scroller altitude-scroller-background" },
                    FSComponent.buildComponent("svg", { height: "35", width: "17" },
                        FSComponent.buildComponent("g", { ref: this.altitudeHundredsDataElement, transform: "translate(0,0)" }, this.buildSingleScroller()))),
                FSComponent.buildComponent("div", { class: "alt-tens-scroller altitude-scroller-background" },
                    FSComponent.buildComponent("div", { class: "alt-tens-mask" }),
                    FSComponent.buildComponent("svg", { height: "66", width: "29" },
                        FSComponent.buildComponent("g", { ref: this.altitudeTensDataElement, transform: "translate(0,0)" }, this.buildDoubleScroller())))),
            FSComponent.buildComponent("div", { class: "preselect-bug", ref: this.altitudeBugRef },
                FSComponent.buildComponent("svg", null,
                    FSComponent.buildComponent("path", { d: "M 0 36 l 12 0 l 0 9 l -8 5 l 8 4 l 0 9 l -12 0 z", fill: "cyan", stroke: "black", "stroke-width": "1" }))),
            FSComponent.buildComponent("div", { class: "minimums-bug", ref: this.minimumsBugRef },
                FSComponent.buildComponent("svg", null,
                    FSComponent.buildComponent("path", { ref: this.minimumsBugColor, d: 'M 5 50 l 8 -5 l 0 -14 l 3 0 l 0 14 l -9 5 l 9 4 l 0 14 l -3 0 l 0 -14 l -8 -4', fill: "cyan" }))),
            FSComponent.buildComponent("div", { class: "preselect-box", ref: this.alerterBoxRef },
                FSComponent.buildComponent("svg", null,
                    FSComponent.buildComponent("path", { ref: this.alerterSVGBugRef, d: "M 6 8 l 8 0 l 0 4 l -4 3 l 0 2 l 4 3 l 0 4 l -8 0 l 0 -16 z", fill: "cyan" })),
                FSComponent.buildComponent("div", { class: "preselect-value", ref: this.alerterTextRef },
                    FSComponent.buildComponent("span", { ref: this.selectedAltitudeHundredsRef }, this.selectedAltitudeHundredsSubject),
                    FSComponent.buildComponent("span", { ref: this.selectedAltitudeTensRef, class: 'preselect-tens' }, this.selectedAltitudeTensSubject))),
            FSComponent.buildComponent("div", { class: "alt-indicator-vnav-target", ref: this.vnavTargetAltRef }, this.vnavTargetAltSubject),
            FSComponent.buildComponent("div", { class: "pressure-box" },
                FSComponent.buildComponent("span", { ref: this.kohlsmanSetting }),
                FSComponent.buildComponent("span", { ref: this.baroUnits, class: "size14" }, "IN"))));
    }
}

/**
 * The PFD Flight Director.
 */
class FlightDirector extends DisplayComponent {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.fltDirectorRef = FSComponent.createRef();
        this.currentBank = 0;
        this.fdRawBank = 0;
        this.fdServoBank = 0;
        this.currentPitch = 0;
        this.pitchIncrementDistance = 1;
        this.fdRawPitch = 0;
        this.bankServo = new LinearServo(5);
        this.pitchAverage = new SimpleMovingAverage(20);
        this.needUpdate = false;
        this.fdPitchHandler = (fdPitch) => {
            this.fdRawPitch = fdPitch;
            this.needUpdate = true;
        };
        this.fdBankHandler = (fdBank) => {
            this.fdRawBank = fdBank;
            this.needUpdate = true;
        };
        this.pitchHandler = (pitch) => {
            this.currentPitch = pitch;
            this.needUpdate = true;
        };
        this.bankHandler = (bank) => {
            this.currentBank = bank;
            this.needUpdate = true;
        };
        /**
         * A callback called when the Flight Director is turned on or off.
         * @param state The bool state of the flight director status.
         */
        this.toggleFltDir = (state) => {
            if (state) {
                this.fdPitchConsumer.handle(this.fdPitchHandler);
                this.fdBankConsumer.handle(this.fdBankHandler);
                this.pitchConsumer.handle(this.pitchHandler);
                this.bankConsumer.handle(this.bankHandler);
                this.fltDirectorRef.instance.style.display = '';
            }
            else {
                this.fdPitchConsumer.off(this.fdPitchHandler);
                this.fdBankConsumer.off(this.fdBankHandler);
                this.pitchConsumer.off(this.pitchHandler);
                this.bankConsumer.off(this.bankHandler);
                this.fltDirectorRef.instance.style.display = 'none';
            }
        };
        const subscriber = this.props.bus.getSubscriber();
        this.fdStateConsumer = subscriber.on('flight_director_state').whenChanged();
        this.fdPitchConsumer = subscriber.on('flight_director_pitch').withPrecision(2);
        this.fdBankConsumer = subscriber.on('flight_director_bank').withPrecision(2);
        this.pitchConsumer = subscriber.on('pitch_deg').withPrecision(2);
        this.bankConsumer = subscriber.on('roll_deg').withPrecision(2);
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        this.props.bus.getSubscriber().on('realTime').handle(this.updateFD.bind(this));
        this.fdStateConsumer.handle(this.toggleFltDir);
        this.props.bus.getSubscriber().on('fd_not_installed').handle(v => {
            if (v) {
                this.fdStateConsumer.off(this.toggleFltDir);
                this.toggleFltDir(false);
            }
        });
        PFDUserSettings.getManager(this.props.bus).whenSettingChanged('svtToggle').handle((svt) => {
            svt ? this.pitchIncrementDistance = 1 : this.pitchIncrementDistance = .5;
            this.updateFD();
        });
    }
    /**
     * Updates the flight director.
     */
    updateFD() {
        if (!this.needUpdate) {
            return;
        }
        this.fdServoBank = this.bankServo.drive(this.fdServoBank, this.fdRawBank);
        const correctedBank = this.fdServoBank - this.currentBank;
        const averagedPitch = this.pitchAverage.getAverage(this.fdRawPitch);
        const correctedPitch = MathUtils.clamp(averagedPitch - this.currentPitch, -10, 10);
        const translation = correctedPitch * this.pitchIncrementDistance * 13.5;
        this.fltDirectorRef.instance.style.transform = `translate3d(0px, ${translation}px, 0px) rotate3d(0, 0, 1, ${-correctedBank}deg)`;
        this.needUpdate = false;
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "flight-director-container", ref: this.fltDirectorRef },
            FSComponent.buildComponent("svg", { width: "414", height: "315" },
                FSComponent.buildComponent("path", { d: "M 207 204 l -120 30 l -14 -9 l 134 -22 z", fill: "magenta", stroke: "black", "stroke-width": ".5px" }),
                FSComponent.buildComponent("path", { d: "M 73 225 l 0 9 l 14 0 z", fill: "magenta", stroke: "black", "stroke-width": ".5px" }),
                FSComponent.buildComponent("path", { d: "M 207 204 l 120 30 l 14 -9 l -134 -22 z", fill: "magenta", stroke: "black", "stroke-width": ".5px" }),
                FSComponent.buildComponent("path", { d: "M 341 225 l 0 9 l -14 0 z", fill: "magenta", stroke: "black", "stroke-width": ".5px" }))));
    }
}

/* eslint-disable max-len */
/**
 * Representation of the active and standby frequencies of a nav or com radio.
 */
class NavComFrequencyElement extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.selectorBorderElement = FSComponent.createRef();
        this.selectorArrowElement = FSComponent.createRef();
        this.activeFreq = FSComponent.createRef();
        this.standbyFreq = FSComponent.createRef();
        this.ident = FSComponent.createRef();
        /**
         * Handle a radioo state update event.
         * @param radio The Radio that was updated.
         */
        this.onUpdateState = (radio) => {
            if (!(radio.radioType == this.props.type && radio.index == this.props.index)) {
                return;
            }
            if (this.activeFreq.instance !== null) {
                this.activeFreq.instance.textContent = radio.activeFrequency.toFixed(radio.radioType == RadioType.Nav ? 2 : 3);
            }
            if (this.standbyFreq.instance !== null) {
                this.standbyFreq.instance.textContent = radio.standbyFrequency.toFixed(radio.radioType == RadioType.Nav ? 2 : 3);
            }
            if (this.selectorBorderElement.instance !== null && this.selectorArrowElement.instance !== null) {
                this.selectorBorderElement.instance.style.display = radio.selected ? '' : 'none';
                this.selectorArrowElement.instance.style.visibility = radio.selected ? 'visible' : 'hidden';
            }
            if (this.ident.getOrDefault() !== null) {
                this.ident.instance.textContent = radio.ident;
            }
        };
        /**
         * Handle a frequency change event.
         * @param change The FrequencyChangeEvent to process.
         */
        this.onUpdateFrequency = (change) => {
            if (!(change.radio.radioType == this.props.type && change.radio.index == this.props.index)) {
                return;
            }
            switch (change.bank) {
                case FrequencyBank.Active:
                    if (this.activeFreq.instance !== null) {
                        this.activeFreq.instance.textContent = change.frequency.toFixed(change.radio.radioType == RadioType.Nav ? 2 : 3);
                    }
                    break;
                case FrequencyBank.Standby:
                    if (this.standbyFreq.instance !== null) {
                        this.standbyFreq.instance.textContent = change.frequency.toFixed(change.radio.radioType == RadioType.Nav ? 2 : 3);
                    }
                    break;
            }
        };
        /**
         * Handle an ident set event.
         * @param change The IdentChangeEvent to process.
         */
        this.onUpdateIdent = (change) => {
            if (change.index == this.props.index && this.ident.getOrDefault() !== null) {
                this.ident.instance.textContent = change.ident;
            }
        };
        /**
         * A callback called when the CDI Source Changes.
         * @param source The current selected CDI Source.
         */
        this.onUpdateCdiSelect = (source) => {
            if (source.type === NavSourceType.Nav && source.index == this.props.index) {
                this.activeFreq.instance.classList.add('navcom-green');
                this.ident.instance.classList.add('navcom-green');
            }
            else {
                this.activeFreq.instance.classList.remove('navcom-green');
                this.ident.instance.classList.remove('navcom-green');
            }
        };
    }
    /**
     * Set this frequency as the active selection visually.
     * @param isSelected Indicates if the frequency should show as selected or not.
     */
    setSelected(isSelected) {
        if (this.selectorBorderElement.instance !== null && this.selectorArrowElement.instance !== null) {
            this.selectorBorderElement.instance.style.display = isSelected ? '' : 'none';
            this.selectorArrowElement.instance.style.visibility = isSelected ? 'visible' : 'hidden';
        }
    }
    /**
     * Stuff to do after rendering.
     */
    onAfterRender() {
        const nav = this.props.bus.getSubscriber();
        nav.on('setRadioState').handle(this.onUpdateState);
        nav.on('setFrequency').handle(this.onUpdateFrequency);
        nav.on('setIdent').handle(this.onUpdateIdent);
        if (this.props.position === 'left') {
            const navproc = this.props.bus.getSubscriber();
            navproc.on('cdi_select').handle(this.onUpdateCdiSelect);
        }
    }
    /**
     * Render NavCom Freq Element.
     * @returns Vnode containing the element.
     */
    render() {
        if (this.props.position === 'left') {
            return (FSComponent.buildComponent("div", { class: "navcom-frequencyelement-container" },
                FSComponent.buildComponent("div", { ref: this.selectorBorderElement, id: "navcomselect", class: "navcom-selector left" }),
                FSComponent.buildComponent("span", { class: "navcom-freqstandby", ref: this.standbyFreq }),
                FSComponent.buildComponent("span", { ref: this.selectorArrowElement, class: "navcom-arrows" },
                    FSComponent.buildComponent("svg", { width: "22", height: "16" },
                        FSComponent.buildComponent("path", { d: "M 12 8 m 0 0.75 l -5 0 l 1 3.25 l 0 1 l -4.5 -5 l 4.5 -5 l 0 1 l -1 3.25 l 10 0 l -1 -3.25 l 0 -1 l 4.5 5 l -4.5 5 l 0 -1 l 1 -3.25 l -5 0 z", fill: "cyan" }))),
                FSComponent.buildComponent("span", { class: "navcom-freqactive", ref: this.activeFreq }),
                FSComponent.buildComponent("div", { class: "navcom-ident", ref: this.ident })));
        }
        else {
            return (FSComponent.buildComponent("div", { class: "navcom-frequencyelement-container" },
                FSComponent.buildComponent("div", { ref: this.selectorBorderElement, id: "navcomselect", class: "navcom-selector right" }),
                FSComponent.buildComponent("span", { class: "navcom-freqactive", ref: this.activeFreq }),
                FSComponent.buildComponent("span", { ref: this.selectorArrowElement, class: "navcom-arrows" },
                    FSComponent.buildComponent("svg", { width: "25", height: "16" },
                        FSComponent.buildComponent("path", { d: "M 12 8 m 0 0.75 l -5 0 l 1 3.25 l 0 1 l -4.5 -5 l 4.5 -5 l 0 1 l -1 3.25 l 10 0 l -1 -3.25 l 0 -1 l 4.5 5 l -4.5 5 l 0 -1 l 1 -3.25 l -5 0 z", fill: "cyan" }))),
                FSComponent.buildComponent("span", { class: "navcom-freqstandby", ref: this.standbyFreq })));
        }
    }
}

/* eslint-disable max-len */
/**
 *
 */
class NavComRadio extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.frequency1Element = FSComponent.createRef();
        this.frequency2Element = FSComponent.createRef();
    }
    /**
     * Stuff to do after render.
     */
    onAfterRender() {
        // Nothing to do at the moment.
        return;
    }
    /**
     * Render NavCom Element
     * @returns Vnode containing the element
     */
    render() {
        if (this.props.position === 'left') {
            return (FSComponent.buildComponent("div", null,
                FSComponent.buildComponent("div", { class: "navcom-title left" }, this.props.title),
                FSComponent.buildComponent("div", { class: "navcom-title-numbers left" }, "12"),
                FSComponent.buildComponent("div", { class: "navcom-frequencies left" },
                    FSComponent.buildComponent(NavComFrequencyElement, { ref: this.frequency1Element, bus: this.props.bus, position: this.props.position, type: RadioType.Nav, index: 1 }),
                    FSComponent.buildComponent(NavComFrequencyElement, { ref: this.frequency2Element, bus: this.props.bus, position: this.props.position, type: RadioType.Nav, index: 2 }))));
        }
        else {
            return (FSComponent.buildComponent("div", null,
                FSComponent.buildComponent("div", { class: "navcom-frequencies right" },
                    FSComponent.buildComponent(NavComFrequencyElement, { ref: this.frequency1Element, bus: this.props.bus, position: this.props.position, type: RadioType.Com, index: 1 }),
                    FSComponent.buildComponent(NavComFrequencyElement, { ref: this.frequency2Element, bus: this.props.bus, position: this.props.position, type: RadioType.Com, index: 2 })),
                FSComponent.buildComponent("div", { class: "navcom-title-numbers right" }, "12"),
                FSComponent.buildComponent("div", { class: "navcom-title right" }, this.props.title)));
        }
    }
}

/**
 * The PFD vertical speed indicator.
 */
class VerticalSpeedIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.verticalSpeedPointer = FSComponent.createRef();
        this.desiredSpeedPointer = FSComponent.createRef();
        this.selectedVerticalSpeed = FSComponent.createRef();
        this.selectedVSBug = FSComponent.createRef();
        this.previousVSNumber = 0;
        this.verticalSpeedValue = Subject.create(0);
        this.verticalSpeedVisible = Subject.create('');
        this.selectedVsVisibility = Subject.create(false);
        this.selectedVsValue = Subject.create(0);
        this.vnavDisplayMode = VNavDisplayMode.NONE;
        this.gpDisplayMode = GPDisplayMode.NONE;
        this.selectedVsValueTransform = ComputedSubject.create(0, (v) => {
            return `translate3d(0px, ${MathUtils.clamp(v, -2250, 2250) * -0.064}px, 0px)`;
        });
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        this.selectedVSBug.instance.classList.add('hide-element');
        this.selectedVerticalSpeed.instance.classList.add('hide-element');
        const adc = this.props.bus.getSubscriber();
        const vnav = this.props.bus.getSubscriber();
        const ap = this.props.bus.getSubscriber();
        adc.on('vs')
            .withPrecision(-1)
            .handle(this.updateVerticalSpeed.bind(this));
        vnav.on('vnavRequiredVs').whenChanged().handle(reqVs => this.updateDesiredSpeedPointer(reqVs));
        this.props.navIndicatorController.vnavDisplayMode.sub((mode) => {
            this.vnavDisplayMode = mode;
            this.updateDesiredSpeedPointerVisibility();
        });
        this.props.navIndicatorController.gpDisplayMode.sub((mode) => {
            this.gpDisplayMode = mode;
            this.updateDesiredSpeedPointerVisibility();
        });
        ap.on('vs_hold_fpm').handle((value) => {
            this.selectedVsValue.set(value);
            this.selectedVsValueTransform.set(value);
            this.updateSelectedVSBug();
        });
        ap.on('ap_lock_release').handle((unlock) => {
            if (unlock === APLockType.Vs) {
                this.selectedVsVisibility.set(false);
                this.selectedVSBug.instance.classList.add('hide-element');
                this.selectedVerticalSpeed.instance.classList.add('hide-element');
            }
        });
        ap.on('ap_lock_set').handle((lock) => {
            if (lock === APLockType.Vs) {
                this.selectedVsVisibility.set(true);
                this.selectedVSBug.instance.classList.remove('hide-element');
                this.selectedVerticalSpeed.instance.classList.remove('hide-element');
            }
        });
    }
    /**
     * Updates the vertical speed indicator when the vertical speed changes.
     * @param vs The new vertical speed.
     */
    updateVerticalSpeed(vs) {
        const quantizedVS = Math.ceil(vs / 50) * 50;
        this.updateVerticalSpeedPointer(vs);
        if (quantizedVS !== this.previousVSNumber) {
            this.previousVSNumber = quantizedVS;
            this.verticalSpeedVisible.set((vs > 50 || vs < -100) ? 'visible' : 'hidden');
            this.verticalSpeedValue.set(quantizedVS);
        }
    }
    /**
     * Updates the transform of the vertical speed pointer
     * @param vs The vertical speed
     */
    updateVerticalSpeedPointer(vs) {
        if (this.verticalSpeedPointer.instance !== null) {
            const clampedVs = MathUtils.clamp(vs, -2250, 2250);
            this.verticalSpeedPointer.instance.style.transform = `translate3d(0px, ${clampedVs * -0.064}px, 0px)`;
        }
    }
    /**
     * Updates the transform of the selected vertical speed bug
     */
    updateSelectedVSBug() {
        if (this.selectedVSBug.instance !== null) {
            this.selectedVSBug.instance.style.transform = `${this.selectedVsValueTransform.get()}`;
        }
    }
    /**
     * Updates the transform of the desired speed pointer
     * @param requiredVs The required Vertical Speed from VNAV.
     */
    updateDesiredSpeedPointer(requiredVs) {
        if (this.vnavDisplayMode !== VNavDisplayMode.NONE || this.gpDisplayMode !== GPDisplayMode.NONE) {
            const clampedVs = MathUtils.clamp(requiredVs, -2200, 0);
            this.desiredSpeedPointer.instance.style.transform = `translate3d(0px, ${clampedVs * -0.064}px, 0px)`;
        }
    }
    /**
     * Updates the visibility of the desired speed pointer.
     */
    updateDesiredSpeedPointerVisibility() {
        if (this.vnavDisplayMode === VNavDisplayMode.NONE && this.gpDisplayMode === GPDisplayMode.NONE) {
            this.desiredSpeedPointer.instance.style.display = 'none';
        }
        else {
            this.desiredSpeedPointer.instance.style.display = '';
        }
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "vsi-container" },
            FSComponent.buildComponent("svg", { height: "305px", width: "75" },
                FSComponent.buildComponent("defs", null,
                    FSComponent.buildComponent("linearGradient", { id: "vsiGradient", x1: "0%", y1: "0%", x2: "0%", y2: "100%" },
                        FSComponent.buildComponent("stop", { offset: "0%", style: "stop-color:rgb(80,80,80)" }),
                        FSComponent.buildComponent("stop", { offset: "100%", style: "stop-color:rgb(0,0,0)" }))),
                FSComponent.buildComponent("path", { d: "M 0 0 l 38 0 c 5 0 10 5 10 10 l 0 105 l -48 33 l 48 33 l 0 105 c 0 5 -5 10 -10 10 l -38 0", fill: "none", stroke: "url(#vsiGradient)", "stroke-width": "1px" }),
                FSComponent.buildComponent("path", { d: "M 15 137.691 l -15 10.309 l 15 10.312", fill: "none", stroke: "whitesmoke", "stroke-width": "2px" }),
                FSComponent.buildComponent("line", { x1: "2", y1: "20", x2: "16", y2: "20", style: "stroke:rgb(150,150,150);stroke-width:2px" }),
                FSComponent.buildComponent("text", { x: "25", y: "27", style: "fill:whitesmoke;font-size:20px" }, "2"),
                FSComponent.buildComponent("line", { x1: "2", y1: "52", x2: "10", y2: "52", style: "stroke:rgb(150,150,150);stroke-width:2px" }),
                FSComponent.buildComponent("line", { x1: "2", y1: "84", x2: "16", y2: "84", style: "stroke:rgb(150,150,150);stroke-width:2px" }),
                FSComponent.buildComponent("text", { x: "25", y: "91", style: "fill:whitesmoke;font-size:20px" }, "1"),
                FSComponent.buildComponent("line", { x1: "2", y1: "116", x2: "10", y2: "116", style: "stroke:rgb(150,150,150);stroke-width:2px" }),
                FSComponent.buildComponent("line", { x1: "2", y1: "180", x2: "10", y2: "180", style: "stroke:rgb(150,150,150);stroke-width:2px" }),
                FSComponent.buildComponent("line", { x1: "2", y1: "212", x2: "16", y2: "212", style: "stroke:rgb(150,150,150);stroke-width:2px" }),
                FSComponent.buildComponent("text", { x: "25", y: "219", style: "fill:whitesmoke;font-size:20px" }, "1"),
                FSComponent.buildComponent("line", { x1: "2", y1: "244", x2: "10", y2: "244", style: "stroke:rgb(150,150,150);stroke-width:2px" }),
                FSComponent.buildComponent("line", { x1: "2", y1: "276", x2: "16", y2: "276", style: "stroke:rgb(150,150,150);stroke-width:2px" }),
                FSComponent.buildComponent("text", { x: "25", y: "283", style: "fill:whitesmoke;font-size:20px" }, "2")),
            FSComponent.buildComponent("div", { ref: this.desiredSpeedPointer, class: "vsi-pointer", style: 'display: none' },
                FSComponent.buildComponent("svg", { height: "25px", width: "25px" },
                    FSComponent.buildComponent("path", { d: "m 2 9 l 14 -9 l 0 4 l -13 8 l 13 8 l 0 4 l -14 -9 z", fill: "magenta", stroke: "1px black" }))),
            FSComponent.buildComponent("div", { ref: this.verticalSpeedPointer, class: "vsi-pointer" },
                FSComponent.buildComponent("svg", { height: "25px", width: "68px" },
                    FSComponent.buildComponent("path", { d: "M 2 10 l 16 -10 l 47 0 c 2 0 3 1 3 3 l 0 16 c 0 2 -1 3 -3 3 l -47 0 l -16 -10 z ", fill: "black" }),
                    FSComponent.buildComponent("text", { x: "63", y: "18", "font-size": "20", "text-anchor": "end", fill: "white", visibility: this.verticalSpeedVisible }, this.verticalSpeedValue))),
            FSComponent.buildComponent("div", { ref: this.selectedVSBug, class: "vsi-selected-vs-bug" },
                FSComponent.buildComponent("svg", null,
                    FSComponent.buildComponent("path", { d: 'M 0 0 l 8 0 l 0 4.25 l -6 3.75 l 0 2 l 6 3.75 l 0 4.25 l -8 0 z', fill: "cyan", stroke: "black", "stroke-width": "1px" }))),
            FSComponent.buildComponent("div", { ref: this.selectedVerticalSpeed, class: "vsi-selected-vs" }, this.selectedVsValue)));
    }
}

/**
 * The FMA Leg Icon component
 */
class FmaLegIcon extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.iconElement = FSComponent.createRef();
        this.dtoTextElement = FSComponent.createRef();
        /**
         * A callback called when the leg type changes to modify the leg type icon in the FMA.
         * @param legExists is a bool for whether an arrow should be drawn at all
         * @param isDirectTo is a bool for whether the flight plan is current in a direct to state.
         * @param legType The current enum value for the leg type.
         * @param turnDirection the direction of the turn
         */
        this.updateFmaIcon = (legExists, isDirectTo, legType, turnDirection) => {
            if (this.iconElement.instance !== null && this.dtoTextElement.instance !== null) {
                let svgD = 'm 33 14 l -7.2 -7.2 l 0 5.04 l -19.04 0 l 0 4.32 l 19.04 0 l 0 5.04 l 7.2 -7.2 z ';
                let svgFill = 'magenta';
                let svgStroke = 'none';
                let svgStrokeWidth = '0px';
                let directTo = false;
                if (legExists) {
                    switch (legType) {
                        case LegType.DF:
                            if (isDirectTo === true) {
                                directTo = true;
                            }
                            svgD = 'm 33 14 l -7.2 -7.2 l 0 5.04 l -19.04 0 l 0 4.32 l 19.04 0 l 0 5.04 l 7.2 -7.2 z ';
                            svgFill = 'magenta';
                            svgStroke = 'none';
                            svgStrokeWidth = '0px';
                            break;
                        case LegType.HA:
                        case LegType.HF:
                        case LegType.HM:
                            if (turnDirection === LegTurnDirection.Left) {
                                svgD = 'm 4 20 l 22 0 m 0 -2 l 3 0 m 0 2 l 8 0 m -8 -1 l 1 0 c 7 0 7 -11 0 -11 l -19 0 c -7 0 -7 11 0 11 l 15 0 m 0 2 l 3 0 ';
                            }
                            else {
                                svgD = 'm 3 8 l 23 0 m 0 -1 l 3 0 m 0 1 l 8 0 m -8 1 l 1 0 c 7 0 7 11 0 11 l -19 0 c -7 0 -7 -11 0 -11 l 15 0 m 0 1 l 3 0 ';
                            }
                            svgFill = 'none';
                            svgStroke = 'magenta';
                            svgStrokeWidth = '2px';
                            break;
                        case LegType.PI:
                            if (turnDirection === LegTurnDirection.Left) {
                                svgD = 'm 3 8 l 3 0 m 2 -1 l 27 0 m -32 0 l 3 0 m 0 -1 l 2 0 m -2 3 l 2 0 m 0 -1 l 10 0 l 10 11 c 5 5 11 0 6 -5 l -5 -6 l -11 0 ';
                            }
                            else {
                                svgD = 'm 3 20 l 3 0 m 2 0 l 27 0 m -32 -1 l 3 0 m 0 -1 l 2 0 m -2 3 l 2 0 m 0 -2 l 10 0 l 10 -10 c 5 -5 11 0 6 5 l -5 5 l -11 0 ';
                            }
                            svgFill = 'none';
                            svgStroke = 'magenta';
                            svgStrokeWidth = '2px';
                            break;
                        case LegType.RF:
                        case LegType.AF:
                            if (turnDirection === LegTurnDirection.Left) {
                                svgD = 'm 4 12 c 0 6 2 9 7 9 l 16 0 c 5 0 7 -3 7 -9 l 4 0 l -7.5 -9 l -7.5 9 l 4 0 c 0 2 -1 4 -4 4 l -8 0 c -3 0 -4 -2 -4 -4 l -7 0 ';
                            }
                            else {
                                svgD = 'm 4 12 c 0 -6 2 -9 7 -9 l 16 0 c 5 0 7 3 7 9 l 4 0 l -7.5 9 l -7.5 -9 l 4 0 c 0 -2 -1 -4 -4 -4 l -8 0 c -3 0 -4 2 -4 4 l -7 0 ';
                            }
                            svgFill = 'magenta';
                            svgStroke = 'none';
                            svgStrokeWidth = '0px';
                            break;
                        default:
                            svgD = 'm 33 14 l -7.2 -7.2 l 0 5.04 l -19.04 0 l 0 4.32 l 19.04 0 l 0 5.04 l 7.2 -7.2 z ';
                            svgFill = 'magenta';
                            svgStroke = 'none';
                            svgStrokeWidth = '0px';
                            break;
                    }
                }
                else {
                    svgD = 'm 33 14 l -7.2 -7.2 l 0 5.04 l -19.04 0 l 0 4.32 l 19.04 0 l 0 5.04 l 7.2 -7.2 z ';
                    svgFill = 'none';
                    svgStroke = 'none';
                    svgStrokeWidth = '0px';
                }
                this.iconElement.instance.setAttribute('d', `${svgD}`);
                this.iconElement.instance.setAttribute('fill', `${svgFill}`);
                this.iconElement.instance.setAttribute('stroke', `${svgStroke}`);
                this.iconElement.instance.setAttribute('stroke-width', `${svgStrokeWidth}`);
                if (directTo) {
                    this.dtoTextElement.instance.setAttribute('visibility', 'visible');
                }
                else {
                    this.dtoTextElement.instance.setAttribute('visibility', 'hidden');
                }
            }
        };
    }
    /**
     * Do stuff after rendering.
     */
    onAfterRender() {
        this.dtoTextElement.instance.setAttribute('visibility', 'hidden');
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("svg", { class: "fma-symbols", width: "40", height: "24" },
            FSComponent.buildComponent("path", { ref: this.iconElement, d: 'm 0 0 ' }),
            FSComponent.buildComponent("text", { ref: this.dtoTextElement, x: "10", y: "21.3", fill: "magenta", "font-size": "20" }, "D")));
    }
}

/**
 * A component that alerts when the waypoint is about to change.
 */
class WaypointAlerter extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.el = new NodeReference();
        this.currentSpeed = 0;
        this.secondsRemaining = 0;
        this.nextDTK = 0;
        this.flashing = false;
        /**
         * A callback called when the LNAV distance to go is updated.
         * @param distance The distance to go.
         */
        this.onDistanceUpdated = (distance) => {
            if (distance !== 0) {
                const secondsRemaining = (distance / this.currentSpeed) * 60 * 60;
                if (secondsRemaining <= 5.25 && !this.flashing) {
                    this.el.instance && this.el.instance.classList.add('flashing');
                    this.el.instance && (this.el.instance.style.display = 'block');
                    this.secondsRemaining = Math.floor(secondsRemaining);
                    this.startFlash();
                }
            }
        };
        /**
         * Starts the waypoint alerter flashing.
         */
        this.startFlash = () => {
            if (this.secondsRemaining > 0) {
                this.flashing = true;
                this.el.instance && (this.el.instance.textContent = `Next DTK ${this.nextDTK.toFixed(0)}° in ${this.secondsRemaining} sec`);
                this.secondsRemaining--;
                this.currentTimeout = setTimeout(this.startFlash, 1000);
            }
            else {
                this.flashing = false;
                this.showNowMessage();
            }
        };
    }
    /**
     * A callback called after the component is rendered.
     */
    onAfterRender() {
        const lnav = this.props.bus.getSubscriber();
        this.props.bus.getSubscriber().on('ground_speed').handle(spd => this.currentSpeed = spd);
        lnav.on('lnavDisTurn').handle(this.onDistanceUpdated);
        lnav.on('lnavNextDtkMag').handle(dtk => this.nextDTK = dtk);
    }
    /**
     * Shows the waypoint dtk now message.
     */
    showNowMessage() {
        this.el.instance && (this.el.instance.classList.remove('flashing'));
        this.el.instance && (this.el.instance.textContent = `Next DTK ${this.nextDTK.toFixed(0)}° now`);
        setTimeout(() => this.el.instance && (this.el.instance.style.display = 'none'), 3000);
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: 'waypoint-alerter flashing', ref: this.el }, "Next DTK 275\u00B0 in 5 sec"));
    }
}

/**
 * Utility Methods for the FMS.
 */
class FmsUtils {
    /**
     * Utility method to return a one-way runway leg
     * @param airport The runway's parent airport.
     * @param oneWayRunway is the one wway runway object
     * @param isOriginRunway is a bool whether this is the origin or destination (origin = true, dest = false)
     * @returns a leg object for the runway
     */
    static buildRunwayLeg(airport, oneWayRunway, isOriginRunway) {
        const leg = FlightPlan.createLeg({
            lat: oneWayRunway.latitude,
            lon: oneWayRunway.longitude,
            type: isOriginRunway ? LegType.IF : LegType.TF,
            fixIcao: RunwayUtils.getRunwayFacilityIcao(airport, oneWayRunway),
            altitude1: oneWayRunway.elevation
        });
        return leg;
    }
    /**
     * Utility method to return a one-way runway leg from an approach runway leg definition
     * @param airport is the facility associated with the arrival
     * @param runwayIcao is the icao string for the runway waypoint in the final legs
     * @returns a leg object for the runway
     */
    static buildRunwayLegForApproach(airport, runwayIcao) {
        for (let i = 0; i < airport.runways.length; i++) {
            const match = RunwayUtils.getOneWayRunways(airport.runways[i], i).find((r) => {
                return (r.designation == ICAO.getIdent(runwayIcao));
            });
            if (match) {
                const leg = FlightPlan.createLeg({
                    lat: match.latitude,
                    lon: match.longitude,
                    type: LegType.TF,
                    fixIcao: runwayIcao
                });
                return leg;
            }
        }
        return undefined;
    }
    /**
     * Utility method to return a visual approach for a runway.
     * @param airport is the airport facility for the visual approach.
     * @param runway is the runway to build the visual approach for.
     * @param finalLegDistance is the distance from the runway to place the faf leg in NM.
     * @param initialLegDistance is the distance from the final leg to place the iaf leg in NM.
     * @param name is the optional name for the approach.
     * @param finalLegIdent is the optional name for the faf leg.
     * @param initialLegIdent is the optional name for the iaf leg.
     * @returns an approach procedure.
     */
    static buildVisualApproach(airport, runway, finalLegDistance, initialLegDistance, name, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    finalLegIdent, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    initialLegIdent) {
        const iafLatLon = FmsUtils.tempGeoPoint
            .set(runway.latitude, runway.longitude)
            .offset(NavMath.normalizeHeading(runway.course + 180), UnitType.NMILE.convertTo(initialLegDistance + finalLegDistance, UnitType.GA_RADIAN));
        const runwayCode = RunwayUtils.getRunwayCode(parseInt(runway.designation.substr(2)));
        const runwayLetter = isNaN(parseInt(runway.designation.substr(-1))) ? runway.designation.substr(-1) : ' ';
        if (initialLegIdent === undefined) {
            initialLegIdent = 'STRGHT';
        }
        const iafLeg = FlightPlan.createLeg({
            type: LegType.IF,
            fixIcao: `S${ICAO.getIdent(airport.icao).padStart(4, ' ')}${runwayCode}${runwayLetter}${initialLegIdent}`,
            course: runway.course,
            fixTypeFlags: FixTypeFlags.IAF,
            lat: iafLatLon.lat,
            lon: iafLatLon.lon,
        });
        const fafLatLon = FmsUtils.tempGeoPoint
            .set(runway.latitude, runway.longitude)
            .offset(NavMath.normalizeHeading(runway.course + 180), UnitType.NMILE.convertTo(finalLegDistance, UnitType.GA_RADIAN));
        if (finalLegIdent === undefined) {
            finalLegIdent = ' FINAL';
        }
        const fafLeg = FlightPlan.createLeg({
            type: LegType.TF,
            fixIcao: `S${ICAO.getIdent(airport.icao).padStart(4, ' ')}${runwayCode}${runwayLetter}${finalLegIdent}`,
            course: runway.course,
            fixTypeFlags: FixTypeFlags.FAF,
            lat: fafLatLon.lat,
            lon: fafLatLon.lon,
            altDesc: AltitudeRestrictionType.AtOrAbove,
            altitude1: runway.elevation + 110,
        });
        const runwayLeg = FmsUtils.buildRunwayLeg(airport, runway, false);
        runwayLeg.fixTypeFlags = FixTypeFlags.MAP;
        const finalLegs = [];
        finalLegs.push(iafLeg);
        finalLegs.push(fafLeg);
        finalLegs.push(runwayLeg);
        const missedLegLatLon = FmsUtils.tempGeoPoint
            .set(runway.latitude, runway.longitude)
            .offset(NavMath.normalizeHeading(runway.course), UnitType.NMILE.convertTo(5, UnitType.GA_RADIAN));
        const missedLeg = FlightPlan.createLeg({
            type: LegType.TF,
            fixIcao: `S${ICAO.getIdent(airport.icao).padStart(4, ' ')}${runwayCode}${runwayLetter}MANSEQ`,
            lat: missedLegLatLon.lat,
            lon: missedLegLatLon.lon,
        });
        const missedLegs = [];
        missedLegs.push(missedLeg);
        const proc = {
            name: name !== null && name !== void 0 ? name : `Visual RW${runway.designation}`,
            runway: runway.designation,
            icaos: [],
            transitions: [],
            finalLegs: finalLegs,
            missedLegs: missedLegs,
            approachType: AdditionalApproachType.APPROACH_TYPE_VISUAL,
            approachSuffix: '',
            runwayDesignator: runway.runwayDesignator,
            runwayNumber: runway.direction,
            rnavTypeFlags: RnavTypeFlags.None
        };
        return proc;
    }
    /**
     * Utility method to return all offset transitions from a transition.
     * @param approach is the facility approach
     * @param transitionIndex is the transition index to search.
     * @returns an array of TransitionListItems
     */
    static getOffsetTransitions(approach, transitionIndex) {
        const outputTransitions = [];
        const transition = approach.transitions[transitionIndex];
        outputTransitions.push({ name: ICAO.getIdent(transition.legs[0].fixIcao), transitionIndex: transitionIndex });
        for (let j = 1; j < transition.legs.length; j++) {
            const leg = transition.legs[j];
            if (leg.fixTypeFlags === FixTypeFlags.IAF) {
                const offsetTrans = { name: ICAO.getIdent(leg.fixIcao) + ' iaf', transitionIndex: transitionIndex, startIndex: j };
                outputTransitions.push(offsetTrans);
            }
        }
        return outputTransitions;
    }
    /**
     * Utility method to return a single RnavTypeFlag from multiple possible flags.
     * @param rnavTypeFlags The input RnavTypeFlags.
     * @returns A single RnavTypeFlag
     */
    static getBestRnavType(rnavTypeFlags) {
        if (rnavTypeFlags & RnavTypeFlags.LPV) {
            return RnavTypeFlags.LPV;
        }
        if (rnavTypeFlags & RnavTypeFlags.LNAVVNAV) {
            return RnavTypeFlags.LNAVVNAV;
        }
        if (rnavTypeFlags & RnavTypeFlags.LP) {
            return RnavTypeFlags.LP;
        }
        if (rnavTypeFlags & RnavTypeFlags.LNAV) {
            return RnavTypeFlags.LNAV;
        }
        return RnavTypeFlags.None;
    }
    /**
     * Utility method to check whether an approach is authorized for GPS guidance.
     * @param approach The approach procedure
     * @returns True if GPS guidance is authorized, false otherwise.
     */
    static isGpsApproach(approach) {
        switch (approach.approachType) {
            case ApproachType.APPROACH_TYPE_GPS:
            case ApproachType.APPROACH_TYPE_RNAV:
                return true;
        }
        return false;
    }
    /**
     * Utility method to check for an approach with a a tunable localizer.
     * @param approach The approach procedure
     * @returns True if a localizer needs to be tuned, otherwise false.
     */
    static isLocalizerApproach(approach) {
        switch (approach.approachType) {
            case ApproachType.APPROACH_TYPE_ILS:
            case ApproachType.APPROACH_TYPE_LDA:
            case ApproachType.APPROACH_TYPE_LOCALIZER:
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
            case ApproachType.APPROACH_TYPE_SDF:
                return true;
        }
        return false;
    }
    /**
     * Gets an approach procedure from a flight plan.
     * @param plan A flight plan.
     * @param destination The detsination airport of the flight plan.
     * @returns The approach procedure from the flight plan, or undefined if the plan has no approach.
     */
    static getApproachFromPlan(plan, destination) {
        let approach = destination.approaches[plan.procedureDetails.approachIndex];
        if (!approach) {
            const visualRwyDesignation = plan.getUserData('visual_approach');
            if (visualRwyDesignation && plan.destinationAirport) {
                const runway = RunwayUtils.matchOneWayRunwayFromDesignation(destination, visualRwyDesignation);
                if (runway) {
                    approach = {
                        name: `VISUAL ${visualRwyDesignation}`,
                        runway: runway.designation,
                        icaos: [],
                        transitions: [],
                        finalLegs: [],
                        missedLegs: [],
                        approachType: AdditionalApproachType.APPROACH_TYPE_VISUAL,
                        approachSuffix: '',
                        runwayDesignator: runway.runwayDesignator,
                        runwayNumber: runway.direction,
                        rnavTypeFlags: RnavTypeFlags.None
                    };
                }
            }
        }
        return approach;
    }
    /**
     * Gets the name of a departure procedure as a string.
     * @param airport The airport to which the departure belongs.
     * @param departure A departure procedure definition.
     * @param transitionIndex The index of the departure enroute transition.
     * @param runway The runway of the departure, if any.
     * @returns The name of the departure procedure.
     */
    static getDepartureNameAsString(airport, departure, transitionIndex, runway) {
        let name = `${ICAO.getIdent(airport.icao)}–`;
        if (runway) {
            name += `RW${runway.designation}.`;
        }
        const transition = departure.enRouteTransitions[transitionIndex];
        if (transition !== undefined && transitionIndex > -1 && transition.legs.length > 0) {
            name += `${departure.name}.${ICAO.getIdent(transition.legs[transition.legs.length - 1].fixIcao)}`;
        }
        else if (departure.commonLegs.length > 0) {
            name += `${departure.name}.${ICAO.getIdent(departure.commonLegs[departure.commonLegs.length - 1].fixIcao)}`;
        }
        else {
            name += `${departure.name}`;
        }
        return name;
    }
    /**
     * Gets the name of a arrival procedure as a string.
     * @param airport The airport to which the departure belongs.
     * @param arrival An arrival procedure definition.
     * @param transitionIndex The index of the arrival enroute transition.
     * @param runway The runway of the arrival, if any.
     * @returns The name of the arrival procedure.
     */
    static getArrivalNameAsString(airport, arrival, transitionIndex, runway) {
        let name = `${ICAO.getIdent(airport.icao)}–`;
        const transition = arrival.enRouteTransitions[transitionIndex];
        if (transition !== undefined && transitionIndex > -1 && transition.legs.length > 0) {
            name += `${ICAO.getIdent(transition.legs[0].fixIcao)}.${arrival === null || arrival === void 0 ? void 0 : arrival.name}`;
        }
        else if (arrival.commonLegs.length > 0) {
            name += `${ICAO.getIdent(arrival.commonLegs[0].fixIcao)}.${arrival === null || arrival === void 0 ? void 0 : arrival.name}`;
        }
        else {
            name += `${arrival === null || arrival === void 0 ? void 0 : arrival.name}`;
        }
        if (runway) {
            name += `.RW${runway.designation}`;
        }
        return name;
    }
    /**
     * Utility method to analyze an approach for its name components and
     * pack them into a custom type.
     * @param proc The approach procedure.
     * @returns The name as an ApproachNameParts
     */
    static getApproachNameAsParts(proc) {
        let type;
        let subtype;
        let rnavType;
        switch (proc.approachType) {
            case ApproachType.APPROACH_TYPE_GPS:
                type = 'GPS';
                break;
            case ApproachType.APPROACH_TYPE_VOR:
                type = 'VOR';
                break;
            case ApproachType.APPROACH_TYPE_NDB:
                type = 'NDB';
                break;
            case ApproachType.APPROACH_TYPE_ILS:
                type = 'ILS';
                break;
            case ApproachType.APPROACH_TYPE_LOCALIZER:
                type = 'LOC';
                break;
            case ApproachType.APPROACH_TYPE_SDF:
                type = 'SDF';
                break;
            case ApproachType.APPROACH_TYPE_LDA:
                type = 'LDA';
                break;
            case ApproachType.APPROACH_TYPE_VORDME:
                type = 'VOR/DME';
                break;
            case ApproachType.APPROACH_TYPE_NDBDME:
                type = 'NDB/DME';
                break;
            case ApproachType.APPROACH_TYPE_RNAV:
                type = 'RNAV';
                subtype = 'GPS';
                break;
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
                type = 'LOC BC';
                break;
            case AdditionalApproachType.APPROACH_TYPE_VISUAL:
                type = 'VISUAL';
                break;
            default:
                type = '???';
                break;
        }
        if (proc.approachType === ApproachType.APPROACH_TYPE_RNAV) {
            switch (FmsUtils.getBestRnavType(proc.rnavTypeFlags)) {
                case RnavTypeFlags.LNAV:
                    rnavType = 'LNAV+V';
                    break;
                case RnavTypeFlags.LP:
                    rnavType = 'LP+V';
                    break;
                case RnavTypeFlags.LNAVVNAV:
                    rnavType = 'LNAV/VNAV';
                    break;
                case RnavTypeFlags.LPV:
                    rnavType = 'LPV';
                    break;
            }
        }
        return {
            type: type,
            subtype: subtype,
            suffix: proc.approachSuffix ? proc.approachSuffix : undefined,
            runway: proc.runwayNumber === 0 ? undefined : RunwayUtils.getRunwayNameString(proc.runwayNumber, proc.runwayDesignator, true),
            flags: rnavType
        };
    }
    /**
     * Utility method that takes an approach and returns its name as a flat
     * string suitable for use in embedded text content.
     * @param approach The approach as an ApproaceProcedure
     * @returns The formatted name as a string.
     */
    static getApproachNameAsString(approach) {
        const parts = FmsUtils.getApproachNameAsParts(approach);
        let name = parts.type;
        parts.subtype && (name += `${parts.subtype}`);
        parts.suffix && (name += `${parts.runway ? ' ' : '–'}${parts.suffix}`);
        parts.runway && (name += ` ${parts.runway}`);
        parts.flags && (name += ` ${parts.flags}`);
        return name;
    }
    /**
     * Gets an approach frequency from the facility record.
     * @param facility The airport facility.
     * @param approachIndex The approach Index.
     * @returns The FacilityFrequency or undefined
     */
    static getApproachFrequency(facility, approachIndex) {
        const approach = facility === null || facility === void 0 ? void 0 : facility.approaches[approachIndex !== null && approachIndex !== void 0 ? approachIndex : -1];
        if (approach && (approach.approachType === ApproachType.APPROACH_TYPE_ILS
            || approach.approachType === ApproachType.APPROACH_TYPE_LOCALIZER
            || approach.approachType === ApproachType.APPROACH_TYPE_LDA
            || approach.approachType === ApproachType.APPROACH_TYPE_SDF)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const freq = RunwayUtils.getLocFrequency(facility, approach.runway);
            return freq;
        }
        else {
            return undefined;
        }
    }
}
FmsUtils.tempGeoPoint = new GeoPoint(0, 0);

var DirectToState;
(function (DirectToState) {
    DirectToState[DirectToState["NONE"] = 0] = "NONE";
    DirectToState[DirectToState["TOEXISTING"] = 1] = "TOEXISTING";
    DirectToState[DirectToState["TORANDOM"] = 2] = "TORANDOM";
})(DirectToState || (DirectToState = {}));
var ProcedureType;
(function (ProcedureType) {
    ProcedureType[ProcedureType["DEPARTURE"] = 0] = "DEPARTURE";
    ProcedureType[ProcedureType["ARRIVAL"] = 1] = "ARRIVAL";
    ProcedureType[ProcedureType["APPROACH"] = 2] = "APPROACH";
    ProcedureType[ProcedureType["VISUALAPPROACH"] = 3] = "VISUALAPPROACH";
})(ProcedureType || (ProcedureType = {}));
var AirwayLegType;
(function (AirwayLegType) {
    AirwayLegType[AirwayLegType["NONE"] = 0] = "NONE";
    AirwayLegType[AirwayLegType["ENTRY"] = 1] = "ENTRY";
    AirwayLegType[AirwayLegType["EXIT"] = 2] = "EXIT";
    AirwayLegType[AirwayLegType["ONROUTE"] = 3] = "ONROUTE";
    AirwayLegType[AirwayLegType["EXIT_ENTRY"] = 4] = "EXIT_ENTRY";
})(AirwayLegType || (AirwayLegType = {}));
/**
 * A fms menu system tracker.
 */
class Fms {
    /**
     * Initialize an instance of the FMS.
     * @param bus is the event bus
     * @param flightPlanner is the flight planner
     * @param viewService the popout menu service
     * @param g1000EvtPub is the G1000 Control Publisher
     * @param autopilot is the optional autopilot.
     */
    constructor(bus, flightPlanner, viewService, g1000EvtPub, autopilot) {
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.autopilot = autopilot;
        this.ppos = new GeoPoint(0, 0);
        this.facRepo = FacilityRespository.getRepository(this.bus);
        this.facLoader = new FacilityLoader(this.facRepo);
        this.calculator = new FlightPathCalculator(this.facLoader, { defaultClimbRate: 300, defaultSpeed: 85, bankAngle: 15 });
        this.approachDetails = {
            approachLoaded: false,
            approachType: ApproachType.APPROACH_TYPE_UNKNOWN,
            approachRnavType: RnavTypeFlags.None,
            approachIsActive: false
        };
        this.approachFrequency = Subject.create(undefined);
        this._lastApproachFrequencyEventValue = undefined;
        this.cdiSource = { type: NavSourceType.Gps, index: 1 };
        this.missedApproachActive = false;
        /**
         * Sets the approach details when an approach_details_set event is received from the bus.
         * @param approachDetails The approachDetails received from the bus.
         */
        this.onApproachDetailsSet = (approachDetails) => {
            if (approachDetails !== this.approachDetails) {
                this.approachDetails = approachDetails;
            }
        };
        if (viewService) {
            Fms.viewService = viewService;
        }
        if (g1000EvtPub) {
            Fms.g1000EvtPub = g1000EvtPub;
        }
        this.bus.getSubscriber().on('gps-position').atFrequency(1).handle(pos => this.ppos.set(pos.lat, pos.long));
        this.bus.getSubscriber().on('cdi_select').handle(source => this.cdiSource = source);
        const planEvents = this.bus.getSubscriber();
        planEvents.on('fplActiveLegChange').handle(data => this.onActiveLegChanged(data.type, data.planIndex));
        planEvents.on('fplLoaded').handle(() => this.checkApproachState());
        this.approachFrequency.sub((v) => {
            if (v !== this._lastApproachFrequencyEventValue) {
                g1000EvtPub.publishEvent('approach_freq_set', v);
            }
        });
        const g1000Events = this.bus.getSubscriber();
        g1000Events.on('approach_freq_set').handle((v) => {
            this._lastApproachFrequencyEventValue = v;
            this.approachFrequency.set(v);
        });
        g1000Events.on('activate_missed_approach').handle(v => {
            this.missedApproachActive = v;
            if (this.missedApproachActive) {
                Fms.g1000EvtPub.publishEvent('suspend', false);
                this.setApproachDetails(undefined, undefined, undefined, false);
            }
        });
        g1000Events.on('approach_details_set').handle(this.onApproachDetailsSet);
    }
    /**
     * Initializes the primary flight plan. Does nothing if the primary flight plan already exists.
     */
    async initPrimaryFlightPlan() {
        if (this.flightPlanner.hasFlightPlan(Fms.PRIMARY_PLAN_INDEX)) {
            return;
        }
        this.flightPlanner.createFlightPlan(Fms.PRIMARY_PLAN_INDEX);
        await this.emptyPrimaryFlightPlan();
    }
    /**
     * Gets a specified flightplan, or by default the primary flight plan.
     * @param index The index of the flight plan.
     * @returns the requested flight plan
     * @throws Error if no flight plan exists at the specified index.
     */
    getFlightPlan(index = Fms.PRIMARY_PLAN_INDEX) {
        return this.flightPlanner.getFlightPlan(index);
    }
    /**
     * Checks whether the primary flight plan exists.
     * @returns Whether the primary flight plan exists.
     */
    hasPrimaryFlightPlan() {
        return this.flightPlanner.hasFlightPlan(Fms.PRIMARY_PLAN_INDEX);
    }
    /**
     * Gets the primary flight plan.
     * @returns The primary flight plan.
     * @throws Error if the primary flight plan does not exist.
     */
    getPrimaryFlightPlan() {
        return this.flightPlanner.getFlightPlan(Fms.PRIMARY_PLAN_INDEX);
    }
    /**
     * Checks whether the Direct To Random flight plan exists.
     * @returns Whether the Direct To Random flight plan exists.
     */
    hasDirectToFlightPlan() {
        return this.flightPlanner.hasFlightPlan(Fms.DTO_RANDOM_PLAN_INDEX);
    }
    /**
     * Gets the Direct To Random flight plan.
     * @returns The Direct To Random flight plan.
     * @throws Error if the Direct To Random flight plan does not exist.
     */
    getDirectToFlightPlan() {
        return this.flightPlanner.getFlightPlan(Fms.DTO_RANDOM_PLAN_INDEX);
    }
    /**
     * Gets the procedure preview flight plan.
     * @returns The procedure preview flight plan.
     * @throws Error if the procedure preview flight plan does not exist.
     */
    getProcPreviewFlightPlan() {
        return this.flightPlanner.getFlightPlan(Fms.PROC_PREVIEW_PLAN_INDEX);
    }
    /**
     * Handles when a flight plan active leg changes.
     * @param legType The type of flight plan active leg change.
     * @param planIndex The index of the plan whose active leg changed.
     */
    onActiveLegChanged(legType, planIndex) {
        if (legType === ActiveLegType.Lateral && planIndex === 0) {
            const activePlan = this.flightPlanner.getActiveFlightPlan();
            if (activePlan.length > 0 && !this.missedApproachActive) {
                const activeSegment = activePlan.getSegment(activePlan.getSegmentIndex(Math.max(0, activePlan.activeLateralLeg)));
                if (activeSegment.segmentType === FlightPlanSegmentType.Approach && activePlan.activeLateralLeg - activeSegment.offset > 0) {
                    this.setApproachDetails(undefined, undefined, undefined, true);
                }
                else {
                    this.setApproachDetails(undefined, undefined, undefined, false);
                }
            }
            else {
                this.setApproachDetails(undefined, undefined, undefined, false);
            }
            if (!this.missedApproachActive && activePlan.activeLateralLeg < activePlan.length - 1 && activePlan.getLeg(activePlan.activeLateralLeg).isInMissedApproachSequence) {
                Fms.g1000EvtPub.publishEvent('activate_missed_approach', true);
            }
        }
    }
    /**
     * A method to check the current approach state.
     */
    async checkApproachState() {
        const plan = this.getFlightPlan();
        let approachLoaded = false;
        let approachIsActive = false;
        let approachType;
        let approachRnavType;
        if (plan.destinationAirport && (plan.procedureDetails.approachIndex > -1 || plan.getUserData('visual_approach') !== undefined)) {
            approachLoaded = true;
            if (plan.length > 0 && plan.activeLateralLeg < plan.length && plan.activeLateralLeg > 0) {
                const segment = plan.getSegment(plan.getSegmentIndex(plan.activeLateralLeg));
                approachIsActive = segment.segmentType === FlightPlanSegmentType.Approach;
            }
            if (plan.procedureDetails.approachIndex > -1) {
                const facility = await this.facLoader.getFacility(FacilityType.Airport, plan.destinationAirport);
                const approach = facility.approaches[plan.procedureDetails.approachIndex];
                if (approach) {
                    approachType = approach.approachType;
                    approachRnavType = FmsUtils.getBestRnavType(approach.rnavTypeFlags);
                }
            }
            else {
                approachType = AdditionalApproachType.APPROACH_TYPE_VISUAL;
                approachRnavType = RnavTypeFlags.None;
            }
        }
        this.setApproachDetails(approachLoaded, approachType, approachRnavType, approachIsActive);
    }
    /**
     * Removes the direct to existing legs from the primary flight plan. If a direct to existing is currently active,
     * this will effectively cancel it.
     * @param lateralLegIndex The index of the leg to set as the active lateral leg after the removal operation. Defaults
     * to the index of the current active primary flight plan leg.
     */
    removeDirectToExisting(lateralLegIndex) {
        const plan = this.getFlightPlan();
        const directToData = plan.directToData;
        if (directToData && directToData.segmentIndex > -1) {
            plan.removeLeg(directToData.segmentIndex, directToData.segmentLegIndex + 1, true);
            plan.removeLeg(directToData.segmentIndex, directToData.segmentLegIndex + 1, true);
            plan.removeLeg(directToData.segmentIndex, directToData.segmentLegIndex + 1, true);
            const activateIndex = lateralLegIndex !== null && lateralLegIndex !== void 0 ? lateralLegIndex : plan.activeLateralLeg;
            const adjustedActivateIndex = activateIndex - Utils.Clamp(activateIndex - (plan.getSegment(directToData.segmentIndex).offset + directToData.segmentLegIndex), 0, 3);
            plan.setDirectToData(-1, true);
            plan.setLateralLeg(adjustedActivateIndex);
            plan.calculate(Math.min(0, plan.activeLateralLeg));
        }
    }
    /**
     * Checks whether a leg in the primary flight plan is a valid direct to target.
     * @param segmentIndex The index of the segment in which the leg resides.
     * @param segmentLegIndex The index of the leg in its segment.
     * @returns Whether the leg is a valid direct to target.
     */
    canDirectTo(segmentIndex, segmentLegIndex) {
        const plan = this.getFlightPlan();
        const segment = plan.getSegment(segmentIndex);
        const leg = segment.legs[segmentLegIndex];
        if (leg.leg.fixIcao === '' || leg.leg.fixIcao === ICAO.emptyIcao) {
            return false;
        }
        switch (leg.leg.type) {
            case LegType.IF:
            case LegType.TF:
            case LegType.DF:
            case LegType.CF:
            case LegType.AF:
            case LegType.RF:
                return true;
        }
        return false;
    }
    /**
     * Gets the current Direct To State.
     * @returns the DirectToState.
     */
    getDirectToState() {
        if (this.flightPlanner.activePlanIndex == 1 && this.getFlightPlan(1).getSegment(0).segmentType === FlightPlanSegmentType.RandomDirectTo) {
            return DirectToState.TORANDOM;
        }
        else {
            const plan = this.getFlightPlan();
            const directDataExists = plan.directToData.segmentIndex > -1 && plan.directToData.segmentLegIndex > -1;
            if (directDataExists && plan.segmentCount >= plan.directToData.segmentIndex
                && plan.getLegIndexFromLeg(plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex]) === plan.activeLateralLeg - 3) {
                return DirectToState.TOEXISTING;
            }
        }
        return DirectToState.NONE;
    }
    /**
     * Gets the ICAO string of the current Direct To target.
     * @returns The ICAO string of the current Direct To target, or undefined if Direct To is not active.
     */
    getDirectToTargetIcao() {
        var _a;
        return (_a = this.getDirectToLeg()) === null || _a === void 0 ? void 0 : _a.fixIcao;
    }
    /**
     * Gets the current DTO Target Flight Plan Leg.
     * @returns the FlightPlanLeg.
     */
    getDirectToLeg() {
        switch (this.getDirectToState()) {
            case DirectToState.TORANDOM: {
                const plan = this.getDirectToFlightPlan();
                return plan.getSegment(0).legs[2].leg;
            }
            case DirectToState.TOEXISTING: {
                const plan = this.getFlightPlan();
                return plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex + 3].leg;
            }
        }
        return undefined;
    }
    /**
     * Checks if a segment is the first enroute segment that is not an airway.
     * @param segmentIndex is the segment index of the segment to check
     * @returns whether or not the segment is the first enroute segment that is not an airway.
     */
    isFirstEnrouteSegment(segmentIndex) {
        const plan = this.getFlightPlan();
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            if (segment.segmentType === FlightPlanSegmentType.Enroute && !segment.airway) {
                return i === segmentIndex;
            }
        }
        return false;
    }
    /**
     * Adds a user facility.
     * @param userFacility the facility to add.
     */
    addUserFacility(userFacility) {
        this.facRepo.add(userFacility);
    }
    /**
     * Removes a user facility.
     * @param userFacility the facility to remove.
     */
    removeUserFacility(userFacility) {
        this.facRepo.remove(userFacility);
    }
    /**
     * Adds a visual or runway facility from the FlightPlanLeg.
     * @param leg the leg to build the facility from.
     * @param visualRunwayDesignation is the visual runway this facility belongs to.
     */
    addVisualFacilityFromLeg(leg, visualRunwayDesignation) {
        const fac = {
            icao: leg.fixIcao,
            lat: leg.lat !== undefined ? leg.lat : 0,
            lon: leg.lon !== undefined ? leg.lon : 0,
            approach: `VISUAL ${visualRunwayDesignation}`,
            city: '',
            name: `${visualRunwayDesignation} - ${ICAO.getIdent(leg.fixIcao)}`,
            region: '',
            magvar: 0
        };
        this.facRepo.add(fac);
    }
    /**
     * Method to insert a waypoint to the flightplan.
     * @param segmentIndex is index of the segment to add the waypoint to
     * @param facility is the new facility to add a leg to.
     * @param legIndex is the index to insert the waypoint (if none, append)
     * @returns whether the waypoint was successfully inserted.
     */
    insertWaypoint(segmentIndex, facility, legIndex) {
        var _a;
        const leg = FlightPlan.createLeg({
            type: LegType.TF,
            fixIcao: facility.icao
        });
        const plan = this.getFlightPlan();
        const segment = plan.getSegment(segmentIndex);
        const prevLeg = plan.getPrevLeg(segmentIndex, legIndex !== null && legIndex !== void 0 ? legIndex : Infinity);
        const nextLeg = plan.getNextLeg(segmentIndex, legIndex === undefined ? Infinity : legIndex - 1);
        // Make sure we are not inserting a duplicate leg
        if ((prevLeg && this.isDuplicateLeg(prevLeg.leg, leg)) || (nextLeg && this.isDuplicateLeg(leg, nextLeg.leg))) {
            return false;
        }
        // Deal with whether this insert is in an airway segment
        if (segment.airway) {
            //check to see if this insert will leave more than 1 airway leg
            if (!legIndex || segment.legs.length - legIndex < 3) {
                // we don't need another airway segment,
                // we just need to add the inserted segment, the remaining airway segments into the next enroute segment
                const nextSegment = plan.getSegment(segmentIndex + 1);
                if (nextSegment.airway || nextSegment.segmentType !== FlightPlanSegmentType.Enroute) {
                    //the next segment is an airway, arrival, approach or destination, so we need to add an enroute segment
                    this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                }
                //now we can add the new leg into the next enroute segment
                this.planAddLeg(segmentIndex + 1, leg);
                //get the legs after the insert index from the first airway segment, if any, and move them to the second airway segment
                legIndex = legIndex ? legIndex : segment.legs.length - 1;
                const legsToMove = [];
                const legsLength = segment.legs.length;
                for (let i = legIndex; i < legsLength; i++) {
                    legsToMove.push(segment.legs[i].leg);
                }
                for (let j = legsLength - 1; j >= legIndex; j--) {
                    this.planRemoveLeg(segmentIndex, j, true, true);
                }
                for (let k = 0; k < legsToMove.length; k++) {
                    this.planAddLeg(segmentIndex + 1, legsToMove[k]);
                }
            }
            else {
                //we need to create a new airway segment
                //split the segment into three
                this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                const newAirwaySegment = plan.getSegment(segmentIndex + 2);
                //add the leg to the new enroute segment (between the old and new airway segments)
                this.planAddLeg(segmentIndex + 1, leg);
                //get the legs after the insert index from the first airway segment, if any, and move them to the second airway segment
                legIndex = legIndex ? legIndex : segment.legs.length - 1;
                const legsToMove = [];
                const legsLength = segment.legs.length;
                for (let i = legIndex; i < legsLength; i++) {
                    legsToMove.push(segment.legs[i].leg);
                }
                for (let j = legsLength - 1; j >= legIndex; j--) {
                    this.planRemoveLeg(segmentIndex, j, true, true);
                }
                this.planAddLeg(segmentIndex + 1, legsToMove[0]);
                for (let k = 1; k < legsToMove.length; k++) {
                    this.planAddLeg(segmentIndex + 2, legsToMove[k]);
                }
                const airway = (_a = segment.airway) === null || _a === void 0 ? void 0 : _a.split('.');
                segment.airway = airway && airway[0] ? airway[0] + '.' + segment.legs[legIndex - 1].name : segment.airway;
                plan.setAirway(segmentIndex, segment.airway);
                newAirwaySegment.airway = airway && airway[0] ? airway[0] + '.' + newAirwaySegment.legs[newAirwaySegment.legs.length - 1].name : segment.airway;
                plan.setAirway(segmentIndex + 2, newAirwaySegment.airway);
            }
            return true;
        }
        this.planAddLeg(segmentIndex, leg, legIndex);
        return true;
    }
    /**
     * Method to delete a waypoint from the flightplan.
     * @param segmentIndex is the index of the segment containing the leg to delete.
     * @param legIndex is the index of the leg to delete in the segment.
     * @returns whether the waypoint was successfully deleted.
     */
    deleteWaypoint(segmentIndex, legIndex) {
        return this.planRemoveLeg(segmentIndex, legIndex);
    }
    /**
     * Gets the airway leg type of a flight plan leg.
     * @param plan The flight plan containing the query leg.
     * @param segmentIndex The index of the flight plan segment containing the query leg.
     * @param segmentLegIndex The index of the query leg in its segment.
     * @returns The airway leg type of the query leg.
     */
    getAirwayLegType(plan, segmentIndex, segmentLegIndex) {
        const segment = plan.getSegment(segmentIndex);
        const segmentIsAirway = segment.airway !== undefined;
        const nextSegmentIsAirway = segmentIndex + 1 < plan.segmentCount && plan.getSegment(segmentIndex + 1).airway !== undefined;
        const legIsLast = segmentLegIndex == segment.legs.length - 1;
        if ((segmentIsAirway && legIsLast && nextSegmentIsAirway)) {
            return AirwayLegType.EXIT_ENTRY;
        }
        if ((legIsLast && nextSegmentIsAirway)) {
            return AirwayLegType.ENTRY;
        }
        if (segmentIsAirway) {
            if (legIsLast) {
                return AirwayLegType.EXIT;
            }
            return AirwayLegType.ONROUTE;
        }
        return AirwayLegType.NONE;
    }
    /**
     * Method to get the distance of an airway segment.
     * @param segmentIndex is the index of the segment of the airway.
     * @returns the cumulative distance for the airway segment.
     */
    getAirwayDistance(segmentIndex) {
        var _a, _b, _c, _d;
        const plan = this.getFlightPlan();
        const segment = plan.getSegment(segmentIndex);
        const entrySegment = plan.getSegment(segmentIndex - 1);
        const entryCumulativeDistance = (_b = (_a = entrySegment.legs[entrySegment.legs.length - 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistance;
        const exitCumulativeDistance = (_d = (_c = segment.legs[segment.legs.length - 1]) === null || _c === void 0 ? void 0 : _c.calculated) === null || _d === void 0 ? void 0 : _d.cumulativeDistance;
        return exitCumulativeDistance && entryCumulativeDistance ? exitCumulativeDistance - entryCumulativeDistance : -1;
    }
    /**
     * Method to add a new origin airport and runway to the flight plan.
     * @param airport is the facility of the origin airport.
     * @param runway is the onewayrunway
     */
    setOrigin(airport, runway) {
        const plan = this.getFlightPlan();
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Departure);
        if (airport) {
            plan.setOriginAirport(airport.icao);
            plan.setOriginRunway(runway);
            this.planClearSegment(segmentIndex, FlightPlanSegmentType.Departure);
            this.planAddOriginDestinationLeg(true, segmentIndex, airport, runway);
            const prevLeg = plan.getPrevLeg(segmentIndex, 1);
            const nextLeg = plan.getNextLeg(segmentIndex, 0);
            if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
                this.planRemoveDuplicateLeg(prevLeg, nextLeg);
            }
        }
        else {
            plan.removeOriginAirport();
            this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, RnavTypeFlags.None, false);
            this.planClearSegment(segmentIndex, FlightPlanSegmentType.Departure);
        }
        plan.calculate(0);
    }
    /**
     * Method to add a new destination airport and runway to the flight plan.
     * @param airport is the facility of the destination airport.
     * @param runway is the selected runway at the destination facility.
     */
    setDestination(airport, runway) {
        const plan = this.getFlightPlan();
        const destSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Destination);
        if (airport) {
            plan.setDestinationAirport(airport.icao);
            plan.setDestinationRunway(runway);
            this.planClearSegment(destSegmentIndex, FlightPlanSegmentType.Destination);
            const hasArrival = plan.procedureDetails.arrivalIndex > -1;
            const hasApproach = plan.procedureDetails.approachIndex > -1;
            if (!hasArrival && !hasApproach) {
                this.planAddOriginDestinationLeg(false, destSegmentIndex, airport, runway);
            }
        }
        else {
            plan.removeDestinationAirport();
            this.planClearSegment(destSegmentIndex, FlightPlanSegmentType.Destination);
        }
        plan.calculate(0);
    }
    /**
     * Method to remove runway or airport legs from segments where they shouldn't exist.
     */
    removeDestLegFromSegments() {
        const plan = this.getFlightPlan();
        const destination = plan.destinationAirport;
        const hasArrival = plan.procedureDetails.arrivalIndex > -1;
        const hasApproach = plan.procedureDetails.approachIndex > -1 || plan.getUserData('visual_approach');
        const destinationSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Destination);
        const destinationSegment = plan.getSegment(destinationSegmentIndex);
        if (hasApproach && destination) {
            if (hasArrival) {
                const arrivalSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Arrival);
                const arrival = plan.getSegment(arrivalSegmentIndex);
                const lastArrivalLegIcao = arrival.legs[arrival.legs.length - 1].leg.fixIcao;
                if (lastArrivalLegIcao === destination || lastArrivalLegIcao.search('R') === 0) {
                    this.planRemoveLeg(arrivalSegmentIndex, arrival.legs.length - 1);
                }
            }
            if (destinationSegment.legs.length > 0) {
                this.planClearSegment(destinationSegmentIndex, FlightPlanSegmentType.Destination);
            }
        }
        else if (hasArrival && destination) {
            if (destinationSegment.legs.length > 0) {
                this.planClearSegment(destinationSegmentIndex, FlightPlanSegmentType.Destination);
            }
        }
    }
    /**
     * Method to ensure only one segment of a specific type exists in the flight plan and optionally insert it if needed.
     * @param segmentType is the segment type we want to evaluate.
     * @param insert is whether to insert the segment if missing
     * @returns segmentIndex of the only segment of this type in the flight plan.
     */
    ensureOnlyOneSegmentOfType(segmentType, insert = true) {
        const plan = this.getFlightPlan();
        let segmentIndex;
        const selectedSegments = plan.segmentsOfType(segmentType);
        const segmentIndexArray = [];
        for (const element of selectedSegments) {
            segmentIndexArray.push(element.segmentIndex);
        }
        if (segmentIndexArray.length === 0) {
            if (insert) {
                segmentIndex = this.planInsertSegmentOfType(segmentType);
            }
            else {
                segmentIndex = -1;
            }
        }
        else if (segmentIndexArray.length > 1) {
            for (let i = 0; i < segmentIndexArray.length; i++) {
                this.planRemoveSegment(segmentIndexArray[i]);
            }
            segmentIndex = this.planInsertSegmentOfType(segmentType);
        }
        else {
            segmentIndex = segmentIndexArray[0];
        }
        return segmentIndex;
    }
    /**
     * Method to invert the flightplan.
     */
    invertFlightplan() {
        var _a;
        const plan = this.getFlightPlan();
        const activeLegIcao = plan.getLeg(plan.activeLateralLeg).leg.fixIcao;
        if (plan.directToData.segmentIndex >= 0 && plan.directToData.segmentLegIndex >= 0) {
            this.removeDirectToExisting();
        }
        if (!Simplane.getIsGrounded() && activeLegIcao) {
            this.buildRandomDirectTo(activeLegIcao);
        }
        const newOriginIcao = plan.destinationAirport;
        const newDestinationIcao = plan.originAirport;
        const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
        if (lastEnrouteSegmentIndex === 1 && plan.getSegment(1).legs.length > 0) {
            //case for when there is only 1 enroute segment and it has at least 1 waypoint, a simple reversal is all that's required.
            const segment = Object.assign({}, plan.getSegment(1));
            this.emptyPrimaryFlightPlan();
            for (let l = segment.legs.length - 1; l >= 0; l--) {
                plan.addLeg(1, segment.legs[l].leg);
            }
        }
        else if (lastEnrouteSegmentIndex > 1) {
            //case for when there is more than 1 enroute segment we know we have to deal with airways
            const legs = [];
            for (let i = 1; i <= lastEnrouteSegmentIndex; i++) {
                //create a temporary list of legs that looks like what a flight plan import looks like with ICAO and the airway
                //we fly FROM the leg on.
                const oldSegment = plan.getSegment(i);
                const airway = oldSegment.airway ? (_a = oldSegment.airway) === null || _a === void 0 ? void 0 : _a.split('.')[0] : undefined;
                for (const leg of oldSegment.legs) {
                    const legListItem = { icao: leg.leg.fixIcao, airway: airway };
                    legs.push(legListItem);
                }
            }
            //after the array of legs is complete, we just reverse it
            legs.reverse();
            this.emptyPrimaryFlightPlan();
            let currentSegment = 1;
            let lastLegWasAirway = false;
            //last we go through each leg and use the same logic we use for the flight plan import to go through each leg and create airway
            //segments as appropriate for these legs.
            for (let i = 0; i < legs.length; i++) {
                const wpt = legs[i];
                const segment = plan.getSegment(currentSegment);
                if (wpt.airway) {
                    const leg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: wpt.icao
                    });
                    plan.addLeg(currentSegment, leg);
                    if (!lastLegWasAirway) {
                        plan.insertSegment(currentSegment + 1, FlightPlanSegmentType.Enroute, wpt.airway);
                        currentSegment += 1;
                    }
                    for (let j = i + 1; j < legs.length; j++) {
                        i++;
                        const airwayLeg = FlightPlan.createLeg({
                            type: LegType.TF,
                            fixIcao: legs[j].icao
                        });
                        plan.addLeg(currentSegment, airwayLeg);
                        if (legs[j].airway !== wpt.airway) {
                            lastLegWasAirway = legs[j].airway ? true : false;
                            break;
                        }
                    }
                    plan.setAirway(currentSegment, wpt.airway + '.' + ICAO.getIdent(legs[i].icao));
                    currentSegment += 1;
                    plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute, lastLegWasAirway ? legs[i].airway : undefined);
                }
                else {
                    let leg = undefined;
                    leg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: wpt.icao
                    });
                    if (leg) {
                        plan.addLeg(currentSegment, leg);
                        if (lastLegWasAirway) {
                            plan.setAirway(currentSegment, segment.airway + '.' + ICAO.getIdent(wpt.icao));
                            currentSegment += 1;
                            plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute);
                        }
                        lastLegWasAirway = false;
                    }
                }
            }
            if (plan.getSegment(currentSegment).airway) {
                currentSegment += 1;
                plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute);
            }
        }
        else {
            this.emptyPrimaryFlightPlan();
        }
        if (newOriginIcao) {
            this.facLoader.getFacility(FacilityType.Airport, newOriginIcao).then((facility) => {
                this.setOrigin(facility);
            });
        }
        if (newDestinationIcao) {
            this.facLoader.getFacility(FacilityType.Airport, newDestinationIcao).then((facility) => {
                this.setDestination(facility);
            });
        }
        this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, RnavTypeFlags.None, false);
        plan.calculate(0);
    }
    /**
     * Method to add or replace a departure procedure in the flight plan.
     * @param facility is the facility that contains the procedure to add.
     * @param departureIndex is the index of the departure
     * @param departureRunwayIndex is the index of the runway transition
     * @param enrouteTransitionIndex is the index of the enroute transition
     * @param oneWayRunway is the one way runway to set as the origin leg.
     */
    insertDeparture(facility, departureIndex, departureRunwayIndex, enrouteTransitionIndex, oneWayRunway) {
        const plan = this.getFlightPlan();
        plan.setDeparture(facility.icao, departureIndex, enrouteTransitionIndex, departureRunwayIndex);
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Departure);
        this.planClearSegment(segmentIndex, FlightPlanSegmentType.Departure);
        const insertProcedureObject = this.buildDepartureLegs(facility, departureIndex, enrouteTransitionIndex, departureRunwayIndex, oneWayRunway);
        if (oneWayRunway) {
            plan.setOriginAirport(facility.icao);
            plan.setOriginRunway(oneWayRunway);
        }
        else if (plan.originAirport == facility.icao && plan.procedureDetails.originRunway) {
            const originLeg = FmsUtils.buildRunwayLeg(facility, plan.procedureDetails.originRunway, true);
            insertProcedureObject.procedureLegs.splice(0, 1, originLeg);
        }
        else {
            plan.setOriginAirport(facility.icao);
        }
        insertProcedureObject.procedureLegs.forEach(l => this.planAddLeg(segmentIndex, l));
        const nextLeg = plan.getNextLeg(segmentIndex, Infinity);
        const depSegment = plan.getSegment(segmentIndex);
        const lastDepLeg = depSegment.legs[depSegment.legs.length - 1];
        if (nextLeg && lastDepLeg && this.isDuplicateLeg(lastDepLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(lastDepLeg, nextLeg);
        }
        plan.calculate(0);
    }
    /**
     * Method to insert the arrival legs.
     * @param facility is the facility to build legs from.
     * @param procedureIndex is the procedure index to build legs from.
     * @param enrouteTransitionIndex is the enroute transition index to build legs from.
     * @param runwayTransitionIndex is the runway transition index to build legs from.
     * @param oneWayRunway is the one way runway, if one is specified in the procedure.
     * @returns InsertProcedureObject to insert into the flight plan.
     */
    buildDepartureLegs(facility, procedureIndex, enrouteTransitionIndex, runwayTransitionIndex, oneWayRunway) {
        const departure = facility.departures[procedureIndex];
        const enRouteTransition = departure.enRouteTransitions[enrouteTransitionIndex];
        const runwayTransition = departure.runwayTransitions[runwayTransitionIndex];
        const insertProcedureObject = { procedureLegs: [] };
        let originLeg;
        if (oneWayRunway) {
            originLeg = FmsUtils.buildRunwayLeg(facility, oneWayRunway, true);
        }
        else {
            originLeg = FlightPlan.createLeg({
                lat: facility.lat,
                lon: facility.lon,
                type: LegType.IF,
                fixIcao: facility.icao
            });
        }
        insertProcedureObject.procedureLegs.push(originLeg);
        if (runwayTransition !== undefined && runwayTransition.legs.length > 0) {
            runwayTransition.legs.forEach((leg) => {
                insertProcedureObject.procedureLegs.push(FlightPlan.createLeg(leg));
            });
        }
        for (let i = 0; i < departure.commonLegs.length; i++) {
            const leg = FlightPlan.createLeg(departure.commonLegs[i]);
            if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                    this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                continue;
            }
            insertProcedureObject.procedureLegs.push(leg);
        }
        if (enRouteTransition) {
            for (let i = 0; i < enRouteTransition.legs.length; i++) {
                const leg = FlightPlan.createLeg(enRouteTransition.legs[i]);
                if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                    this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                    insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                        this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                    continue;
                }
                insertProcedureObject.procedureLegs.push(enRouteTransition.legs[i]);
            }
        }
        return insertProcedureObject;
    }
    /**
     * Method to add or replace an arrival procedure in the flight plan.
     * @param facility is the facility that contains the procedure to add.
     * @param arrivalIndex is the index of the arrival procedure.
     * @param arrivalRunwayTransitionIndex is the index of the arrival runway transition.
     * @param enrouteTransitionIndex is the index of the enroute transition.
     * @param oneWayRunway is the one way runway to set as the destination leg.
     */
    insertArrival(facility, arrivalIndex, arrivalRunwayTransitionIndex, enrouteTransitionIndex, oneWayRunway) {
        const plan = this.getFlightPlan();
        plan.setArrival(facility.icao, arrivalIndex, enrouteTransitionIndex, arrivalRunwayTransitionIndex);
        if (plan.length > 0 && plan.procedureDetails.approachIndex < 0 && plan.destinationAirport) {
            if (!this.moveDirectToDestinationLeg(plan, FlightPlanSegmentType.Enroute)) {
                if (plan.getLeg(plan.activeLateralLeg).leg.fixIcao === plan.destinationAirport && plan.destinationAirport !== facility.icao && plan.activeLateralLeg === plan.length - 1) {
                    const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
                    const newDestinationLeg = FlightPlan.createLeg({ fixIcao: plan.destinationAirport, type: LegType.TF });
                    this.planAddLeg(lastEnrouteSegmentIndex, newDestinationLeg);
                }
            }
        }
        if (plan.procedureDetails.approachIndex < 0) {
            plan.setDestinationAirport(facility.icao);
            plan.setDestinationRunway(oneWayRunway);
        }
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Arrival);
        if (plan.getSegment(segmentIndex).legs.length > 0) {
            this.planClearSegment(segmentIndex, FlightPlanSegmentType.Arrival);
        }
        const insertProcedureObject = this.buildArrivalLegs(facility, arrivalIndex, enrouteTransitionIndex, arrivalRunwayTransitionIndex, oneWayRunway);
        let directTargetLeg;
        let handleDirectToDestination = false;
        const directToState = this.getDirectToState();
        if (plan.procedureDetails.approachIndex > -1) {
            insertProcedureObject.procedureLegs.pop();
        }
        else if (directToState === DirectToState.TOEXISTING) {
            directTargetLeg = this.getDirectToLeg();
            if ((directTargetLeg === null || directTargetLeg === void 0 ? void 0 : directTargetLeg.fixIcao) === plan.destinationAirport &&
                (directTargetLeg === null || directTargetLeg === void 0 ? void 0 : directTargetLeg.fixIcao) === insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1].fixIcao) {
                insertProcedureObject.procedureLegs.pop();
                handleDirectToDestination = true;
            }
        }
        insertProcedureObject.procedureLegs.forEach(l => this.planAddLeg(segmentIndex, l));
        const arrSegment = plan.getSegment(segmentIndex);
        const prevLeg = plan.getPrevLeg(segmentIndex, 0);
        const firstArrLeg = arrSegment.legs[0];
        if (prevLeg && firstArrLeg && this.isDuplicateLeg(prevLeg.leg, firstArrLeg.leg)) {
            this.planRemoveDuplicateLeg(prevLeg, firstArrLeg);
        }
        this.removeDestLegFromSegments();
        const nextLeg = plan.getNextLeg(segmentIndex, Infinity);
        const lastArrLeg = arrSegment.legs[arrSegment.legs.length - 1];
        if (nextLeg && lastArrLeg && this.isDuplicateLeg(lastArrLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(lastArrLeg, nextLeg);
        }
        if (handleDirectToDestination) {
            this.moveDirectToDestinationLeg(plan, FlightPlanSegmentType.Arrival, segmentIndex);
            this.activateLeg(segmentIndex, arrSegment.legs.length - 1);
        }
        else if (directToState === DirectToState.TOEXISTING && directTargetLeg && directTargetLeg.fixIcao === plan.destinationAirport) {
            this.removeDirectToExisting();
            this.buildRandomDirectTo(plan.destinationAirport);
        }
        plan.calculate(0);
    }
    /**
     * Method to insert the arrival legs.
     * @param facility is the facility to build legs from.
     * @param procedureIndex is the procedure index to build legs from.
     * @param enrouteTransitionIndex is the enroute transition index to build legs from.
     * @param runwayTransitionIndex is the runway transition index to build legs from.
     * @param oneWayRunway is the one way runway, if one is specified in the procedure.
     * @returns InsertProcedureObject to insert into the flight plan.
     */
    buildArrivalLegs(facility, procedureIndex, enrouteTransitionIndex, runwayTransitionIndex, oneWayRunway) {
        const arrival = facility.arrivals[procedureIndex];
        const enRouteTransition = arrival.enRouteTransitions[enrouteTransitionIndex];
        const runwayTransition = arrival.runwayTransitions[runwayTransitionIndex];
        const insertProcedureObject = { procedureLegs: [] };
        if (enRouteTransition !== undefined && enRouteTransition.legs.length > 0) {
            enRouteTransition.legs.forEach((leg) => {
                insertProcedureObject.procedureLegs.push(FlightPlan.createLeg(leg));
            });
        }
        for (let i = 0; i < arrival.commonLegs.length; i++) {
            const leg = FlightPlan.createLeg(arrival.commonLegs[i]);
            if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                    this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                continue;
            }
            insertProcedureObject.procedureLegs.push(leg);
        }
        if (runwayTransition) {
            for (let i = 0; i < runwayTransition.legs.length; i++) {
                const leg = FlightPlan.createLeg(runwayTransition.legs[i]);
                if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                    this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                    insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                        this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                    continue;
                }
                insertProcedureObject.procedureLegs.push(leg);
            }
        }
        const destinationLeg = oneWayRunway
            ? FmsUtils.buildRunwayLeg(facility, oneWayRunway, false)
            : FlightPlan.createLeg({
                lat: facility.lat,
                lon: facility.lon,
                type: LegType.TF,
                fixIcao: facility.icao
            });
        insertProcedureObject.procedureLegs.push(destinationLeg);
        this.tryInsertIFLeg(insertProcedureObject);
        return insertProcedureObject;
    }
    /**
     * Method to move a direct to destination to a specified target segment.
     * @param plan is the primary flight plan.
     * @param targetSegmentType is the target segment type.
     * @param arrivalSegmentIndex is the arrival segment index
     * @returns whether a direct to destination was moved.
     */
    moveDirectToDestinationLeg(plan, targetSegmentType, arrivalSegmentIndex) {
        if (this.getDirectToState() === DirectToState.TOEXISTING) {
            const directTargetSegmentIndex = targetSegmentType === FlightPlanSegmentType.Arrival ? arrivalSegmentIndex : this.findLastEnrouteSegmentIndex(plan);
            if (directTargetSegmentIndex !== undefined && directTargetSegmentIndex > 0 && plan.getLeg(plan.activeLateralLeg).leg.fixIcao === plan.destinationAirport) {
                const destinationLeg = Object.assign({}, plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex].leg);
                const directTargetLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg).leg);
                const directOriginLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg - 1).leg);
                const discoLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg - 2).leg);
                const newDirectLegIndex = plan.getSegment(directTargetSegmentIndex).legs.length;
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
                plan.setDirectToData(directTargetSegmentIndex, newDirectLegIndex);
                plan.addLeg(directTargetSegmentIndex, destinationLeg);
                plan.addLeg(directTargetSegmentIndex, discoLeg, undefined, true);
                plan.addLeg(directTargetSegmentIndex, directOriginLeg, undefined, true);
                const newActiveLeg = plan.addLeg(directTargetSegmentIndex, directTargetLeg, undefined, true);
                plan.setLateralLeg(plan.getLegIndexFromLeg(newActiveLeg));
                plan.calculate(plan.activeLateralLeg);
                return true;
            }
        }
        return false;
    }
    /**
     * Method to find the last enroute segment of the supplied flight plan.
     * @param plan is the flight plan to find the last enroute segment in.
     * @returns a segment index.
     */
    findLastEnrouteSegmentIndex(plan) {
        let enrouteSegmentFound = 0;
        for (let i = 1; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            if (segment.segmentType === FlightPlanSegmentType.Enroute) {
                enrouteSegmentFound = i;
            }
        }
        return enrouteSegmentFound;
    }
    /**
     * Method manage the destination leg in the last enroute segment.
     * @param plan is the flight plan.
     * @param currentDestination is the currently set destination airport icao.
     */
    manageAirportLeg(plan, currentDestination) {
        if (plan.procedureDetails.arrivalIndex > -1 || !currentDestination || Simplane.getIsGrounded()) {
            //if we don't have a destination set, or an arrival is selected, don't add the airport to enroute
            return;
        }
        const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
        const segment = plan.getSegment(lastEnrouteSegmentIndex);
        const lastLegIndex = segment.legs.length - 1;
        if (currentDestination && (lastLegIndex < 0 || segment.legs[lastLegIndex].leg.fixIcao !== currentDestination)) {
            //if a destination is set, AND either (a) the last enroute segment is empty OR (b) the last enroute segment isn't empty and
            //the last leg of the last enroute segment is not already the current destination
            this.planAddLeg(lastEnrouteSegmentIndex, FlightPlan.createLeg({ fixIcao: currentDestination, type: LegType.TF }));
        }
    }
    /**
     * Method to check whether an approach can load, or only activate.
     * @returns true if the approach can be loaded and not activated, otherwise the approach can only be immediatly activated.
     */
    canApproachLoad() {
        const plan = this.getFlightPlan();
        if (plan.length > 0) {
            const activeSegment = plan.getSegment(plan.getSegmentIndex(plan.activeLateralLeg));
            if (activeSegment.segmentType !== FlightPlanSegmentType.Approach && plan.length > 1) {
                return true;
            }
        }
        return false;
    }
    /**
     * Method to add or replace an approach procedure in the flight plan.
     * @param facility is the facility that contains the procedure to add.
     * @param approachIndex is the index of the approach procedure.
     * @param approachTransitionIndex is the index of the approach transition.
     * @param visualRunwayNumber is the visual runway number, if any.
     * @param visualRunwayDesignator is the visual runway designator, if any.
     * @param transStartIndex is the starting leg index for the transition, if any.
     * @param skipCourseReversal Whether to skip the course reversal.
     */
    insertApproach(facility, approachIndex, approachTransitionIndex, visualRunwayNumber, visualRunwayDesignator, transStartIndex, skipCourseReversal) {
        var _a, _b;
        const plan = this.getFlightPlan();
        let visualRunway;
        if (visualRunwayNumber !== undefined && visualRunwayDesignator !== undefined) {
            visualRunway = RunwayUtils.matchOneWayRunway(facility, visualRunwayNumber, visualRunwayDesignator);
            plan.setUserData('visual_approach', `${visualRunway === null || visualRunway === void 0 ? void 0 : visualRunway.designation}`);
        }
        if (!visualRunway && plan.getUserData('visual_approach')) {
            plan.deleteUserData('visual_approach');
        }
        plan.setApproach(facility.icao, approachIndex, approachTransitionIndex);
        if (plan.procedureDetails.arrivalIndex < 0) {
            if (!this.moveDirectToDestinationLeg(plan, FlightPlanSegmentType.Enroute)) {
                this.manageAirportLeg(plan, plan.destinationAirport);
            }
        }
        plan.setDestinationAirport(facility.icao);
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Approach);
        if (plan.getSegment(segmentIndex).legs.length > 0) {
            this.planClearSegment(segmentIndex, FlightPlanSegmentType.Approach);
        }
        const insertProcedureObject = this.buildApproachLegs(facility, approachIndex, approachTransitionIndex, visualRunway, transStartIndex, skipCourseReversal);
        if (insertProcedureObject.runway) {
            plan.setDestinationRunway(insertProcedureObject.runway);
        }
        let haveAddedMap = false;
        insertProcedureObject.procedureLegs.forEach((l) => {
            let isMissedLeg = false;
            if (visualRunway !== undefined) {
                this.addVisualFacilityFromLeg(l, visualRunway.designation);
                if (haveAddedMap) {
                    isMissedLeg = true;
                }
                if (l.fixTypeFlags & FixTypeFlags.MAP) {
                    haveAddedMap = true;
                }
            }
            this.planAddLeg(segmentIndex, l, undefined, false, isMissedLeg);
        });
        let skipDestinationLegCheck = false;
        if (this.getDirectToState() === DirectToState.TOEXISTING) {
            if (((_a = this.getDirectToLeg()) === null || _a === void 0 ? void 0 : _a.fixIcao) === plan.destinationAirport) {
                skipDestinationLegCheck = true;
            }
        }
        if (!skipDestinationLegCheck) {
            this.removeDestLegFromSegments();
        }
        const prevLeg = plan.getPrevLeg(segmentIndex, 0);
        const firstAppLeg = plan.getSegment(segmentIndex).legs[0];
        if (prevLeg && firstAppLeg && this.isDuplicateLeg(prevLeg.leg, firstAppLeg.leg)) {
            this.planRemoveDuplicateLeg(prevLeg, firstAppLeg);
        }
        // Adds missed approach legs
        if (!visualRunway && insertProcedureObject.procedureLegs.length > 0) {
            const missedLegs = (_b = facility.approaches[approachIndex].missedLegs) !== null && _b !== void 0 ? _b : [];
            if (missedLegs.length > 0) {
                let maphIndex = -1;
                for (let m = missedLegs.length - 1; m >= 0; m--) {
                    switch (missedLegs[m].type) {
                        case LegType.HA:
                        case LegType.HF:
                        case LegType.HM:
                            maphIndex = m - 1;
                            break;
                    }
                }
                for (let n = 0; n < missedLegs.length; n++) {
                    const newLeg = FlightPlan.createLeg(missedLegs[n]);
                    if (maphIndex >= 0 && n === maphIndex) {
                        newLeg.fixTypeFlags |= FixTypeFlags.MAHP;
                        this.planAddLeg(segmentIndex, newLeg, undefined, false, true);
                    }
                    else {
                        this.planAddLeg(segmentIndex, newLeg, undefined, false, true);
                    }
                }
            }
        }
        const approachType = visualRunway ? AdditionalApproachType.APPROACH_TYPE_VISUAL : facility.approaches[approachIndex].approachType;
        const rnavTypeFlag = visualRunway ? RnavTypeFlags.None : FmsUtils.getBestRnavType(facility.approaches[approachIndex].rnavTypeFlags);
        this.setApproachDetails(true, approachType, rnavTypeFlag, false);
        plan.calculate();
        this.loadApproachFrequency(facility, approachIndex);
        this.setLocFrequency(1);
        this.setLocFrequency(2);
    }
    /**
     * Method to insert the approach legs.
     * @param facility The facility to build legs from.
     * @param approachIndex The approach procedure index to build legs from.
     * @param approachTransitionIndex The transition index to build legs from.
     * @param visualRunway If this is a visual approach, the visual approach one way runway object.
     * @param transStartIndex The starting leg index for the transition, if any.
     * @param skipCourseReversal Whether to skip the course reversal.
     * @returns procedurelegs array to insert into the flight plan.
     */
    buildApproachLegs(facility, approachIndex, approachTransitionIndex, visualRunway, transStartIndex, skipCourseReversal) {
        const isVisual = visualRunway ? true : false;
        const approach = isVisual && visualRunway !== undefined ? FmsUtils.buildVisualApproach(facility, visualRunway, 1, 2.5) : facility.approaches[approachIndex];
        const transition = !isVisual ? approach.transitions[approachTransitionIndex] : undefined;
        const insertProcedureObject = { procedureLegs: [] };
        if (transition !== undefined && transition.legs.length > 0) {
            const startIndex = transStartIndex !== undefined ? transStartIndex : 0;
            for (let t = startIndex; t < transition.legs.length; t++) {
                insertProcedureObject.procedureLegs.push(FlightPlan.createLeg(transition.legs[t]));
            }
        }
        const finalLegs = approach.finalLegs;
        for (let i = 0; i < finalLegs.length; i++) {
            const leg = FlightPlan.createLeg(finalLegs[i]);
            if (i === 0 && insertProcedureObject.procedureLegs.length > 0 &&
                this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                    this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                continue;
            }
            if (!isVisual && leg.fixIcao.search('R') === 0) {
                const approachRunway = RunwayUtils.matchOneWayRunway(facility, approach.runwayNumber, approach.runwayDesignator);
                if (approachRunway) {
                    insertProcedureObject.runway = approachRunway;
                    const runwayLeg = FmsUtils.buildRunwayLeg(facility, approachRunway, false);
                    insertProcedureObject.procedureLegs.push(runwayLeg);
                }
            }
            else if (isVisual && i === finalLegs.length - 1) {
                insertProcedureObject.runway = visualRunway;
                insertProcedureObject.procedureLegs.push(leg);
                if (approach.missedLegs.length > 0) {
                    insertProcedureObject.procedureLegs.push(approach.missedLegs[0]);
                }
            }
            else {
                insertProcedureObject.procedureLegs.push(leg);
            }
        }
        if (!isVisual) {
            this.tryInsertIFLeg(insertProcedureObject);
            this.tryReconcileIAFLeg(insertProcedureObject);
            this.manageVerticalAngleInfo(insertProcedureObject);
            this.tryCleanupHold(insertProcedureObject);
            if (skipCourseReversal) {
                this.tryRemoveCourseReversal(insertProcedureObject);
            }
            this.tryInsertMap(insertProcedureObject);
            if (!insertProcedureObject.runway && approach.runway) {
                insertProcedureObject.runway = RunwayUtils.matchOneWayRunway(facility, approach.runwayNumber, approach.runwayDesignator);
            }
            return insertProcedureObject;
        }
        return insertProcedureObject;
    }
    /**
     * Manages the altitude constraints for FAF legs where vertical angle info is also provided.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    manageVerticalAngleInfo(proc) {
        proc.procedureLegs.forEach(leg => {
            if (leg.fixTypeFlags === FixTypeFlags.FAF && leg.altitude2 > 0) {
                const alt = leg.altitude1 <= leg.altitude2 ? leg.altitude1 : leg.altitude2;
                leg.altDesc = AltitudeRestrictionType.AtOrAbove;
                leg.altitude1 = alt;
                leg.altitude2 = 0;
            }
        });
        return proc;
    }
    /**
     * Inserts an IF leg at the beginning of a procedure if it begins with a leg type which defines a fixed origin.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryInsertIFLeg(proc) {
        const firstLeg = proc.procedureLegs[0];
        let icao;
        switch (firstLeg === null || firstLeg === void 0 ? void 0 : firstLeg.type) {
            case LegType.HA:
            case LegType.HF:
            case LegType.HM:
            case LegType.PI:
            case LegType.FD:
            case LegType.FC:
                icao = firstLeg.fixIcao;
                break;
            case LegType.FM:
            case LegType.VM:
                icao = firstLeg.originIcao;
                break;
        }
        if (icao && icao !== ICAO.emptyIcao) {
            proc.procedureLegs.unshift(FlightPlan.createLeg({
                type: LegType.IF,
                fixIcao: icao,
                fixTypeFlags: firstLeg.fixTypeFlags & (FixTypeFlags.IF | FixTypeFlags.IAF)
            }));
            if ((firstLeg === null || firstLeg === void 0 ? void 0 : firstLeg.type) === LegType.HF || (firstLeg === null || firstLeg === void 0 ? void 0 : firstLeg.type) === LegType.PI) {
                proc.procedureLegs[0].altDesc = firstLeg.altDesc;
                proc.procedureLegs[0].altitude1 = firstLeg.altitude1;
                proc.procedureLegs[0].altitude2 = firstLeg.altitude2;
            }
            // need to remove IF/IAF flags from the original first leg (now the second leg)
            const replacementLeg = FlightPlan.createLeg(proc.procedureLegs[1]);
            replacementLeg.fixTypeFlags = replacementLeg.fixTypeFlags & ~(FixTypeFlags.IF | FixTypeFlags.IAF);
            proc.procedureLegs[1] = replacementLeg;
        }
        return proc;
    }
    /**
     * Checks the approach legs for an IAF fix type flag, and if one exists, amend the approach to ensure that
     * the IAF is not on a hold/pt leg and that we do not add legs prior to the IAF except in cases where we needed to add
     * an IF leg type.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryReconcileIAFLeg(proc) {
        let iafIndex = -1;
        for (let i = 0; i < proc.procedureLegs.length; i++) {
            const leg = proc.procedureLegs[i];
            if (leg.fixTypeFlags === FixTypeFlags.IAF) {
                iafIndex = i;
                switch (leg.type) {
                    case LegType.HA:
                    case LegType.HF:
                    case LegType.HM:
                    case LegType.PI:
                    case LegType.FD:
                    case LegType.FC:
                        if (iafIndex > 0) {
                            leg.fixTypeFlags &= ~FixTypeFlags.IAF;
                            proc.procedureLegs[iafIndex - 1].fixTypeFlags |= FixTypeFlags.IAF;
                            iafIndex--;
                        }
                }
                break;
            }
        }
        return proc;
    }
    /**
     * Inserts a MAP fix type flag if none exists on the approach.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryInsertMap(proc) {
        let addMap = true;
        let runwayIndex = -1;
        for (let i = 0; i < proc.procedureLegs.length; i++) {
            const leg = proc.procedureLegs[i];
            if (leg.fixTypeFlags === FixTypeFlags.MAP) {
                addMap = false;
                break;
            }
            if (leg.fixIcao.search('R') === 0) {
                runwayIndex = i;
                break;
            }
        }
        if (addMap && runwayIndex > -1) {
            proc.procedureLegs[runwayIndex].fixTypeFlags = FixTypeFlags.MAP;
        }
        return proc;
    }
    /**
     * Method to remove the duplicate leg after the hold leg.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryCleanupHold(proc) {
        for (let i = 0; i < proc.procedureLegs.length; i++) {
            const leg = proc.procedureLegs[i];
            if (leg.type === LegType.HF) {
                const next = proc.procedureLegs[i + 1];
                if (leg.fixIcao === next.fixIcao && next.type === LegType.IF) {
                    proc.procedureLegs.splice(i + 1, 1);
                }
            }
        }
        return proc;
    }
    /**
     * Method to remove a course reversal in an approach procedure.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryRemoveCourseReversal(proc) {
        let canRemove = false;
        if (proc.procedureLegs.length > 2) {
            const leg = proc.procedureLegs[1];
            switch (leg.type) {
                case LegType.HA:
                case LegType.HF:
                case LegType.HM:
                case LegType.PI:
                    canRemove = true;
            }
        }
        if (canRemove) {
            proc.procedureLegs.splice(1, 1);
        }
        return proc;
    }
    /**
     * Method to remove the departure from the flight plan.
     */
    async removeDeparture() {
        const plan = this.getFlightPlan();
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Departure);
        plan.setDeparture();
        this.planClearSegment(segmentIndex, FlightPlanSegmentType.Departure);
        if (plan.originAirport) {
            const airport = await this.facLoader.getFacility(FacilityType.Airport, plan.originAirport);
            const updatedSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Departure);
            this.planAddOriginDestinationLeg(true, updatedSegmentIndex, airport, plan.procedureDetails.originRunway);
            const prevLeg = plan.getPrevLeg(updatedSegmentIndex, 1);
            const nextLeg = plan.getNextLeg(updatedSegmentIndex, 0);
            if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
                this.planRemoveDuplicateLeg(prevLeg, nextLeg);
            }
        }
        plan.calculate(0);
    }
    /**
     * Method to remove the arrival from the flight plan.
     */
    async removeArrival() {
        const plan = this.getFlightPlan();
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Arrival);
        plan.setArrival();
        this.planRemoveSegment(segmentIndex);
        if (plan.procedureDetails.approachIndex < 0 && plan.destinationAirport) {
            const airport = await this.facLoader.getFacility(FacilityType.Airport, plan.destinationAirport);
            const destSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Destination);
            this.planAddOriginDestinationLeg(false, destSegmentIndex, airport, plan.procedureDetails.destinationRunway);
        }
        const prevLeg = plan.getPrevLeg(segmentIndex, 0);
        const nextLeg = plan.getNextLeg(segmentIndex, -1);
        if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(prevLeg, nextLeg);
        }
        plan.calculate(0);
    }
    /**
     * Method to remove the approach from the flight plan.
     */
    async removeApproach() {
        this.loadApproachFrequency();
        this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, RnavTypeFlags.None, false);
        const plan = this.getFlightPlan();
        const hasArrival = plan.procedureDetails.arrivalIndex >= 0;
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Approach);
        if (hasArrival) {
            const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
            const segment = plan.getSegment(lastEnrouteSegmentIndex);
            const lastLegIndex = segment && segment.legs.length > 0 ? segment.legs.length - 1 : 0;
            if (plan.destinationAirport && segment.legs[lastLegIndex] && segment.legs[lastLegIndex].leg.fixIcao === plan.destinationAirport) {
                this.planRemoveLeg(lastEnrouteSegmentIndex, lastLegIndex);
            }
            plan.setDestinationRunway();
            if (plan.procedureDetails.arrivalFacilityIcao && plan.procedureDetails.arrivalFacilityIcao !== plan.destinationAirport) {
                const arrivalFacility = await this.facLoader.getFacility(FacilityType.Airport, plan.procedureDetails.arrivalFacilityIcao);
                this.setDestination(arrivalFacility);
            }
        }
        plan.setApproach();
        this.planRemoveSegment(segmentIndex);
        if (plan.destinationAirport) {
            const airport = await this.facLoader.getFacility(FacilityType.Airport, plan.destinationAirport);
            const destLegSegmentIndex = hasArrival
                ? this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Arrival)
                : this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Destination);
            this.planAddOriginDestinationLeg(false, destLegSegmentIndex, airport, plan.procedureDetails.destinationRunway);
        }
        const prevLeg = plan.getPrevLeg(segmentIndex, 0);
        const nextLeg = plan.getNextLeg(segmentIndex, -1);
        if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(prevLeg, nextLeg);
        }
        if (plan.getUserData('visual_approach')) {
            plan.deleteUserData('visual_approach');
        }
        plan.calculate(0);
    }
    /**
     * Method to activate a leg in the flight plan.
     * @param segmentIndex is the index of the segment containing the leg to activate.
     * @param legIndex is the index of the leg in the selected segment activate.
     * @param fplnIndex is the index of the flight plan in which to activate the leg.
     */
    activateLeg(segmentIndex, legIndex, fplnIndex = 0) {
        const plan = this.getFlightPlan(fplnIndex);
        const indexInFlightplan = plan.getSegment(segmentIndex).offset + legIndex;
        if (fplnIndex === 0 && this.flightPlanner.activePlanIndex > 0) {
            this.flightPlanner.setActivePlanIndex(0);
        }
        if (this.missedApproachActive) {
            const segment = plan.getSegment(segmentIndex);
            if (segment.legs[legIndex] && !segment.legs[legIndex].isInMissedApproachSequence) {
                Fms.g1000EvtPub.publishEvent('activate_missed_approach', false);
            }
        }
        if ((fplnIndex !== 0 && this.getDirectToState() === DirectToState.TOEXISTING)
            || (fplnIndex === 0 && (segmentIndex < plan.directToData.segmentIndex || (segmentIndex === plan.directToData.segmentIndex && legIndex <= plan.directToData.segmentLegIndex)))) {
            this.removeDirectToExisting(indexInFlightplan);
            if (fplnIndex !== 0) {
                plan.setLateralLeg(indexInFlightplan);
                plan.calculate(Math.max(0, indexInFlightplan - 1));
            }
        }
        else {
            plan.setLateralLeg(indexInFlightplan);
            plan.calculate(Math.max(0, indexInFlightplan - 1));
        }
        Fms.g1000EvtPub.publishEvent('suspend', false);
    }
    /**
     * Method to check if there is a currently loaded approach to be activated.
     * @returns whether the approach can activate
     */
    canApproachActivate() {
        const plan = this.getFlightPlan();
        if (plan.destinationAirport !== undefined && plan.procedureDetails.approachIndex > -1) {
            return true;
        }
        else if (plan.destinationAirport !== undefined) {
            const approachSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Approach, false);
            if (approachSegmentIndex > 0 && plan.getSegment(approachSegmentIndex).legs.length > 0) {
                return true;
            }
        }
        return false;
    }
    /**
     * Method to activate the approach.
     */
    activateApproach() {
        if (this.canApproachActivate()) {
            const approachSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Approach, false);
            this.createDirectToExisting(approachSegmentIndex, 0);
        }
        this.setLocFrequency(1, true);
        this.setLocFrequency(2, true);
    }
    /**
     * Method to check if there is a currently loaded missed approach to be activated.
     * @returns whether the approach can activate
     */
    canMissedApproachActivate() {
        const plan = this.getFlightPlan();
        if (this.cdiSource.type === NavSourceType.Gps && plan && plan.activeLateralLeg < plan.length - 1 && plan.segmentCount > 0) {
            const segmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
            if (segmentIndex > 0) {
                const segment = plan.getSegment(segmentIndex);
                if (segment.segmentType === FlightPlanSegmentType.Approach && segment.legs[segment.legs.length - 1].isInMissedApproachSequence) {
                    for (let i = 0; i < segment.legs.length; i++) {
                        const leg = segment.legs[i];
                        if (leg.leg.fixTypeFlags === FixTypeFlags.FAF) {
                            if (plan.activeLateralLeg - segment.offset >= i) {
                                return true;
                            }
                        }
                    }
                }
            }
        }
        return false;
    }
    /**
     * Method to activate the missed approach.
     */
    activateMissedApproach() {
        if (this.canMissedApproachActivate()) {
            Fms.g1000EvtPub.publishEvent('activate_missed_approach', true);
        }
    }
    /**
     * Method to create a direct to a random waypoint just from the fixIcao.
     * @param icao is the desired fixIcao.
     */
    async buildRandomDirectTo(icao) {
        if (ICAO.isFacility(icao)) {
            const type = ICAO.getFacilityType(icao);
            const fac = await this.facLoader.getFacility(type, icao);
            this.createDirectToRandom(fac);
        }
    }
    /**
     * Method to create a direct to a waypoint. This method will also then call activateLeg.
     * @param waypoint is the facility for the DTO destination to be added.
     * @param course is the course for this direct to, if specified.
     */
    createDirectToRandom(waypoint, course) {
        const plan = this.flightPlanner.createFlightPlan(1);
        plan.setLateralLeg(0);
        for (let i = plan.segmentCount - 1; i >= 0; i--) {
            if (plan.getSegment(i) !== undefined) {
                plan.removeSegment(i);
            }
        }
        plan.insertSegment(0, FlightPlanSegmentType.RandomDirectTo, undefined, true);
        const segment = plan.getSegment(0);
        if (segment) {
            const discoLeg = FlightPlan.createLeg({ type: LegType.Discontinuity });
            const dtoOriginLeg = this.createDTOOriginLeg(this.ppos);
            const dtoTargetLeg = this.createDTODirectLeg(waypoint.icao);
            plan.addLeg(0, discoLeg, 0, true);
            plan.addLeg(0, dtoOriginLeg, 1, true);
            plan.addLeg(0, dtoTargetLeg, 2, true);
            plan.calculate(0);
            if (this.flightPlanner.activePlanIndex !== 1) {
                this.flightPlanner.setActivePlanIndex(1);
            }
            Fms.g1000EvtPub.publishEvent('suspend', false);
        }
    }
    /**
     * Method to create a direct to an existing waypoint in the plan. This method will also then call activateLeg.
     * @param segmentIndex is the index of the segment containing the leg to activate as direct to.
     * @param legIndex is the index of the leg in the specified segment to activate as direct to.
     * @param course is the course for this direct to, if specified.
     */
    createDirectToExisting(segmentIndex, legIndex, course) {
        const plan = this.getFlightPlan();
        const segment = plan.getSegment(segmentIndex);
        const leg = segment.legs[legIndex];
        let legIndexDelta = 0;
        if (plan.directToData.segmentIndex > -1 && plan.directToData.segmentLegIndex > -1) {
            legIndexDelta -= plan.directToData.segmentIndex === segmentIndex && legIndex > plan.directToData.segmentLegIndex ? 3 : 0;
            if (this.getDirectToState() === DirectToState.TOEXISTING) {
                this.removeDirectToExisting();
            }
            else {
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
            }
        }
        plan.setDirectToData(segmentIndex, legIndex + legIndexDelta);
        if (segment && leg) {
            const discoLeg = FlightPlan.createLeg({ type: LegType.Discontinuity });
            const dtoOriginLeg = this.createDTOOriginLeg(this.ppos);
            const dtoTargetLeg = this.createDTODirectLeg(leg.leg.fixIcao, leg.leg);
            plan.addLeg(segmentIndex, discoLeg, legIndex + legIndexDelta + 1, true);
            plan.addLeg(segmentIndex, dtoOriginLeg, legIndex + legIndexDelta + 2, true);
            plan.addLeg(segmentIndex, dtoTargetLeg, legIndex + legIndexDelta + 3, true);
            this.activateLeg(segmentIndex, legIndex + legIndexDelta + 3);
        }
    }
    /**
     * Creates a Direct-To origin IF leg.
     * @param ppos The current plane position.
     * @returns a Direct-To origin IF leg.
     */
    createDTOOriginLeg(ppos) {
        return FlightPlan.createLeg({
            type: LegType.IF,
            lat: ppos.lat,
            lon: ppos.lon
        });
    }
    /**
     * Creates a Direct-To DF leg.
     * @param icao is the icao.
     * @param leg The FlightPlanLeg.
     * @returns a Direct-To DF leg.
     */
    createDTODirectLeg(icao, leg) {
        const planeHeading = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', 'degrees');
        if (leg) {
            const directLeg = Object.assign({}, leg);
            directLeg.type = LegType.DF;
            directLeg.course = planeHeading === 0 ? 360 : planeHeading;
            return directLeg;
        }
        else {
            return FlightPlan.createLeg({
                type: LegType.DF,
                fixIcao: icao,
                course: planeHeading === 0 ? 360 : planeHeading
            });
        }
    }
    /**
     * Empties the primary flight plan.
     */
    async emptyPrimaryFlightPlan() {
        if (!this.flightPlanner.hasFlightPlan(Fms.PRIMARY_PLAN_INDEX)) {
            return;
        }
        const plan = this.flightPlanner.getFlightPlan(Fms.PRIMARY_PLAN_INDEX);
        const directToState = this.getDirectToState();
        if (directToState === DirectToState.TOEXISTING || (directToState !== DirectToState.TORANDOM && !Simplane.getIsGrounded() && plan.activeLateralLeg > 0)) {
            const directToIcao = plan.getLeg(plan.activeLateralLeg).leg.fixIcao;
            if (directToIcao) {
                const facType = ICAO.getFacilityType(directToIcao);
                const fac = await this.facLoader.getFacility(facType, directToIcao);
                this.createDirectToRandom(fac);
            }
        }
        for (let i = plan.segmentCount - 1; i >= 0; i--) {
            this.planRemoveSegment(i);
        }
        plan.addSegment(0, FlightPlanSegmentType.Departure);
        plan.addSegment(1, FlightPlanSegmentType.Enroute);
        plan.addSegment(2, FlightPlanSegmentType.Destination);
        this.setOrigin(undefined, undefined);
        this.setDestination(undefined, undefined);
        plan.setDirectToData(-1);
        this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, RnavTypeFlags.None, false);
        plan.setLateralLeg(0);
        plan.setVerticalLeg(0);
        plan.setCalculatingLeg(0);
        plan.calculate(0);
    }
    /**
     * Builds a temporary flight plan to preview the approach in the MFD Select Procedure pages.
     * @param facility The airport facility to load the approach from
     * @param procType The type of procedure to preview.
     * @param procIndex The procedure index selected.
     * @param transIndex The transition index selected.
     * @param oneWayRunway The one way runway to build the preview with, if any.
     * @param rwyTransIndex The runway transition index selected, if any.
     * @param visualRunwayNumber is the visual runway number, if any.
     * @param visualRunwayDesignator is the visual runway designator, if any.
     * @param transStartIndex The transition start offset, if any.
     * @returns the index of the temporary flight plan.
     */
    buildProcedurePreviewPlan(facility, procType, procIndex, transIndex, oneWayRunway, rwyTransIndex, visualRunwayNumber, visualRunwayDesignator, transStartIndex) {
        var _a;
        this.flightPlanner.deleteFlightPlan(Fms.PROC_PREVIEW_PLAN_INDEX);
        const plan = this.flightPlanner.createFlightPlan(Fms.PROC_PREVIEW_PLAN_INDEX);
        let procedureLegObject;
        switch (procType) {
            case ProcedureType.APPROACH:
                procedureLegObject = this.buildApproachLegs(facility, procIndex, transIndex, undefined, transStartIndex !== undefined ? transStartIndex : 0);
                plan.addSegment(0, FlightPlanSegmentType.Approach, undefined, false);
                break;
            case ProcedureType.ARRIVAL:
                {
                    const runwayIndex = rwyTransIndex !== null && rwyTransIndex !== void 0 ? rwyTransIndex : -1;
                    procedureLegObject = this.buildArrivalLegs(facility, procIndex, transIndex, runwayIndex, oneWayRunway);
                    plan.addSegment(0, FlightPlanSegmentType.Arrival, undefined, false);
                }
                break;
            case ProcedureType.DEPARTURE:
                {
                    const runwayIndex = rwyTransIndex !== null && rwyTransIndex !== void 0 ? rwyTransIndex : -1;
                    procedureLegObject = this.buildDepartureLegs(facility, procIndex, transIndex, runwayIndex, oneWayRunway);
                    plan.addSegment(0, FlightPlanSegmentType.Departure, undefined, false);
                }
                break;
            case ProcedureType.VISUALAPPROACH:
                if (visualRunwayNumber !== undefined && visualRunwayDesignator !== undefined) {
                    const visualRunway = RunwayUtils.matchOneWayRunway(facility, visualRunwayNumber, visualRunwayDesignator);
                    procedureLegObject = this.buildApproachLegs(facility, -1, -1, visualRunway);
                    plan.addSegment(0, FlightPlanSegmentType.Approach, undefined, false);
                }
                break;
        }
        if (procedureLegObject && procedureLegObject.procedureLegs.length > 0) {
            if (procedureLegObject.procedureLegs[0].type !== LegType.IF) {
                const replacementLeg = FlightPlan.createLeg({
                    type: LegType.IF,
                    fixIcao: procedureLegObject.procedureLegs[0].fixIcao,
                    fixTypeFlags: procedureLegObject.procedureLegs[0].fixTypeFlags,
                });
                procedureLegObject.procedureLegs.splice(0, 1, replacementLeg);
            }
            procedureLegObject.procedureLegs.forEach((l) => {
                plan.addLeg(0, l, undefined, undefined, undefined, false);
            });
            if (procType === ProcedureType.APPROACH) {
                // Adds missed approach legs
                if (!visualRunwayNumber && !visualRunwayDesignator && procedureLegObject.procedureLegs.length > 0) {
                    const missedLegs = (_a = facility.approaches[procIndex].missedLegs) !== null && _a !== void 0 ? _a : [];
                    if (missedLegs && missedLegs.length > 0) {
                        let maphIndex = -1;
                        for (let m = missedLegs.length - 1; m >= 0; m--) {
                            switch (missedLegs[m].type) {
                                case LegType.HA:
                                case LegType.HF:
                                case LegType.HM:
                                    maphIndex = m - 1;
                                    break;
                            }
                        }
                        for (let n = 0; n < missedLegs.length; n++) {
                            const newLeg = FlightPlan.createLeg(missedLegs[n]);
                            if (maphIndex > 0 && n === maphIndex) {
                                newLeg.fixTypeFlags |= FixTypeFlags.MAHP;
                                plan.addLeg(0, newLeg, undefined, false, true, false);
                            }
                            else {
                                plan.addLeg(0, newLeg, undefined, false, true, false);
                            }
                        }
                    }
                }
            }
            plan.calculate(0);
            return 2;
        }
        else {
            return -1;
        }
    }
    /**
     * Builds a temporary flight plan to preview an airway entry.
     * @param airway The airway object.
     * @param entry The entry intersection facility.
     * @param exit The exit intersection facility.
     * @returns the index of the temporary flight plan.
     */
    buildAirwayPreviewSegment(airway, entry, exit) {
        this.flightPlanner.deleteFlightPlan(Fms.PROC_PREVIEW_PLAN_INDEX);
        const plan = this.flightPlanner.createFlightPlan(Fms.PROC_PREVIEW_PLAN_INDEX);
        const airwayLegObject = this.buildAirwayLegs(airway, entry, exit);
        plan.insertSegment(0, FlightPlanSegmentType.Enroute, airway.name, false);
        if (airwayLegObject.procedureLegs.length > 0) {
            airwayLegObject.procedureLegs.forEach((l) => {
                plan.addLeg(0, l, undefined, undefined, undefined, false);
            });
            plan.calculate(0, true);
        }
        return Fms.PROC_PREVIEW_PLAN_INDEX;
    }
    /**
     * Adds an airway and airway segment to the flight plan.
     * @param airway The airway object.
     * @param entry The entry intersection facility.
     * @param exit The exit intersection facility.
     * @param segmentIndex Is the segment index for the entry leg.
     * @param legIndex Is the leg index of the entry leg in the segment of the
     */
    insertAirwaySegment(airway, entry, exit, segmentIndex, legIndex) {
        const plan = this.getFlightPlan();
        const airwaySegmentIndex = this.prepareAirwaySegment(`${airway.name}.${ICAO.getIdent(exit.icao)}`, segmentIndex, legIndex);
        const airwayLegObject = this.buildAirwayLegs(airway, entry, exit);
        const airwayLegs = airwayLegObject.procedureLegs;
        for (let i = 1; i < airwayLegs.length; i++) {
            this.planAddLeg(airwaySegmentIndex, airwayLegs[i]);
        }
        // handle duplicates
        const airwaySegment = plan.getSegment(airwaySegmentIndex);
        const lastLeg = airwaySegment.legs[airwaySegment.legs.length - 1];
        const nextLeg = plan.getNextLeg(airwaySegmentIndex + 1, -1);
        if (lastLeg && nextLeg && this.isDuplicateLeg(lastLeg.leg, nextLeg.leg)) {
            const nextLegIndex = plan.getLegIndexFromLeg(nextLeg);
            const nextLegSegmentIndex = plan.getSegmentIndex(nextLegIndex);
            const nextLegSegment = plan.getSegment(nextLegSegmentIndex);
            if (this.getAirwayLegType(plan, nextLegSegmentIndex, nextLegIndex - nextLegSegment.offset) === AirwayLegType.ENTRY) {
                // the duplicated leg is an airway entry -> remove the segment containing it (the segment is guaranteed to
                // contain just the one leg)
                this.planRemoveSegment(nextLegSegmentIndex);
            }
            else {
                this.planRemoveDuplicateLeg(lastLeg, nextLeg);
            }
        }
        plan.calculate(0, true);
    }
    /**
     * Prepares a new, empty airway segment in the primary flight plan which is ready to accept airway legs. Also
     * modifies the segment containing the entry leg, if necessary, either splitting it following the entry leg if it is
     * a non-airway enroute segment, or removing all legs following the entry leg if it is an airway segment. If the
     * entry leg is the last leg in its segment, a new non-airway enroute segment will be inserted after the entry leg
     * segment if the entry leg segment is the last segment in the flight plan or if the following segment is not an
     * enroute segment. If the entry leg is the entry for an existing airway segment, the existing airway segment will be
     * removed.
     * @param airwayName The name of the airway.
     * @param entrySegmentIndex The index of the segment containing the airway entry leg.
     * @param entrySegmentLegIndex The index of the airway entry leg in its segment.
     * @returns The index of the new airway segment.
     */
    prepareAirwaySegment(airwayName, entrySegmentIndex, entrySegmentLegIndex) {
        const plan = this.getPrimaryFlightPlan();
        const entrySegment = plan.getSegment(entrySegmentIndex);
        const nextSegment = entrySegmentIndex + 1 < plan.segmentCount ? plan.getSegment(entrySegmentIndex + 1) : undefined;
        let airwaySegmentIndex = entrySegmentIndex + 1;
        let removeLegsSegmentIndex = -1;
        let removeLegsFromIndex = -1;
        if (entrySegment.airway !== undefined) {
            // the entry leg is within an existing airway segment -> remove all legs in the same segment after the entry leg
            removeLegsSegmentIndex = entrySegmentIndex;
            removeLegsFromIndex = entrySegmentLegIndex + 1;
        }
        else if (entrySegmentLegIndex === entrySegment.legs.length - 1 && (nextSegment === null || nextSegment === void 0 ? void 0 : nextSegment.airway) !== undefined) {
            // the entry leg is the entry leg for an existing airway segment -> remove all legs from the existing airway segment
            removeLegsSegmentIndex = entrySegmentIndex + 1;
            removeLegsFromIndex = 0;
        }
        // remove legs as required
        if (removeLegsSegmentIndex >= 0) {
            const removeLegsSegment = plan.getSegment(removeLegsSegmentIndex);
            if (plan.directToData.segmentIndex === removeLegsSegmentIndex && plan.directToData.segmentLegIndex >= removeLegsFromIndex) {
                this.removeDirectToExisting();
            }
            if (this.getAirwayLegType(plan, removeLegsSegmentIndex, removeLegsSegment.legs.length - 1) === AirwayLegType.EXIT_ENTRY) {
                // preserve the airway entry leg
                const lastLeg = removeLegsSegment.legs[removeLegsSegment.legs.length - 1];
                this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, removeLegsSegmentIndex + 1);
                this.planAddLeg(removeLegsSegmentIndex + 1, lastLeg.leg, 0);
            }
            if (removeLegsFromIndex > 0) {
                while (removeLegsSegment.legs.length > removeLegsFromIndex) {
                    this.planRemoveLeg(removeLegsSegmentIndex, entrySegment.legs.length - 1, true, true);
                }
            }
            else {
                this.planRemoveSegment(removeLegsSegmentIndex);
            }
        }
        if (entrySegment.legs.length - 1 > entrySegmentLegIndex) {
            // entry leg is not the last leg in its segment -> split the segment after the entry leg
            airwaySegmentIndex = this.splitSegment(plan, entrySegmentIndex, entrySegmentLegIndex);
        }
        else if (plan.getSegment(entrySegmentIndex).segmentType === FlightPlanSegmentType.Enroute
            && ((nextSegment === null || nextSegment === void 0 ? void 0 : nextSegment.segmentType) !== FlightPlanSegmentType.Enroute)) {
            // entry leg is the last leg in its segment and the following segment doesn't exist or is not an enroute segment
            plan.insertSegment(airwaySegmentIndex, FlightPlanSegmentType.Enroute);
        }
        plan.insertSegment(airwaySegmentIndex, FlightPlanSegmentType.Enroute, airwayName);
        return airwaySegmentIndex;
    }
    /**
     * Splits a segment into two segments if type is enroute; if departure, remove legs after the legIndex, else do nothing.
     * @param plan is the flight plan to edit.
     * @param segmentIndex Is the segment index for the entry leg.
     * @param legIndex Is the leg index of the entry leg in the segment of the
     * @returns the segment number of the new airway segment if one was created, else the current segment or if no action was taken.
     */
    splitSegment(plan, segmentIndex, legIndex) {
        const segment = plan.getSegment(segmentIndex);
        if (segment.segmentType === FlightPlanSegmentType.Enroute) {
            const nextSegmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
            for (let i = legIndex + 1; i < segment.legs.length; i++) {
                const leg = segment.legs[i].leg;
                this.planRemoveLeg(segmentIndex, i);
                this.planAddLeg(nextSegmentIndex, leg);
            }
            return nextSegmentIndex;
        }
        else if (segment.segmentType === FlightPlanSegmentType.Departure) {
            for (let i = legIndex + 1; i < segment.legs.length; i++) {
                this.planRemoveLeg(segmentIndex, i);
            }
        }
        return segmentIndex;
    }
    /**
     * Builds a legs for an airway.
     * @param airway The airway object.
     * @param entry The entry intersection facility.
     * @param exit The exit intersection facility.
     * @returns the InsertProcedureObject.
     */
    buildAirwayLegs(airway, entry, exit) {
        const insertAirwayObject = { procedureLegs: [] };
        const waypoints = airway.waypoints;
        const entryIndex = waypoints.findIndex((w) => w.icao === entry.icao);
        const exitIndex = waypoints.findIndex((w) => w.icao === exit.icao);
        const ascending = exitIndex > entryIndex;
        if (ascending) {
            for (let i = entryIndex; i <= exitIndex; i++) {
                const leg = FlightPlan.createLeg({
                    fixIcao: waypoints[i].icao,
                    type: i === entryIndex ? LegType.IF : LegType.TF
                });
                insertAirwayObject.procedureLegs.push(leg);
            }
        }
        else {
            for (let i = entryIndex; i >= exitIndex; i--) {
                const leg = FlightPlan.createLeg({
                    fixIcao: waypoints[i].icao,
                    type: i === entryIndex ? LegType.IF : LegType.TF
                });
                insertAirwayObject.procedureLegs.push(leg);
            }
        }
        return insertAirwayObject;
    }
    /**
     * Method to remove an airway from the flight plan.
     * @param segmentIndex is the segment index of the airway to remove.
     */
    removeAirway(segmentIndex) {
        const plan = this.getFlightPlan();
        let combineSegments = false;
        const nextSegmentIsAirway = plan.getSegment(segmentIndex + 1).airway;
        if (segmentIndex > 0) {
            const priorSegmentEnrouteNonAirway = plan.getSegment(segmentIndex - 1).segmentType === FlightPlanSegmentType.Enroute
                && plan.getSegment(segmentIndex - 1).airway === undefined;
            const nextSegmentEnrouteNonAirway = plan.getSegment(segmentIndex + 1).segmentType === FlightPlanSegmentType.Enroute
                && plan.getSegment(segmentIndex + 1).airway === undefined;
            if (priorSegmentEnrouteNonAirway && nextSegmentEnrouteNonAirway) {
                combineSegments = true;
            }
            let entryLeg = undefined;
            if (nextSegmentIsAirway) {
                const segment = plan.getSegment(segmentIndex);
                entryLeg = segment.legs[segment.legs.length - 1].leg;
            }
            this.planRemoveSegment(segmentIndex);
            if (combineSegments) {
                this.mergeSegments(plan, segmentIndex - 1);
            }
            if (priorSegmentEnrouteNonAirway && entryLeg !== undefined) {
                this.planAddLeg(segmentIndex - 1, entryLeg);
            }
            else if (entryLeg !== undefined) {
                const newSegmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex);
                this.planAddLeg(newSegmentIndex, entryLeg);
            }
        }
        plan.calculate(0, true);
    }
    /**
     * Merges the legs of two consecutive segments into a single segment. All legs in the second segment are moved to the
     * first, and the second segment is removed from the flight plan.
     * @param plan The flight plan to modify.
     * @param segmentIndex The index of the first segment to merge.
     */
    mergeSegments(plan, segmentIndex) {
        const segmentToGrow = plan.getSegment(segmentIndex);
        const segmentToRemove = plan.getSegment(segmentIndex + 1);
        const segmentToGrowOrigLength = segmentToGrow.legs.length;
        segmentToRemove.legs.forEach((l) => {
            plan.addLeg(segmentIndex, l.leg, undefined, l.isInDirectToSequence);
        });
        if (plan.directToData.segmentIndex === segmentIndex + 1) {
            plan.setDirectToData(segmentIndex, segmentToGrowOrigLength + plan.directToData.segmentLegIndex);
        }
        this.planRemoveSegment(segmentIndex + 1);
    }
    /**
     * Adds a hold leg to a segment.
     * @param segmentIndex The segment to add to.
     * @param legIndex The index of the leg.
     * @param holdLeg The hold leg to add.
     */
    addHold(segmentIndex, legIndex, holdLeg) {
        this.planAddLeg(segmentIndex, holdLeg, legIndex + 1);
    }
    /**
     * Returns the index of the last element in the array where predicate is true, and -1
     * otherwise.
     * @param array The source array to search in
     * @param predicate find calls predicate once for each element of the array, in descending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.
     * @param defaultReturn is the default value
     * @returns either the index or the default if the predicate criteria is not met
     */
    findLastSegmentIndex(array, predicate, defaultReturn = -1) {
        let l = array.length;
        while (l--) {
            if (predicate(array[l], l, array)) {
                return array[l].segmentIndex;
            }
        }
        return defaultReturn;
    }
    /**
     * Adds a leg to the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param leg The leg to add to the plan.
     * @param index The index of the leg in the segment to insert. Will add to the end of the segment if ommitted.
     * @param isInDirectToSequence Whether the new leg is in a direct to sequence.
     * @param isInMissedSequence Whether the new leg is in a missed approach sequence.
     * @param notify Whether or not to send notifications after the operation.
     */
    planAddLeg(segmentIndex, leg, index, isInDirectToSequence = false, isInMissedSequence = false, notify = true) {
        const plan = this.getFlightPlan();
        const dtoLegIndex = plan.directToData.segmentLegIndex;
        const dtoSegmentIndex = plan.directToData.segmentIndex;
        if (dtoSegmentIndex >= 0
            && (segmentIndex < dtoSegmentIndex
                || (segmentIndex === dtoSegmentIndex && index !== undefined && index <= dtoLegIndex))) {
            this.removeDirectToExisting();
        }
        const segment = plan.getSegment(segmentIndex);
        const addIndex = index ? index : Math.max(segment.legs.length - 1, 0);
        if (segment.segmentType === FlightPlanSegmentType.Approach && (addIndex > 0) && segment.legs[addIndex - 1].isInMissedApproachSequence) {
            isInMissedSequence = true;
        }
        plan.addLeg(segmentIndex, leg, index, isInDirectToSequence, isInMissedSequence, notify);
        plan.calculate(plan.activeLateralLeg - 1);
        const activeSegmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
        if (activeSegmentIndex !== -1) {
            const activeLegIndex = plan.activeLateralLeg - plan.getSegment(activeSegmentIndex).offset;
            if (segmentIndex < activeSegmentIndex || (index && segmentIndex == activeSegmentIndex && index < activeLegIndex)) {
                plan.setLateralLeg(plan.activeLateralLeg + 1);
            }
        }
        else {
            console.error('planAddLeg: activeSegmentIndex was -1');
        }
    }
    /**
     * Removes a leg from the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param index The index of the leg in the segment to remove.
     * @param notify Whether or not to send notifications after the operation. True by default.
     * @param skipDupCheck Whether to skip checking for duplicates. False by default.
     * @param skipCancelDirectTo Whether to skip canceling a direct to existing if the removed leg is equal to or is
     * located before the direct to target. False by default.
     * @returns whether a leg was removed.
     */
    planRemoveLeg(segmentIndex, index, notify = true, skipDupCheck = false, skipCancelDirectTo = false) {
        const plan = this.getFlightPlan();
        const removeLegGlobalIndex = plan.getSegment(segmentIndex).offset + index;
        const prevLeg = plan.getPrevLeg(segmentIndex, index);
        const nextLeg = plan.getNextLeg(segmentIndex, index);
        const isDirectToExistingActive = this.getDirectToState() === DirectToState.TOEXISTING;
        let removed = false;
        const airwayLegType = this.getAirwayLegType(plan, segmentIndex, index);
        if (airwayLegType !== AirwayLegType.NONE) {
            removed = this.removeLegAirwayHandler(plan, airwayLegType, segmentIndex, index);
        }
        else {
            removed = plan.removeLeg(segmentIndex, index, notify) !== null ? true : false;
        }
        if (!removed) {
            return false;
        }
        const dtoLegIndex = plan.directToData.segmentLegIndex;
        const dtoSegmentIndex = plan.directToData.segmentIndex;
        if (!skipCancelDirectTo
            && dtoSegmentIndex >= 0
            && (segmentIndex < dtoSegmentIndex
                || (segmentIndex === dtoSegmentIndex && index <= dtoLegIndex))) {
            // Need to adjust direct to data to compensate for removed leg.
            if (segmentIndex === dtoSegmentIndex) {
                plan.directToData.segmentLegIndex--;
            }
            if (isDirectToExistingActive && segmentIndex === dtoSegmentIndex && index === dtoLegIndex) {
                const directIcao = plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex + 3].leg.fixIcao;
                this.buildRandomDirectTo(directIcao);
            }
            this.removeDirectToExisting(plan.activeLateralLeg - 1);
        }
        else if (removeLegGlobalIndex < plan.activeLateralLeg || plan.activeLateralLeg >= plan.length) {
            plan.setLateralLeg(plan.activeLateralLeg - 1);
        }
        // Detect if we have created consecutive duplicate legs. If we have, we need to delete one of them.
        if (!skipDupCheck && prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(prevLeg, nextLeg);
        }
        if (!skipDupCheck && this.checkIfRemoveLeftEmptySegmentToDelete(plan, segmentIndex)) {
            this.planRemoveSegment(segmentIndex);
        }
        plan.calculate(plan.activeLateralLeg - 1);
        return true;
    }
    /**
     * Method to handle a remove leg request t.
     * @param plan is the flight plan.
     * @param airwayLegType is the airwayLegType returned from the checkIfAirwayLeg method.
     * @param segmentIndex The segment we are removing from.
     * @param index is the leg index in the segment we are removing.
     * @returns whether this handler processed the remove request.
     */
    removeLegAirwayHandler(plan, airwayLegType, segmentIndex, index) {
        var _a, _b;
        switch (airwayLegType) {
            case AirwayLegType.ONROUTE:
                if (plan.getSegment(segmentIndex + 1).airway) {
                    const segment = plan.getSegment(segmentIndex);
                    const leg = segment.legs[segment.legs.length - 1].leg;
                    this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                    this.planAddLeg(segmentIndex + 1, leg);
                }
                this.removeAirway(segmentIndex);
                return true;
            case AirwayLegType.ENTRY:
                if (plan.getSegment(segmentIndex).segmentType === FlightPlanSegmentType.Enroute) {
                    const segment = plan.getSegment(segmentIndex + 1);
                    const leg = segment.legs[0].leg;
                    plan.removeLeg(segmentIndex + 1, 0);
                    this.planAddLeg(segmentIndex, leg);
                }
                else if (plan.getSegment(segmentIndex).segmentType === FlightPlanSegmentType.Departure) {
                    this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                    const segment = plan.getSegment(segmentIndex + 2);
                    const leg = segment.legs[0].leg;
                    plan.removeLeg(segmentIndex + 2, 0);
                    this.planAddLeg(segmentIndex + 1, leg);
                }
                return plan.removeLeg(segmentIndex, index) !== null ? true : false;
            case AirwayLegType.EXIT: {
                if (index < 1) {
                    this.removeAirway(segmentIndex);
                    return true;
                }
                else {
                    const segment = plan.getSegment(segmentIndex);
                    const airway = (_a = segment.airway) === null || _a === void 0 ? void 0 : _a.split('.');
                    segment.airway = airway && airway[0] ? airway[0] + '.' + segment.legs[index - 1].name : segment.airway;
                    plan.setAirway(segmentIndex, segment.airway);
                    return plan.removeLeg(segmentIndex, index) !== null ? true : false;
                }
            }
            case AirwayLegType.EXIT_ENTRY: {
                const segment = plan.getSegment(segmentIndex + 1);
                const leg = segment.legs[0].leg;
                this.planRemoveLeg(segmentIndex + 1, 0);
                if (index < 1) {
                    this.removeAirway(segmentIndex);
                }
                else {
                    plan.removeLeg(segmentIndex, index);
                    this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                    const firstAirwaySegment = plan.getSegment(segmentIndex);
                    const airway = (_b = firstAirwaySegment.airway) === null || _b === void 0 ? void 0 : _b.split('.');
                    firstAirwaySegment.airway = airway && airway[0] ? airway[0] + '.' + firstAirwaySegment.legs[index - 1].name : firstAirwaySegment.airway;
                    plan.setAirway(segmentIndex, firstAirwaySegment.airway);
                }
                this.planAddLeg(segmentIndex + 1, leg);
                return true;
            }
        }
        return false;
    }
    /**
     * Checks if a remove left an empty segment that also needs to be removed.
     * @param plan is the flight plan
     * @param segmentIndex The segment to add the leg to.
     * @returns whether to remove the segment.
     */
    checkIfRemoveLeftEmptySegmentToDelete(plan, segmentIndex) {
        const segment = plan.getSegment(segmentIndex);
        let nextSegment;
        if (segmentIndex < plan.segmentCount - 1) {
            nextSegment = plan.getSegment(segmentIndex + 1);
        }
        if (segment.legs.length < 1) {
            switch (segment.segmentType) {
                case FlightPlanSegmentType.Enroute:
                    if (nextSegment && nextSegment.segmentType === FlightPlanSegmentType.Enroute) {
                        return true;
                    }
                    break;
                //TODO: Add more cases as appropriate
            }
        }
        return false;
    }
    /**
     * Adds an appropriate origin or destination leg (either an airport or runway fix) to the primary flight plan. Origin
     * legs are added to the beginning of the specified segment. Destination legs are added to the end of the specified
     * segment.
     * @param isOrigin Whether to add an origin leg.
     * @param segmentIndex The index of the segment to which to add the leg.
     * @param airport The origin airport.
     * @param runway The origin runway.
     */
    planAddOriginDestinationLeg(isOrigin, segmentIndex, airport, runway) {
        let leg;
        if (runway) {
            leg = FmsUtils.buildRunwayLeg(airport, runway, isOrigin);
        }
        else {
            leg = FlightPlan.createLeg({
                lat: airport.lat,
                lon: airport.lon,
                type: isOrigin ? LegType.IF : LegType.TF,
                fixIcao: airport.icao,
                altitude1: airport.runways[0].elevation + UnitType.FOOT.convertTo(50, UnitType.METER)
            });
        }
        if (leg) {
            this.planAddLeg(segmentIndex, leg, isOrigin ? 0 : undefined);
            if (!isOrigin) {
                const plan = this.getFlightPlan();
                const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
                const lastEnrouteSegment = plan.getSegment(lastEnrouteSegmentIndex);
                for (let i = lastEnrouteSegment.legs.length - 1; i >= 0; i--) {
                    if (lastEnrouteSegment.legs[i].leg.fixIcao === airport.icao) {
                        this.planRemoveLeg(lastEnrouteSegmentIndex, i, true, true);
                    }
                }
            }
        }
    }
    /**
     * Method to add a segment to the flightplan.
     * @param segmentType is the FlightPlanSegmentType.
     * @param index is the optional segment index to insert the segment.
     * @returns the segment index of the inserted segment.
     */
    planInsertSegmentOfType(segmentType, index) {
        const plan = this.getFlightPlan();
        let segmentIndex = -1;
        if (index) {
            segmentIndex = index - 1;
        }
        else {
            const segments = [];
            for (const segment of plan.segments()) {
                segments.push(segment);
            }
            switch (segmentType) {
                case FlightPlanSegmentType.Origin:
                    break;
                case FlightPlanSegmentType.Departure:
                    segmentIndex = 0;
                    break;
                case FlightPlanSegmentType.Arrival:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Enroute;
                    }, 2);
                    break;
                case FlightPlanSegmentType.Approach:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Enroute || v.segmentType === FlightPlanSegmentType.Arrival;
                    }, 2);
                    break;
                case FlightPlanSegmentType.MissedApproach:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Approach;
                    }, 2);
                    break;
                case FlightPlanSegmentType.Destination:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Enroute || v.segmentType === FlightPlanSegmentType.Arrival
                            || v.segmentType === FlightPlanSegmentType.Approach;
                    }, 5);
                    break;
                default:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Enroute || v.segmentType === FlightPlanSegmentType.Arrival
                            || v.segmentType === FlightPlanSegmentType.Approach || v.segmentType === FlightPlanSegmentType.Destination;
                    }, 1);
                    segmentIndex--;
                    break;
            }
        }
        return this.planInsertSegment(segmentIndex + 1, segmentType).segmentIndex;
    }
    /**
     * Method to remove all legs from a segment.
     * @param segmentIndex is the index of the segment to delete all legs from.
     * @param segmentType is the type if segment to delete all legs from, if known.
     */
    planClearSegment(segmentIndex, segmentType) {
        this.planRemoveSegment(segmentIndex);
        this.planInsertSegment(segmentIndex, segmentType);
    }
    /**
     * Inserts a segment into the flight plan at the specified index and
     * reflows the subsequent segments.
     * @param segmentIndex The index to insert the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    planInsertSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
        const plan = this.getFlightPlan();
        const segment = plan.insertSegment(segmentIndex, segmentType, airway, notify);
        plan.calculate(plan.activeLateralLeg - 1);
        if (plan.directToData.segmentIndex >= 0 && segmentIndex <= plan.directToData.segmentIndex) {
            plan.setDirectToData(plan.directToData.segmentIndex + 1, plan.directToData.segmentLegIndex);
        }
        return segment;
    }
    /**
     * Removes a segment from the flight plan and reflows the segments following
     * the removed segment, not leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    planRemoveSegment(segmentIndex, notify = true) {
        const plan = this.getFlightPlan();
        const segment = plan.getSegment(segmentIndex);
        const activeSegmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
        if (plan.directToData.segmentIndex >= 0) {
            if (segmentIndex < plan.directToData.segmentIndex) {
                plan.setDirectToData(plan.directToData.segmentIndex - 1, plan.directToData.segmentLegIndex);
            }
            else if (segmentIndex === plan.directToData.segmentIndex) {
                plan.setDirectToData(-1);
            }
        }
        if (activeSegmentIndex === segmentIndex && !Simplane.getIsGrounded() && plan.length > 1) {
            const directIcao = plan.getLeg(plan.activeLateralLeg).leg.fixIcao;
            this.removeDirectToExisting();
            if (this.getDirectToState() !== DirectToState.TORANDOM) {
                this.buildRandomDirectTo(directIcao);
            }
        }
        plan.setLateralLeg(plan.activeLateralLeg - Utils.Clamp(plan.activeLateralLeg - segment.offset, 0, segment.legs.length));
        plan.removeSegment(segmentIndex, notify);
        plan.calculate(plan.activeLateralLeg - 1);
    }
    /**
     * Checks whether of two consecutive flight plan legs, the second is a duplicate of the first. The second leg is
     * considered a duplicate if and only if it is an IF, TF, or DF leg with the same terminator fix as the first leg,
     * which is also an IF, TF, or DF leg.
     * @param leg1 The first leg.
     * @param leg2 The second leg.
     * @returns whether the second leg is a duplicate of the first.
     */
    isDuplicateLeg(leg1, leg2) {
        if (leg2.type !== LegType.IF
            && leg2.type !== LegType.DF
            && leg2.type !== LegType.TF) {
            return false;
        }
        return (leg1.type === LegType.IF
            || leg1.type === LegType.TF
            || leg1.type === LegType.DF)
            && leg1.fixIcao === leg2.fixIcao;
    }
    /**
     * Checks whether of two consecutive flight plan legs, the second is an IF leg and is a duplicate of the first. The
     * IF leg is considered a duplicate if and only if its fix is the same as the fix at which the first leg terminates.
     * @param leg1 The first leg.
     * @param leg2 The second leg.
     * @returns whether the second leg is an duplicate IF leg of the first.
     */
    isDuplicateIFLeg(leg1, leg2) {
        if (leg2.type !== LegType.IF) {
            return false;
        }
        if (leg1.type !== LegType.TF
            && leg1.type !== LegType.DF
            && leg1.type !== LegType.RF
            && leg1.type !== LegType.CF
            && leg1.type !== LegType.AF
            && leg1.type !== LegType.IF) {
            return false;
        }
        return leg1.fixIcao === leg2.fixIcao;
    }
    /**
     * Merges two duplicate legs such that the new merged leg contains the fix type and altitude data from the source leg
     * and all other data is derived from the target leg.
     * @param target The target leg.
     * @param source The source leg.
     * @returns the merged leg.
     */
    mergeDuplicateLegData(target, source) {
        const merged = FlightPlan.createLeg(target);
        merged.fixTypeFlags |= source.fixTypeFlags;
        merged.altDesc = source.altDesc;
        merged.altitude1 = source.altitude1;
        merged.altitude2 = source.altitude2;
        return merged;
    }
    /**
     * Deletes one of two consecutive duplicate legs. If one leg is in a procedure and the other is not, the leg that is
     * not in a procedure will be deleted. If the legs are in different procedures, the earlier leg will be deleted.
     * Otherwise, the later leg will be deleted. If the deleted leg is the target leg of a direct to, the legs in the
     * direct to sequence will be copied and moved to immediately follow the duplicate leg that was not deleted.
     * @param leg1 The first duplicate leg.
     * @param leg2 The second duplicate leg.
     * @returns the leg that was deleted, or null if neither leg was deleted.
     * @throws Error if direct to legs could not be updated.
     */
    planRemoveDuplicateLeg(leg1, leg2) {
        const plan = this.getFlightPlan();
        const leg1Segment = plan.getSegmentFromLeg(leg1);
        const leg1Index = plan.getLegIndexFromLeg(leg1);
        const leg2Segment = plan.getSegmentFromLeg(leg2);
        const leg2Index = plan.getLegIndexFromLeg(leg2);
        if (!leg1Segment || !leg2Segment) {
            return null;
        }
        const isLeg1DirectToLeg = leg1.isInDirectToSequence;
        const isLeg2DirectToLeg = leg2.isInDirectToSequence;
        const dupDirectToLeg = isLeg1DirectToLeg ? leg1
            : isLeg2DirectToLeg ? leg2
                : null;
        if (dupDirectToLeg) {
            if (dupDirectToLeg.leg.type === LegType.IF) {
                // Technically this should never happen.
                return null;
            }
            else {
                // If one of the duplicates is the second leg in a direct to sequence, then the true duplicated leg is the
                // target leg of the DTO. In this case, we call this method with the DTO target leg replacing the DTO leg.
                const dtoTargetLeg = plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex];
                return isLeg1DirectToLeg ? this.planRemoveDuplicateLeg(dtoTargetLeg, leg2) : this.planRemoveDuplicateLeg(leg1, dtoTargetLeg);
            }
        }
        const isLeg1InProc = leg1Segment.segmentType !== FlightPlanSegmentType.Enroute;
        const isLeg2InProc = leg2Segment.segmentType !== FlightPlanSegmentType.Enroute;
        let toDeleteSegment;
        let toDeleteIndex;
        let toDeleteLeg;
        if (!isLeg1InProc && isLeg2InProc || (isLeg1InProc && isLeg2InProc && leg1Segment !== leg2Segment)) {
            toDeleteSegment = leg1Segment;
            toDeleteIndex = leg1Index - leg1Segment.offset;
            toDeleteLeg = leg1;
        }
        else {
            toDeleteSegment = leg2Segment;
            toDeleteIndex = leg2Index - leg2Segment.offset;
            leg1.leg = this.mergeDuplicateLegData(leg1.leg, leg2.leg);
            toDeleteLeg = leg2;
        }
        if (toDeleteIndex >= 0) {
            const dtoTargetLeg = plan.directToData.segmentIndex < 0 ? null : plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex];
            const needMoveDtoLegs = toDeleteLeg === dtoTargetLeg;
            if (needMoveDtoLegs) {
                const isDtoExistingActive = this.getDirectToState() === DirectToState.TOEXISTING;
                // If the removed leg was the target leg of a DTO existing, we need to shift the DTO legs to target the leg
                // that was not removed.
                const oldDiscoLeg = plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                const oldDtoLeg1 = plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                const oldDtoLeg2 = plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                if (!oldDtoLeg1 || !oldDtoLeg2 || !oldDiscoLeg) {
                    throw new Error(`Fms: Could not remove direct to legs starting at segment index ${plan.directToData.segmentIndex}, leg index ${plan.directToData.segmentLegIndex} during duplicate leg resolution.`);
                }
                const preservedLeg = toDeleteLeg === leg1 ? leg2 : leg1;
                const preservedLegIndex = plan.getLegIndexFromLeg(preservedLeg);
                const newTargetSegmentIndex = plan.getSegmentIndex(preservedLegIndex);
                const newTargetSegmentLegIndex = preservedLegIndex - plan.getSegment(newTargetSegmentIndex).offset;
                plan.setDirectToData(newTargetSegmentIndex, newTargetSegmentLegIndex);
                plan.addLeg(newTargetSegmentIndex, FlightPlan.createLeg(oldDiscoLeg.leg), newTargetSegmentLegIndex + 1, true);
                plan.addLeg(newTargetSegmentIndex, FlightPlan.createLeg(oldDtoLeg1.leg), newTargetSegmentLegIndex + 2, true);
                plan.addLeg(newTargetSegmentIndex, FlightPlan.createLeg(oldDtoLeg2.leg), newTargetSegmentLegIndex + 3, true);
                if (isDtoExistingActive) {
                    plan.setLateralLeg(preservedLegIndex + 3);
                }
            }
            const success = this.planRemoveLeg(toDeleteSegment.segmentIndex, toDeleteIndex, true, false, needMoveDtoLegs);
            if (success) {
                return toDeleteLeg;
            }
        }
        return null;
    }
    /**
     * Loads an approach frequency into the fms.
     * @param facility The airport facility.
     * @param approachIndex The approach Index.
     */
    loadApproachFrequency(facility, approachIndex) {
        this.approachFrequency.set(FmsUtils.getApproachFrequency(facility, approachIndex));
    }
    /**
     * Loads an approach frequency into the fms.
     * @param radioIndex The radio index to set (1 or 2).
     * @param forceNotify resets the subject to force a cross-instrument notification.
     */
    setLocFrequency(radioIndex, forceNotify = false) {
        const setActive = this.cdiSource.type === NavSourceType.Gps || this.cdiSource.index !== radioIndex;
        const approachFrequency = this.approachFrequency.get();
        if (forceNotify) {
            this.approachFrequency.set(undefined);
            this.approachFrequency.set(approachFrequency);
        }
        if (approachFrequency !== undefined && radioIndex > 0 && radioIndex < 3) {
            SimVar.SetSimVarValue(`K:NAV${radioIndex}_STBY_SET_HZ`, 'Hz', approachFrequency.freqMHz * 1000000);
            if (setActive) {
                SimVar.SetSimVarValue(`K:NAV${radioIndex}_RADIO_SWAP`, 'Bool', 1);
            }
        }
    }
    /**
     * Sets the approach details for the loaded approach and sends an event across the bus.
     * @param approachLoaded Whether an approach is loaded.
     * @param approachType The approach type.
     * @param approachRnavType The approach RNAV type.
     * @param approachIsActive Whether the approach is active.
     */
    setApproachDetails(approachLoaded, approachType, approachRnavType, approachIsActive) {
        const approachDetails = {
            approachLoaded: approachLoaded !== undefined ? approachLoaded : this.approachDetails.approachLoaded,
            approachType: approachType !== undefined ? approachType : this.approachDetails.approachType,
            approachRnavType: approachRnavType !== undefined ? approachRnavType : this.approachDetails.approachRnavType,
            approachIsActive: approachIsActive !== undefined ? approachIsActive : this.approachDetails.approachIsActive
        };
        if (approachDetails.approachIsActive && !approachDetails.approachLoaded) {
            this.checkApproachState();
            return;
        }
        if (approachDetails !== this.approachDetails) {
            this.approachDetails = approachDetails;
            Fms.g1000EvtPub.publishEvent('approach_details_set', this.approachDetails);
        }
    }
}
Fms.PRIMARY_PLAN_INDEX = 0;
Fms.DTO_RANDOM_PLAN_INDEX = 1;
Fms.PROC_PREVIEW_PLAN_INDEX = 2;

/** A FMA Mode Display Slot */
class FmaDisplaySlot extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.activeFailed = false;
        this.active = Subject.create('');
        this.el = FSComponent.createRef();
    }
    /** @inheritdoc */
    onAfterRender() {
        var _a;
        this.props.isFailed.sub((v) => {
            if (v) {
                this.activeFailed = true;
                this.onFailed(true);
            }
        });
        this.props.armed.sub(armed => this.currentArmedMode = armed);
        (_a = this.props.secondaryArmed) === null || _a === void 0 ? void 0 : _a.sub(armed => this.currentSecondaryArmedMode = armed);
        this.props.active.sub(this.onActiveChanged.bind(this));
    }
    /**
     * Called when the active mode changes to set the flash class if required.
     * @param active is the active mode.
     */
    onActiveChanged(active) {
        if (!this.activeFailed) {
            this.active.set(this.props.active.get());
            if (this.currentArmedMode === active || this.currentSecondaryArmedMode === active || this.isDualVerticalTransition(active)) {
                this.el.instance.classList.add('fma-slot-alert');
                clearTimeout(this.timeout);
                this.timeout = setTimeout(() => {
                    this.el.instance.classList.remove('fma-slot-alert');
                }, 10000);
            }
            else {
                this.el.instance.classList.remove('fma-slot-alert');
            }
        }
    }
    /**
     * Called when the active mode fails to set the flash class if required.
     * @param failed is if the mode failed.
     */
    onFailed(failed) {
        if (failed) {
            this.el.instance.classList.remove('fma-slot-alert');
            this.el.instance.classList.add('fma-slot-failed');
            clearTimeout(this.timeout);
            this.timeout = setTimeout(() => {
                this.el.instance.classList.remove('fma-slot-failed');
                this.activeFailed = false;
                this.onActiveChanged(this.props.active.get());
            }, 5000);
        }
    }
    /**
     * Checks whether the active mode transition is coming from a combined dual vertical armed mode.
     * @param active is the active mode.
     * @returns True if coming from a dual mode, false otherwise;
     */
    isDualVerticalTransition(active) {
        return (this.currentSecondaryArmedMode === 'GP/V' && (active === 'GP' || active === 'VPTH'))
            || (this.currentSecondaryArmedMode === 'GS/V' && (active === 'GS' || active === 'VPTH'));
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: this.props.class },
            FSComponent.buildComponent("span", { ref: this.el }, this.active)));
    }
}

/** A FMA Mode AP Slot */
class FmaApSlot extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.el = FSComponent.createRef();
        this.apLabel = Subject.create('');
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.isActive.sub(this.onActiveChanged.bind(this));
    }
    /**
     * Called when the autopilot is activated or deactivated.
     * @param active Whether or not the autopilot is active.
     */
    onActiveChanged(active) {
        clearTimeout(this.timeout);
        if (!active) {
            this.el.instance.classList.add('fma-ap-alert');
            this.timeout = setTimeout(() => {
                this.el.instance.classList.remove('fma-ap-alert');
                this.apLabel.set('');
            }, 10000);
        }
        else {
            this.apLabel.set('AP');
            this.el.instance.classList.remove('fma-ap-alert');
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { id: 'CenterBarBottomMiddle' },
            FSComponent.buildComponent("span", { ref: this.el }, this.apLabel)));
    }
}

/**
 * The PFD FMA.
 */
class Fma extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.apVerticalSpeedArrow = FSComponent.createRef();
        this.fromWptElement = FSComponent.createRef();
        this.toWptElement = FSComponent.createRef();
        this.iconComponentRef = FSComponent.createRef();
        this.planActive = false;
        this.distanceSubject = ComputedSubject.create(-1, (v) => {
            if (this.planActive && v > 0) {
                return v.toFixed(1);
            }
            else {
                return '_ _._ _';
            }
        });
        this.bearingSubject = ComputedSubject.create(-1, (v) => {
            if (this.planActive && v > 0) {
                return `${Math.round(v)}`.padStart(3, '0');
            }
            else {
                return '_ _ _';
            }
        });
        this.autopilotModes = {
            verticalActive: APVerticalModes.NONE,
            verticalArmed: APVerticalModes.NONE,
            verticalApproachArmed: APVerticalModes.NONE,
            verticalAltitudeArmed: APAltitudeModes.NONE,
            altitideCaptureArmed: false,
            altitideCaptureValue: 0,
            lateralActive: APLateralModes.NONE,
            lateralArmed: APLateralModes.NONE,
            lateralModeFailed: false,
        };
        this.selectedVs = 0;
        this.selectedFLC = 0;
        this.lateralActiveModeSubject = ComputedSubject.create(APLateralModes.NONE, (v) => {
            return this.getLateralActiveString(v);
        });
        this.lateralArmedModeSubject = ComputedSubject.create(APLateralModes.NONE, (v) => {
            return this.getLateralArmedString(v);
        });
        this.verticalActiveSubject = ComputedSubject.create(APVerticalModes.NONE, (v) => {
            return this.getVerticalActiveString(v);
        });
        this.verticalArmedSubject = Subject.create('');
        this.verticalApproachArmedSubject = Subject.create('');
        this.verticalValueSubject = Subject.create('');
        this.verticalValueUnitSubject = Subject.create('');
        this.vnavAltCapType = VNavAltCaptureType.None;
        this.vnavPathMode = VNavPathMode.None;
        this.approachMode = VNavApproachGuidanceMode.None;
        this.lateralModeFailed = Subject.create(false);
        this.verticalModeFailed = Subject.create(false);
        this.obsActive = false;
        this.obsValue = 0;
        this.flightDirectorOn = false;
        this.apMaster = Subject.create(false);
        this.fdNotInstalled = false;
        /**
         * A callback called when the FD State changes from the event bus.
         * @param fdState The current FD State value.
         */
        this.onFdChange = (fdState) => {
            this.flightDirectorOn = fdState;
            if (!this.flightDirectorOn) {
                this.lateralArmedModeSubject.set(APLateralModes.NONE);
                this.lateralActiveModeSubject.set(APLateralModes.NONE);
                this.verticalActiveSubject.set(APVerticalModes.NONE);
                this.verticalArmedSubject.set('');
                this.verticalApproachArmedSubject.set('');
                this.verticalValueSubject.set('');
                this.verticalValueUnitSubject.set('');
                this.apVerticalSpeedArrow.instance.style.display = 'none';
            }
        };
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        if (this.apVerticalSpeedArrow.instance !== null) {
            this.apVerticalSpeedArrow.instance.style.display = 'none';
        }
        const ap = this.props.bus.getSubscriber();
        const vnav = this.props.bus.getSubscriber();
        const fpl = this.props.bus.getSubscriber();
        const lnav = this.props.bus.getSubscriber();
        const g1000Events = this.props.bus.getSubscriber();
        ap.on('ap_master_engage').handle((engaged) => { engaged && !this.fdNotInstalled ? this.apMaster.set(true) : null; });
        ap.on('ap_master_disengage').handle((disengaged) => { disengaged ? this.apMaster.set(false) : null; });
        ap.on('flight_director_state').handle(this.onFdChange);
        ap.on('vs_hold_fpm').handle((vs) => {
            this.selectedVs = vs;
            this.handleVerticalValueChanged();
        });
        ap.on('flc_hold_knots').handle((flc) => {
            this.selectedFLC = flc;
            this.handleVerticalValueChanged();
        });
        vnav.on('vnavPathMode').whenChanged().handle(mode => this.onVNavUpdate(mode, this.vnavAltCapType, this.approachMode));
        vnav.on('vnavAltCaptureType').whenChanged().handle(type => this.onVNavUpdate(this.vnavPathMode, type, this.approachMode));
        vnav.on('vnavApproachMode').whenChanged().handle(mode => this.onVNavUpdate(this.vnavPathMode, this.vnavAltCapType, mode));
        fpl.on('fplActiveLegChange').handle((change) => {
            this.onLegChange(change);
        });
        fpl.on('fplIndexChanged').handle(() => {
            this.onLegChange();
        });
        fpl.on('fplLegChange').handle(() => {
            this.onLegChange();
        });
        lnav.on('lnavDis').whenChangedBy(0.1).handle((v) => {
            this.distanceSubject.set(v);
        });
        lnav.on('lnavBrgMag').whenChangedBy(1).handle((v) => {
            this.bearingSubject.set(v);
        });
        g1000Events.on('fma_modes').handle((v) => {
            this.autopilotModes = v;
            let verticalModeFailed = false;
            if (v.lateralModeFailed) {
                this.lateralModeFailed.set(true);
                const verticalMode = this.verticalActiveSubject.getRaw();
                if (verticalMode === APVerticalModes.GP || verticalMode === APVerticalModes.GS) {
                    verticalModeFailed = true;
                    this.verticalModeFailed.set(true);
                }
            }
            else {
                this.lateralModeFailed.set(false);
                this.verticalModeFailed.set(false);
            }
            if (!v.lateralModeFailed) {
                this.lateralActiveModeSubject.set(this.autopilotModes.lateralActive);
            }
            if (!verticalModeFailed) {
                this.verticalActiveSubject.set(this.autopilotModes.verticalActive);
            }
            this.lateralArmedModeSubject.set(this.autopilotModes.lateralArmed);
            this.verticalArmedSubject.set(this.getVerticalArmedString(this.autopilotModes.verticalArmed));
            this.verticalApproachArmedSubject.set(this.getVerticalApproachArmedString(this.autopilotModes.verticalApproachArmed));
            this.handleVerticalValueChanged();
        });
        g1000Events.on('fd_not_installed').handle(v => {
            this.fdNotInstalled = v;
            if (v) {
                this.apMaster.set(false);
            }
        });
        const nav = this.props.bus.getSubscriber();
        nav.on('gps_obs_active').whenChanged().handle((state) => {
            this.obsActive = state;
            this.onLegChange();
        });
        nav.on('gps_obs_value').whenChanged().handle((v) => {
            const value = Math.round(NavMath.normalizeHeading(v));
            this.obsValue = value === 0 ? 360 : value;
            this.onLegChange();
        });
    }
    /**
     * Gets the FMA display string from an AP Vertical Active Mode.
     * @param v The computed subject input value.
     * @returns the string to display on the FMA
     */
    getVerticalActiveString(v) {
        switch (v) {
            case APVerticalModes.VS:
                return 'VS';
            case APVerticalModes.FLC:
                return 'FLC';
            case APVerticalModes.ALT:
                return 'ALT';
            case APVerticalModes.GS:
                return 'GS';
            case APVerticalModes.VNAV:
                return 'VPTH';
            case APVerticalModes.GP:
                return 'GP';
            case APVerticalModes.PITCH:
                return 'PIT';
            case APVerticalModes.CAP: {
                const alt = this.autopilotModes.verticalAltitudeArmed;
                return alt === APAltitudeModes.ALTS ? 'ALTS' : alt === APAltitudeModes.ALTV ? 'ALTV' : 'ALT';
            }
            default:
                return ' ';
        }
    }
    /**
     * Gets the FMA display string from an AP Vertical Armed Mode.
     * @param v The computed subject input value.
     * @returns the string to display on the FMA
     */
    getVerticalArmedString(v) {
        if (this.autopilotModes.altitideCaptureArmed || this.autopilotModes.verticalActive === APVerticalModes.VNAV) {
            const alt = this.autopilotModes.verticalAltitudeArmed;
            return alt === APAltitudeModes.ALTS ? 'ALTS' : alt === APAltitudeModes.ALTV ? 'ALTV' : 'ALT';
        }
        switch (v) {
            case APVerticalModes.ALT:
                return 'ALT';
            case APVerticalModes.VNAV:
                if (this.vnavPathMode === VNavPathMode.PathArmed) {
                    return 'VPTH';
                }
                return ' ';
            default:
                return ' ';
        }
    }
    /**
     * Gets the FMA display string from an AP Vertical Approach Armed Mode.
     * @param v The computed subject input value.
     * @returns the string to display on the FMA
     */
    getVerticalApproachArmedString(v) {
        switch (v) {
            case APVerticalModes.GP:
                if (this.autopilotModes.altitideCaptureArmed && this.autopilotModes.verticalArmed === APVerticalModes.VNAV) {
                    return 'GP/V';
                }
                return 'GP';
            case APVerticalModes.GS:
                if (this.autopilotModes.altitideCaptureArmed && this.autopilotModes.verticalArmed === APVerticalModes.VNAV) {
                    return 'GS/V';
                }
                return 'GS';
            default:
                if (this.autopilotModes.altitideCaptureArmed && this.autopilotModes.verticalArmed === APVerticalModes.VNAV) {
                    return 'VPTH';
                }
                return ' ';
        }
    }
    /**
     * Gets the FMA display string from an AP Lateral Active Mode.
     * @param v The computed subject input value.
     * @returns the string to display on the FMA
     */
    getLateralActiveString(v) {
        switch (v) {
            case APLateralModes.HEADING:
                return 'HDG';
            case APLateralModes.LOC:
                return 'LOC';
            case APLateralModes.VOR:
                return 'VOR';
            case APLateralModes.GPSS:
                return 'GPS';
            case APLateralModes.ROLL:
                return 'ROL';
            case APLateralModes.LEVEL:
                return 'LVL';
            default:
                return '';
        }
    }
    /**
     * Gets the FMA display string from an AP Lateral Armed Mode.
     * @param v The computed subject input value.
     * @returns the string to display on the FMA
     */
    getLateralArmedString(v) {
        switch (v) {
            case APLateralModes.HEADING:
                return 'HDG';
            case APLateralModes.LOC:
                return 'LOC';
            case APLateralModes.VOR:
                return 'VOR';
            case APLateralModes.GPSS:
                return 'GPS';
            case APLateralModes.ROLL:
                return 'ROL';
            case APLateralModes.LEVEL:
                return 'LVL';
            case APLateralModes.BC:
                return 'BC';
            default:
                return '';
        }
    }
    /**
     * A callback called when the active VNAV path mode changes.
     * @param mode The new path mode.
     * @param type The new alt capture type.
     * @param approachMode The new approach mode.
     */
    onVNavUpdate(mode, type, approachMode) {
        this.vnavPathMode = mode;
        this.vnavAltCapType = type;
        this.approachMode = approachMode;
    }
    /**
     * Handles the vertical value subjects on inputs from the event bus.
     */
    handleVerticalValueChanged() {
        if (this.autopilotModes.verticalActive === APVerticalModes.VS) {
            const vsValue = Math.abs(this.selectedVs);
            this.verticalValueSubject.set(`${(vsValue)}`);
            this.verticalValueUnitSubject.set('FPM');
            if (this.selectedVs < -1) {
                this.apVerticalSpeedArrow.instance.style.display = '';
                this.apVerticalSpeedArrow.instance.setAttribute('transform', 'rotate(180,6,10)');
            }
            else if (this.selectedVs > 1) {
                this.apVerticalSpeedArrow.instance.style.display = '';
                this.apVerticalSpeedArrow.instance.setAttribute('transform', 'rotate(0,6,10)');
            }
            else {
                this.apVerticalSpeedArrow.instance.style.display = 'none';
            }
        }
        else if (this.autopilotModes.verticalActive === APVerticalModes.ALT || this.autopilotModes.verticalActive === APVerticalModes.CAP) {
            this.verticalValueSubject.set(`${(Math.round(this.autopilotModes.altitideCaptureValue))}`);
            this.verticalValueUnitSubject.set('FT');
            this.apVerticalSpeedArrow.instance.style.display = 'none';
        }
        else if (this.autopilotModes.verticalActive == APVerticalModes.FLC) {
            this.verticalValueSubject.set(`${(Math.round(this.selectedFLC))}`);
            this.verticalValueUnitSubject.set('KT');
            this.apVerticalSpeedArrow.instance.style.display = 'none';
        }
        else {
            this.apVerticalSpeedArrow.instance.style.display = 'none';
            this.verticalValueSubject.set('');
            this.verticalValueUnitSubject.set('');
        }
    }
    /**
     * A callback called when the flight plan changes.
     * @param change is the flightplanactivelegevent
     */
    onLegChange(change) {
        var _a, _b;
        const planIndex = this.props.planner.activePlanIndex;
        if (change && change.planIndex !== planIndex || !this.props.planner.hasFlightPlan(planIndex)) {
            return;
        }
        const plan = this.props.planner.getFlightPlan(planIndex);
        const legIndex = (_a = (change && change.index)) !== null && _a !== void 0 ? _a : plan.activeLateralLeg;
        const directToState = this.props.navController.fms.getDirectToState();
        const isDirectTo = directToState === DirectToState.TOEXISTING || directToState === DirectToState.TORANDOM ? true : false;
        if (change === undefined || (change !== undefined && change.type === ActiveLegType.Lateral)) {
            let toWpt = undefined;
            let fromWpt = '';
            let toLeg = undefined;
            if (plan.length > 0 && legIndex < plan.length) {
                this.planActive = true;
                toLeg = plan.getLeg(legIndex);
                toWpt = toLeg.name + this.getFixType(toLeg.leg.fixTypeFlags);
                if (legIndex > 0) {
                    const fromLeg = plan.getLeg(legIndex - 1);
                    if (fromLeg && fromLeg.name !== 'PPOS') {
                        fromWpt = plan.getLeg(legIndex - 1).name + this.getFixType(fromLeg.leg.fixTypeFlags);
                    }
                }
            }
            else {
                this.planActive = false;
            }
            if (toWpt === undefined) {
                toWpt = '';
            }
            if (toWpt === 'MANSEQ') {
                toWpt = 'man seq';
                let hdg = (_b = toLeg === null || toLeg === void 0 ? void 0 : toLeg.leg.course) !== null && _b !== void 0 ? _b : 0;
                hdg = NavMath.normalizeHeading(Math.round(hdg));
                hdg = hdg === 0 ? 360 : hdg;
                fromWpt = `hdg ${hdg.toString().padStart(3, '0')}°`;
            }
            if (this.toWptElement.instance !== null) {
                if (this.toWptElement.instance.textContent !== toWpt) {
                    this.toWptElement.instance.textContent = toWpt;
                }
            }
            if (this.obsActive) {
                fromWpt = `obs ${this.obsValue.toFixed(0).padStart(3, '0')}°`;
            }
            if (this.fromWptElement.instance !== null) {
                if (this.fromWptElement.instance.textContent !== fromWpt) {
                    this.fromWptElement.instance.textContent = fromWpt;
                }
            }
            if (this.iconComponentRef.instance !== null) {
                if (this.obsActive) {
                    this.iconComponentRef.instance.updateFmaIcon(true, false, LegType.TF, LegTurnDirection.None);
                }
                else if (toLeg !== undefined) {
                    this.iconComponentRef.instance.updateFmaIcon(true, isDirectTo, toLeg.leg.type, toLeg.leg.turnDirection);
                }
                else {
                    this.iconComponentRef.instance.updateFmaIcon(false);
                }
            }
        }
    }
    /**
     * Returns the fix type string from the flag.
     * @param fixTypeFlag is the flag.
     * @returns a string.
     */
    getFixType(fixTypeFlag) {
        switch (fixTypeFlag) {
            case FixTypeFlags.FAF:
                return ' faf';
            case FixTypeFlags.IAF:
                return ' iaf';
            case FixTypeFlags.MAP:
                return ' map';
        }
        return '';
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { id: "NavComBoxCenter" },
            FSComponent.buildComponent("div", { id: "CenterBarTopLeft" },
                FSComponent.buildComponent("span", { ref: this.fromWptElement, class: "dataField" }),
                FSComponent.buildComponent(FmaLegIcon, { ref: this.iconComponentRef }),
                FSComponent.buildComponent("span", { ref: this.toWptElement, class: "dataField" }),
                FSComponent.buildComponent(WaypointAlerter, { bus: this.props.bus })),
            FSComponent.buildComponent("div", { id: "CenterBarTopRight" },
                FSComponent.buildComponent("div", { class: 'FixDist smallText' }, "DIS"),
                FSComponent.buildComponent("div", { class: 'FixDistValue dataField' },
                    FSComponent.buildComponent("span", null, this.distanceSubject),
                    FSComponent.buildComponent("span", { class: 'smallText' }, "NM")),
                FSComponent.buildComponent("div", { class: 'FixBrg smallText' }, "BRG"),
                FSComponent.buildComponent("div", { class: 'FixBrgValue dataField' },
                    FSComponent.buildComponent("span", null, this.bearingSubject),
                    FSComponent.buildComponent("span", null, "\u00B0"))),
            FSComponent.buildComponent("div", { id: "CenterBarBottomLeft" },
                FSComponent.buildComponent("div", { class: 'lateral-armed-mode' }, this.lateralArmedModeSubject),
                FSComponent.buildComponent(FmaDisplaySlot, { class: 'lateral-active-mode', armed: this.lateralArmedModeSubject, active: this.lateralActiveModeSubject, isFailed: this.lateralModeFailed })),
            FSComponent.buildComponent(FmaApSlot, { isActive: this.apMaster }),
            FSComponent.buildComponent("div", { class: "fma-ap-vertical-modes" },
                FSComponent.buildComponent(FmaDisplaySlot, { class: 'activeVerticalMode', armed: this.verticalArmedSubject, secondaryArmed: this.verticalApproachArmedSubject, active: this.verticalActiveSubject, isFailed: this.verticalModeFailed }),
                FSComponent.buildComponent("div", { class: 'verticalModeArrow' },
                    FSComponent.buildComponent("svg", { width: '12', height: '22' },
                        FSComponent.buildComponent("path", { ref: this.apVerticalSpeedArrow, d: "M 6 18 l -1 0 l 0 -12 l -3 3 l -1.333 -1.344 l 5.333 -5.656 l 5.333 5.656 l -1.333 1.344 l -3 -3 l 0 12 z", fill: "rgb(0, 255, 0)" }))),
                FSComponent.buildComponent("div", { class: 'verticalModeValue' }, this.verticalValueSubject),
                FSComponent.buildComponent("div", { class: 'verticalModeUnits' }, this.verticalValueUnitSubject),
                FSComponent.buildComponent("div", { class: 'right' }, this.verticalArmedSubject),
                FSComponent.buildComponent("div", { class: 'right' }, this.verticalApproachArmedSubject))));
    }
}

/**
 * The PFD attitude indicator.
 */
class Transponder extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.xpdrCodeElement = FSComponent.createRef();
        this.xpdrModeElement = FSComponent.createRef();
        this.xpdrIdentElement = FSComponent.createRef();
        this.codeEdit = {
            editMode: false,
            charIndex: 0,
            tempCode: ''
        };
        this.xpdrCodeSubject = ComputedSubject.create(0, (v) => {
            return `${Math.round(v)}`.padStart(4, '0');
        });
        this.xpdrModeSubject = ComputedSubject.create(XPDRMode.OFF, (v) => {
            switch (v) {
                case XPDRMode.OFF:
                    return 'OFF';
                case XPDRMode.STBY:
                    return 'STBY';
                case XPDRMode.ON:
                    return 'ON';
                case XPDRMode.ALT:
                    return 'ALT';
                case XPDRMode.GROUND:
                    return 'GND';
            }
            return 'XXX';
        });
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        const xpdr = this.props.bus.getSubscriber();
        xpdr.on('xpdrCode1')
            .whenChanged().handle(this.onXpdrCodeSimUpdate.bind(this));
        xpdr.on('xpdrMode1')
            .whenChanged().handle(this.onXpdrModeUpdate.bind(this));
        xpdr.on('xpdrIdent').whenChanged().handle((isSending) => {
            this.xpdrIdentElement.instance.classList.toggle('hide-element', !isSending);
            this.xpdrModeElement.instance.classList.toggle('hide-element', isSending);
        });
        const g1000ControlEvents = this.props.bus.getSubscriber();
        g1000ControlEvents.on('xpdr_code_push')
            .handle(this.updateCodeEdit.bind(this));
        g1000ControlEvents.on('xpdr_code_digit')
            .handle(this.editCode.bind(this));
    }
    /**
     * A method called when the soft menu sends a G1000 Control Event to edit the xpdr code.
     * @param edit is a bool of whether to edit the code or stop editing the code.
     */
    updateCodeEdit(edit) {
        if (edit && this.xpdrCodeElement.instance !== null) {
            this.codeEdit.editMode = true;
            this.codeEdit.tempCode = '   ';
            if (this.xpdrModeSubject.getRaw() === XPDRMode.STBY || this.xpdrModeSubject.getRaw() === XPDRMode.OFF) {
                this.xpdrCodeElement.instance.classList.add('highlight-white');
            }
            else {
                this.xpdrCodeElement.instance.classList.remove('green', 'white', 'grey');
                this.xpdrCodeElement.instance.classList.add('highlight-green');
            }
        }
        else if (!edit && this.xpdrCodeElement.instance !== null) {
            this.codeEdit.editMode = false;
            this.codeEdit.tempCode = '';
            this.xpdrCodeElement.instance.classList.remove('highlight-green');
            this.xpdrCodeElement.instance.classList.remove('highlight-white');
            this.onXpdrModeUpdate(this.xpdrModeSubject.getRaw());
        }
    }
    /**
     * A method called when the soft menu sends a digit from the xpdr code menu via the g1000 event bus.
     * @param value is the digit sent (0-7; -1 is a backspace).
     */
    editCode(value) {
        let updatedTempCode = this.codeEdit.tempCode;
        if (value == -1 && this.codeEdit.charIndex > 0) {
            updatedTempCode = updatedTempCode.substring(0, this.codeEdit.charIndex);
            this.codeEdit.charIndex--;
        }
        else if (value >= 0) {
            updatedTempCode = updatedTempCode + `${value}`;
            this.codeEdit.charIndex++;
        }
        if (this.codeEdit.charIndex == 4) {
            this.props.controlPublisher.publishEvent('publish_xpdr_code', parseInt(updatedTempCode));
            this.codeEdit.charIndex = 0;
            this.updateCodeEdit(false);
        }
        else {
            this.codeEdit.tempCode = updatedTempCode;
            this.onXpdrCodeUpdate(parseInt(this.codeEdit.tempCode));
        }
    }
    /**
     * A method called when the navcom publisher sends a new xpdr code.
     * @param code is the new xpdr code
     */
    onXpdrCodeSimUpdate(code) {
        this.onXpdrCodeUpdate(code);
    }
    /**
     * A method called to update the displayed xpdr code.
     * @param code is the new xpdr code
     */
    onXpdrCodeUpdate(code) {
        this.xpdrCodeSubject.set(code);
    }
    /**
     * A method called when the navcom publisher sends a new xpdr code.
     * @param mode is the new xpdr code
     */
    onXpdrModeUpdate(mode) {
        if (this.xpdrModeElement.instance !== null && this.xpdrCodeElement.instance !== null) {
            this.xpdrModeSubject.set(mode);
            this.xpdrModeElement.instance.classList.remove('green', 'white', 'grey');
            this.xpdrCodeElement.instance.classList.remove('green', 'white', 'grey');
            switch (mode) {
                case XPDRMode.OFF:
                    this.xpdrModeElement.instance.classList.add('grey');
                    this.xpdrCodeElement.instance.classList.add('grey');
                    break;
                case XPDRMode.STBY:
                    this.xpdrModeElement.instance.classList.add('white');
                    this.xpdrCodeElement.instance.classList.add('white');
                    break;
                case XPDRMode.ON:
                case XPDRMode.ALT:
                case XPDRMode.GROUND:
                    this.xpdrModeElement.instance.classList.add('green');
                    this.xpdrCodeElement.instance.classList.add('green');
                    break;
            }
        }
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "xpdr-container" },
            FSComponent.buildComponent("div", { class: 'small-text' }, "XPDR "),
            FSComponent.buildComponent("div", { ref: this.xpdrCodeElement, class: 'size20' }, this.xpdrCodeSubject),
            FSComponent.buildComponent("div", { ref: this.xpdrModeElement, class: 'size20' },
                "\u00A0",
                this.xpdrModeSubject),
            FSComponent.buildComponent("div", { ref: this.xpdrIdentElement, class: 'size20 green hide-element' }, " Ident")));
    }
}

/**
 * The PFD attitude indicator.
 */
class BottomInfoPanel extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.oatValue = Subject.create(13);
        this.utcTimeStr = Subject.create('19:38:12');
        this.timerStr = Subject.create('0:00:00');
        this.hdg = 0;
        this.bearingPointerAdf = [false, false];
        this.bearingPointerDirection = [null, null];
        this.bearing1Container = FSComponent.createRef();
        this.bearing2Container = FSComponent.createRef();
        this.bearing1SrcElement = FSComponent.createRef();
        this.bearing2SrcElement = FSComponent.createRef();
        this.bearing1DistElement = FSComponent.createRef();
        this.bearing1DistUnits = FSComponent.createRef();
        this.bearing2DistElement = FSComponent.createRef();
        this.bearing2DistUnits = FSComponent.createRef();
        this.bearing1DirElement = FSComponent.createRef();
        this.bearing2DirElement = FSComponent.createRef();
        this.bearing1IdentElement = FSComponent.createRef();
        this.bearing2IdentElement = FSComponent.createRef();
        /**
         * A callback called when the UTC time updates from the event bus.
         * @param utcTime The current utcTime value.
         */
        this.onUtcUpdate = (utcTime) => {
            const seconds = Math.round(utcTime);
            const time = Utils.SecondsToDisplayTime(seconds, true, true, false);
            this.utcTimeStr.set(time);
        };
        /**
         * A callback called when the pitch updates from the event bus.
         * @param temp The current pitch value.
         */
        this.onUpdateOAT = (temp) => {
            this.oatValue.set(temp);
        };
        /**
         * Handle an updated bearing source.
         * @param data The new bearing source info.
         */
        this.onUpdateBearingSrc = (data) => {
            var _a;
            let newLabel = '';
            let updateItem;
            switch ((_a = data.source) === null || _a === void 0 ? void 0 : _a.type) {
                case NavSourceType.Nav:
                    this.bearingPointerAdf[data.index] = false;
                    newLabel = `NAV${data.source.index}`;
                    break;
                case NavSourceType.Gps:
                    this.bearingPointerAdf[data.index] = false;
                    newLabel = 'GPS';
                    break;
                case NavSourceType.Adf:
                    this.bearingPointerAdf[data.index] = true;
                    newLabel = 'ADF';
                    break;
                default:
                    this.bearingPointerAdf[data.index] = false;
                    newLabel = '';
            }
            const direction = this.bearingPointerDirection[data.index];
            if (direction !== null) {
                this.onUpdateBearingDir({ index: data.index, direction: direction });
            }
            switch (data.index) {
                case 0:
                    updateItem = this.bearing1SrcElement;
                    break;
                case 1:
                    updateItem = this.bearing2SrcElement;
                    break;
                default:
                    updateItem = null;
            }
            if (updateItem && updateItem.instance !== null) {
                updateItem.instance.textContent = newLabel;
            }
            if (newLabel == '' && (updateItem === null || updateItem === void 0 ? void 0 : updateItem.instance) !== null) {
                this.onShowBearingDataElement(false, data.index);
            }
            else if (newLabel != '' && (updateItem === null || updateItem === void 0 ? void 0 : updateItem.instance) !== null) {
                this.onShowBearingDataElement(true, data.index);
            }
        };
        /**
         * Handle hiding or showing the entire bearing needle data element.
         * @param display Whether to show thhe bearing needle data element or not.
         * @param index is the index of the bearing source
         */
        this.onShowBearingDataElement = (display, index) => {
            const instance = index == 0 ? this.bearing1Container.instance : index == 1 ? this.bearing2Container.instance : null;
            if (instance !== null && display) {
                instance.style.display = '';
            }
            else if (instance !== null && !display) {
                instance.style.display = 'none';
            }
        };
        /**
         * Handle an updated bearing distance.
         * @param data The BearingDistance message.
         */
        this.onUpdateBearingDist = (data) => {
            let element = undefined;
            let element2 = undefined;
            switch (data.index) {
                case 0:
                    element = this.bearing1DistElement;
                    element2 = this.bearing1DistUnits;
                    break;
                case 1:
                    element = this.bearing2DistElement;
                    element2 = this.bearing2DistUnits;
                    break;
            }
            if (element !== undefined && element2 !== undefined && element.instance !== null && element2.instance !== null) {
                element.instance.textContent = data.distance == null ? '' : data.distance.toFixed(1);
                element2.instance.textContent = data.distance == null ? '' : 'NM';
            }
        };
        /**
         * Handle an updated bearing heading..
         * @param data The BearingDirection message.
         */
        this.onUpdateBearingDir = (data) => {
            this.bearingPointerDirection[data.index] = data.direction;
            let element = undefined;
            switch (data.index) {
                case 0:
                    element = this.bearing1DirElement;
                    break;
                case 1:
                    element = this.bearing2DirElement;
                    break;
            }
            if (element !== undefined && element.instance !== null) {
                let direction = data.direction;
                if (this.bearingPointerAdf[data.index] && data.direction !== null) {
                    direction = NavMath.normalizeHeading(data.direction + this.hdg);
                }
                element.instance.textContent = direction == null ? '' : direction.toFixed(0).padStart(3, '0') + '°';
            }
        };
        /**
         * Handle an updated bearing ident.
         * @param data The BearingIdent message.
         */
        this.onUpdateBearingIdent = (data) => {
            let element = undefined;
            switch (data.index) {
                case 0:
                    element = this.bearing1IdentElement;
                    break;
                case 1:
                    element = this.bearing2IdentElement;
                    break;
            }
            if (element !== undefined && element.instance !== null) {
                element.instance.textContent = data.isLoc ? 'ILS' : data.ident == null ? ' _ _ _ _ _ _' : '' + data.ident + '';
            }
        };
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        const adc = this.props.bus.getSubscriber();
        const gnss = this.props.bus.getSubscriber();
        const g1000 = this.props.bus.getSubscriber();
        adc.on('ambient_temp_c')
            .withPrecision(0)
            .handle(this.onUpdateOAT);
        adc.on('hdg_deg')
            .withPrecision(0)
            .handle((h) => { this.hdg = h; });
        gnss.on('zulu_time')
            .withPrecision(0)
            .whenChangedBy(1)
            .handle(this.onUtcUpdate);
        g1000.on('timer_value')
            .whenChangedBy(1)
            .handle((time) => {
            this.timerStr.set(Utils.SecondsToDisplayDuration(time, true, true, true));
        });
        const nav = this.props.bus.getSubscriber();
        nav.on('brg_source').whenChanged().handle(this.onUpdateBearingSrc);
        nav.on('brg_distance').handle(this.onUpdateBearingDist);
        nav.on('brg_direction').handle(this.onUpdateBearingDir);
        nav.on('brg_ident').whenChanged().handle(this.onUpdateBearingIdent);
        if (this.bearing1Container.instance !== null && this.bearing2Container.instance !== null) {
            this.bearing1Container.instance.style.display = 'none';
            this.bearing2Container.instance.style.display = 'none';
        }
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "bottom-info-panel" },
            FSComponent.buildComponent("div", { class: "bip-temp-box" },
                FSComponent.buildComponent("div", { class: "bip-oat" },
                    FSComponent.buildComponent("div", { class: "bip-oat-label" },
                        FSComponent.buildComponent("span", { class: 'size16' }, "OAT")),
                    FSComponent.buildComponent("div", { class: "bip-oat-value" },
                        FSComponent.buildComponent("span", null,
                            this.oatValue,
                            "\u00B0"),
                        FSComponent.buildComponent("span", { class: 'size16' }, "C")))),
            FSComponent.buildComponent("div", { class: "bip-middle" },
                FSComponent.buildComponent("svg", { viewBox: "0 0 721 55" },
                    FSComponent.buildComponent("defs", null,
                        FSComponent.buildComponent("linearGradient", { id: "gradientBottom", x1: "0%", y1: "0%", x2: "0%", y2: "100%" },
                            FSComponent.buildComponent("stop", { offset: "0%", style: "stop-color:rgb(24,24,24);stop-opacity:1" }),
                            FSComponent.buildComponent("stop", { offset: "100%", style: "stop-color:rgb(0,0,0);stop-opacity:1" }))),
                    FSComponent.buildComponent("path", { d: "M 0 0 l 258 0 a 147 147 0 0 0 204 0 l 260 0 l 0 55 l -722 0 l 0 -55 z", fill: "url(#gradientBottom)" })),
                FSComponent.buildComponent("div", { class: "left-brg-ptr-container", ref: this.bearing1Container },
                    FSComponent.buildComponent("div", { class: "left-brg-ptr-dist" },
                        FSComponent.buildComponent("span", { ref: this.bearing1DistElement }),
                        FSComponent.buildComponent("span", { ref: this.bearing1DistUnits, class: "size14" })),
                    FSComponent.buildComponent("div", { class: "left-brg-ptr-crs-ident" },
                        FSComponent.buildComponent("span", { class: "left-brg-ptr-crs", ref: this.bearing1DirElement }),
                        FSComponent.buildComponent("span", { class: "left-brg-ptr-ident", ref: this.bearing1IdentElement })),
                    FSComponent.buildComponent("div", { class: "left-brg-ptr-src", ref: this.bearing1SrcElement }),
                    FSComponent.buildComponent("div", { class: "left-brg-ptr-svg" },
                        FSComponent.buildComponent("svg", { width: "19", height: "10" },
                            FSComponent.buildComponent("path", { d: "M 0 4 l 18 0 m -10 -4 l -4 4 l 4 4", fill: "none", stroke: "cyan", "stroke-width": "1.0px" })))),
                FSComponent.buildComponent("div", { class: "right-brg-ptr-container", ref: this.bearing2Container },
                    FSComponent.buildComponent("div", { class: "right-brg-ptr-dist" },
                        FSComponent.buildComponent("span", { ref: this.bearing2DistElement }),
                        FSComponent.buildComponent("span", { ref: this.bearing2DistUnits, class: "size14" })),
                    FSComponent.buildComponent("div", { class: "right-brg-ptr-crs-ident" },
                        FSComponent.buildComponent("span", { class: "right-brg-ptr-ident", ref: this.bearing2IdentElement }),
                        FSComponent.buildComponent("span", { class: "right-brg-ptr-crs", ref: this.bearing2DirElement })),
                    FSComponent.buildComponent("div", { class: "right-brg-ptr-src", ref: this.bearing2SrcElement }),
                    FSComponent.buildComponent("div", { class: "right-brg-ptr-svg" },
                        FSComponent.buildComponent("svg", { width: "19", height: "10" },
                            FSComponent.buildComponent("path", { d: "M 0 4 l 3 0 m 12 0 l 4 0 m -8 -4 l 4 4 l -4 4 m 2 -6 l -10 0 l 0 4 l 10 0", fill: "none", stroke: "cyan", "stroke-width": "1.0px" }))))),
            FSComponent.buildComponent(Transponder, { bus: this.props.bus, controlPublisher: this.props.controlPublisher }),
            FSComponent.buildComponent("div", { class: "bip-time" },
                FSComponent.buildComponent("div", { class: 'size16' }, "TMR"),
                FSComponent.buildComponent("div", { class: 'size20' }, this.timerStr),
                FSComponent.buildComponent("div", { class: 'size16' }, "UTC"),
                FSComponent.buildComponent("div", { class: 'size20' }, this.utcTimeStr))));
    }
}

const G1000Config = new NavComConfig();
G1000Config.navSwitchEvents.set('AS1000_PFD_NAV_Switch', 'PFD');
G1000Config.navSwitchEvents.set('AS1000_MFD_NAV_Switch', 'MFD');
G1000Config.navSelectorEvents.set('AS1000_PFD_NAV_Push', 'PFD');
G1000Config.navSelectorEvents.set('AS1000_MFD_NAV_Push', 'MFD');
G1000Config.navWholeIncEvents.set('AS1000_PFD_NAV_Large_INC', 'PFD');
G1000Config.navWholeIncEvents.set('AS1000_MFD_NAV_Large_INC', 'MFD');
G1000Config.navWholeDecEvents.set('AS1000_PFD_NAV_Large_DEC', 'PFD');
G1000Config.navWholeDecEvents.set('AS1000_MFD_NAV_Large_DEC', 'MFD');
G1000Config.navFractionIncEvents.set('AS1000_PFD_NAV_Small_INC', 'PFD');
G1000Config.navFractionIncEvents.set('AS1000_MFD_NAV_Small_INC', 'MFD');
G1000Config.navFractionDecEvents.set('AS1000_PFD_NAV_Small_DEC', 'PFD');
G1000Config.navFractionDecEvents.set('AS1000_MFD_NAV_Small_DEC', 'MFD');
G1000Config.comSwitchEvents.set('AS1000_PFD_COM_Switch', 'PFD');
G1000Config.comSwitchEvents.set('AS1000_MFD_COM_Switch', 'MFD');
G1000Config.comSelectorEvents.set('AS1000_PFD_COM_Push', 'PFD');
G1000Config.comSelectorEvents.set('AS1000_MFD_COM_Push', 'MFD');
G1000Config.comWholeIncEvents.set('AS1000_PFD_COM_Large_INC', 'PFD');
G1000Config.comWholeIncEvents.set('AS1000_MFD_COM_Large_INC', 'MFD');
G1000Config.comWholeDecEvents.set('AS1000_PFD_COM_Large_DEC', 'PFD');
G1000Config.comWholeDecEvents.set('AS1000_MFD_COM_Large_DEC', 'MFD');
G1000Config.comFractionIncEvents.set('AS1000_PFD_COM_Small_INC', 'PFD');
G1000Config.comFractionIncEvents.set('AS1000_MFD_COM_Small_INC', 'MFD');
G1000Config.comFractionDecEvents.set('AS1000_PFD_COM_Small_DEC', 'PFD');
G1000Config.comFractionDecEvents.set('AS1000_MFD_COM_Small_DEC', 'MFD');

/**
 * A configuration for the G1000 NavProcessor, including a custrom simvar
 * publisher configured with your LNav simvars for GPS data publishing.
 */
class NPConfig extends NavProcessorConfig {
    /**
     * Create an NPConfig.
     * @param bus The event bus
     * @param planner A flight planner for LNav data
     */
    constructor(bus, planner) {
        super();
        this.numGps = 0;
        this.numAdf = 1;
        this.courseIncEvents.add('AS1000_PFD_CRS_INC');
        this.courseIncEvents.add('AS1000_MFD_CRS_INC');
        this.courseDecEvents.add('AS1000_PFD_CRS_DEC');
        this.courseDecEvents.add('AS1000_MFD_CRS_DEC');
        this.additionalSources.push(new LNavNavSource(bus, planner));
    }
}
/** A custom nav data source that provides info from our flight plan manager. */
class LNavNavSource {
    /**
     * Create an LNavNavSource.
     * @param bus An event bus.
     * @param planner The flight planner.
     */
    constructor(bus, planner) {
        this.srcId = { type: NavSourceType.Gps, index: 1 };
        this.hasCdi = true;
        this.hasDme = true;
        this.hasGlideslope = false;
        this.hasLocalizer = false;
        this.signal = null;
        this.activeCdi = false;
        this.isLocalizerFrequency = false;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.validHander = (valid, source) => { };
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.identHandler = (ident, source) => { };
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.brgHandler = (brg, source) => { };
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.distHandler = (dist, source) => { };
        this._activeForCount = 0;
        this._dist = null;
        this._brg = null;
        this._ident = null;
        this._valid = false;
        this.planner = planner;
        const fpl = bus.getSubscriber();
        const lnav = bus.getSubscriber();
        fpl.on('fplActiveLegChange').handle((change) => {
            this.onLegChange(change);
        });
        lnav.on('lnavDis').withPrecision(1).handle((dist) => {
            this.distance = dist;
        });
        lnav.on('lnavBrgMag').whenChangedBy(1).handle((brg) => {
            this.bearing = brg;
        });
    }
    /**
     * Get the validity of the source.
     * @returns Whether the source is valid.
     */
    get valid() {
        return this._valid;
    }
    /**
     * Set the validity of the source.
     * @param valid Whether the source is valid.
     */
    set valid(valid) {
        this._valid = valid;
        this.validHander(this.valid, this.srcId);
    }
    /**
     * Get the distance to the active waypoint.
     * @returns The distance in nm or null.
     */
    get distance() {
        return this._dist;
    }
    /**
     * Set the tistance to the active waypoint.
     * @param dist The distance in nm or null.
     */
    set distance(dist) {
        this._dist = dist;
        this.activeBrg && this.distHandler(this.distance, this.srcId);
    }
    /**
     * Get the bearing to the current waypoint.
     * @returns The bearing in degrees or null.
     */
    get bearing() {
        return this._brg;
    }
    /**
     * Set the bearing to the current waypoint.
     * @param brg The bearing in degrees.
     */
    set bearing(brg) {
        this._brg = brg;
        this.activeBrg && this.brgHandler(this.bearing, this.srcId);
    }
    /**
     * Get the ident of the current waypoint.
     * @returns The ident as a string or null.
     */
    get ident() {
        return this._ident;
    }
    /**
     * Set the ident of the current waypoint.
     * @param ident The ident as a string or null.
     */
    set ident(ident) {
        this._ident = ident;
        if (ident === null) {
            this.valid = false;
        }
        else {
            this.valid = true;
        }
        this.activeBrg && this.identHandler(this.ident, this.srcId);
    }
    /**
     * Get active bearing status.
     * @returns Whether we are active for bearing data.
     */
    get activeBrg() {
        return this._activeForCount > 0;
    }
    /**
     * Set active bearing status.
     */
    set activeBrg(active) {
        if (active) {
            this._activeForCount++;
        }
        else if (this._activeForCount > 0) {
            this._activeForCount--;
        }
        if (!this.activeBrg) {
            this.brgHandler(null, this.srcId);
            this.distHandler(null, this.srcId);
            this.identHandler(null, this.srcId);
        }
        else {
            this.brgHandler(this.bearing, this.srcId);
            this.distHandler(this.distance, this.srcId);
            // See if we need to update our ident info before displaying.
            const plan = this.planner.hasActiveFlightPlan() ? this.planner.getActiveFlightPlan() : undefined;
            if (plan && plan.length > 0 && plan.activeLateralLeg < plan.length) {
                const ident = plan.getLeg(plan.activeLateralLeg).name;
                if (ident) {
                    this.ident = ident;
                }
            }
            this.identHandler(this.ident, this.srcId);
        }
    }
    /**
     * Handle a change in the active leg.
     * @param change The change event.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onLegChange(change) {
        const plan = this.planner.getActiveFlightPlan();
        if (plan.length > 0 && plan.activeLateralLeg < plan.length) {
            const leg = plan.getLeg(plan.activeLateralLeg);
            this.ident = leg.name ? leg.name : null;
        }
    }
}

/**
 * The Scrollbar.
 */
class ScrollBar extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
        this.scrollBarRef = FSComponent.createRef();
        this.scrollThumbRef = FSComponent.createRef();
        this.scrollBarContainerRef = FSComponent.createRef();
        this.scrollableContainer = null;
        this.scrollListener = this.onScroll.bind(this);
        this.sizeChangeTimer = null;
        this.arrowPadding = 6;
        this._containerScrollHeight = 0;
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        if (this.scrollBarContainerRef.instance !== null) {
            this.scrollableContainer = this.scrollBarContainerRef.instance.previousElementSibling;
            if (this.scrollableContainer !== null) {
                // bind scroll event
                this.scrollableContainer.addEventListener('scroll', this.scrollListener);
            }
            // HINT: ResizeObserver doesn't exist in Coherent. MutationObserver doesn't perform well.
            // So we do this crap
            /**
             * Checks if the scrollheight of the container has changed and calls adjust
             */
            const diffAndAdjust = () => {
                var _a;
                if (this._containerScrollHeight !== ((_a = this.scrollableContainer) === null || _a === void 0 ? void 0 : _a.scrollHeight)) {
                    this.adjustScrollbarDimensions();
                }
            };
            this.sizeChangeTimer = setInterval(diffAndAdjust, 150);
        }
        this.onScroll();
    }
    /**
     * Adjusts the dimensions of the scrollbar elements.
     * @private
     */
    adjustScrollbarDimensions() {
        if (this.scrollableContainer) {
            const parentTop = this.scrollableContainer.offsetTop;
            this.scrollBarContainerRef.instance.style.top = `${parentTop + 4}px`;
            this._containerScrollHeight = this.scrollableContainer.scrollHeight;
            const containerHeight = this.scrollableContainer.clientHeight;
            const scrollToClientRatio = (this._containerScrollHeight / this.scrollableContainer.clientHeight);
            if (this.scrollThumbRef.instance !== null) {
                this.scrollThumbRef.instance.style.height = `${containerHeight / scrollToClientRatio}`.toString();
            }
            this.scrollBarContainerRef.instance.style.height = `${containerHeight}px`;
            this.svgRef.instance.setAttribute('height', `${containerHeight - 4}px`);
            this.scrollBarRef.instance.setAttribute('d', `M 5 0 l 2 3 l -4 0 l 2 -3 m 0 6 l 0 ${containerHeight - 16} m 0 6 l 2 -3 l -4 0 l 2 3`);
            this.scrollBarContainerRef.instance.style.display = (scrollToClientRatio <= 1.0) ? 'none' : '';
            this.onScroll();
        }
    }
    // TODO needs a method to adjust things on the fly.
    // also put some dimensions into variables
    /**
     * Eventhandler called when a scroll event in the scrollable parent container happens.
     */
    onScroll() {
        if (this.scrollableContainer) {
            // TODO ratio could also take the paddings into account for a more accurate bar
            if (this.scrollBarRef.instance !== null) {
                const ratio = this.scrollThumbRef.instance.getBBox().height / ((this.scrollBarRef.instance.getBBox().height) + this.scrollThumbRef.instance.getBBox().height);
                const scrollY = (this.scrollableContainer.scrollTop * ratio) + this.arrowPadding;
                if (!isNaN(scrollY)) {
                    this.scrollThumbRef.instance.setAttribute('y', scrollY.toString());
                }
            }
        }
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "scroll-bar", ref: this.scrollBarContainerRef },
            FSComponent.buildComponent("svg", { ref: this.svgRef },
                FSComponent.buildComponent("path", { ref: this.scrollBarRef, d: "M 5 0 l 2 3 l -4 0 l 2 -3 m 0 6 l 0 135 m 0 6 l 2 -3 l -4 0 l 2 3", fill: "rgb(150,150,150)", stroke: "rgb(150,150,150)", "stroke-width": "1px" }),
                FSComponent.buildComponent("rect", { ref: this.scrollThumbRef, x: "3", y: "6", width: "4", fill: "rgb(150,150,150)" }))));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    destroy() {
        if (this.scrollableContainer) {
            this.scrollableContainer.removeEventListener('scroll', this.scrollListener);
        }
        if (this.sizeChangeTimer !== null) {
            clearInterval(this.sizeChangeTimer);
        }
    }
}

var FmsHEvent;
(function (FmsHEvent) {
    FmsHEvent[FmsHEvent["UPPER_INC"] = 0] = "UPPER_INC";
    FmsHEvent[FmsHEvent["UPPER_DEC"] = 1] = "UPPER_DEC";
    FmsHEvent[FmsHEvent["LOWER_INC"] = 2] = "LOWER_INC";
    FmsHEvent[FmsHEvent["LOWER_DEC"] = 3] = "LOWER_DEC";
    FmsHEvent[FmsHEvent["PUSH"] = 4] = "PUSH";
    FmsHEvent[FmsHEvent["MENU"] = 5] = "MENU";
    FmsHEvent[FmsHEvent["ENT"] = 6] = "ENT";
    FmsHEvent[FmsHEvent["CLR"] = 7] = "CLR";
    FmsHEvent[FmsHEvent["DIRECTTO"] = 8] = "DIRECTTO";
    FmsHEvent[FmsHEvent["UPPER_PUSH"] = 9] = "UPPER_PUSH";
    FmsHEvent[FmsHEvent["FPL"] = 10] = "FPL";
    FmsHEvent[FmsHEvent["PROC"] = 11] = "PROC";
    FmsHEvent[FmsHEvent["RANGE_INC"] = 12] = "RANGE_INC";
    FmsHEvent[FmsHEvent["RANGE_DEC"] = 13] = "RANGE_DEC";
    FmsHEvent[FmsHEvent["JOYSTICK_PUSH"] = 14] = "JOYSTICK_PUSH";
    FmsHEvent[FmsHEvent["JOYSTICK_LEFT"] = 15] = "JOYSTICK_LEFT";
    FmsHEvent[FmsHEvent["JOYSTICK_UP"] = 16] = "JOYSTICK_UP";
    FmsHEvent[FmsHEvent["JOYSTICK_RIGHT"] = 17] = "JOYSTICK_RIGHT";
    FmsHEvent[FmsHEvent["JOYSTICK_DOWN"] = 18] = "JOYSTICK_DOWN";
})(FmsHEvent || (FmsHEvent = {}));

/**
 * The UiControl component.
 */
class UiControl extends DisplayComponent {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.focusSubject = ComputedSubject.create(false, (v) => {
            return v ? UiControl.FOCUS_CLASS : '';
        });
        this.isEnabledSubject = Subject.create(true);
        this.isVisibleSubject = Subject.create(true);
        this.isActivated = false;
        this.registerSelf = true;
        this.containerRef = FSComponent.createRef();
        this.focusSubject.sub(isFocused => {
            if (isFocused) {
                this.onFocused();
                this.props.onFocused && this.props.onFocused(this);
            }
            else {
                this.onBlurred();
                this.props.onBlurred && this.props.onBlurred(this);
            }
        });
    }
    /** Method to focus this control */
    focus() {
        this.focusSubject.set(true);
    }
    /** Method to unfocus this control */
    blur() {
        this.focusSubject.set(false);
        this.isActivated = false;
    }
    /** Activates the control. Usually after being focused and some action happens. */
    activate() {
        this.isActivated = true;
        this.onActivated();
        if (this.props.onActivated) {
            this.props.onActivated(this);
        }
    }
    /** Deactivate the control. */
    deactivate() {
        this.isActivated = false;
        this.onDeactivated();
        if (this.props.onDeactivated) {
            this.props.onDeactivated(this);
        }
    }
    /** Method to check if this UiControl is in focus
     * @returns a boolean whether this is in focus
     */
    getIsFocused() {
        return this.focusSubject.getRaw();
    }
    /**
     * Gets a boolean indicating if this control is enabled.
     * @returns A boolean.
     */
    getIsEnabled() {
        return this.isEnabledSubject.get();
    }
    /**
     * Sets the enabled state of this control.
     * @param enable A {boolean} indicating if this control should be enabled.
     */
    setIsEnabled(enable) {
        if (!enable && this.getIsFocused()) {
            this.blur();
        }
        this.isEnabledSubject.set(enable);
    }
    /**
     * Sets the visibility of this control.
     * @param visible A {boolean} indicating if this control should be visible.
     */
    setIsVisible(visible) {
        this.isVisibleSubject.set(visible);
    }
    /**
     * Gets a boolean indicating if this control is visible.
     * @returns A boolean.
     */
    getIsVisible() {
        return this.isVisibleSubject.get();
    }
    /**
     * Gets a boolean indicating if this control is able to be focused.
     * @returns A boolean.
     */
    getIsFocusable() {
        return this.getIsEnabled() && this.getIsVisible();
    }
    /**
     * Gets a boolean indicating if this control is currently activated.
     * @returns A boolean.
     */
    getIsActivated() {
        return this.isActivated;
    }
    /** @inheritdoc */
    onBeforeRender() {
        this.onRegister();
    }
    /** @inheritdoc */
    onAfterRender() {
        var _a;
        this.focusSubject.sub((v, rv) => {
            var _a, _b;
            if (rv) {
                (_a = this.getHighlightElement()) === null || _a === void 0 ? void 0 : _a.classList.add(UiControl.FOCUS_CLASS);
            }
            else {
                (_b = this.getHighlightElement()) === null || _b === void 0 ? void 0 : _b.classList.remove(UiControl.FOCUS_CLASS);
            }
        }, true);
        this.isVisibleSubject.sub((v) => {
            if (v) {
                this.containerRef.instance.classList.remove(UiControl.HIDE_CLASS);
            }
            else {
                this.containerRef.instance.classList.add(UiControl.HIDE_CLASS);
            }
        }, true);
        (_a = this.props.isVisible) === null || _a === void 0 ? void 0 : _a.sub((v) => {
            this.setIsVisible(v);
        }, true);
    }
    /**
     * Gets the element to highlight on focus.
     * Should be overriden by inheriting controls when the highlight is not the topmost container.
     * @protected
     * @returns The {Element} to highlight.
     */
    getHighlightElement() {
        return this.containerRef.instance.firstElementChild;
    }
    /** Method to register this Ui Control */
    onRegister() {
        if (this.props.onRegister) {
            if (this.registerSelf) {
                this.props.onRegister(this);
            }
        }
        else {
            console.warn('No register method found for UiControl');
        }
    }
    /**
     * A callback which is called when this control group is focused.
     */
    onFocused() {
        // noop
    }
    /**
     * A callback which is called when this control group is blurred.
     */
    onBlurred() {
        // noop
    }
    /** Method to override what to do when control is activated */
    onActivated() {
        var _a, _b;
        (_a = this.getHighlightElement()) === null || _a === void 0 ? void 0 : _a.classList.remove(UiControl.FOCUS_CLASS);
        (_b = this.getHighlightElement()) === null || _b === void 0 ? void 0 : _b.classList.add(UiControl.ACTIVE_CLASS);
    }
    /** Method to override what to do when control is deactivated */
    onDeactivated() {
        var _a, _b;
        (_a = this.getHighlightElement()) === null || _a === void 0 ? void 0 : _a.classList.remove(UiControl.ACTIVE_CLASS);
        if (this.getIsFocused()) {
            (_b = this.getHighlightElement()) === null || _b === void 0 ? void 0 : _b.classList.add(UiControl.FOCUS_CLASS);
        }
    }
    /**
     * A method which is called when this control receives an interaction event.
     * @param evt The event.
     * @returns Whether the event was handled.
     */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.UPPER_INC:
                this.onUpperKnobInc();
                return true;
            case FmsHEvent.UPPER_DEC:
                this.onUpperKnobDec();
                return true;
            case FmsHEvent.LOWER_DEC:
                this.onLowerKnobDec();
                return true;
            case FmsHEvent.LOWER_INC:
                this.onLowerKnobInc();
                return true;
            case FmsHEvent.ENT:
                return this.onEnter();
            case FmsHEvent.CLR:
                return this.onClr();
            case FmsHEvent.DIRECTTO:
                return this.onDirectTo();
        }
        return false;
    }
    /** Method to override that specifies what to do on Enter
     * @returns A boolean indicating if the control handled the event.
     */
    onEnter() {
        if (this.props.onEnter) {
            return this.props.onEnter(this);
        }
        return false;
    }
    /** Method to override that specifies what to do on Clr
     * @returns A boolean indicating if the control handled the event.
     */
    onClr() {
        if (this.props.onClr) {
            return this.props.onClr(this);
        }
        return false;
    }
    /**
     * Method to overwirte that specifies what to do on a direct to.
     * @returns A boolean indicating if the control handleded the event.
     */
    onDirectTo() {
        if (this.props.onDirectTo) {
            return this.props.onDirectTo(this);
        }
        return false;
    }
    /** Method to override that specifies what to do on upper knob */
    onUpperKnob() {
        if (this.props.onUpperKnob) {
            this.props.onUpperKnob(this);
        }
    }
    /** Method to override that specifies what to do on upper knob inc */
    onUpperKnobInc() {
        if (this.props.onUpperKnobInc) {
            this.props.onUpperKnobInc(this);
        }
        else {
            this.onUpperKnob();
        }
    }
    /** Method to override that specifies what to do on upper knob dec */
    onUpperKnobDec() {
        if (this.props.onUpperKnobDec) {
            this.props.onUpperKnobDec(this);
        }
        else {
            this.onUpperKnob();
        }
    }
    /** Method to override that specifies what to do on lower knob */
    onLowerKnob() {
        if (this.props.onLowerKnob) {
            this.props.onLowerKnob(this);
        }
    }
    /** Method to override that specifies what to do on lower knob inc */
    onLowerKnobInc() {
        if (this.props.onLowerKnobInc) {
            this.props.onLowerKnobInc(this);
        }
        else {
            this.onLowerKnob();
        }
    }
    /** Method to override that specifies what to do on lower knob dec */
    onLowerKnobDec() {
        if (this.props.onLowerKnobDec) {
            this.props.onLowerKnobDec(this);
        }
        else {
            this.onLowerKnob();
        }
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        var _a;
        const content = (this.props.children && this.props.children.length > 0) ? this.props.children : this.renderControl();
        const hideClass = this.getIsVisible() ? '' : UiControl.HIDE_CLASS;
        return (
        // TODO: would like to have this more layout neutral
        FSComponent.buildComponent("div", { ref: this.containerRef, class: `${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''} ${hideClass}` }, content));
    }
}
UiControl.FOCUS_CLASS = 'highlight-select';
UiControl.ACTIVE_CLASS = 'highlight-active';
UiControl.HIDE_CLASS = 'hide-element';

/**
 * The PopoutMenuItem component.
 */
class PopoutMenuItem extends UiControl {
    constructor() {
        super(...arguments);
        this.isEnabled = ComputedSubject.create(true, (v) => {
            return v ? 'popout-menu-item' : 'popout-menu-item text-disabled';
        });
        this.onIsEnabledChanged = (v, rv) => {
            this.setIsEnabled(rv);
        };
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        var _a;
        super.onAfterRender();
        this.isEnabled.sub(this.onIsEnabledChanged);
        this.isEnabled.set((_a = this.props.def.isEnabled) !== null && _a !== void 0 ? _a : true);
    }
    /** @inheritdoc */
    onEnter() {
        if (this.props.def.action) {
            this.props.def.action();
            if ((this.props.def.closeAfterAction === undefined || this.props.def.closeAfterAction) && Fms.viewService.getOpenViews().includes(this.props.parent)) {
                this.props.parent.close();
            }
            return true;
        }
        else if (this.props.onEnter) {
            return this.props.onEnter(this);
        }
        return false;
    }
    /** @inheritdoc */
    getHighlightElement() {
        var _a, _b;
        return (_b = (_a = this.containerRef.instance.firstElementChild) === null || _a === void 0 ? void 0 : _a.firstElementChild) !== null && _b !== void 0 ? _b : null;
    }
    /** @inheritdoc */
    renderControl() {
        return (FSComponent.buildComponent("div", { class: this.isEnabled }, this.props.def.renderContent()));
    }
}

/** Scroll utils */
class ScrollUtils {
    /**
     * Scrolls the container to make sure an element is in view.
     * @param el The element to scroll into view in the container.
     * @param container The container to scroll.
     */
    static ensureInView(el, container) {
        const cHeight = container.offsetHeight;
        const eHeight = el.offsetHeight;
        if (eHeight > cHeight) {
            return;
        }
        const cTop = container.scrollTop;
        const cBottom = cTop + cHeight;
        try {
            const eTop = ScrollUtils.findOffsetTopRelativeToAncestor(el, container);
            const eBottom = eTop + eHeight;
            if (!this.isElementInViewport(cTop, cBottom, eTop, eBottom)) {
                if (eTop < cTop) {
                    container.scrollTop -= (cTop - eTop);
                }
                else if (eBottom > cBottom) {
                    container.scrollTop += (eBottom - cBottom);
                }
            }
        }
        catch (e) {
            console.log(e);
        }
    }
    /**
     * Finds the offsetTop of an element relative to one of its ancestors.
     * @param element An element.
     * @param ancestor An ancestor of `element`.
     * @returns the offsetTop of the element relative to the ancestor.
     * @throws Error if the offsetTop could not be calculated.
     */
    static findOffsetTopRelativeToAncestor(element, ancestor) {
        const ancestorParent = ancestor.offsetParent;
        let top = element.offsetTop;
        while (element.offsetParent !== ancestorParent) {
            if (!(element.offsetParent instanceof HTMLElement)) {
                throw new Error('Element\'s offset ancestry does not directly lead to the specified ancestor');
            }
            element = element.offsetParent;
            top += element.offsetTop;
        }
        return top - ancestor.offsetTop;
    }
    /**
     * Checks if an element is visible.
     * @param cTop The top coordinate of the scroll container.
     * @param cBottom The bottom coordinate of the scroll container.
     * @param eTop The top coordinate of the element.
     * @param eBottom The bottom coordinate of the element.
     * @returns A boolean.
     */
    static isElementInViewport(cTop, cBottom, eTop, eBottom) {
        return eTop >= cTop && eBottom <= cBottom;
    }
}

/** The ScrollController for UI Elements. */
class ScrollController {
    constructor() {
        this.controls = [];
        this.isEnabled = true;
        this.lastFocusedIndex = 0;
        /**
         * Scroll forward.
         * @returns true if it was able to scroll into the given direction.
         */
        this.gotoNext = () => {
            return this.scrollTo('next');
        };
        /**
         * Scroll backwards.
         * @returns true if it was able to scroll into the given direction.
         */
        this.gotoPrev = () => {
            return this.scrollTo('prev');
        };
        /**
         * Callback to override when a scroll event happens.
         * @param ctrl The control now in focus.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.onScroll = (ctrl) => {
            const el = ctrl.getHighlightElement();
            if (el !== null && this.scrollContainer) {
                ScrollUtils.ensureInView(el, this.scrollContainer);
            }
        };
    }
    /**
     * Method to register a control.
     * @param ctrl The control to register.
     */
    registerCtrl(ctrl) {
        this.controls.push(ctrl);
    }
    /**
     * Registers a scroll container with this controller.
     * @param scrollContainer The html block element to assign.
     */
    registerScrollContainer(scrollContainer) {
        this.scrollContainer = scrollContainer;
    }
    // TODO how to handle DOM modifications (add/remove)
    // this solution is not ideal. in theory we need to observe DOM changes and react accordingly
    // but a uicontrol must not be a DOM element directly, its just a component at first. so it all becomes a bit messy. ideas?
    /**
     * Method to unregister a control.
     * @param ctrl The control to unregister.
     */
    unregisterCtrl(ctrl) {
        this.controls.splice(this.controls.indexOf(ctrl), 1);
    }
    /** Method to reset this control. */
    resetCtrls() {
        this.controls.length = 0;
    }
    /**
     * Toggles the scroll enabled state.
     */
    toggleScrollEnabled() {
        this.isEnabled = !this.isEnabled;
        if (this.isEnabled) {
            if (this.lastFocusedIndex > -1) {
                this.gotoIndex(this.lastFocusedIndex);
            }
        }
        for (let i = 0; i < this.controls.length; i++) {
            const ctrl = this.controls[i];
            if (ctrl.setScrollEnabled) {
                ctrl.setScrollEnabled(this.isEnabled);
            }
        }
        if (!this.isEnabled) {
            const focusCtrl = this.getFocusedUiControl();
            this.lastFocusedIndex = focusCtrl ? this.getFocusedUiControlIndex() : -1;
            focusCtrl === null || focusCtrl === void 0 ? void 0 : focusCtrl.blur();
        }
    }
    /**
     * Gets a value indicating if scrolling is enabled
     * @returns true if is scroll enabled
     */
    getIsScrollEnabled() {
        return this.isEnabled;
    }
    /**
     * Method to get the UiControl highlighted by the control.
     * @returns the selected UiControl or undefine
     */
    getFocusedUiControl() {
        return this.controls.find((v) => { return v.getIsFocused(); });
    }
    /**
     * Method to get the UiControl highlighted by the control.
     * @returns the selected UiControl or undefine
     */
    getActivatedUiControl() {
        return this.controls.find((v) => { return (v instanceof UiControl) && v.getIsActivated(); });
    }
    /**
     * Scrolls to the first suitable control.
     * @returns Whether the operation was successful.
     */
    gotoFirst() {
        return this.scrollTo('next', -1);
    }
    /**
     * Highlight the last suitable control.
     * @returns Whether the operation was successful.
     */
    gotoLast() {
        return this.scrollTo('prev', this.controls.length);
    }
    /**
     * Highlight the selected control on the page.
     * @param index is the index to highlight.
     * @returns Whether the operation was successful.
     */
    gotoIndex(index) {
        if (index < 0) {
            return this.scrollTo('next', -1);
        }
        else if (index < this.controls.length) {
            return this.scrollTo('next', index - 1);
        }
        else {
            return this.scrollTo('prev', this.controls.length);
        }
    }
    /**
     * Gets controls count
     * @returns controls count
     */
    getControlsCount() {
        return this.controls.length;
    }
    /** Unfocus the focused control. */
    blur() {
        for (let i = 0; i < this.controls.length; i++) {
            this.controls[i].blur();
        }
    }
    /**
     * Highlights the next focusable control in the direction.
     * @param direction The direction to scroll to.
     * @param activeIdx The index to start the scroll from.
     * @returns true if it was able to scroll into the given direction.
     */
    scrollTo(direction, activeIdx = this.getFocusedUiControlIndex()) {
        var _a;
        if (!this.isEnabled) {
            return false;
        }
        if (this.controls.length > 0) {
            const isAtBounds = ((activeIdx === 0 && direction === 'prev')
                || (activeIdx === this.controls.length - 1 && direction === 'next'));
            const nextCtrl = this.findControlToFocus(activeIdx, direction);
            if (nextCtrl !== undefined) {
                (_a = this.getFocusedUiControl()) === null || _a === void 0 ? void 0 : _a.blur();
                // typecheck for UiControlGroup to avoid circular dependency
                if (nextCtrl.processHEvent) {
                    nextCtrl.focus((direction === 'next') ? 'top' : 'bottom');
                }
                else {
                    nextCtrl.focus();
                }
                this.onScroll(nextCtrl);
                return !isAtBounds;
            }
            else {
                const focusedCtrl = this.getFocusedUiControl();
                if (focusedCtrl !== undefined) {
                    this.onScroll(focusedCtrl);
                }
                return false;
            }
        }
        return false;
    }
    /**
     * Founds the next/prev control that is able to be focused.
     * Returns undefined when no suitable control is found.
     * @private
     * @param activeIdx The index to start the search from.
     * @param direction The direction to look into.
     * @returns A focusable UiControl or undefined.
     */
    findControlToFocus(activeIdx, direction) {
        const nextIdx = (direction === 'next') ? activeIdx + 1 : activeIdx - 1;
        // const ctrl = this.controls[MathUtils.clamp(nextIdx, 0, this.controls.length - 1)];
        const ctrl = this.controls[nextIdx];
        if (ctrl === undefined || ctrl.getIsFocusable()) {
            return ctrl;
        }
        else {
            return this.findControlToFocus(nextIdx, direction);
        }
    }
    /**
     * Gets the index of the focused control.
     * @private
     * @returns The index.
     */
    getFocusedUiControlIndex() {
        return this.controls.findIndex((v) => { return v.getIsFocused(); });
    }
}

/** Ui control group */
class UiControlGroup extends DisplayComponent {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.scrollController = new ScrollController();
        this.focusSubject = Subject.create(false);
        /** Register/Unregisters a UiControl with the scroll controller.
         * @param ctrl The UiControl to register.
         * @param unregister Indicates if the UiControl should be unregistered.
         */
        this.register = (ctrl, unregister = false) => {
            if (unregister) {
                this.scrollController.unregisterCtrl(ctrl);
            }
            else {
                this.scrollController.registerCtrl(ctrl);
            }
        };
        this.focusSubject.sub(isFocused => {
            if (isFocused) {
                this.onFocused();
                this.props.onFocused && this.props.onFocused(this);
            }
            else {
                this.onBlurred();
                this.props.onBlurred && this.props.onBlurred(this);
            }
        });
    }
    /** @inheritdoc */
    onBeforeRender() {
        if (this.props.onRegister) {
            this.props.onRegister(this);
        }
    }
    /**
     * Method to focus this control group
     * @param dir The direction of entry.
     */
    focus(dir = 'top') {
        this.focusSubject.set(true);
        if (dir === 'top') {
            this.scrollController.gotoFirst();
        }
        else {
            this.scrollController.gotoLast();
        }
    }
    /** Method to unfocus this control group */
    blur() {
        this.focusSubject.set(false);
        // TODO: maybe we need to bubble down the blur...
        this.scrollController.blur();
    }
    /** Method to check if this UiControlGroup is in focus
     * @returns true if the control group is in focus, false otherwise
     */
    getIsFocused() {
        return this.focusSubject.get();
    }
    /**
     * Gets a boolean indicating if this control is able to be focused.
     * @returns true
     */
    getIsFocusable() {
        return this.scrollController.getControlsCount() > 0;
    }
    /**
     * A method called when the control group scroll is toggled.
     * @param enabled if the scroll is enabled.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onScrollToggled(enabled) {
        // noop, override it if needed
    }
    /**
     * Toggles the scroll highlighting
     */
    toggleScroll() {
        this.scrollController.toggleScrollEnabled();
        this.onScrollToggled(this.scrollController.getIsScrollEnabled());
    }
    /**
     * Sets the scroll enabled state
     * @param enabled indicating if scrolling should be enabled
     */
    setScrollEnabled(enabled) {
        if (this.scrollController.getIsScrollEnabled() !== enabled) {
            this.toggleScroll();
        }
    }
    /**
     * This is just a dummy that exists here to be compatible
     * with the union type of ScrollableControl
     * @returns null
     */
    getHighlightElement() {
        return null;
    }
    /**
     * Handles HEvents and routes them to the subdialog when existant.
     * @param evt The received event.
     * @returns true if the event was handled in this control group, false otherwise.
     */
    processHEvent(evt) {
        const focusCtrl = this.scrollController.getFocusedUiControl();
        if (focusCtrl instanceof UiControlGroup && focusCtrl.processHEvent(evt)) {
            return true;
        }
        const activeCtrl = this.scrollController.getActivatedUiControl();
        if (activeCtrl instanceof UiControl && this.routeEventToControl(evt, activeCtrl)) {
            return true;
        }
        if (focusCtrl instanceof UiControl
            && evt !== FmsHEvent.LOWER_DEC
            && evt !== FmsHEvent.LOWER_INC
            && this.routeEventToControl(evt, focusCtrl)) {
            return true;
        }
        switch (evt) {
            case FmsHEvent.UPPER_DEC:
            case FmsHEvent.UPPER_INC:
                if (!this.props.upperKnobCanScroll) {
                    break;
                }
            // eslint-disable-next-line no-fallthrough
            case FmsHEvent.LOWER_DEC:
            case FmsHEvent.LOWER_INC:
                if (this.processScrollEvent(evt)) {
                    return true;
                }
        }
        return this.onInteractionEvent(evt);
    }
    /**
     * Routes an interaction event to a UiControl.
     * @param evt An interaction event.
     * @param control The UiControl to which to route the event.
     * @returns Whether the event was handled by the UiControl.
     */
    routeEventToControl(evt, control) {
        switch (evt) {
            case FmsHEvent.UPPER_DEC:
            case FmsHEvent.UPPER_INC:
                if (this.props.upperKnobCanScroll) {
                    break;
                }
            // eslint-disable-next-line no-fallthrough
            default:
                return control.onInteractionEvent(evt);
        }
        return false;
    }
    /**
     * Attempts to handle scroll events.
     * @param evt The received event.
     * @returns whether the event was handled.
     */
    processScrollEvent(evt) {
        if (this.scrollController.getIsScrollEnabled()) {
            switch (evt) {
                case FmsHEvent.LOWER_DEC:
                case FmsHEvent.UPPER_DEC:
                    return this.scrollController.gotoPrev();
                case FmsHEvent.LOWER_INC:
                case FmsHEvent.UPPER_INC:
                    return this.scrollController.gotoNext();
            }
        }
        return false;
    }
    /**
     * Handler for interaction events to be handled by the view.
     * @param evt The HEvenet.
     * @returns true if the event was handled in this group
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onInteractionEvent(evt) {
        // noop, override it if needed
        return false;
    }
    /**
     * A callback which is called when this control group is focused.
     */
    onFocused() {
        // noop
    }
    /**
     * A callback which is called when this control group is blurred.
     */
    onBlurred() {
        // noop
    }
}

/** The List component. */
class List extends UiControlGroup {
    constructor() {
        super(...arguments);
        this._listContainer = FSComponent.createRef();
        this._itemInstanceRefs = [];
        this.previousSelectedIndex = -1;
        this.previousSelectedItem = undefined;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.registerListItem = (ctrl) => {
            // noop here, we will refresh all registrations on our own
        };
    }
    /** @inheritdoc */
    onAfterRender() {
        this.renderList();
        if (this.props.scrollContainer) {
            this.scrollController.registerScrollContainer(this.props.scrollContainer.instance);
        }
        this.props.data.sub(this.onDataChanged.bind(this));
        this.scrollController.onScroll = this.onScroll.bind(this);
    }
    /**
     * A callback fired when the array subject data changes.
     * @param index The index of the change.
     * @param type The type of change.
     * @param item The item that was changed.
     */
    onDataChanged(index, type, item) {
        switch (type) {
            case SubscribableArrayEventType.Added:
                {
                    const el = this._listContainer.instance.children.item(index);
                    if (Array.isArray(item)) {
                        for (let i = 0; i < item.length; i++) {
                            this.addDomNode(item[i], index + i, el);
                        }
                    }
                    else {
                        this.addDomNode(item, index, el);
                    }
                    this.refreshRegistrations();
                }
                break;
            case SubscribableArrayEventType.Removed:
                {
                    if (Array.isArray(item)) {
                        for (let i = 0; i < item.length; i++) {
                            this.removeDomNode(index);
                        }
                    }
                    else {
                        this.removeDomNode(index);
                    }
                    this.refreshRegistrations();
                }
                break;
            case SubscribableArrayEventType.Cleared:
                this._itemInstanceRefs.length = 0;
                this._listContainer.instance.innerHTML = '';
                this.scrollController.resetCtrls();
                if (this.props.onItemSelected) {
                    this.props.onItemSelected(null, null, -1);
                }
                break;
        }
    }
    /**
     * Removes a dom node from the collection at the specified index.
     * @param index The index to remove.
     */
    removeDomNode(index) {
        const child = this._listContainer.instance.childNodes.item(index);
        this._listContainer.instance.removeChild(child);
        const removed = this._itemInstanceRefs.splice(index, 1)[0];
        removed.destroy();
    }
    /**
     * Adds a list rendered dom node to the collection.
     * @param item Item to render and add.
     * @param index The index to add at.
     * @param el The element to add to.
     */
    addDomNode(item, index, el) {
        const node = this.renderListItem(item, index);
        if (el !== null) {
            node && el && FSComponent.renderBefore(node, el);
        }
        else {
            el = this._listContainer.instance;
            node && el && FSComponent.render(node, el);
        }
        if (node !== undefined && node.instance !== null) {
            this._itemInstanceRefs.splice(index, 0, node.instance);
        }
    }
    /**
     * Refreshs control registrations of all list elements.
     */
    refreshRegistrations() {
        var _a;
        this.scrollController.resetCtrls();
        for (let i = 0; i < this._itemInstanceRefs.length; i++) {
            const instance = this._itemInstanceRefs[i];
            if (instance instanceof UiControlGroup) {
                this.register(instance);
            }
            else if (instance instanceof UiControl) {
                instance.props.onRegister = this.register;
                instance.onRegister();
                // this.register(instance);
            }
        }
        if (this.getIsFocused()) {
            if (this.previousSelectedIndex < 0
                ? this.scrollController.gotoFirst()
                : this.previousSelectedIndex >= this.props.data.length
                    ? this.scrollController.gotoLast()
                    : this.scrollController.scrollTo('prev', this.previousSelectedIndex + 1)) {
                return;
            }
            else {
                this.previousSelectedIndex = -1;
            }
        }
        if (this.previousSelectedIndex < 0 || this.previousSelectedIndex >= this.props.data.length) {
            this.previousSelectedIndex = -1;
        }
        const item = (_a = this.props.data.tryGet(this.previousSelectedIndex)) !== null && _a !== void 0 ? _a : null;
        if (item !== this.previousSelectedItem) {
            this.props.onItemSelected && this.props.onItemSelected(item, this.getListItemInstance(this.previousSelectedIndex), this.previousSelectedIndex);
        }
        this.previousSelectedItem = item;
    }
    /**
     * Scrolls to an item.
     * @param index is the index of the list item to scroll to.
     */
    scrollToIndex(index) {
        this.scrollController.gotoIndex(index);
    }
    /**
     * Ensures an indexed list item is in view.
     * @param index The index of the list item.
     */
    ensureIndexInView(index) {
        const el = this._listContainer.instance.children[index];
        if (el && this.props.scrollContainer) {
            ScrollUtils.ensureInView(el, this.props.scrollContainer.instance);
        }
    }
    /**
     * Gets the data object related to the selected DOM element.
     * @returns The selected item, if found.
     */
    getSelectedItem() {
        const selectedIndex = this.getSelectedIndex();
        if (selectedIndex > -1) {
            return this.props.data.get(selectedIndex);
        }
        return null;
    }
    /**
     * Get the selected HTMLElement.
     * @returns The selected element, if found.
     */
    getSelectedElement() {
        var _a;
        return (_a = this._listContainer.instance.children[this.getSelectedIndex()]) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * Gets the index of the currently selected element.
     * @returns Selected element index. Returns -1 if nothing found.
     */
    getSelectedIndex() {
        const focusedControl = this.scrollController.getFocusedUiControl();
        return focusedControl ? this._itemInstanceRefs.indexOf(focusedControl) : -1;
    }
    /**
     * Gets the instance of the node at the specified index.
     * @param index The index to get the instance for.
     * @returns The node instance of specified type.
     */
    getListItemInstance(index) {
        var _a;
        return (_a = this._itemInstanceRefs[index]) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * Gets index of a item in the list by its node instance.
     * @param nodeInstance The node instance to look for.
     * @returns list item index
     */
    getListItemIndex(nodeInstance) {
        return this._itemInstanceRefs.indexOf(nodeInstance);
    }
    /** @inheritdoc */
    onBlurred() {
        if (this.previousSelectedItem && this.props.onItemSelected) {
            this.props.onItemSelected(null, null, -1);
        }
        this.previousSelectedItem = null;
        this.previousSelectedIndex = -1;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onScroll(ctrl) {
        var _a;
        const el = this.getSelectedElement();
        if (el !== null && this.props.scrollContainer) {
            ScrollUtils.ensureInView(el, this.props.scrollContainer.instance);
        }
        const index = this.getSelectedIndex();
        const item = (_a = this.props.data.tryGet(index)) !== null && _a !== void 0 ? _a : null;
        if (this.props.onItemSelected) {
            item !== this.previousSelectedItem && this.props.onItemSelected(item, this.getListItemInstance(index), index);
        }
        this.previousSelectedItem = item;
        this.previousSelectedIndex = index;
    }
    /**
     * Renders a list item
     * @param dataItem The data item to render.
     * @param index The index to render at.
     * @returns list item vnode
     * @throws error when the resulting vnode is not a scrollable control
     */
    renderListItem(dataItem, index) {
        const renderedNode = this.props.renderItem(dataItem, this.registerListItem, index);
        if ((renderedNode.instance instanceof UiControl || renderedNode.instance instanceof UiControlGroup)) {
            return renderedNode;
        }
        else {
            throw new Error('A ListItem must be of type UiControl or UiControlGroup!');
        }
    }
    /** Renders the list of data items. */
    renderList() {
        // clear all items
        this._listContainer.instance.textContent = '';
        // render items
        const dataLen = this.props.data.length;
        for (let i = 0; i < dataLen; i++) {
            const vnode = this.renderListItem(this.props.data.get(i), i);
            if (vnode !== undefined) {
                FSComponent.render(vnode, this._listContainer.instance);
                this._itemInstanceRefs.push(vnode.instance);
            }
        }
        this.refreshRegistrations();
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', ref: this._listContainer }));
    }
}

/** A UiView component. */
class UiView extends UiControlGroup {
    constructor() {
        super(...arguments);
        this.viewContainerRef = FSComponent.createRef();
        this.inputData = Subject.create(undefined);
        this.onOpen = new SubEvent();
        this.onClose = new SubEvent();
        this.onAccept = new SubEvent();
    }
    /**
     * Shows the view.
     * @param isSubView Whether the view is being displayed as a subview.
     * @param zIndex The z-index to assign on the view container.
     */
    open(isSubView, zIndex) {
        if (this.viewContainerRef.instance !== null) {
            if (zIndex) {
                this.viewContainerRef.instance.style.zIndex = `${zIndex}`;
            }
            this.viewContainerRef.instance.classList.remove('quickclosed');
            this.viewContainerRef.instance.classList.remove('closed');
            this.viewContainerRef.instance.classList.add('open');
            isSubView && this.viewContainerRef.instance.classList.add('subview');
            this.notifyViewOpened();
            this.notifyViewResumed();
        }
    }
    /**
     * Closes the view.
     * @param quickclose bool stating whether to quickclose the child.
     */
    close(quickclose = false) {
        if (this.viewContainerRef.instance !== null) {
            this.notifyViewPaused();
            this.viewContainerRef.instance.classList.remove('open');
            if (quickclose === true) {
                this.viewContainerRef.instance.classList.add('quickclosed');
            }
            else {
                this.viewContainerRef.instance.classList.add('closed');
            }
            this.notifyViewClosed();
            this.setInput(undefined);
            this.viewResult = undefined;
            this.onAccept.clear();
        }
    }
    /**
     * Sets this view's z-index.
     * @param zIndex The new z-indez. If not defined, the view's z-index will be reset.
     */
    setZIndex(zIndex) {
        this.viewContainerRef.instance.style.zIndex = `${zIndex !== null && zIndex !== void 0 ? zIndex : ''}`;
    }
    /**
     * Set data on this view.
     * @param input The input data.
     * @returns This view instance for chain commands.
     */
    setInput(input) {
        this.inputData.set(input);
        this.onInputDataSet(input);
        return this;
    }
    /**
     * Confirms the view result and closes the view.
     * @param [result] Provide the view result if not already set.
     * @param closeView Indicates if the view should be closed after confirming the result.
     */
    accept(result, closeView = true) {
        if (result !== undefined) {
            this.viewResult = result;
        }
        this.notifyViewAccept();
        if (closeView) {
            this.close();
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    processScrollEvent(evt) {
        if (this.scrollController.getIsScrollEnabled()) {
            // Do not let scroll events fall through if scrolling is enabled.
            super.processScrollEvent(evt);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Notifies subscribers that the view has been opened.
     * @protected
     */
    notifyViewOpened() {
        this.focus();
        this.onViewOpened();
        this.onOpen.notify(this);
    }
    /**
     * Notifies subscribers that the view has been resumed.
     */
    notifyViewResumed() {
        this.onViewResumed();
    }
    /**
     * Notifies subscribers that the view has been paused.
     */
    notifyViewPaused() {
        this.onViewPaused();
    }
    /**
     * Notifies subscribers that the view has been closed including the view result.
     */
    notifyViewClosed() {
        this.onViewClosed();
        this.onClose.notify(this);
        this.blur();
    }
    /**
     * Notifies subscribers that the view the user confirmed the view and a result should be available.
     */
    notifyViewAccept() {
        this.onAccept.notify(this, this.viewResult);
    }
    /** Method to be overridden by view inheriting UiView to do something when the view opens. */
    onViewOpened() {
        //noop
    }
    /** Method to be overridden by view inheriting UiView to do something when the dialog opens. */
    onViewResumed() {
        // noope
    }
    /** Method to be overridden by view inheriting UiView to do something when the dialog opens. */
    onViewPaused() {
        //noop
    }
    /** Method to be overridden by view inheriting UiView to do something when the dialog opens. */
    onViewClosed() {
        //noop
    }
    /**
     * Method to be overridden by view inheriting UiView to do something when the input data is set.
     * @protected
     * @param input The data that was set.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onInputDataSet(input) {
        //noop
    }
    /**
     * Pauses the view (usually only called by ViewService).
     */
    pause() {
        this.notifyViewPaused();
    }
    /**
     * Resumes the view (usually only called by ViewService).
     */
    resume() {
        this.notifyViewResumed();
    }
}

/** The list menu popout. */
class ListMenuDialog extends UiView {
    constructor() {
        super(...arguments);
        this.listRef = FSComponent.createRef();
        this.listContainerRef = FSComponent.createRef();
        this.menuItems = this.buildMenuItems();
        this.menuItemsSubject = ArraySubject.create(this.menuItems);
        /**
         * A callback called to render the menu items.
         * @param d is the menu item
         * @param registerFn The register function.
         * @returns a vnode for display in the menu
         */
        this.renderItem = (d, registerFn) => {
            return FSComponent.buildComponent(PopoutMenuItem, { onRegister: registerFn, parent: this, def: d });
        };
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.CLR:
                this.close();
                return true;
        }
        return false;
    }
    /**
     * Gets the menu item definitions for the list.
     * @returns menu item definitions.
     */
    buildMenuItems() {
        return [];
    }
    /**
     * Sets the menu items for the list menu dialog.
     * @param items The items to set into the menu.
     */
    setMenuItems(items) {
        this.menuItems = items;
        this.menuItemsSubject.clear();
        this.menuItemsSubject.set(items);
        this.scrollController.gotoFirst();
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        let className = 'popout-dialog';
        if (this.props.isMfd) {
            className = 'MFD-' + className;
        }
        if (this.props.class !== undefined) {
            className += ` ${this.props.class}`;
        }
        return (FSComponent.buildComponent("div", { class: className, ref: this.viewContainerRef },
            FSComponent.buildComponent("h1", null, this.props.title),
            FSComponent.buildComponent("div", { class: "popout-menu-container", ref: this.listContainerRef },
                FSComponent.buildComponent(List, { ref: this.listRef, onRegister: this.register, data: this.menuItemsSubject, renderItem: this.renderItem, scrollContainer: this.listContainerRef })),
            FSComponent.buildComponent(ScrollBar, null)));
    }
}

/**
 * The PFD procedures popout.
 */
class PFDProc extends ListMenuDialog {
    /** @inheritdoc */
    onViewResumed() {
        const menuItems = this.buildMenuList();
        this.setMenuItems(menuItems);
    }
    /**
     * Method to dynamically build the menu list
     * @returns an array of menu item definitions
     */
    buildMenuList() {
        var _a, _b, _c, _d;
        const approachLoaded = (_b = (_a = this.props.fms) === null || _a === void 0 ? void 0 : _a.canApproachActivate()) !== null && _b !== void 0 ? _b : false;
        const canMissedActivate = (_d = (_c = this.props.fms) === null || _c === void 0 ? void 0 : _c.canMissedApproachActivate()) !== null && _d !== void 0 ? _d : false;
        const menuItems = [
            {
                id: 'activate-vector-to-final', renderContent: () => FSComponent.buildComponent("span", null, "Activate Vector-to-Final"), isEnabled: false,
                action: () => {
                }
            },
            {
                id: 'activate-approach', renderContent: () => FSComponent.buildComponent("span", null, "Activate Approach"), isEnabled: approachLoaded,
                action: () => {
                    this.props.fms.activateApproach();
                }
            },
            {
                id: 'activate-missed', renderContent: () => FSComponent.buildComponent("span", null, "Activate Missed Approach"), isEnabled: canMissedActivate,
                action: () => {
                    this.props.fms.activateMissedApproach();
                }
            },
            {
                id: 'select-approach', renderContent: () => FSComponent.buildComponent("span", null, "Select Approach"), isEnabled: true,
                action: () => {
                    this.props.viewService.open('SelectApproach', false);
                }, closeAfterAction: false
            },
            {
                id: 'select-arrival', renderContent: () => FSComponent.buildComponent("span", null, "Select Arrival"), isEnabled: true,
                action: () => {
                    this.props.viewService.open('SelectArrival', false);
                }, closeAfterAction: false
            },
            {
                id: 'select-departure', renderContent: () => FSComponent.buildComponent("span", null, "Select Departure"), isEnabled: true,
                action: () => {
                    this.props.viewService.open('SelectDeparture', false);
                }, closeAfterAction: false
            },
        ];
        return menuItems;
    }
    /** @inheritdoc */
    buildMenuItems() {
        return this.buildMenuList();
    }
}

/**
 * An abstract component which is bound to a waypoint.
 */
class WaypointComponent extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.waypointChangedHandler = this.onWaypointChanged.bind(this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        this.props.waypoint.sub(this.waypointChangedHandler, true);
    }
    /**
     * A callback which is called when this component's waypoint changes.
     * @param waypoint The new waypoint.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onWaypointChanged(waypoint) {
        // noop
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    destroy() {
        this.props.waypoint.unsub(this.waypointChangedHandler);
    }
}

/**
 * A waypoint icon.
 */
class WaypointIcon extends WaypointComponent {
    constructor() {
        super(...arguments);
        this.imgRef = FSComponent.createRef();
        this.planeHeadingChangedHandler = this.onPlaneHeadingChanged.bind(this);
        this.srcSub = ComputedSubject.create(null, (waypoint) => {
            if (!waypoint) {
                return '';
            }
            if (waypoint instanceof FacilityWaypoint) {
                return this.getFacilityIconSrc(waypoint);
            }
            return '';
        });
        this.needUpdateAirportSpriteSub = ComputedSubject.create(null, (waypoint) => {
            if (!waypoint) {
                return false;
            }
            return !!this.props.planeHeading && waypoint instanceof AirportWaypoint;
        });
        this.imgFrameRowCount = 1;
        this.imgFrameColCount = 1;
        this.imgOffset = '0px 0px';
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        this.initImageLoadListener();
        super.onAfterRender();
        this.initPlaneHeadingListener();
    }
    /**
     * Initializes the image onload listener.
     */
    initImageLoadListener() {
        this.imgRef.instance.onload = this.onImageLoaded.bind(this);
    }
    /**
     * Initializes the plane heading listener.
     */
    initPlaneHeadingListener() {
        if (this.props.planeHeading) {
            this.props.planeHeading.sub(this.planeHeadingChangedHandler, true);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onWaypointChanged(waypoint) {
        this.srcSub.set(waypoint);
        this.needUpdateAirportSpriteSub.set(waypoint);
    }
    /**
     * A callback which is called when this component's image element finishes loading an image.
     */
    onImageLoaded() {
        const img = this.imgRef.instance;
        this.imgFrameRowCount = Math.floor(img.naturalHeight / 32);
        this.imgFrameColCount = Math.floor(img.naturalWidth / 32);
    }
    /**
     * A callback which is called when plane heading changes.
     * @param planeHeading The true heading of the airplane, in degrees.
     */
    onPlaneHeadingChanged(planeHeading) {
        if (this.needUpdateAirportSpriteSub.get()) {
            this.updateAirportSprite(planeHeading);
        }
    }
    /**
     * Updates this icon's airport sprite.
     * @param planeHeading The true heading of the airplane, in degrees.
     */
    updateAirportSprite(planeHeading) {
        const waypoint = this.props.waypoint.get();
        if (!(waypoint instanceof AirportWaypoint) || !waypoint.longestRunway) {
            return;
        }
        const headingDelta = waypoint.longestRunway.direction - planeHeading;
        const frame = Math.round(NavMath.normalizeHeading(headingDelta) / 22.5) % 8;
        const row = Math.min(Math.floor(frame / 4), this.imgFrameRowCount - 1);
        const col = Math.min(frame % 4, this.imgFrameColCount - 1);
        const xOffset = col * -32;
        const yOffset = row * -32;
        this.setImgOffset(`${xOffset}px ${yOffset}px`);
    }
    /**
     * Sets the object offset of this icon's image element.
     * @param offset The new offset.
     */
    setImgOffset(offset) {
        if (offset === this.imgOffset) {
            return;
        }
        this.imgOffset = offset;
        this.imgRef.instance.style.objectPosition = offset;
    }
    /**
     * Gets the appropriate icon src for a facility waypoint.
     * @param waypoint A facility waypoint.
     * @returns the appropriate icon src for the facility waypoint.
     */
    getFacilityIconSrc(waypoint) {
        switch (ICAO.getFacilityType(waypoint.facility.icao)) {
            case FacilityType.Airport:
                return this.getAirportIconSrc(waypoint);
            case FacilityType.VOR:
                return this.getVorIconSrc(waypoint);
            case FacilityType.NDB:
                return this.getNdbIconSrc();
            case FacilityType.Intersection:
                return this.getIntersectionIconSrc();
            case FacilityType.USR:
                return this.getUserIconSrc();
            case FacilityType.RWY:
                return this.getRunwayIconSrc();
            default:
                return '';
        }
    }
    /**
     * Gets the appropriate icon src for an airport waypoint.
     * @param waypoint An airport waypoint.
     * @returns the appropriate icon src for the airport waypoint.
     */
    getAirportIconSrc(waypoint) {
        const airport = waypoint.facility;
        const serviced = (airport.fuel1 !== '' || airport.fuel2 !== '') || airport.airportClass === 1;
        if (airport.airportPrivateType !== AirportPrivateType.Public) {
            return `${WaypointIcon.PATH}/airport_r.png`;
        }
        else if (serviced) {
            if (airport.towered) {
                return `${WaypointIcon.PATH}/airport_large_blue.png`;
            }
            else if (airport.airportClass === 1) {
                return `${WaypointIcon.PATH}/airport_large_magenta.png`;
            }
            else {
                return `${WaypointIcon.PATH}/airport_small_b.png`;
            }
        }
        else {
            if (airport.towered) {
                return `${WaypointIcon.PATH}/airport_med_blue.png`;
            }
            else if (airport.airportClass === 1) {
                return `${WaypointIcon.PATH}/airport_med_magenta.png`;
            }
            else {
                return `${WaypointIcon.PATH}/airport_small_a.png`;
            }
        }
    }
    /**
     * Gets the appropriate icon src for a VOR waypoint.
     * @param waypoint A VOR waypoint.
     * @returns the appropriate icon src for the VOR waypoint.
     */
    getVorIconSrc(waypoint) {
        switch (waypoint.facility.type) {
            case VorType.DME:
                return `${WaypointIcon.PATH}/dme.png`;
            case VorType.ILS:
            case VorType.VORDME:
                return `${WaypointIcon.PATH}/vor_dme.png`;
            case VorType.VORTAC:
            case VorType.TACAN:
                return `${WaypointIcon.PATH}/vortac.png`;
            default:
                return `${WaypointIcon.PATH}/vor.png`;
        }
    }
    /**
     * Gets the appropriate icon src for an NDB waypoint.
     * @returns the appropriate icon src for the NDB waypoint.
     */
    getNdbIconSrc() {
        return `${WaypointIcon.PATH}/ndb.png`;
    }
    /**
     * Gets the appropriate icon src for an intersection waypoint.
     * @returns the appropriate icon src for the intersection waypoint.
     */
    getIntersectionIconSrc() {
        return `${WaypointIcon.PATH}/intersection_cyan.png`;
    }
    /**
     * Gets the appropriate icon src for an intersection waypoint.
     * @returns the appropriate icon src for the intersection waypoint.
     */
    getUserIconSrc() {
        return `${WaypointIcon.PATH}/user.png`;
    }
    /**
     * Gets the appropriate icon src for a runway waypoint.
     * @returns the appropriate icon src for the runway waypoint.
     */
    getRunwayIconSrc() {
        return `${WaypointIcon.PATH}/intersection_cyan.png`;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        var _a;
        return (FSComponent.buildComponent("img", { ref: this.imgRef, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', src: this.srcSub, style: `width: 32px; height: 32px; object-fit: none; object-position: ${this.imgOffset};` }));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    destroy() {
        super.destroy();
        if (this.props.planeHeading) {
            this.props.planeHeading.unsub(this.planeHeadingChangedHandler);
        }
    }
}
WaypointIcon.PATH = 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/icons-map';

/**
 * Utility class for working with ICAO region codes in a Garmin context.
 */
class Regions {
    /**
     * Gets the Garmin display name of the region associated with a specified ICAO region code.
     * @param code - the 2 character ICAO region code.
     * @returns the Garmin display name of the region.
     */
    static getName(code) {
        const name = Regions.NAME_TABLE[code.toUpperCase()];
        return name !== null && name !== void 0 ? name : '';
    }
}
Regions.NAME_TABLE = {
    'AG': 'SOLOMON ISL',
    'AN': 'NAURU ISL',
    'AY': 'PAPUA N GN',
    'BG': 'GREENLAND',
    'BI': 'ICELAND',
    'BK': 'KOSOVO',
    'CY': 'CANADA',
    'DA': 'ALGERIA',
    'DB': 'BENIN',
    'DF': 'BURKINA FASO',
    'DG': 'GHANA',
    'DI': 'IVRY COAST',
    'DN': 'NIGERIA',
    'DR': 'NIGER',
    'DT': 'TUNISIA',
    'DX': 'TOGO',
    'EB': 'BELGIUM',
    'ED': 'GERMANY',
    'EE': 'ESTONIA',
    'EF': 'FINLAND',
    'EG': 'U KINGDOM',
    'EH': 'NETHERLNDS',
    'EI': 'IRELAND',
    'EK': 'DENMARK',
    'EL': 'LUXEMBOURG',
    'EN': 'NORWAY',
    'EP': 'POLAND',
    'ES': 'SWEDEN',
    'ET': 'GERMANY',
    'EV': 'LATVIA',
    'EY': 'LITHUANIA',
    'FA': 'S AFRICA',
    'FB': 'BOTSWANA',
    'FC': 'CONGO',
    'FD': 'ESWATINI',
    'FE': 'CENTRL AFR',
    'FG': 'EQU GUINEA',
    'FH': 'ASCENSION IS',
    'FI': 'MAURITIUS',
    'FJ': 'BRIT INDIAN OC TERR',
    'FK': 'CAMEROON',
    'FL': 'ZAMBIA',
    'FM': 'MADAGASCAR',
    'FN': 'ANGOLA',
    'FO': 'GABON',
    'FP': 'SAO TOME',
    'FQ': 'MOZAMBIQUE',
    'FS': 'SEYCHELLES',
    'FT': 'CHAD',
    'FV': 'ZIMBABWE',
    'FW': 'MALAWI',
    'FX': 'LESOTHO',
    'FY': 'NAMIBIA',
    'FZ': 'DEM CONGO',
    'GA': 'MALI',
    'GB': 'GAMBIA',
    'GC': 'CANARY ISL',
    'GE': 'MELILLA',
    'GF': 'SIERRA LEONE',
    'GG': 'GUINEA BISSAU',
    'GL': 'LIBERIA',
    'GM': 'MOROCCO',
    'GO': 'SENEGAL',
    'GQ': 'MAURITANIA',
    'GS': 'W SAHARA',
    'GU': 'GUINEA',
    'GV': 'CAPE VERDE',
    'HA': 'ETHIOPIA',
    'HB': 'BURUNDI',
    'HD': 'DJIBOUTI',
    'HE': 'EGYPT',
    'HH': 'ERITREA',
    'HK': 'KENYRA',
    'HL': 'LIBYA',
    'HR': 'RWANDA',
    'HS': 'SUDAN',
    'HT': 'TANZANIA',
    'HU': 'UGANDA',
    'K1': 'NW USA',
    'K2': 'SW USA',
    'K3': 'N CEN USA',
    'K4': 'S CEN USA',
    'K5': 'GR LKS USA',
    'K6': 'NE USA',
    'K7': 'SE USA',
    'LA': 'ALBANIA',
    'LB': 'BULGARIA',
    'LC': 'CYPRUS',
    'LD': 'CROATIA',
    'LE': 'SPAIN',
    'LF': 'FRANCE',
    'LG': 'GREECE',
    'LH': 'HUNGARY',
    'LI': 'ITALY',
    'LJ': 'SLOVENIA',
    'LK': 'CZECH',
    'LL': 'ISRAEL',
    'LM': 'MALTA',
    'LO': 'AUSTRIA',
    'LP': 'PORTUGAL',
    'LQ': 'BOSNIA-HRZ',
    'LR': 'ROMANIA',
    'LS': 'SWITZERLAND',
    'LT': 'TURKEY',
    'LU': 'MOLDOVA',
    'LV': 'PALESTINE',
    'LW': 'MACEDONIA',
    'LX': 'GIBRALTAR',
    'LY': 'SERB/MONTG',
    'LZ': 'SLOVAKIA',
    'MB': 'TURKS/CAIC',
    'MD': 'DOM REPBLC',
    'MG': 'GUATEMALA',
    'MH': 'HONDURAS',
    'MK': 'JAMAICA',
    'MM': 'MEXICO',
    'MN': 'NICARAGUA',
    'MP': 'PANAMA',
    'MR': 'COSTA RICA',
    'MS': 'EL SALVADOR',
    'MT': 'HAITI',
    'MU': 'CUBA',
    'MW': 'CAYMAN IS',
    'MY': 'BAHAMAS',
    'MZ': 'BELIZE',
    'NC': 'COOK IS',
    'NF': 'FIJI',
    'NG': 'KIRIBATI IS',
    'NI': 'NIUE IS',
    'NL': 'WALLIS IS',
    'NS': 'AM/W SAMOA',
    'NT': 'FRNCH POLY',
    'NV': 'VANUATU',
    'NW': 'NEW CALEDONIA',
    'NZ': 'NEW ZEALND',
    'OA': 'AFGHANISTAN',
    'OB': 'BAHRAIN',
    'OE': 'SAUDI ARAB',
    'OI': 'IRAN',
    'OJ': 'JORDAN',
    'OK': 'KUWAIT',
    'OL': 'LEBANON',
    'OM': 'ARAB EMIRA',
    'OO': 'OMAN',
    'OP': 'PAKISTAN',
    'OR': 'IRAQ',
    'OS': 'SYRIA',
    'OT': 'QATAR',
    'OY': 'YEMEN',
    'PA': 'ALASKA',
    'PG': 'GUAM',
    'PH': 'HAWAII',
    'PJ': 'JOHNSTON ATOLL',
    'PK': 'MARSHLL IS',
    'PL': 'KIRIBATI',
    'PM': 'MIDWAY IS',
    'PO': 'ALASKA',
    'PP': 'ALASKA',
    'PT': 'MICRONESIA',
    'PW': 'WAKE IS',
    'RC': 'TAIWAN',
    'RJ': 'JAPAN',
    'RK': 'S KOREA',
    'RO': 'OKINAWA',
    'RP': 'PHILIPPINES',
    'SA': 'ARGENTINA',
    'SB': 'BRAZIL',
    'SC': 'CHILE',
    'SD': 'BRAZIL',
    'SE': 'EQUADOR',
    'SG': 'PARAGUAY',
    'SI': 'BRAZIL',
    'SJ': 'BRAZIL',
    'SK': 'COLOMBIA',
    'SL': 'BOLIVIA',
    'SM': 'SURINAME',
    'SO': 'FRN GUIANA',
    'SP': 'PERU',
    'SS': 'BRAZIL',
    'SU': 'URUGUAY',
    'SV': 'VENEZUELA',
    'SW': 'BRAZIL',
    'SY': 'GUYANA',
    'TA': 'ANTIGUA',
    'TB': 'BARBADOS',
    'TD': 'ANTIGUA',
    'TF': 'GUAD/MRTNQ',
    'TG': 'GRENADA',
    'TI': 'US VRGN IS',
    'TJ': 'PUERTO RIC',
    'TK': 'ST KTS/NEV',
    'TL': 'ST LUCIA',
    'TN': 'ARUBA',
    'TQ': 'ANGUILLA',
    'TT': 'MONTSERRAT',
    'TU': 'TRIN/TOBAG',
    'TV': 'BR VRGN IS',
    'TX': 'BERMUDA',
    'UA': 'KZKHSTN',
    'UB': 'AZERBAIJAN',
    'UC': 'KYRGYZSTAN',
    'UD': 'ARMENIA',
    'UE': 'RUSSIA',
    'UG': 'GEORGIA',
    'UH': 'RUSSIA',
    'UI': 'RUSSIA',
    'UK': 'UKRAINE',
    'UL': 'NW RUSSIA',
    'UM': 'BELARUS',
    'UN': 'RUSSIA',
    'UO': 'RUSSIA',
    'UR': 'RUSS/KZKST',
    'US': 'RUSSIA',
    'UT': 'UZBEK/TADZ',
    'UU': 'RUSSIA',
    'UW': 'RUSSIA',
    'VA': 'INDIA',
    'VC': 'SRI LANKA',
    'VD': 'CAMBODIA',
    'VE': 'INDIA',
    'VG': 'BANGLADESH',
    'VH': 'HONG KONG',
    'VI': 'INDIA',
    'VL': 'LAOS',
    'VM': 'MACAU',
    'VN': 'NEPAL',
    'VO': 'INDIA',
    'VR': 'MALDIVES',
    'VT': 'THAILAND',
    'VV': 'VIETNAM',
    'VY': 'MYANMAR',
    'WA': 'INDONESIA',
    'WB': 'BRUNEI',
    'WI': 'INDONESIA',
    'WM': 'MALAYSIA',
    'WR': 'INDONESIA',
    'WS': 'SINGAPORE',
    'YB': 'AUSTRALIA',
    'YM': 'AUSTRALIA',
    'ZB': 'CHINA',
    'ZG': 'CHINA',
    'ZH': 'CHINA',
    'ZK': 'N KOREA',
    'ZL': 'CHINA',
    'ZM': 'MONGOLIA',
    'ZP': 'CHINA',
    'ZS': 'CHINA',
    'ZU': 'CHINA',
    'ZW': 'CHINA',
    'ZY': 'CHINA',
};

/**
 * A text display for waypoint region.
 */
class WaypointRegion extends WaypointComponent {
    constructor() {
        super(...arguments);
        this.textSub = ComputedSubject.create(null, (waypoint) => {
            if (waypoint instanceof FacilityWaypoint) {
                if (waypoint instanceof AirportWaypoint) {
                    // airports don't have region codes in their ICAO strings, we will try to grab the code from the first 2
                    // letters of the ident. However, some airports (e.g. in the US and those w/o 4-letter idents) don't use the
                    // region code for the ident, so we need a third fallback, which is to just display the city name instead.
                    const airport = waypoint.facility;
                    const ident = ICAO.getIdent(airport.icao).trim();
                    let text = ident.length === 4 ? Regions.getName(ident.substr(0, 2)) : '';
                    if (text === '' && airport.city !== '') {
                        text = airport.city.split(', ').map(name => Utils.Translate(name)).join(', ');
                    }
                    if (text) {
                        return text;
                    }
                }
                else {
                    return Regions.getName(waypoint.facility.icao.substr(1, 2));
                }
            }
            return '__________';
        });
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onWaypointChanged(waypoint) {
        this.textSub.set(waypoint);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' }, this.textSub));
    }
}

/**
 * An item in a list of duplicate facility waypoints. Displays the type of the waypoint, an icon, and the region in
 * which the waypoint is located.
 */
class WptDupListItem extends UiControl {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.iconRef = FSComponent.createRef();
        this.regionContainerRef = FSComponent.createRef();
        this.regionRef = FSComponent.createRef();
        this.waypointChangedHandler = this.onWaypointChanged.bind(this);
        this.facilityTypeSub = ComputedSubject.create(null, (waypoint) => {
            return waypoint ? WptDupListItem.FACILITY_TYPE_TEXT[ICAO.getFacilityType(waypoint.facility.icao)] : '';
        });
        this.props.waypoint.sub(this.waypointChangedHandler, true);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getHighlightElement() {
        return this.regionContainerRef.instance;
    }
    /**
     * A callback which is called when this item's waypoint changes.
     * @param waypoint The new waypoint.
     */
    onWaypointChanged(waypoint) {
        this.facilityTypeSub.set(waypoint);
    }
    /**
     * Renders this control.
     * @returns this control's VNode.
     */
    renderControl() {
        var _a;
        return (FSComponent.buildComponent("div", { class: `wpt-dup-listitem ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}` },
            FSComponent.buildComponent("div", { class: 'wpt-dup-listitem-type' }, this.facilityTypeSub),
            FSComponent.buildComponent(WaypointIcon, { ref: this.iconRef, waypoint: this.props.waypoint, class: 'wpt-dup-listitem-icon' }),
            FSComponent.buildComponent("div", { ref: this.regionContainerRef, class: 'wpt-dup-listitem-region-container' },
                FSComponent.buildComponent(WaypointRegion, { ref: this.regionRef, waypoint: this.props.waypoint, class: 'wpt-dup-listitem-region' }))));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    destroy() {
        this.iconRef.instance.destroy();
        this.regionRef.instance.destroy();
        this.props.waypoint.unsub(this.waypointChangedHandler);
    }
}
WptDupListItem.FACILITY_TYPE_TEXT = {
    [FacilityType.Airport]: 'APT',
    [FacilityType.VOR]: 'VOR',
    [FacilityType.NDB]: 'NDB',
    [FacilityType.Intersection]: 'INT',
    [FacilityType.USR]: 'USR',
    [FacilityType.RWY]: 'RWY',
    [FacilityType.VIS]: 'VIS'
};

/**
 * A dialog for selecting from a list of duplicate waypoints.
 */
class WptDupDialog extends UiView {
    constructor() {
        super(...arguments);
        this.listRef = FSComponent.createRef();
        this.waypoints = ArraySubject.create();
        this.ident = Subject.create('');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onInputDataSet(input) {
        this.ident.set((input === null || input === void 0 ? void 0 : input.length) ? ICAO.getIdent(input[0].facility.icao) : '');
        input ? this.waypoints.set(input) : this.waypoints.clear();
        this.scrollController.gotoFirst();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.ENT:
                return this.onEnterPressed();
            case FmsHEvent.CLR:
                return this.onClearPressed();
        }
        return false;
    }
    /**
     * This method is called when Enter is pressed.
     * @returns whether the event was handled.
     */
    onEnterPressed() {
        const selectedWaypoint = this.listRef.instance.getSelectedItem();
        if (selectedWaypoint) {
            this.accept(selectedWaypoint.facility, true);
            return true;
        }
        return false;
    }
    /**
     * This method is called when CLR is pressed.
     * @returns whether the event was handled.
     */
    onClearPressed() {
        this.close();
        return true;
    }
    /**
     * Renders a duplicate waypoint list item.
     * @param cssClass CSS class(es) to add to the list item.
     * @param waypoint A waypoint.
     * @param registerFn The register callback to use.
     * @returns a list item VNode.
     */
    renderListItem(cssClass, waypoint, registerFn) {
        return (FSComponent.buildComponent(WptDupListItem, { onRegister: registerFn, waypoint: Subject.create(waypoint), class: cssClass }));
    }
}

/**
 * A dialog for selecting from a list of duplicate waypoints.
 */
class PFDWptDupDialog extends WptDupDialog {
    /**
     * Renders this component.
     * @returns the component VNode.
     */
    render() {
        const listContainerRef = FSComponent.createRef();
        return (FSComponent.buildComponent("div", { class: 'popout-dialog pfd-wpt-dup', ref: this.viewContainerRef },
            FSComponent.buildComponent("h1", null, this.props.title),
            FSComponent.buildComponent("div", { class: 'pfd-wpt-dup-ident' },
                FSComponent.buildComponent("div", { class: 'pfd-wpt-dup-ident-title' }, "WPT"),
                FSComponent.buildComponent("div", null, this.ident)),
            FSComponent.buildComponent("hr", null),
            FSComponent.buildComponent("div", { class: 'pfd-wpt-dup-list-container', ref: listContainerRef },
                FSComponent.buildComponent(List, { ref: this.listRef, onRegister: this.register, data: this.waypoints, renderItem: this.renderListItem.bind(this, 'pfd-wpt-dup-listitem'), scrollContainer: listContainerRef, class: 'pfd-wpt-dup-list' })),
            FSComponent.buildComponent(ScrollBar, null)));
    }
}

/**
 * A store for commonly used waypoint info.
 */
class WaypointInfoStore {
    /**
     * Constructor.
     * @param waypoint A subscribable which provides this store's waypoint. If not defined, this store's waypoint can
     * still be set via its .waypoint Subject.
     * @param planePos A subscribable which provides the current airplane position for this store. If not defined, then
     * this store will not provide distance- or bearing-to-waypoint information.
     */
    constructor(waypoint, planePos) {
        this.planePos = planePos;
        /** This store's current waypoint. */
        this.waypoint = Subject.create(null);
        this._location = GeoPointSubject.createFromGeoPoint(WaypointInfoStore.NULL_LOCATION.copy());
        this._name = ComputedSubject.create(null, (waypoint) => {
            if (waypoint) {
                if (waypoint instanceof FacilityWaypoint && waypoint.facility.name !== '') {
                    return Utils.Translate(waypoint.facility.name);
                }
            }
            return '__________';
        });
        this._region = ComputedSubject.create(null, (waypoint) => {
            if (waypoint instanceof FacilityWaypoint) {
                if (waypoint instanceof AirportWaypoint) {
                    // airports don't have region codes in their ICAO strings, we will try to grab the code from the first 2
                    // letters of the ident. However, some airports (e.g. in the US and those w/o 4-letter idents) don't use the
                    // region code for the ident, so we need a third fallback, which is to just display the city name instead.
                    const airport = waypoint.facility;
                    const ident = ICAO.getIdent(airport.icao).trim();
                    let text = ident.length === 4 ? Regions.getName(ident.substr(0, 2)) : '';
                    if (text === '' && airport.city !== '') {
                        text = airport.city.split(', ').map(name => Utils.Translate(name)).join(', ');
                    }
                    if (text) {
                        return text;
                    }
                }
                else {
                    return Regions.getName(waypoint.facility.icao.substr(1, 2));
                }
            }
            return '__________';
        });
        this._city = ComputedSubject.create(null, (waypoint) => {
            if (waypoint instanceof FacilityWaypoint && waypoint.facility.city !== '') {
                return waypoint.facility.city.split(', ').map(name => Utils.Translate(name)).join(', ');
            }
            return '__________';
        });
        this._distance = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(NaN));
        this._bearing = NumberUnitSubject.createFromNumberUnit(UnitType.DEGREE.createNumber(NaN));
        waypoint && waypoint.sub(wpt => { this.waypoint.set(wpt); }, true);
        this.waypoint.sub(this.onWaypointChanged.bind(this), true);
        planePos && planePos.sub(this.onPlanePosChanged.bind(this), true);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The location of this store's current waypoint. */
    get location() {
        return this._location;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The name of this store's current waypoint. */
    get name() {
        return this._name;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The region of this store's current waypoint. */
    get region() {
        return this._region;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The city associated with this store's current waypoint. */
    get city() {
        return this._city;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The distance from the airplane to this store's current waypoint. */
    get distance() {
        return this._distance;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The true bearing from the airplane to this store's current waypoint. */
    get bearing() {
        return this._bearing;
    }
    /**
     * A callback which is called when this store's waypoint changes.
     * @param waypoint The new waypoint.
     */
    onWaypointChanged(waypoint) {
        var _a, _b;
        const planePos = (_b = (_a = this.planePos) === null || _a === void 0 ? void 0 : _a.get()) !== null && _b !== void 0 ? _b : WaypointInfoStore.NULL_LOCATION;
        this.updateLocation(waypoint);
        this.updateName(waypoint);
        this.updateRegion(waypoint);
        this.updateCity(waypoint);
        this.updateDistance(waypoint, planePos);
        this.updateBearing(waypoint, planePos);
    }
    /**
     * A callback which is called when this store's plane position changes.
     * @param planePos The new plane position.
     */
    onPlanePosChanged(planePos) {
        const waypoint = this.waypoint.get();
        if (waypoint) {
            this.updateDistance(waypoint, planePos);
            this.updateBearing(waypoint, planePos);
        }
    }
    /**
     * Updates this store's location information.
     * @param waypoint The store's current waypoint.
     */
    updateLocation(waypoint) {
        var _a;
        this._location.set((_a = waypoint === null || waypoint === void 0 ? void 0 : waypoint.location) !== null && _a !== void 0 ? _a : WaypointInfoStore.NULL_LOCATION);
    }
    /**
     * Updates this store's name information.
     * @param waypoint The store's current waypoint.
     */
    updateName(waypoint) {
        this._name.set(waypoint);
    }
    /**
     * Updates this store's region information.
     * @param waypoint The store's current waypoint.
     */
    updateRegion(waypoint) {
        this._region.set(waypoint);
    }
    /**
     * Updates this store's city information.
     * @param waypoint The store's current waypoint.
     */
    updateCity(waypoint) {
        this._city.set(waypoint);
    }
    /**
     * Updates this store's distance-to-waypoint information.
     * @param waypoint The store's current waypoint.
     * @param planePos The current position of the airplane.
     */
    updateDistance(waypoint, planePos) {
        if (!waypoint || isNaN(planePos.lat) || isNaN(planePos.lon)) {
            this._distance.set(NaN);
            return;
        }
        this._distance.set(waypoint.location.distance(planePos), UnitType.GA_RADIAN);
    }
    /**
     * Updates this store's bearing-to-waypoint information.
     * @param waypoint The store's current waypoint.
     * @param planePos The current position of the airplane.
     */
    updateBearing(waypoint, planePos) {
        if (!waypoint || isNaN(planePos.lat) || isNaN(planePos.lon)) {
            this._bearing.set(NaN);
            return;
        }
        const brg = NavMath.normalizeHeading(Math.round(planePos.bearingTo(waypoint.location) - MagVar.get(planePos)));
        this._bearing.set(brg === 0 ? 360 : brg);
    }
}
WaypointInfoStore.NULL_LOCATION = new GeoPoint(NaN, NaN);

/**
 * Wpt info store
 */
class WptInfoStore extends WaypointInfoStore {
    constructor() {
        super(...arguments);
        this.prompt = Subject.create('');
        this._matchedWaypoints = [];
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** An array of waypoints which have matched the input. */
    get matchedWaypoints() {
        return this._matchedWaypoints;
    }
    /**
     * Set the list of matched waypoints.
     * @param waypoints An array of matched waypoints.
     */
    setMatchedWaypoints(waypoints) {
        this._matchedWaypoints = [...waypoints];
    }
}

/**
 * Wpt info controller
 */
class WptInfoController {
    /**
     * Creates an instance of wpt info controller.
     * @param store The store.
     * @param selectedWaypoint The subject which provides the waypoint info component's selected waypoint.
     */
    constructor(store, selectedWaypoint) {
        this.store = store;
        this.selectedWaypoint = selectedWaypoint;
        /**
         * A function which handles changes in waypoint input's matched waypoints.
         * @param waypoints The matched waypoints.
         */
        this.matchedWaypointsChangedHandler = this.onMatchedWaypointsChanged.bind(this);
        /**
         * A function which handles changes in waypoint input's selected waypoint.
         * @param waypoint The selected waypoint.
         */
        this.selectedWaypointChangedHandler = this.onSelectedWaypointChanged.bind(this);
        this.onMatchedWaypointsChanged([]);
    }
    /**
     * A callback which is called when the waypoint input's matched waypoints change.
     * @param waypoints The matched waypoints.
     */
    onMatchedWaypointsChanged(waypoints) {
        this.store.setMatchedWaypoints(waypoints);
        if (waypoints.length > 1) {
            this.store.prompt.set('Press "ENT" for dups');
        }
        else {
            this.store.prompt.set('Press "ENT" to accept');
        }
    }
    /**
     * A callback which is called when the waypoint input's selected waypoint changes.
     * @param waypoint The selected waypoint.
     */
    onSelectedWaypointChanged(waypoint) {
        this.selectedWaypoint.set(waypoint);
    }
}

/**
 * Input Component Class
 */
class InputComponent extends UiControl {
    constructor() {
        super(...arguments);
        this.textBoxRef = FSComponent.createRef();
        this.keyboardIconRef = FSComponent.createRef();
        this.inputValueContainerRef = FSComponent.createRef();
        this.selectedSpanRef = FSComponent.createRef();
        this.keyboardInputHandler = this.handleTextboxInput.bind(this);
        this.dataEntry = {
            text: '',
            highlightIndex: 0,
            beforeSelected: Subject.create(''),
            selected: Subject.create(''),
            afterSelected: Subject.create(''),
        };
        this.characterMap = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
        this.isKeyboardActive = false;
        this.inputCharacterIndex = 0;
        this.previousValue = '';
        /**
         * Method to handle when the virtual keyboard button is clicked
         */
        this.handleKeyboardClicked = () => {
            if (this.getIsFocused()) {
                if (!this.isKeyboardActive) {
                    this.activateKeyboardInput();
                }
                else {
                    this.deactivateKeyboardInput();
                }
            }
        };
        /**
         * Method to handle when input focus is set
         * @param e The focus event.
         */
        this.onInputFocus = (e) => {
            e.preventDefault();
            Coherent.trigger('FOCUS_INPUT_FIELD', '', '', '', '', false);
            Coherent.on('mousePressOutsideView', () => {
                this.textBoxRef.instance.blur();
            });
            this.textBoxRef.instance.focus({ preventScroll: true });
            this.textBoxRef.instance.value = this.dataEntry.text.substr(0, this.dataEntry.highlightIndex);
            this.textBoxRef.instance.disabled = false;
            this.textBoxRef.instance.addEventListener('input', this.keyboardInputHandler);
            this.keyboardIconRef.instance.classList.add('active');
        };
        /**
         * Method to handle on input blur
         */
        this.onInputBlur = () => {
            this.textBoxRef.instance.disabled = true;
            this.textBoxRef.instance.value = '';
            Coherent.trigger('UNFOCUS_INPUT_FIELD', '');
            Coherent.off('mousePressOutsideView');
            if (this.keyboardInputHandler) {
                this.textBoxRef.instance.removeEventListener('input', this.keyboardInputHandler);
            }
            this.keyboardIconRef.instance.classList.remove('active');
        };
    }
    /**
     * Method to set the initial text value when the component is made active.
     * @param value is a string containing the start text value
     * @param highlightIndex The new index of the highlighted character. The index will remain unchanged if this
     * argument is undefined.
     * @param emitEvent Whether a text changed event should be emitted.
     */
    setText(value, highlightIndex, emitEvent = true) {
        this.dataEntry.text = value.padEnd(this.props.maxLength, '_').substr(0, this.props.maxLength);
        this.dataEntry.highlightIndex = Utils.Clamp(highlightIndex !== null && highlightIndex !== void 0 ? highlightIndex : this.dataEntry.highlightIndex, 0, this.dataEntry.text.length - 1);
        this.textBoxRef.instance.value = value.substr(0, this.dataEntry.highlightIndex);
        this.updateDataEntryElement(undefined, emitEvent);
    }
    /**
     * Gets the current input.
     * @returns the data entry text
     */
    getText() {
        return this.dataEntry.text;
    }
    /**
     * Gets the raw input without blank fills.
     * @returns the data entry text without blank fills
     */
    getRawText() {
        return this.dataEntry.text.replace(/_/g, ' ').trim();
    }
    /**
     * Clears the input.
     * @param emitEvent A boolean indicating if an event should be emitted after clearing the input value.
     */
    clear(emitEvent = true) {
        this.setText('', 0, emitEvent);
    }
    /**
     * Method to select a character for data entry. TODO: Make part of component
     * @param increment is a bool for whether to increment or decrement the input character when the method is called
     * @returns a character to input into the data entry element
     */
    updateSelectedCharacter(increment = true) {
        this.inputCharacterIndex += increment ? 1 : -1;
        if (this.inputCharacterIndex > (this.characterMap.length - 1)) {
            this.inputCharacterIndex = 0;
        }
        else if (this.inputCharacterIndex < 0) {
            this.inputCharacterIndex = (this.characterMap.length - 1);
        }
        return this.characterMap[this.inputCharacterIndex];
    }
    /**
     * Method to update data entry field. TODO: Make part of component
     * @param newCharacter is the new string character to input
     * @param [emitEvent] A boolean indicating if a text changed event should be emitted.
     */
    updateDataEntryElement(newCharacter = undefined, emitEvent = true) {
        let beforeText = '';
        let selectedChar = '';
        let afterText = '';
        const text = this.dataEntry.text;
        if (this.dataEntry.highlightIndex !== undefined) {
            beforeText = text.substr(0, this.dataEntry.highlightIndex);
            selectedChar = text.substr(this.dataEntry.highlightIndex, 1);
            afterText = text.substr(this.dataEntry.highlightIndex + 1);
        }
        else {
            afterText = text;
        }
        if (newCharacter) {
            selectedChar = newCharacter;
            // clear chars after this
            const blankFill = this.props.maxLength - (this.dataEntry.highlightIndex + 1);
            if (blankFill > 1) {
                afterText = ''.padStart(blankFill, '_');
            }
        }
        this.inputCharacterIndex = this.characterMap.indexOf(selectedChar);
        const updatedText = beforeText + selectedChar + afterText;
        this.dataEntry.text = updatedText;
        if (emitEvent) {
            this.props.onTextChanged(this.dataEntry.text.replace(/_/g, ' ').trim());
        }
        this.dataEntry.beforeSelected.set(beforeText);
        this.dataEntry.selected.set(selectedChar);
        this.dataEntry.afterSelected.set(afterText);
    }
    /**
     * Handles the input from the hidden textbox
     */
    handleTextboxInput() {
        const targetChars = this.textBoxRef.instance.value.trimRight().length;
        this.dataEntry.text = this.textBoxRef.instance.value.toUpperCase().padEnd(6, '_');
        this.dataEntry.highlightIndex = Utils.Clamp(targetChars, 0, this.dataEntry.text.length - 1);
        this.updateDataEntryElement(undefined, true);
    }
    /**
     * Activates keyboard input. If this control is not active, activating keyboard input will activate this control as
     * well.
     */
    activateKeyboardInput() {
        if (!this.isActivated) {
            this.activate();
        }
        this.textBoxRef.instance.disabled = false;
        this.textBoxRef.instance.focus();
        this.isKeyboardActive = true;
    }
    /**
     * Deactivates keyboard input.
     */
    deactivateKeyboardInput() {
        this.textBoxRef.instance.blur();
        this.textBoxRef.instance.disabled = true;
        this.isKeyboardActive = false;
    }
    /** @inheritdoc */
    onUpperKnobInc() {
        if (!this.getIsActivated()) {
            this.activate();
            if (this.getRawText() === '') {
                this.inputCharacterIndex = 9;
                this.updateDataEntryElement(this.updateSelectedCharacter(true));
            }
        }
        else {
            this.updateDataEntryElement(this.updateSelectedCharacter(true));
        }
    }
    /** @inheritdoc */
    onUpperKnobDec() {
        if (!this.getIsActivated()) {
            this.activate();
            if (this.getRawText() === '') {
                this.inputCharacterIndex = 11;
                this.updateDataEntryElement(this.updateSelectedCharacter(false));
            }
        }
        else {
            this.updateDataEntryElement(this.updateSelectedCharacter(false));
        }
    }
    /** @inheritdoc */
    onLowerKnobInc() {
        if (this.dataEntry.highlightIndex < 5) {
            this.dataEntry.highlightIndex++;
            this.updateDataEntryElement();
            if (this.isKeyboardActive) {
                this.textBoxRef.instance.value = this.dataEntry.text.substr(0, this.dataEntry.highlightIndex);
            }
        }
    }
    /** @inheritdoc */
    onLowerKnobDec() {
        if (this.dataEntry.highlightIndex < 1) {
            this.dataEntry.highlightIndex = 0;
        }
        else {
            this.dataEntry.highlightIndex--;
            this.updateDataEntryElement();
            if (this.isKeyboardActive) {
                this.textBoxRef.instance.value = this.dataEntry.text.substr(0, this.dataEntry.highlightIndex);
            }
        }
    }
    /** @inheritdoc */
    onEnter() {
        if (this.getIsActivated()) {
            this.deactivate();
            if (this.props.onEnter) {
                this.props.onEnter(this);
            }
            return true;
        }
        else if (this.getIsFocused()) {
            if (this.props.onEnter) {
                this.props.onEnter(this);
            }
        }
        return false;
    }
    /** @inheritdoc */
    onClr() {
        if (this.getIsActivated()) {
            this.setText(this.previousValue);
            this.deactivate();
            return true;
        }
        return false;
    }
    /** @inheritdoc */
    getHighlightElement() {
        return this.inputValueContainerRef.instance;
    }
    /** @inheritdoc */
    onAfterRender() {
        super.onAfterRender();
        this.clear();
        this.inputValueContainerRef.instance.style.width = `${this.props.maxLength * 15}px`;
        this.keyboardIconRef.instance.onmouseup = this.handleKeyboardClicked;
        this.inputValueContainerRef.instance.onmouseup = this.handleKeyboardClicked;
        this.textBoxRef.instance.onfocus = this.onInputFocus;
        this.textBoxRef.instance.onblur = this.onInputBlur;
        this.textBoxRef.instance.blur();
        // Make sure we deactivate ourselves if we lose focus.
        this.focusSubject.sub((v, rv) => { !rv && this.isActivated && this.deactivate(); });
    }
    /** @inheritdoc */
    onActivated() {
        var _a;
        this.dataEntry.highlightIndex = 0;
        this.updateDataEntryElement();
        this.previousValue = this.getText();
        this.selectedSpanRef.instance.classList.add(UiControl.FOCUS_CLASS);
        (_a = this.getHighlightElement()) === null || _a === void 0 ? void 0 : _a.classList.remove(UiControl.FOCUS_CLASS);
    }
    /** @inheritdoc */
    onDeactivated() {
        var _a;
        this.previousValue = this.getText();
        this.textBoxRef.instance.blur();
        this.selectedSpanRef.instance.classList.remove(UiControl.FOCUS_CLASS);
        if (this.getIsFocused()) {
            (_a = this.getHighlightElement()) === null || _a === void 0 ? void 0 : _a.classList.add(UiControl.FOCUS_CLASS);
        }
    }
    /** @inheritdoc */
    renderControl() {
        return (FSComponent.buildComponent("div", { class: "input-component-scroller" },
            FSComponent.buildComponent("div", { ref: this.inputValueContainerRef, class: "input-component-value", style: "display:inline-block;" },
                this.dataEntry.beforeSelected,
                FSComponent.buildComponent("span", { ref: this.selectedSpanRef }, this.dataEntry.selected),
                this.dataEntry.afterSelected),
            FSComponent.buildComponent("input", { tabindex: "-1", ref: this.textBoxRef, width: "5px", style: "border:1px; background-color:black; opacity:0;", type: "text", size: "1", maxLength: "6" }),
            FSComponent.buildComponent("img", { ref: this.keyboardIconRef, src: 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/keyboard_icon.png', class: 'input-component-keyboard-icon' })));
    }
}

/**
 * The ActionButton component.
 */
class ActionButton extends UiControl {
    /** @inheritdoc */
    onEnter() {
        this.props.onExecute();
        return true;
    }
    /** @inheritdoc */
    renderControl() {
        return (FSComponent.buildComponent("div", { class: "action-button" }, this.props.text));
    }
}

/**
 * Confirmation dialog for generic messages.
 */
class MessageDialog extends UiView {
    constructor() {
        super(...arguments);
        this.closeOnAccept = true;
        this.contentRef = FSComponent.createRef();
        this.confirmButtonText = Subject.create('');
        this.rejectButtonText = Subject.create('');
        this.orDivRef = FSComponent.createRef();
        this.rejectButtonRef = FSComponent.createRef();
        this.renderedContent = null;
        /** Callback for when the first button is pressed. */
        this.onButton1Pressed = () => {
            //this.close();
            this.accept(true, this.closeOnAccept);
        };
        /** Callback for when the second button is pressed. */
        this.onButton2Pressed = () => {
            this.accept(false, this.closeOnAccept);
        };
    }
    /** @inheritdoc */
    onInputDataSet(input) {
        if (input) {
            this.rejectButtonRef.instance.setIsVisible(input.hasRejectButton ? true : false);
            this.orDivRef.instance.style.display = input.hasRejectButton ? '' : 'none';
            this.closeOnAccept = input.closeOnAccept !== undefined ? input.closeOnAccept : true;
            this.renderContent(input);
        }
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        // noop
        switch (evt) {
            case FmsHEvent.CLR:
                this.close();
                return true;
        }
        return false;
    }
    /**
     * Renders the dialog content.
     * @param input The input data
     **/
    renderContent(input) {
        var _a, _b;
        this.cleanUpRenderedContent();
        if (input) {
            this.confirmButtonText.set((_a = input.confirmButtonText) !== null && _a !== void 0 ? _a : 'OK');
            this.rejectButtonText.set((_b = input.rejectButtonText) !== null && _b !== void 0 ? _b : 'CANCEL');
        }
        if (input.inputString !== undefined) {
            // we use innerHTML rather than textContent so we can provide pre-formatted strings.
            this.contentRef.instance.innerHTML = input.inputString;
        }
        else {
            // render items
            if (input.renderContent) {
                this.renderedContent = input.renderContent();
                FSComponent.render(this.renderedContent, this.contentRef.instance);
            }
        }
    }
    /**
     * Cleans up any rendered content.
     */
    cleanUpRenderedContent() {
        var _a;
        this.contentRef.instance.innerHTML = '';
        if (((_a = this.renderedContent) === null || _a === void 0 ? void 0 : _a.instance) instanceof DisplayComponent) {
            this.renderedContent.instance.destroy();
        }
        this.renderedContent = null;
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: 'popout-dialog msgdialog', ref: this.viewContainerRef },
            FSComponent.buildComponent("div", { class: 'msgdialog-popout-background' },
                FSComponent.buildComponent("div", { class: 'msgdialog-container' },
                    FSComponent.buildComponent("div", { class: 'msgdialog-content msgdialog-center', ref: this.contentRef }),
                    FSComponent.buildComponent("hr", { class: 'msgdialog-hr' }),
                    FSComponent.buildComponent("div", { class: "msgdialog-action-buttons" },
                        FSComponent.buildComponent(ActionButton, { onRegister: this.register, onExecute: this.onButton1Pressed, text: this.confirmButtonText }),
                        FSComponent.buildComponent("div", { ref: this.orDivRef }, "or"),
                        FSComponent.buildComponent(ActionButton, { ref: this.rejectButtonRef, onRegister: this.register, onExecute: this.onButton2Pressed, text: this.rejectButtonText }))))));
    }
}

/**
 * Waypoint input controller
 */
class WaypointInputController {
    /**
     * Creates an instance of waypoint input controller.
     * @param store The store associated with this controller.
     * @param selectedIcao A subject which provides an ICAO string for this controller's input component to bind.
     * @param onInputTextValueOverride A function which is called when the input text value needs to be overridden.
     */
    constructor(store, selectedIcao, onInputTextValueOverride) {
        this.store = store;
        this.selectedIcao = selectedIcao;
        this.onInputTextValueOverride = onInputTextValueOverride;
        this.icaoSearchDebounceTimer = null;
        this.searchOpId = 0;
        this.ignoreSelectedIcao = false;
        this.store.selectedWaypoint.sub((waypoint) => {
            var _a;
            this.ignoreSelectedIcao = true;
            const icao = (_a = waypoint === null || waypoint === void 0 ? void 0 : waypoint.facility.icao) !== null && _a !== void 0 ? _a : '';
            this.selectedIcao.set(icao);
            if (waypoint) {
                const ident = ICAO.getIdent(icao);
                // check if the current input value is a prefix of the suggested ident.
                if (ident.indexOf(this.store.inputValue.get()) === 0) {
                    this.store.inputValue.set(ident);
                    this.onInputTextValueOverride && this.onInputTextValueOverride(ident);
                }
            }
            this.ignoreSelectedIcao = false;
        });
        this.selectedIcao.sub((icao) => {
            if (this.ignoreSelectedIcao) {
                return;
            }
            this.searchOpId++;
            if (icao === '') {
                this.onInputTextValueOverride && this.onInputTextValueOverride('');
                this.store.loadIcaoData([]);
                this.store.inputValue.set('');
            }
            else {
                this.onInputTextValueOverride && this.onInputTextValueOverride(ICAO.getIdent(icao));
                this.store.loadIcaoData([icao]);
            }
        });
    }
    /**
     * Handler method to handle the input text from the input component.
     * @param value is the updated text from the input component.
     */
    onInputChanged(value) {
        this.store.inputValue.set(value);
        this.scheduleICAOSearch(value);
    }
    /**
     * Schedules an ICAO search. Cancels any pending ICAO searches which were scheduled earlier.
     * @param text The text to search against.
     */
    scheduleICAOSearch(text) {
        if (this.icaoSearchDebounceTimer !== null) {
            clearTimeout(this.icaoSearchDebounceTimer);
        }
        const opId = ++this.searchOpId;
        this.icaoSearchDebounceTimer = setTimeout(() => {
            this.icaoSearchDebounceTimer = null;
            this.executeICAOSearch(text, opId);
        }, WaypointInputController.ICAO_SEARCH_DEBOUNCE_DELAY);
    }
    /**
     * Executes an ICAO search.
     * @param text The text to search against.
     * @param opId The id of the search to complete.
     */
    async executeICAOSearch(text, opId) {
        if (this.isIcaoValid(text)) {
            try {
                if (opId === this.searchOpId) {
                    const searchText = text.trim();
                    let icaos = await this.store.doSearch(searchText);
                    if (opId !== this.searchOpId) {
                        return;
                    }
                    //One or more exact matches
                    let exactMatches = 0;
                    if (ICAO.getIdent(icaos[0]) === searchText) {
                        for (let i = 0; i < icaos.length; i++) {
                            if (ICAO.getIdent(icaos[i]) === searchText) {
                                exactMatches++;
                            }
                            else {
                                break;
                            }
                        }
                    }
                    if (exactMatches !== 0) {
                        icaos = icaos.slice(0, exactMatches);
                    }
                    else {
                        icaos.splice(1, icaos.length - 1);
                    }
                    this.store.loadIcaoData(icaos.length > 1 ? Array.from(new Set(icaos)) : icaos);
                }
            }
            catch (e) {
                // noop
            }
        }
        else {
            if (opId === this.searchOpId) {
                this.store.loadIcaoData([]);
            }
        }
    }
    /**
     * Validates the ICAO search input.
     * @param icao The value coming from the ICAO input.
     * @returns A {boolean} indicating if the input is valid for search.
     */
    isIcaoValid(icao) {
        if (icao.length > 0 && !icao.startsWith(' ')) {
            // check if there comes another whitespace before a letter
            let prevCharBlank = false;
            for (let i = 1; i < icao.length; i++) {
                const char = icao[i];
                const currentCharBlank = char === ' ';
                if (prevCharBlank && !currentCharBlank) {
                    return false;
                }
                prevCharBlank = currentCharBlank;
            }
            return true;
        }
        return false;
    }
}
WaypointInputController.ICAO_SEARCH_DEBOUNCE_DELAY = 250; // milliseconds

/**
 * Waypoint input store
 */
class WaypointInputStore {
    /**
     * Creates an instance of waypoint input store.
     * @param bus The event bus.
     * @param searchFilter This store's search filter for ICAOSearch.
     * @param onWaypointChanged A function which is called when this store's selected waypoint changes.
     * @param onFacilityChanged A function which is called when this store's selected facility changes.
     * @param onMatchedWaypointsChanged A function which is called when this store's matched waypoints changes.
     */
    constructor(bus, searchFilter, onWaypointChanged, onFacilityChanged, onMatchedWaypointsChanged) {
        this.searchFilter = searchFilter;
        this.onWaypointChanged = onWaypointChanged;
        this.onFacilityChanged = onFacilityChanged;
        this.onMatchedWaypointsChanged = onMatchedWaypointsChanged;
        this.nameEmptyStr = '_______________';
        this.cityEmptyStr = '________________';
        this.displayWaypoint = {
            icao: '',
            name: ComputedSubject.create(this.nameEmptyStr, (v) => {
                return (v === '') ? this.nameEmptyStr : Utils.Translate(v);
            }),
            city: ComputedSubject.create('', (v) => {
                if (v === '') {
                    return this.cityEmptyStr;
                }
                const separatedCity = v.split(', ');
                return separatedCity.length > 1 ? Utils.Translate(separatedCity[0]) + ' ' + Utils.Translate(separatedCity[1]).substr(0, 2).toUpperCase() : Utils.Translate(v);
            }),
        };
        /** A subject which provides the currently selected waypoint. */
        this.selectedWaypoint = Subject.create(null);
        /** A subject which provides the input text value which should be displayed. */
        this.inputValue = Subject.create('');
        this._matchedIcaos = [];
        this._matchedWaypoints = [];
        this.loadIcaosOpId = 0;
        this.facRepo = FacilityRespository.getRepository(bus);
        this.facLoader = new FacilityLoader(this.facRepo);
        this.facWaypointCache = FacilityWaypointCache.getCache();
        this.selectedWaypoint.sub(waypoint => {
            this.onWaypointChanged && this.onWaypointChanged(waypoint);
            this.onFacilityChanged && this.onFacilityChanged(waypoint === null || waypoint === void 0 ? void 0 : waypoint.facility);
        });
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** An array of ICAO strings which have matched the input. */
    get matchedIcaos() {
        return this._matchedIcaos;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** An array of facilities which have matched the input. */
    get matchedWaypoints() {
        return this._matchedWaypoints;
    }
    /**
     * Executes the icao search.
     * @param searchStr The search string.
     * @returns An array of the found ICAOs.
     */
    doSearch(searchStr) {
        return this.facLoader.searchByIdent(this.searchFilter, searchStr);
    }
    /**
     * Loads and display the facility data for the currently found ICAO
     * @param icaos The ICAO to load.
     * @returns a Promise which fulfills with whether the ICAO data was successfully loaded.
     */
    async loadIcaoData(icaos) {
        if (icaos.length === this._matchedIcaos.length && icaos.every((icao, index) => icao === this._matchedIcaos[index])) {
            return false;
        }
        const opId = ++this.loadIcaosOpId;
        let matchedWaypoints;
        try {
            matchedWaypoints = await Promise.all(icaos.map(async (icao) => this.facWaypointCache.get(await this.facLoader.getFacility(ICAO.getFacilityType(icao), icao))));
        }
        catch (e) {
            icaos = [];
        }
        if (opId !== this.loadIcaosOpId) {
            return false;
        }
        this._matchedIcaos = [...icaos];
        this._matchedWaypoints = matchedWaypoints !== null && matchedWaypoints !== void 0 ? matchedWaypoints : [];
        this.onMatchedWaypointsChanged && this.onMatchedWaypointsChanged(this.matchedWaypoints);
        if (this._matchedWaypoints.length > 0) {
            this.setWaypoint(this._matchedWaypoints[0]);
        }
        else {
            this.clearWaypoint();
        }
        return true;
    }
    /**
     * Sets the selected and displayed waypoint.
     * @param waypoint A facility waypoint.
     */
    setWaypoint(waypoint) {
        this.selectedWaypoint.set(waypoint);
        this.displayWaypoint.icao = waypoint.facility.icao;
        this.displayWaypoint.city.set(waypoint.facility.city);
        this.displayWaypoint.name.set(waypoint.facility.name);
    }
    /**
     * Clears the selected and displayed waypoint.
     */
    clearWaypoint() {
        this.selectedWaypoint.set(null);
        if (this.displayWaypoint.icao !== '') {
            this.displayWaypoint.icao = '';
            this.displayWaypoint.city.set('');
            this.displayWaypoint.name.set('');
        }
    }
}

/** The WaypointInput component. */
class WaypointInput extends UiControlGroup {
    constructor() {
        super(...arguments);
        this.inputComponentRef = FSComponent.createRef();
        this.store = new WaypointInputStore(this.props.bus, this.props.filter, this.props.onWaypointChanged, this.props.onFacilityChanged, this.props.onMatchedWaypointsChanged);
        this.controller = new WaypointInputController(this.store, this.props.selectedIcao, this.onInputTextValueOverride.bind(this));
    }
    /**
     * A callback which is called when the input text value needs to be overridden.
     * @param value The new input text value.
     */
    onInputTextValueOverride(value) {
        this.inputComponentRef.instance.setText(value, value === '' ? 0 : undefined, false);
    }
    /**
     * A callback which is called when Enter is pressed on this component's InputComponent child.
     * @returns whether the Enter event was handled.
     */
    onInputEnterPressed() {
        const facilityWaypoint = this.store.selectedWaypoint.get();
        if (!facilityWaypoint && this.store.inputValue.get() !== '') {
            Fms.viewService.open(MessageDialog.name, true).setInput({ inputString: `${this.store.inputValue.get().replace(/^_+|_+$/g, '')} does not exist.` }).onClose.on(() => {
                this.inputComponentRef.instance.activate();
            });
        }
        else {
            if (this.props.onInputEnterPressed !== undefined && facilityWaypoint !== null) {
                this.props.onInputEnterPressed(facilityWaypoint.facility);
            }
        }
        return true;
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "wpt-entry" },
            FSComponent.buildComponent(InputComponent, { onRegister: this.register, ref: this.inputComponentRef, maxLength: 6, onTextChanged: this.controller.onInputChanged.bind(this.controller), onEnter: this.onInputEnterPressed.bind(this) }),
            FSComponent.buildComponent(WaypointIcon, { waypoint: this.store.selectedWaypoint, planeHeading: this.props.planeHeading, class: 'wpt-entry-icon' }),
            FSComponent.buildComponent("div", { class: "wpt-entry-location" }, this.store.displayWaypoint.city),
            FSComponent.buildComponent("div", { class: "wpt-entry-name" }, this.store.displayWaypoint.name)));
    }
}

/**
 * The PFD waypoint info popout.
 */
class WptInfo extends UiView {
    constructor() {
        super(...arguments);
        this.inputSelectedIcao = Subject.create('');
        this.selectedWaypointSub = Subject.create(null);
        this.planePosSub = GeoPointSubject.createFromGeoPoint(new GeoPoint(NaN, NaN));
        this.planeHeadingSub = Subject.create(NaN);
        this.planePosConsumer = this.props.bus.getSubscriber().on('gps-position').whenChanged();
        this.planeHeadingConsumer = this.props.bus.getSubscriber().on('hdg_deg_true').withPrecision(1);
        this.planePosHandler = this.onPlanePosChanged.bind(this);
        this.planeHeadingHandler = this.onPlaneHeadingChanged.bind(this);
        this.store = new WptInfoStore(this.selectedWaypointSub, this.planePosSub);
        this.controller = new WptInfoController(this.store, this.selectedWaypointSub);
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.CLR:
                this.close();
                return true;
            case FmsHEvent.ENT:
                this.onEnterPressed();
                return true;
        }
        return false;
    }
    /**
     * Executes actions when Enter is pressed.
     */
    onEnterPressed() {
        const matchedWaypoints = this.store.matchedWaypoints;
        const selectedWaypoint = this.store.waypoint.get();
        if (matchedWaypoints.length > 1) {
            const dialog = Fms.viewService.open(this.getWptDupDialogName(), true).setInput(matchedWaypoints);
            dialog.onAccept.on((sender, facility) => {
                this.onWptDupDialogAccept(facility);
            });
            dialog.onClose.on(() => { this.onWptDupDialogClose(); });
        }
        else if (selectedWaypoint) {
            this.accept(selectedWaypoint.facility);
        }
    }
    /**
     * A callback which is called when a waypoint duplicate dialog invoked by this view accepts.
     * @param facility The facility returned by the waypoint duplicate dialog.
     */
    onWptDupDialogAccept(facility) {
        facility && this.accept(facility);
    }
    /**
     * A callback which is called when a waypoint duplicate dialog invoked by this view closes.
     */
    onWptDupDialogClose() {
        // noop
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewOpened() {
        this.inputSelectedIcao.set('');
        this.planePosConsumer.handle(this.planePosHandler);
        this.planeHeadingConsumer.handle(this.planeHeadingHandler);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewClosed() {
        this.planePosConsumer.off(this.planePosHandler);
        this.planeHeadingConsumer.off(this.planeHeadingHandler);
    }
    /**
     * A callback which is called when the plane's current position changes.
     * @param pos The new position.
     */
    onPlanePosChanged(pos) {
        this.planePosSub.set(pos.lat, pos.long);
    }
    /**
     * A callback which is called when the plane's current true heading changes.
     * @param heading The new heading, in degrees.
     */
    onPlaneHeadingChanged(heading) {
        this.planeHeadingSub.set(heading);
    }
    /**
     * Renders a waypoint input component.
     * @returns a waypoint input component, as a VNode.
     */
    renderWaypointInput() {
        return (FSComponent.buildComponent(WaypointInput, { bus: this.props.bus, onRegister: this.register, selectedIcao: this.inputSelectedIcao, onMatchedWaypointsChanged: this.controller.matchedWaypointsChangedHandler, onWaypointChanged: this.controller.selectedWaypointChangedHandler, onInputEnterPressed: this.onEnterPressed.bind(this), planeHeading: this.planeHeadingSub, filter: FacilitySearchType.None }));
    }
    /**
     * Renders a component which displays the bearing to the store's selected waypoint.
     * @param cssClass CSS class(es) to apply to the root of the component.
     * @returns a component which displays the bearing to the store's selected waypoint, as a VNode.
     */
    renderBearing(cssClass) {
        return (FSComponent.buildComponent(NumberUnitDisplay, { value: this.store.bearing, displayUnit: Subject.create(UnitType.DEGREE), formatter: NumberFormatter.create({ precision: 1, pad: 3, nanString: '___' }), class: cssClass }));
    }
    /**
     * Renders a component which displays the distance to the store's selected waypoint.
     * @param cssClass CSS class(es) to apply to the root of the component.
     * @returns a component which displays the distance to the store's selected waypoint, as a VNode.
     */
    renderDistance(cssClass) {
        return (FSComponent.buildComponent(NumberUnitDisplay, { value: this.store.distance, displayUnit: Subject.create(UnitType.NMILE), formatter: NumberFormatter.create({ precision: 0.1, maxDigits: 3, forceDecimalZeroes: false, nanString: '__._' }), class: cssClass }));
    }
}

/**
 * The PFD waypoint info popout.
 */
class PFDWptInfo extends WptInfo {
    // eslint-disable-next-line jsdoc/require-jsdoc
    getWptDupDialogName() {
        return PFDWptDupDialog.name;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent("div", { class: 'popout-dialog pfd-wptinfo', ref: this.viewContainerRef },
            FSComponent.buildComponent("h1", null, this.props.title),
            this.renderWaypointInput(),
            FSComponent.buildComponent("hr", null),
            FSComponent.buildComponent("div", { class: 'pfd-wptinfo-data' },
                FSComponent.buildComponent("div", { class: 'pfd-wptinfo-data-field pfd-wptinfo-bearing' },
                    FSComponent.buildComponent("div", { class: 'pfd-wptinfo-data-field-title' }, "BRG"),
                    this.renderBearing()),
                FSComponent.buildComponent("div", { class: 'pfd-wptinfo-data-field pfd-wptinfo-distance' },
                    FSComponent.buildComponent("div", { class: 'pfd-wptinfo-data-field-title' }, "DIS"),
                    this.renderDistance()),
                FSComponent.buildComponent("div", { class: 'pfd-wptinfo-region' }, this.store.region),
                FSComponent.buildComponent(LatLonDisplay, { location: this.store.location, class: 'pfd-wptinfo-latlon' })),
            FSComponent.buildComponent("div", { class: 'pfd-wptinfo-prompt' }, this.store.prompt)));
    }
}

/**
 * The map layer showing a rotating compass arrow pointing to true north.
 */
class MapMiniCompassLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.imgRef = FSComponent.createRef();
        this.needUpdate = false;
    }
    /** @inheritdoc */
    onAttached() {
        this.needUpdate = true;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.needUpdate = BitFlags.isAll(changeFlags, MapProjectionChangeType.Rotation);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        if (!this.needUpdate) {
            return;
        }
        this.updateRotation();
        this.needUpdate = false;
    }
    /**
     * Updates the rotation of the arrow.
     */
    updateRotation() {
        const rotation = this.props.mapProjection.getRotation();
        this.imgRef.instance.style.transform = `rotate(${rotation}rad)`;
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', style: 'position: relative; width: var(--minicompass-size, 4em); height: var(--minicompass-size, 4em);' },
            FSComponent.buildComponent("img", { ref: this.imgRef, src: this.props.imgSrc, style: 'width: 100%; height: 100%;' }),
            FSComponent.buildComponent("div", { style: 'position: absolute; top: 50%; width: 100%; transform: translateY(-50%); text-align: center; color: black;' }, "N")));
    }
}

/**
 * A map layer which draws a range compass in front of the map target.
 */
class MapRangeCompassLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.rootRef = FSComponent.createRef();
        this.arcLayerRef = FSComponent.createRef();
        this.roseLayerContainerRef = FSComponent.createRef();
        this.roseLayerRef = FSComponent.createRef();
        this.referenceMarkerContainerRef = FSComponent.createRef();
        this.roseLabelsLayerRef = FSComponent.createRef();
        this.headingIndicatorRef = FSComponent.createRef();
        this.rangeDisplayContainerRef = FSComponent.createRef();
        this.centerSubject = Vec2Subject.createFromVector(new Float64Array(2));
        this.radiusSubject = Subject.create(0);
        this.rotationSubject = Subject.create(0);
        this.isMagneticSubject = Subject.create(true);
        this.referenceMarkerTypeSub = Subject.create(MapRangeCompassReferenceMarkerType.TICK);
        this.needUpdateRootVisibility = false;
        this.needRedrawArc = true;
        this.needRedrawBearings = true;
        this.needRotateBearingTicks = true;
        this.needRechooseReferenceMarker = true;
        this.needRepositionReferenceMarker = true;
        this.needReclipTicks = true;
        this.needUpdateHeadingIndicatorVisibility = true;
        this.needRepositionLabel = true;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onVisibilityChanged(isVisible) {
        this.needUpdateRootVisibility = true;
        if (isVisible) {
            this.needRechooseReferenceMarker = true;
            this.updateParameters();
        }
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.arcLayerRef.instance.onAttached();
        this.roseLayerRef.instance.onAttached();
        this.roseLabelsLayerRef.instance.onAttached();
        this.referenceMarkerContainerRef.instance.onAttached();
        this.headingIndicatorRef.instance.onAttached();
        this.initStyles();
        this.initListeners();
        this.updateVisibility();
        this.updateParameters();
    }
    /**
     * Initializes ring styles.
     */
    initStyles() {
        const bearingLabelLayerDisplay = this.roseLabelsLayerRef.instance.display;
        bearingLabelLayerDisplay.context.lineWidth = this.props.bearingLabelOutlineWidth * 2;
        bearingLabelLayerDisplay.context.strokeStyle = 'black';
        bearingLabelLayerDisplay.context.font = `${this.props.bearingLabelFontSize}px ${this.props.bearingLabelFont}`;
        bearingLabelLayerDisplay.context.fillStyle = 'white';
    }
    /**
     * Initializes listeners.
     */
    initListeners() {
        this.initParameterListeners();
        this.initModuleListeners();
        this.props.showHeadingBug.sub(() => {
            this.needRechooseReferenceMarker = true;
            this.needUpdateHeadingIndicatorVisibility = true;
        });
    }
    /**
     * Initializes parameter listeners.
     */
    initParameterListeners() {
        this.centerSubject.sub(this.onCenterChanged.bind(this));
        this.radiusSubject.sub(this.onRadiusChanged.bind(this));
        this.rotationSubject.sub(this.onRotationChanged.bind(this));
        this.isMagneticSubject.sub(this.onIsMagneticChanged.bind(this));
    }
    /**
     * Initializes modules listeners.
     */
    initModuleListeners() {
        const rangeModule = this.props.model.getModule('range');
        rangeModule.nominalRange.sub(this.onRangeChanged.bind(this));
        const orientationModule = this.props.model.getModule('orientation');
        orientationModule.orientation.sub(this.onOrientationChanged.bind(this));
        const rangeRingModule = this.props.model.getModule('rangeCompass');
        rangeRingModule.show.sub(this.onRangeCompassShowChanged.bind(this));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.arcLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        this.roseLabelsLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        if (this.props.showHeadingBug) {
            this.headingIndicatorRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        }
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            // resizing the map will cause synced canvas layers to clear themselves, so we need to force a redraw on these
            // layers.
            this.needRedrawArc = true;
            this.needRedrawBearings = true;
            // we also need to re-initialize the styles on these canvases since these are also cleared.
            this.initStyles();
        }
        if (!this.isVisible()) {
            return;
        }
        this.updateParameters();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        if (this.needUpdateRootVisibility) {
            this.updateRootVisibility();
            this.needUpdateRootVisibility = false;
        }
        this.redraw();
        this.updateSubLayers(time, elapsed);
    }
    /**
     * Updates the visibility of this layer's root.
     */
    updateRootVisibility() {
        this.rootRef.instance.style.display = this.isVisible() ? 'block' : 'none';
    }
    /**
     * Redraws the compass.
     */
    redraw() {
        this.redrawArc();
        this.redrawBearings();
        this.updateReferenceMarker();
        this.updateHeadingIndicator();
        if (this.props.showLabel) {
            this.updateLabel();
        }
    }
    /**
     * Redraws the arc of the compass.
     */
    redrawArc() {
        if (!this.needRedrawArc) {
            return;
        }
        const arcLayerDisplay = this.arcLayerRef.instance.display;
        arcLayerDisplay.clear();
        const center = this.centerSubject.get();
        const radius = this.radiusSubject.get();
        const angularWidthRad = MapRangeCompassLayer.ARC_ANGULAR_WIDTH * Avionics.Utils.DEG2RAD;
        const startAngle = -Math.PI / 2 - angularWidthRad / 2;
        const endAngle = -Math.PI / 2 + angularWidthRad / 2;
        const leftTickStart = Vec2Math.add(Vec2Math.setFromPolar(radius + this.props.arcEndTickLength, startAngle, MapRangeCompassLayer.vec2Cache[0]), center, MapRangeCompassLayer.vec2Cache[0]);
        const leftTickEnd = Vec2Math.add(Vec2Math.setFromPolar(radius, startAngle, MapRangeCompassLayer.vec2Cache[1]), center, MapRangeCompassLayer.vec2Cache[1]);
        const rightTickStart = Vec2Math.add(Vec2Math.setFromPolar(radius, endAngle, MapRangeCompassLayer.vec2Cache[2]), center, MapRangeCompassLayer.vec2Cache[2]);
        const rightTickEnd = Vec2Math.add(Vec2Math.setFromPolar(radius + this.props.arcEndTickLength, endAngle, MapRangeCompassLayer.vec2Cache[3]), center, MapRangeCompassLayer.vec2Cache[3]);
        this.composeArcPath(center, radius, angularWidthRad, leftTickStart, leftTickEnd, rightTickStart, rightTickEnd);
        arcLayerDisplay.context.lineWidth = this.props.arcStrokeWidth;
        arcLayerDisplay.context.strokeStyle = 'white';
        arcLayerDisplay.context.stroke();
        this.needRedrawArc = false;
    }
    /**
     * Composes the path of the compass arc.
     * @param center The center of the compass, in pixels.
     * @param radius The radius of the compass, in pixels.
     * @param angularWidth The angular width of the arc, in radians.
     * @param leftTickStart The position of the start of the left end tick, in pixels.
     * @param leftTickEnd The position of the end of the left end tick, in pixels.
     * @param rightTickStart The position of the start of the right end tick, in pixels.
     * @param rightTickEnd The position of the end of the right end tick, in pixels.
     */
    composeArcPath(center, radius, angularWidth, leftTickStart, leftTickEnd, rightTickStart, rightTickEnd) {
        const arcLayerDisplay = this.arcLayerRef.instance.display;
        arcLayerDisplay.context.beginPath();
        arcLayerDisplay.context.moveTo(leftTickStart[0], leftTickStart[1]);
        arcLayerDisplay.context.lineTo(leftTickEnd[0], leftTickEnd[1]);
        arcLayerDisplay.context.arc(center[0], center[1], radius, (-angularWidth - Math.PI) / 2, (angularWidth - Math.PI) / 2);
        arcLayerDisplay.context.lineTo(rightTickEnd[0], rightTickEnd[1]);
    }
    /**
     * Redraws the bearing tick and labels.
     */
    redrawBearings() {
        if (!this.needRedrawBearings && !this.needRotateBearingTicks) {
            return;
        }
        this.roseLabelsLayerRef.instance.redraw();
        this.roseLayerRef.instance.updateRotation();
        this.needRotateBearingTicks = false;
        if (!this.needRedrawBearings && !this.needReclipTicks) {
            return;
        }
        if (this.needReclipTicks) {
            this.updateBearingTickClip();
        }
        this.roseLayerRef.instance.redraw();
        this.needRedrawBearings = false;
    }
    /**
     * Updates the bearing tick clip mask.
     */
    updateBearingTickClip() {
        const center = this.centerSubject.get();
        const radius = this.radiusSubject.get();
        const thick = this.props.arcStrokeWidth / 2;
        const innerToOuterLength = this.props.arcEndTickLength + thick + 5;
        const totalRadius = radius + this.props.arcEndTickLength + thick / 2 + 5;
        const leftAngle = -MapRangeCompassLayer.ARC_ANGULAR_WIDTH / 2 * Avionics.Utils.DEG2RAD - Math.PI / 2;
        const leftInner1 = Vec2Math.setFromPolar(radius - thick / 2, leftAngle, MapRangeCompassLayer.vec2Cache[0]);
        const leftInner2 = Vec2Math.setFromPolar(thick / 2, leftAngle - Math.PI / 2, MapRangeCompassLayer.vec2Cache[1]);
        const leftOuter = Vec2Math.setFromPolar(innerToOuterLength, leftAngle, MapRangeCompassLayer.vec2Cache[2]);
        const outerWidth = Math.abs(leftInner1[0] + leftInner2[0] + leftOuter[0]) * 2;
        this.roseLayerContainerRef.instance.style.webkitClipPath // the cast is to avoid typescript complaining webkitCliPath doesn't exist
            = `path('M${center[0]},${center[1]} l${leftInner1[0]},${leftInner1[1]} l${leftInner2[0]},${leftInner2[1]} l${leftOuter[0]},${leftOuter[1]} a${totalRadius},${totalRadius},0,0,1,${outerWidth},0 l${leftInner2[0]},${-leftInner2[1]} l${leftInner1[0]},${-leftInner1[1]} Z')`;
        this.needReclipTicks = false;
    }
    /**
     * Redraws the reference marker.
     */
    updateReferenceMarker() {
        if (!this.needRechooseReferenceMarker && !this.needRepositionReferenceMarker) {
            return;
        }
        if (this.needRechooseReferenceMarker) {
            const orientation = this.props.model.getModule('orientation').orientation.get();
            const type = (this.props.showHeadingBug.get() && orientation === MapOrientation.HeadingUp)
                ? MapRangeCompassReferenceMarkerType.ARROW
                : MapRangeCompassReferenceMarkerType.TICK;
            this.referenceMarkerTypeSub.set(type);
            this.needRechooseReferenceMarker = false;
        }
        if (!this.needRepositionReferenceMarker) {
            return;
        }
        this.referenceMarkerContainerRef.instance.reposition();
        this.needRepositionReferenceMarker = false;
    }
    /**
     * Updates the selected heading indicator.
     */
    updateHeadingIndicator() {
        if (!this.needUpdateHeadingIndicatorVisibility) {
            return;
        }
        const orientation = this.props.model.getModule('orientation').orientation.get();
        this.headingIndicatorRef.instance.setVisible(this.props.showHeadingBug.get() && orientation === MapOrientation.HeadingUp);
        this.needUpdateHeadingIndicatorVisibility = false;
    }
    /**
     * Updates the range display label.
     */
    updateLabel() {
        if (!this.needRepositionLabel) {
            return;
        }
        const center = this.centerSubject.get();
        const radius = this.radiusSubject.get();
        const pos = Vec2Math.add(Vec2Math.setFromPolar(radius, MapRangeCompassLayer.RANGE_LABEL_RADIAL_ANGLE * Avionics.Utils.DEG2RAD, MapRangeCompassLayer.vec2Cache[0]), center, MapRangeCompassLayer.vec2Cache[0]);
        this.rangeDisplayContainerRef.instance.style.left = `${pos[0]}px`;
        this.rangeDisplayContainerRef.instance.style.top = `${pos[1]}px`;
        this.needRepositionLabel = false;
    }
    /**
     * Updates this layer's sublayers.
     * @param time The current time as a UNIX timestamp.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    updateSubLayers(time, elapsed) {
        this.arcLayerRef.instance.onUpdated(time, elapsed);
        this.roseLayerRef.instance.onUpdated(time, elapsed);
        this.roseLabelsLayerRef.instance.onUpdated(time, elapsed);
        this.referenceMarkerContainerRef.instance.onUpdated(time, elapsed);
        if (this.props.showHeadingBug) {
            this.headingIndicatorRef.instance.onUpdated(time, elapsed);
        }
    }
    /**
     * Updates this layer's visibility.
     */
    updateVisibility() {
        this.setVisible(this.props.model.getModule('rangeCompass').show.get());
    }
    /**
     * Updates the ring.
     */
    updateParameters() {
        const center = this.props.mapProjection.getTargetProjected();
        const radius = this.props.model.getModule('range').nominalRange.get().asUnit(UnitType.GA_RADIAN) / this.props.mapProjection.getProjectedResolution();
        // TODO: Find a better way to get magvar.
        const rotation = Math.round((this.props.mapProjection.getRotation() + (this.isMagneticSubject.get() ? SimVar.GetSimVarValue('GPS MAGVAR', 'radians') : 0)) * 1e4) / 1e4;
        this.centerSubject.set(center);
        this.radiusSubject.set(radius);
        this.rotationSubject.set(rotation);
    }
    /**
     * A callback which is called when the center of the compass changes.
     * @param center The new center of the compass, in pixels.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onCenterChanged(center) {
        this.needRedrawArc = true;
        this.needRedrawBearings = true;
        this.needRepositionReferenceMarker = true;
        this.needReclipTicks = true;
        this.needRepositionLabel = true;
    }
    /**
     * A callback which is called when the center of the compass changes.
     * @param radius The new radius of the compass, in pixels.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onRadiusChanged(radius) {
        this.needRedrawArc = true;
        this.needRedrawBearings = true;
        this.needRepositionReferenceMarker = true;
        this.needReclipTicks = true;
        this.needRepositionLabel = true;
    }
    /**
     * A callback which is called when the rotation of the compass changes.
     * @param angle The new rotation angle of the compass, in radians.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onRotationChanged(angle) {
        this.needRotateBearingTicks = true;
    }
    /**
     * A callback which is called when whether the compass should display magnetic bearings changes.
     * @param isMagnetic Whether the compass should display magnetic bearings.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onIsMagneticChanged(isMagnetic) {
        this.updateParameters();
    }
    /**
     * A callback which is called when the nominal map range changes.
     * @param range The new nominal map range.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onRangeChanged(range) {
        if (!this.isVisible()) {
            return;
        }
        this.updateParameters();
    }
    /**
     * A callback which is called when the map orientation changes.
     * @param orientation The new map orientation.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onOrientationChanged(orientation) {
        if (!this.isVisible()) {
            return;
        }
        this.needRechooseReferenceMarker = true;
        this.needUpdateHeadingIndicatorVisibility = true;
    }
    /**
     * A callback which is called when the show range ring property changes.
     * @param show The new value of the show range ring property.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onRangeCompassShowChanged(show) {
        this.updateVisibility();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { ref: this.rootRef, style: 'position: absolute; left: 0; top: 0; width: 100%; height: 100%;' },
            FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.arcLayerRef, model: this.props.model, mapProjection: this.props.mapProjection }),
            FSComponent.buildComponent("div", { ref: this.roseLayerContainerRef, style: 'position: absolute; width: 100%; height: 100%;' },
                FSComponent.buildComponent(MapRangeCompassRose, { ref: this.roseLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, compassCenterSubject: this.centerSubject, compassRadiusSubject: this.radiusSubject, compassRotationSubject: this.rotationSubject, tickMajorInterval: MapRangeCompassLayer.BEARING_TICK_MAJOR_INTERVAL, tickMinorMultiplier: MapRangeCompassLayer.BEARING_TICK_MINOR_FACTOR, tickMajorLength: this.props.bearingTickMajorLength, tickMinorLength: this.props.bearingTickMinorLength, tickStrokeWidth: this.props.arcStrokeWidth })),
            FSComponent.buildComponent(MapRangeCompassReferenceMarkerContainer, { ref: this.referenceMarkerContainerRef, model: this.props.model, mapProjection: this.props.mapProjection, compassCenterSubject: this.centerSubject, compassRadiusSubject: this.radiusSubject, compassRotationSubject: this.rotationSubject, activeType: this.referenceMarkerTypeSub, tickWidth: this.props.referenceTickWidth, tickHeight: this.props.referenceTickHeight, arrowWidth: this.props.referenceArrowWidth, arrowHeight: this.props.referenceArrowHeight }),
            this.renderSelectedHeadingIndicator(),
            FSComponent.buildComponent(MapRangeCompassRoseLabels, { ref: this.roseLabelsLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, compassCenterSubject: this.centerSubject, compassRadiusSubject: this.radiusSubject, compassRotationSubject: this.rotationSubject, angularWidth: MapRangeCompassLayer.ARC_ANGULAR_WIDTH, interval: MapRangeCompassLayer.BEARING_TICK_MAJOR_INTERVAL, font: this.props.bearingLabelFont, fontSize: this.props.bearingLabelFontSize, outlineWidth: this.props.bearingLabelOutlineWidth, radialOffset: this.props.bearingTickMajorLength + this.props.bearingLabelRadialOffset }),
            this.renderRangeDisplay()));
    }
    /**
     * Renders the selected heading indicator.
     * @returns a VNode representing the range display label.
     */
    renderSelectedHeadingIndicator() {
        return this.props.showHeadingBug
            ? (FSComponent.buildComponent(MapRangeCompassSelectedHeading, { ref: this.headingIndicatorRef, model: this.props.model, mapProjection: this.props.mapProjection, bus: this.props.bus, compassCenterSubject: this.centerSubject, compassRadiusSubject: this.radiusSubject, compassRotationSubject: this.rotationSubject, bugWidth: this.props.headingBugWidth, bugHeight: this.props.headingBugHeight, bugNotchHeight: this.props.referenceArrowHeight / 3, bugNotchWidth: this.props.referenceArrowWidth / 3, outlineWidth: 1, lineWidth: this.props.arcStrokeWidth, lineDash: [this.props.arcStrokeWidth * 3, this.props.arcStrokeWidth * 3] }))
            : (FSComponent.buildComponent("div", { style: 'display: none;' }));
    }
    /**
     * Renders the range display label.
     * @returns a VNode representing the range display label.
     */
    renderRangeDisplay() {
        // TODO: Add customizable display unit support.
        const rangeModule = this.props.model.getModule('range');
        return this.props.showLabel
            ? (FSComponent.buildComponent("div", { ref: this.rangeDisplayContainerRef, style: 'position: absolute; transform: translate(-50%, -50%);' },
                FSComponent.buildComponent(MapRangeDisplay, { range: rangeModule.nominalRange, displayUnit: Subject.create(UnitType.NMILE) })))
            : null;
    }
}
/** The angular width of the compass arc, in degrees. */
MapRangeCompassLayer.ARC_ANGULAR_WIDTH = 120;
/** The angular interval, in degrees, between major bearing ticks. */
MapRangeCompassLayer.BEARING_TICK_MAJOR_INTERVAL = 30;
/** The number of minor bearing ticks per major bearing tick. */
MapRangeCompassLayer.BEARING_TICK_MINOR_FACTOR = 3;
/** The radial on which the range label is positioned, in degrees. */
MapRangeCompassLayer.RANGE_LABEL_RADIAL_ANGLE = -135;
MapRangeCompassLayer.vec2Cache = Array.from({ length: 4 }, () => new Float64Array(2));
/**
 * A rotating compass rose with unlabeled graduated bearing ticks.
 */
class MapRangeCompassRose extends MapCanvasLayer {
    constructor() {
        super(...arguments);
        this.bearingStep = this.props.tickMajorInterval / this.props.tickMinorMultiplier * Avionics.Utils.DEG2RAD;
        this.numMinorBearingTicks = Math.floor(2 * Math.PI / this.bearingStep);
    }
    /**
     * Redraws the canvas.
     */
    redraw() {
        const display = this.display;
        const center = this.props.compassCenterSubject.get();
        const radius = this.props.compassRadiusSubject.get();
        const canvasSize = Math.ceil(radius) * 2;
        this.setWidth(canvasSize);
        this.setHeight(canvasSize);
        display.canvas.style.left = `${center[0] - canvasSize / 2}px`;
        display.canvas.style.top = `${center[1] - canvasSize / 2}px`;
        display.clear();
        this.composeBearingTicksPath(radius);
        display.context.lineWidth = this.props.tickStrokeWidth;
        display.context.strokeStyle = 'white';
        display.context.stroke();
    }
    /**
     * Composes the path of the bearing ticks.
     * @param radius The radius of the compass, in pixels.
     */
    composeBearingTicksPath(radius) {
        const canvasSize = this.getWidth();
        const center = Vec2Math.set(canvasSize / 2, canvasSize / 2, MapRangeCompassRose.vec2Cache[0]);
        const display = this.display;
        display.context.beginPath();
        for (let i = 0; i < this.numMinorBearingTicks; i++) {
            const bearing = i * this.bearingStep;
            const angle = bearing - Math.PI / 2;
            let start;
            if (i % MapRangeCompassLayer.BEARING_TICK_MINOR_FACTOR === 0) {
                // major tick
                start = Vec2Math.add(Vec2Math.setFromPolar(radius - this.props.tickMajorLength, angle, MapRangeCompassRose.vec2Cache[1]), center, MapRangeCompassRose.vec2Cache[1]);
            }
            else {
                // minor tick
                start = Vec2Math.add(Vec2Math.setFromPolar(radius - this.props.tickMinorLength, angle, MapRangeCompassRose.vec2Cache[1]), center, MapRangeCompassRose.vec2Cache[1]);
            }
            const end = Vec2Math.add(Vec2Math.setFromPolar(radius, angle, MapRangeCompassRose.vec2Cache[2]), center, MapRangeCompassRose.vec2Cache[2]);
            display.context.moveTo(start[0], start[1]);
            display.context.lineTo(end[0], end[1]);
        }
    }
    /**
     * Updates the rotation of this rose.
     */
    updateRotation() {
        const display = this.display;
        display.canvas.style.transform = `rotate(${this.props.compassRotationSubject.get()}rad)`;
    }
}
MapRangeCompassRose.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2)];
/**
 * Bearing labels for a rotating range compass rose.
 */
class MapRangeCompassRoseLabels extends MapSyncedCanvasLayer {
    /**
     * Redraws the bearing labels.
     */
    redraw() {
        const display = this.display;
        display.clear();
        const PI2 = Math.PI * 2;
        const center = this.props.compassCenterSubject.get();
        const radius = this.props.compassRadiusSubject.get();
        const rotation = this.props.compassRotationSubject.get();
        const halfAngularWidth = this.props.angularWidth / 2 * Avionics.Utils.DEG2RAD;
        const centerBearing = (-rotation + PI2) % PI2;
        const intervalRad = this.props.interval * Avionics.Utils.DEG2RAD;
        for (let bearing = 0; bearing < PI2; bearing += intervalRad) {
            if (Math.min(Math.abs(bearing - centerBearing), PI2 - Math.abs(bearing - centerBearing)) > halfAngularWidth) {
                continue;
            }
            this.drawBearingLabel(center, radius, rotation, bearing);
        }
    }
    /**
     * Draws a bearing label.
     * @param center The center of the compass, in pixels.
     * @param radius The radius of the compass, in pixels.
     * @param rotation The rotation of the compass, in radians.
     * @param bearing The label's bearing, in radians.
     */
    drawBearingLabel(center, radius, rotation, bearing) {
        const display = this.display;
        // TODO: support the T superscript for true bearings.
        const text = (360 - (360 - (bearing * Avionics.Utils.RAD2DEG)) % 360).toFixed(0).padStart(3, '0');
        const angle = bearing - Math.PI / 2 + rotation;
        const textWidth = display.context.measureText(text).width;
        const textHeight = this.props.fontSize;
        const textOffset = Math.hypot(textWidth, textHeight) / 2 + this.props.radialOffset;
        const textRadius = radius - textOffset;
        const labelPos = Vec2Math.add(Vec2Math.setFromPolar(textRadius, angle, MapRangeCompassRoseLabels.vec2Cache[0]), Vec2Math.set(center[0] - textWidth / 2, center[1] + textHeight / 2, MapRangeCompassRoseLabels.vec2Cache[1]), MapRangeCompassRoseLabels.vec2Cache[0]);
        if (this.props.outlineWidth > 0) {
            display.context.strokeText(text, labelPos[0], labelPos[1]);
        }
        display.context.fillText(text, labelPos[0], labelPos[1]);
    }
}
MapRangeCompassRoseLabels.vec2Cache = [new Float64Array(2), new Float64Array(2)];
/**
 * A reference arrow for MapRangeCompassLayer.
 */
class MapRangeCompassReferenceArrow extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
    }
    /**
     * Sets whether this marker should be visible. This method has no effect if this marker has not been rendered.
     * @param val Whether this marker should be visible.
     */
    setVisible(val) {
        if (!this.svgRef.instance) {
            return;
        }
        this.svgRef.instance.style.display = val ? 'block' : 'none';
    }
    /**
     * Sets this marker's position. The provided position should be the position of the middle of the range compass arc.
     * This method has no effect if this marker has not been rendered.
     * @param pos The new position, in pixels.
     */
    setPosition(pos) {
        if (!this.svgRef.instance) {
            return;
        }
        const svg = this.svgRef.instance;
        svg.style.left = `${pos[0]}px`;
        svg.style.top = `${pos[1]}px`;
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("svg", { ref: this.svgRef, viewBox: '0 0 100 100', preserveAspectRatio: 'none', style: `display: none; position: absolute; width: ${this.props.width}px; height: ${this.props.height}px; transform: translate(-50%, -66.7%);` },
            FSComponent.buildComponent("path", { d: 'M 0 0 L 100 0 L 50 100 Z', fill: 'white' })));
    }
}
/**
 * A reference tick for MapRangeCompassLayer.
 */
class MapRangeCompassReferenceTick extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
    }
    /**
     * Sets whether this marker should be visible. This method has no effect if this marker has not been rendered.
     * @param val Whether this marker should be visible.
     */
    setVisible(val) {
        if (!this.svgRef.instance) {
            return;
        }
        this.svgRef.instance.style.display = val ? 'block' : 'none';
    }
    /**
     * Sets this marker's position. The provided position should be the position of the middle of the range compass arc.
     * This method has no effect if this marker has not been rendered.
     * @param pos The new position, in pixels.
     */
    setPosition(pos) {
        if (!this.svgRef.instance) {
            return;
        }
        const svg = this.svgRef.instance;
        svg.style.left = `${pos[0]}px`;
        svg.style.top = `${pos[1]}px`;
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("svg", { ref: this.svgRef, viewBox: '0 0 100 100', preserveAspectRatio: 'none', style: `display: none; position: absolute; width: ${this.props.width}px; height: ${this.props.height}px; transform: translate(-50%, -100%);` },
            FSComponent.buildComponent("rect", { x: '0', y: '0', width: '100', height: '100', fill: 'white' })));
    }
}
/**
 *
 */
var MapRangeCompassReferenceMarkerType;
(function (MapRangeCompassReferenceMarkerType) {
    MapRangeCompassReferenceMarkerType[MapRangeCompassReferenceMarkerType["TICK"] = 0] = "TICK";
    MapRangeCompassReferenceMarkerType[MapRangeCompassReferenceMarkerType["ARROW"] = 1] = "ARROW";
})(MapRangeCompassReferenceMarkerType || (MapRangeCompassReferenceMarkerType = {}));
/**
 * A container for range compass reference markers.
 */
class MapRangeCompassReferenceMarkerContainer extends MapLayer {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.referenceTickRef = FSComponent.createRef();
        this.referenceArrowRef = FSComponent.createRef();
        this.activeReferenceMarker = null;
    }
    /** @inheritdoc */
    onAttached() {
        this.props.activeType.sub(this.onActiveTypeChanged.bind(this), true);
    }
    /**
     * Responds to active marker type changes.
     * @param type The active marker type.
     */
    onActiveTypeChanged(type) {
        const selectedReferenceMarker = type === MapRangeCompassReferenceMarkerType.TICK
            ? this.referenceTickRef.instance
            : this.referenceArrowRef.instance;
        const oldActiveMarker = this.activeReferenceMarker;
        if (oldActiveMarker !== selectedReferenceMarker) {
            this.activeReferenceMarker = selectedReferenceMarker;
            oldActiveMarker === null || oldActiveMarker === void 0 ? void 0 : oldActiveMarker.setVisible(false);
            this.activeReferenceMarker.setVisible(true);
            this.reposition();
        }
    }
    /**
     * Repositions the reference marker.
     */
    reposition() {
        var _a;
        const center = this.props.compassCenterSubject.get();
        const radius = this.props.compassRadiusSubject.get();
        const pos = Vec2Math.add(Vec2Math.setFromPolar(radius, -Math.PI / 2, MapRangeCompassReferenceMarkerContainer.tempVec2), center, MapRangeCompassReferenceMarkerContainer.tempVec2);
        (_a = this.activeReferenceMarker) === null || _a === void 0 ? void 0 : _a.setPosition(pos);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { ref: this.containerRef, style: 'position: absolute; width: 100%; height: 100%;' },
            FSComponent.buildComponent(MapRangeCompassReferenceTick, { ref: this.referenceTickRef, width: this.props.tickWidth, height: this.props.tickHeight }),
            FSComponent.buildComponent(MapRangeCompassReferenceArrow, { ref: this.referenceArrowRef, width: this.props.arrowWidth, height: this.props.arrowHeight })));
    }
}
MapRangeCompassReferenceMarkerContainer.tempVec2 = new Float64Array(2);
/**
 * The selected heading bug and heading line for the map range compass layer.
 */
class MapRangeCompassSelectedHeading extends MapLayer {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.canvasLayerRef = FSComponent.createRef();
        this.selectedHeading = 0;
        this.isInit = false;
        this.isSuppressedSubject = Subject.create(true);
        this.suppressTimer = null;
        this.centerSubject = Vec2Subject.createFromVector(new Float64Array(2));
        this.radiusSubject = Subject.create(0);
        this.rotationSubject = Subject.create(0);
        this.isOOBSubject = Subject.create(true);
        this.needRedraw = true;
        this.needReposition = true;
        this.needRotate = true;
        /**
         * A callback which is called when the suppress timer fires.
         */
        this.suppressCallback = () => {
            this.suppressTimer = null;
            this.isSuppressedSubject.set(true);
        };
        /**
         * A callback which is called when the selected heading changes.
         * @param heading The new selected heading, in degrees.
         */
        this.onSelectedHeadingChanged = (heading) => {
            this.selectedHeading = heading;
            this.unsuppress(MapRangeCompassSelectedHeading.UNSUPPRESS_DURATION);
            this.updateParameters();
        };
        this.selectedHeadingConsumer = this.props.bus.getSubscriber().on('heading_select').whenChanged();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        if (this.isInit) {
            this.updateFromVisibility();
        }
    }
    /**
     * Updates this layer according to its current visibility.
     */
    updateFromVisibility() {
        const isVisible = this.isVisible();
        if (isVisible) {
            this.selectedHeadingConsumer.handle(this.onSelectedHeadingChanged);
        }
        else {
            this.selectedHeadingConsumer.off(this.onSelectedHeadingChanged);
            this.suppress();
        }
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.canvasLayerRef.instance.onAttached();
        this.initCanvas();
        this.isInit = true;
        this.initSubjectListeners();
        this.updateFromVisibility();
    }
    /**
     * Initializes canvas width.
     */
    initCanvas() {
        const width = Math.max(this.props.lineWidth, this.props.bugWidth + this.props.outlineWidth * 2);
        this.canvasLayerRef.instance.setWidth(width);
        const canvasLayerDisplay = this.canvasLayerRef.instance.display;
        canvasLayerDisplay.canvas.style.width = `${width}px`;
        canvasLayerDisplay.canvas.style.transformOrigin = '50% 100%';
    }
    /**
     * Initializes subject listeners.
     */
    initSubjectListeners() {
        this.props.compassCenterSubject.sub(this.updateParameters.bind(this));
        this.props.compassRadiusSubject.sub(this.updateParameters.bind(this));
        this.props.compassRotationSubject.sub(this.updateParameters.bind(this));
        this.centerSubject.sub(this.onCenterChanged.bind(this));
        this.radiusSubject.sub(this.onRadiusChanged.bind(this));
        this.rotationSubject.sub(this.onRotationChanged.bind(this));
        this.isSuppressedSubject.sub(this.onIsSuppressedChanged.bind(this));
        this.isOOBSubject.sub(this.onIsOOBChanged.bind(this));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.needReposition = true;
            this.needRedraw = true;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        this.canvasLayerRef.instance.onUpdated(time, elapsed);
        if (this.needReposition) {
            this.reposition();
        }
        else if (this.needRedraw) {
            this.redraw();
        }
        if (this.needRotate) {
            this.rotate();
        }
    }
    /**
     * Repositions the canvas.
     */
    reposition() {
        const center = this.props.compassCenterSubject.get();
        const projectedWidth = this.props.mapProjection.getProjectedSize()[0];
        const projectedHeight = this.props.mapProjection.getProjectedSize()[1];
        // find the distance to the farthest corner.
        const isLeft = center[0] > projectedWidth / 2;
        const isTop = center[1] > projectedHeight / 2;
        const height = Math.hypot(center[0] - (isLeft ? 0 : projectedWidth), center[1] - (isTop ? 0 : projectedHeight));
        this.canvasLayerRef.instance.setHeight(height);
        const canvasLayerDisplay = this.canvasLayerRef.instance.display;
        canvasLayerDisplay.canvas.style.height = `${height}px`;
        canvasLayerDisplay.canvas.style.left = `${center[0] - this.canvasLayerRef.instance.getWidth() / 2}px`;
        canvasLayerDisplay.canvas.style.bottom = `${projectedHeight - center[1]}px`;
        this.needReposition = false;
        this.redraw();
    }
    /**
     * Redraws the canvas.
     */
    redraw() {
        const canvasWidth = this.canvasLayerRef.instance.getWidth();
        const canvasHeight = this.canvasLayerRef.instance.getHeight();
        const radius = this.props.compassRadiusSubject.get();
        const canvasLayerDisplay = this.canvasLayerRef.instance.display;
        canvasLayerDisplay.clear();
        this.redrawLine(canvasWidth, canvasHeight);
        this.redrawBug(canvasWidth, canvasHeight, radius);
        this.needRedraw = false;
    }
    /**
     * Redraws the heading line.
     * @param canvasWidth The width of the canvas, in pixels.
     * @param canvasHeight The height of the canvas, in pixels.
     */
    redrawLine(canvasWidth, canvasHeight) {
        const canvasLayerDisplay = this.canvasLayerRef.instance.display;
        canvasLayerDisplay.context.beginPath();
        canvasLayerDisplay.context.moveTo(canvasWidth / 2, canvasHeight);
        canvasLayerDisplay.context.lineTo(canvasWidth / 2, 0);
        canvasLayerDisplay.context.lineWidth = this.props.lineWidth;
        canvasLayerDisplay.context.strokeStyle = MapRangeCompassSelectedHeading.COLOR;
        canvasLayerDisplay.context.setLineDash(this.props.lineDash);
        canvasLayerDisplay.context.stroke();
    }
    /**
     * Redraws the heading bug.
     * @param canvasWidth The width of the canvas, in pixels.
     * @param canvasHeight The height of the canvas, in pixels.
     * @param radius The radius of the compass, in pixels.
     */
    redrawBug(canvasWidth, canvasHeight, radius) {
        const canvasLayerDisplay = this.canvasLayerRef.instance.display;
        const left = (canvasWidth - this.props.bugWidth) / 2;
        const top = canvasHeight - radius;
        const middle = canvasWidth / 2;
        const right = left + this.props.bugWidth;
        const bottom = top + this.props.bugHeight;
        canvasLayerDisplay.context.beginPath();
        canvasLayerDisplay.context.moveTo(left, top);
        canvasLayerDisplay.context.lineTo(middle - this.props.bugNotchWidth / 2, top);
        canvasLayerDisplay.context.lineTo(middle, top + this.props.bugNotchHeight);
        canvasLayerDisplay.context.lineTo(middle + this.props.bugNotchWidth / 2, top);
        canvasLayerDisplay.context.lineTo(right, top);
        canvasLayerDisplay.context.lineTo(right, bottom);
        canvasLayerDisplay.context.lineTo(left, bottom);
        canvasLayerDisplay.context.closePath();
        canvasLayerDisplay.context.fillStyle = MapRangeCompassSelectedHeading.COLOR;
        canvasLayerDisplay.context.lineWidth = this.props.outlineWidth * 2;
        canvasLayerDisplay.context.strokeStyle = MapRangeCompassSelectedHeading.OUTLINE_COLOR;
        canvasLayerDisplay.context.setLineDash(MapRangeCompassSelectedHeading.NO_LINE_DASH);
        canvasLayerDisplay.context.stroke();
        canvasLayerDisplay.context.fill();
    }
    /**
     * Rotates the canvas.
     */
    rotate() {
        const compassRotation = this.props.compassRotationSubject.get();
        const rotation = this.selectedHeading * Avionics.Utils.DEG2RAD + compassRotation;
        const canvasLayerDisplay = this.canvasLayerRef.instance.display;
        canvasLayerDisplay.canvas.style.transform = `rotate(${rotation}rad)`;
        this.needRotate = false;
    }
    /**
     * Suppresses this indicator, making it invisible. Also kills the suppress timer if it is running.
     */
    suppress() {
        this.killSuppressTimer();
        this.isSuppressedSubject.set(true);
    }
    /**
     * Unsuppresses this indicator, making it visible, for a certain duration. If the suppress timer is currently
     * running, it is killed and replaced with a new one which will fire after the specified duration.
     * @param duration The duration for which to unsuppress, in milliseconds.
     */
    unsuppress(duration) {
        this.killSuppressTimer();
        this.isSuppressedSubject.set(false);
        this.suppressTimer = setTimeout(this.suppressCallback, duration);
    }
    /**
     * Kills the timer to suppress this indicator, if one is currently running.
     */
    killSuppressTimer() {
        if (this.suppressTimer !== null) {
            clearTimeout(this.suppressTimer);
        }
    }
    /**
     * Updates this indicator based on whether it should be suppressed.
     * @param isSuppressed Whether this indicator should be suppressed.
     */
    updateFromIsSuppressed(isSuppressed) {
        this.updateCanvasVisibility(isSuppressed, this.isOOBSubject.get());
    }
    /**
     * Updates this indicator based on whether it is out of the current compass bounds.
     * @param isOOB Whether this indicator is out of the current compass bounds.
     */
    updateFromIsOOB(isOOB) {
        this.updateCanvasVisibility(this.isSuppressedSubject.get(), isOOB);
    }
    /**
     * Updates the visibility of the canvas.
     * @param isSuppressed Whether this indicator is suppressed.
     * @param isOOB Whether this indicator is out of the current compass bounds.
     */
    updateCanvasVisibility(isSuppressed, isOOB) {
        this.canvasLayerRef.instance.setVisible(!isOOB && !isSuppressed);
    }
    /**
     * Updates this indicator's center, radius, and rotation.
     */
    updateParameters() {
        const compassRotation = this.props.compassRotationSubject.get();
        const compassCenter = -compassRotation * Avionics.Utils.RAD2DEG;
        const isOOB = Math.abs(NavMath.diffAngle(this.selectedHeading, compassCenter)) > MapRangeCompassLayer.ARC_ANGULAR_WIDTH / 2;
        this.isOOBSubject.set(isOOB);
        if (!this.canvasLayerRef.instance.isVisible()) {
            return;
        }
        const center = this.props.compassCenterSubject.get();
        const radius = this.props.compassRadiusSubject.get();
        const rotation = compassRotation + this.selectedHeading * Avionics.Utils.DEG2RAD;
        this.centerSubject.set(center);
        this.radiusSubject.set(radius);
        this.rotationSubject.set(rotation);
    }
    /**
     * A callback which is called when the center of the compass changes.
     * @param center The new center of the compass, in pixels.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onCenterChanged(center) {
        this.needReposition = true;
    }
    /**
     * A callback which is called when the center of the compass changes.
     * @param radius The new radius of the compass, in pixels.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onRadiusChanged(radius) {
        this.needRedraw = true;
    }
    /**
     * A callback which is called when the rotation of the compass changes.
     * @param angle The new rotation angle of the compass, in radians.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onRotationChanged(angle) {
        this.needRotate = true;
    }
    /**
     * A callback which is called when whether this indicator is suppressed has changed.
     * @param isSuppressed Whether this indicator is suppressed.
     */
    onIsSuppressedChanged(isSuppressed) {
        this.updateFromIsSuppressed(isSuppressed);
    }
    /**
     * A callback which is called when whether this indicator is out of the current compass bounds has changed.
     * @param isOOB Whether this indicator is out of the current compass bounds.
     */
    onIsOOBChanged(isOOB) {
        this.updateFromIsOOB(isOOB);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(MapCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection }));
    }
}
/** The amount of time, in milliseconds, the indicator is unsuppressed when the selected heading is changed. */
MapRangeCompassSelectedHeading.UNSUPPRESS_DURATION = 3000;
/** The color of the bug and line. */
MapRangeCompassSelectedHeading.COLOR = 'cyan';
/** The outline color of the bug. */
MapRangeCompassSelectedHeading.OUTLINE_COLOR = 'black';
MapRangeCompassSelectedHeading.NO_LINE_DASH = [];

/**
 * A map layer which draws a range ring around the map target.
 */
class MapRangeRingLayer extends MapLabeledRingLayer {
    constructor() {
        super(...arguments);
        this.label = null;
        this.needUpdateRing = false;
    }
    /**
     * Updates this layer according to its current visibility.
     */
    updateFromVisibility() {
        super.updateFromVisibility();
        const isVisible = this.isVisible();
        if (isVisible) {
            this.needUpdateRing = true;
        }
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.initLabel();
        this.initStyles();
        this.initModuleListeners();
        this.updateVisibility();
        this.needUpdateRing = true;
    }
    /**
     * Initializes the range display label.
     */
    initLabel() {
        if (!this.props.showLabel) {
            return;
        }
        // TODO: Add customizable display unit support.
        const rangeModule = this.props.model.getModule('range');
        this.label = this.createLabel(FSComponent.buildComponent(MapRangeDisplay, { range: rangeModule.nominalRange, displayUnit: Subject.create(UnitType.NMILE) }));
        this.label.setAnchor(new Float64Array([0.5, 0.5]));
        this.label.setRadialAngle(225 * Avionics.Utils.DEG2RAD);
    }
    /**
     * Initializes ring styles.
     */
    initStyles() {
        this.setRingStrokeStyles(this.props.strokeWidth, this.props.strokeStyle, this.props.strokeDash);
        this.setRingOutlineStyles(this.props.outlineWidth, this.props.outlineStyle, this.props.outlineDash);
    }
    /**
     * Initializes modules listeners.
     */
    initModuleListeners() {
        const rangeModule = this.props.model.getModule('range');
        rangeModule.nominalRange.sub(this.onRangeChanged.bind(this));
        const rangeRingModule = this.props.model.getModule('rangeRing');
        rangeRingModule.show.sub(this.onRangeRingShowChanged.bind(this));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        super.onMapProjectionChanged(mapProjection, changeFlags);
        if (!this.isVisible()) {
            return;
        }
        this.needUpdateRing = true;
    }
    /**
     * Updates this layer's visibility.
     */
    updateVisibility() {
        this.setVisible(this.props.model.getModule('rangeRing').show.get());
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        if (this.needUpdateRing) {
            this.updateRing();
            this.needUpdateRing = false;
        }
        super.onUpdated(time, elapsed);
    }
    /**
     * Updates the ring.
     */
    updateRing() {
        const center = this.props.mapProjection.getTargetProjected();
        const radius = this.props.model.getModule('range').nominalRange.get().asUnit(UnitType.GA_RADIAN) / this.props.mapProjection.getProjectedResolution();
        this.setRingPosition(center, radius);
    }
    /**
     * A callback which is called when the nominal map range changes.
     * @param range The new nominal map range.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onRangeChanged(range) {
        if (!this.isVisible()) {
            return;
        }
        this.needUpdateRing = true;
    }
    /**
     * A callback which is called when the show range ring property changes.
     * @param show The new value of the show range ring property.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onRangeRingShowChanged(show) {
        this.updateVisibility();
    }
}

/**
 * Map pointer information box size.
 */
var MapPointerInfoLayerSize;
(function (MapPointerInfoLayerSize) {
    MapPointerInfoLayerSize[MapPointerInfoLayerSize["Full"] = 0] = "Full";
    MapPointerInfoLayerSize[MapPointerInfoLayerSize["Medium"] = 1] = "Medium";
    MapPointerInfoLayerSize[MapPointerInfoLayerSize["Small"] = 2] = "Small";
})(MapPointerInfoLayerSize || (MapPointerInfoLayerSize = {}));
/**
 * A map layer which displays a pointer information box.
 */
class MapPointerInfoLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.rootRef = FSComponent.createRef();
        this.ownAirplanePropsModule = this.props.model.getModule('ownAirplaneProps');
        this.pointerModule = this.props.model.getModule('pointer');
        this.distanceSub = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(NaN));
        this.distanceUnitSub = Subject.create(UnitType.NMILE);
        this.bearingSub = ComputedSubject.create(NaN, bearing => {
            const rounded = Math.round(bearing);
            return `${isNaN(bearing) ? '___' : (rounded === 0 ? 360 : rounded).toString().padStart(3, '0')}°`;
        });
        this.latLonSub = GeoPointSubject.createFromGeoPoint(new GeoPoint(0, 0));
        this.scheduleUpdateHandler = () => { this.needUpdate = true; };
        this.needUpdate = false;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        this.rootRef.getOrDefault() && this.updateFromVisibility();
    }
    /**
     * Updates this layer according to its current visibility.
     */
    updateFromVisibility() {
        if (this.isVisible()) {
            this.rootRef.instance.style.display = '';
            this.ownAirplanePropsModule.position.sub(this.scheduleUpdateHandler);
            this.pointerModule.position.sub(this.scheduleUpdateHandler, true);
        }
        else {
            this.rootRef.instance.style.display = 'none';
            this.ownAirplanePropsModule.position.unsub(this.scheduleUpdateHandler);
            this.pointerModule.position.unsub(this.scheduleUpdateHandler);
        }
    }
    /** @inheritdoc */
    onAfterRender() {
        this.updateFromVisibility();
        this.pointerModule.isActive.sub(isActive => this.setVisible(isActive), true);
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.needUpdate || (this.needUpdate = this.isVisible() && BitFlags.isAny(changeFlags, MapProjectionChangeType.Center | MapProjectionChangeType.Rotation | MapProjectionChangeType.ProjectedResolution));
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        if (!this.needUpdate) {
            return;
        }
        this.updateInfo();
        this.needUpdate = false;
    }
    /**
     * Updates this layer's displayed information.
     */
    updateInfo() {
        const latLon = this.props.mapProjection.invert(this.pointerModule.position.get(), MapPointerInfoLayer.geoPointCache[0]);
        this.latLonSub.set(latLon);
        const airplanePos = this.ownAirplanePropsModule.position.get();
        this.distanceSub.set(airplanePos.distance(latLon), UnitType.GA_RADIAN);
        // TODO: Add support for metric
        if (this.distanceSub.get().compare(0.1) < 0) {
            this.distanceUnitSub.set(UnitType.FOOT);
        }
        else {
            this.distanceUnitSub.set(UnitType.NMILE);
        }
        this.bearingSub.set(MagVar.trueToMagnetic(airplanePos.bearingTo(latLon), airplanePos));
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { ref: this.rootRef, class: 'map-pointerinfolayer-box' },
            FSComponent.buildComponent("div", { class: 'map-pointerinfolayer-box-column map-pointerinfolayer-box-dis' },
                FSComponent.buildComponent("span", { class: 'map-pointerinfolayer-box-title', style: this.props.size === MapPointerInfoLayerSize.Small ? 'display: none;' : '' }, "DIS"),
                FSComponent.buildComponent(NumberUnitDisplay, { value: this.distanceSub, displayUnit: this.distanceUnitSub, formatter: NumberFormatter.create({ precision: 0.1, maxDigits: 3, forceDecimalZeroes: false, nanString: '__._' }), class: 'map-pointerinfolayer-box-title-value' })),
            FSComponent.buildComponent("div", { class: 'map-pointerinfolayer-box-column map-pointerinfolayer-box-brg', style: this.props.size === MapPointerInfoLayerSize.Small ? 'display: none;' : '' },
                FSComponent.buildComponent("span", { class: 'map-pointerinfolayer-box-title' }, "BRG"),
                FSComponent.buildComponent("span", { class: 'map-pointerinfolayer-box-title-value' }, this.bearingSub)),
            this.props.size === MapPointerInfoLayerSize.Full
                ? FSComponent.buildComponent(LatLonDisplay, { location: this.latLonSub, class: 'map-pointerinfolayer-box-column map-pointerinfolayer-box-title-value' })
                : null));
    }
}
MapPointerInfoLayer.geoPointCache = [new GeoPoint(0, 0)];

/**
 * The PFD inset navigation map.
 */
class PFDInsetNavMapComponent extends NavMapComponent {
    constructor() {
        super(...arguments);
        this.miniCompassLayerRef = FSComponent.createRef();
        this.rangeRingLayerRef = FSComponent.createRef();
        this.rangeCompassLayerRef = FSComponent.createRef();
        this.pointerInfoLayerRef = FSComponent.createRef();
    }
    /** @inheritdoc */
    createRangeTargetRotationController() {
        return new PFDInsetNavMapRangeTargetRotationController(this.props.model, this.mapProjection, this.deadZone, NavMapRangeTargetRotationController.DEFAULT_MAP_RANGES, this.props.settingManager, this.rangeSettingManager, 'pfdMapRangeIndex', this.pointerBoundsSub);
    }
    /** @inheritdoc */
    initLayers() {
        super.initLayers();
        this.attachLayer(this.miniCompassLayerRef.instance);
        this.attachLayer(this.rangeRingLayerRef.instance);
        this.attachLayer(this.rangeCompassLayerRef.instance);
        this.attachLayer(this.pointerInfoLayerRef.instance);
    }
    /** @inheritdoc */
    updatePointerBounds() {
        const size = this.mapProjection.getProjectedSize();
        const minX = this.deadZone[0];
        const minY = this.deadZone[1];
        const maxX = size[0] - this.deadZone[2];
        const maxY = size[1] - this.deadZone[3];
        const width = maxX - minX;
        const height = maxY - minY;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        this.pointerBoundsSub.set(Math.min(centerX, minX + width * 0.2), Math.min(centerY, minY + height * 0.2), Math.max(centerX, maxX - height * 0.4), Math.max(centerY, maxY - height * 0.2));
    }
    /** @inheritdoc */
    renderTopLeftIndicators() {
        return [
            this.renderOrientationIndicator(),
            this.renderRangeIndicator()
        ];
    }
    /** @inheritdoc */
    renderMiniCompassLayer() {
        return (FSComponent.buildComponent(MapMiniCompassLayer, { ref: this.miniCompassLayerRef, class: 'minicompass-layer', model: this.props.model, mapProjection: this.mapProjection, imgSrc: 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/map_mini_compass.png' }));
    }
    /** @inheritdoc */
    renderRangeRingLayer() {
        return (FSComponent.buildComponent(MapRangeRingLayer, { ref: this.rangeRingLayerRef, model: this.props.model, mapProjection: this.mapProjection, showLabel: false, strokeWidth: 2, strokeStyle: 'white' }));
    }
    /** @inheritdoc */
    renderRangeCompassLayer() {
        return (FSComponent.buildComponent(MapRangeCompassLayer, { ref: this.rangeCompassLayerRef, model: this.props.model, mapProjection: this.mapProjection, bus: this.props.bus, showLabel: false, showHeadingBug: Subject.create(false), arcStrokeWidth: 2, arcEndTickLength: 5, referenceTickWidth: 2, referenceTickHeight: 5, bearingTickMajorLength: 10, bearingTickMinorLength: 5, bearingLabelFont: 'Roboto-Bold', bearingLabelFontSize: 20, bearingLabelOutlineWidth: 6, bearingLabelRadialOffset: 0 }));
    }
    /** @inheritdoc */
    renderPointerInfoLayer() {
        return (FSComponent.buildComponent(MapPointerInfoLayer, { ref: this.pointerInfoLayerRef, model: this.props.model, mapProjection: this.mapProjection, size: MapPointerInfoLayerSize.Small }));
    }
    /** @inheritdoc */
    renderTerrainScaleIndicator() {
        return null;
    }
    /** @inheritdoc */
    renderDetailIndicator() {
        return (FSComponent.buildComponent(MapDetailIndicator, { declutterMode: this.props.model.getModule('declutter').mode, showTitle: false }));
    }
}
/**
 * A controller for handling map range, target, and rotation changes for the MFD navigation map.
 */
class PFDInsetNavMapRangeTargetRotationController extends NavMapRangeTargetRotationController {
    /** @inheritdoc */
    convertToTrueRange(nominalRange) {
        const projectedHeight = this.mapProjection.getProjectedSize()[1];
        const correctedHeight = projectedHeight - this.deadZone[1] - this.deadZone[3];
        const orientation = this.orientationModule.orientation.get();
        const factor = orientation === MapOrientation.NorthUp ? 2.5 : 2;
        return nominalRange.asUnit(UnitType.GA_RADIAN) * projectedHeight / correctedHeight * factor;
    }
    /** @inheritdoc */
    getDesiredTargetOffset() {
        const trueCenterOffsetX = (this.deadZone[0] - this.deadZone[2]) / 2;
        const trueCenterOffsetY = (this.deadZone[1] - this.deadZone[3]) / 2;
        const projectedSize = this.mapProjection.getProjectedSize();
        const relativeOffset = this.orientationModule.orientation.get() === MapOrientation.NorthUp
            ? PFDInsetNavMapRangeTargetRotationController.NORTH_UP_TARGET_OFFSET_REL
            : PFDInsetNavMapRangeTargetRotationController.HDG_TRK_UP_TARGET_OFFSET_REL;
        return Vec2Math.set(relativeOffset[0] * projectedSize[0] + trueCenterOffsetX, relativeOffset[1] * projectedSize[1] + trueCenterOffsetY, PFDInsetNavMapRangeTargetRotationController.tempVec2_1);
    }
    /** @inheritdoc */
    updateModules() {
        super.updateModules();
        const isNorthUp = this.mapModel.getModule('orientation').orientation.get() === MapOrientation.NorthUp;
        this.mapModel.getModule('rangeRing').show.set(isNorthUp);
        this.mapModel.getModule('rangeCompass').show.set(!isNorthUp);
    }
}
PFDInsetNavMapRangeTargetRotationController.NORTH_UP_TARGET_OFFSET_REL = new Float64Array(2);
PFDInsetNavMapRangeTargetRotationController.HDG_TRK_UP_TARGET_OFFSET_REL = new Float64Array([0, 1 / 6]);
PFDInsetNavMapRangeTargetRotationController.tempVec2_1 = new Float64Array(2);

/**
 * Controls the pointer of a map.
 */
class MapPointerController {
    /**
     * Constructor.
     * @param mapModel The model of the map associated with this controller.
     * @param mapProjection The map projection associated with this controller.
     */
    constructor(mapModel, mapProjection) {
        this.mapModel = mapModel;
        this.mapProjection = mapProjection;
        this.pointerModule = this.mapModel.getModule('pointer');
    }
    /**
     * Activates or deactivates the map pointer.
     * @param isActive Whether to activate the map pointer.
     */
    setPointerActive(isActive) {
        if (isActive === this.pointerModule.isActive.get()) {
            return;
        }
        if (isActive) {
            this.pointerModule.target.set(this.mapProjection.getTarget());
            this.pointerModule.position.set(this.mapProjection.getTargetProjected());
        }
        this.pointerModule.isActive.set(isActive);
    }
    /**
     * Toggles activation of the map pointer.
     * @returns Whether the map pointer is active after the toggle operation.
     */
    togglePointerActive() {
        this.setPointerActive(!this.pointerModule.isActive.get());
        return this.pointerModule.isActive.get();
    }
    /**
     * Moves the map pointer.
     * @param dx The horizontal displacement, in pixels.
     * @param dy The vertical dispacement, in pixels.
     */
    movePointer(dx, dy) {
        const currentPos = this.pointerModule.position.get();
        this.pointerModule.position.set(currentPos[0] + dx, currentPos[1] + dy);
    }
    /**
     * Sets the map target to the current position of the pointer. The pointer will also be moved to the
     */
    targetPointer() {
        const target = this.mapProjection.invert(this.pointerModule.position.get(), MapPointerController.geoPointCache[0]);
        this.pointerModule.target.set(target);
        this.pointerModule.position.set(this.mapProjection.getTargetProjected());
    }
}
MapPointerController.geoPointCache = [new GeoPoint(0, 0)];

/**
 * The PFD map inset overlay.
 */
class MapInset extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.el = new NodeReference();
        this.mapRef = FSComponent.createRef();
        this.mapModel = NavMapModel.createModel(this.props.tas);
        this.pointerModule = this.mapModel.getModule('pointer');
        this.mapRangeSettingManager = MapRangeSettings.getManager(this.props.bus);
        this.mapRangeSetting = this.mapRangeSettingManager.getSetting('pfdMapRangeIndex');
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        this.mapPointerController = new MapPointerController(this.mapModel, this.mapRef.instance.mapProjection);
        this.setVisible(false);
        PFDUserSettings.getManager(this.props.bus).whenSettingChanged('mapLayout').handle((mode) => {
            this.setVisible(mode === PfdMapLayoutSettingMode.Inset || mode === PfdMapLayoutSettingMode.TFC);
        });
        const hEvents = this.props.bus.getSubscriber();
        hEvents.on('hEvent').handle(this.onInteractionEvent.bind(this));
    }
    /**
     * Sets whether or not the inset map is visible.
     * @param isVisible Whether or not the map is visible.
     */
    setVisible(isVisible) {
        var _a;
        if (isVisible) {
            this.el.instance.style.display = '';
            this.mapRef.instance.wake();
        }
        else {
            this.el.instance.style.display = 'none';
            (_a = this.mapPointerController) === null || _a === void 0 ? void 0 : _a.setPointerActive(false);
            this.mapRef.instance.sleep();
        }
    }
    /**
     * A callback which is called when an interaction event occurs.
     * @param hEvent An interaction event.
     */
    onInteractionEvent(hEvent) {
        var _a;
        if (!this.mapRef.instance.isAwake) {
            return;
        }
        switch (hEvent) {
            case 'AS1000_PFD_RANGE_INC':
                this.changeMapRangeIndex(1);
                break;
            case 'AS1000_PFD_RANGE_DEC':
                this.changeMapRangeIndex(-1);
                break;
            case 'AS1000_PFD_JOYSTICK_PUSH':
                (_a = this.mapPointerController) === null || _a === void 0 ? void 0 : _a.togglePointerActive();
                break;
            default:
                this.handleMapPointerMoveEvent(hEvent);
        }
    }
    /**
     * Changes the MFD map range index setting.
     * @param delta The change in index to apply.
     */
    changeMapRangeIndex(delta) {
        var _a;
        const newIndex = Utils.Clamp(this.mapRangeSetting.value + delta, 0, MapRangeSettings.DEFAULT_RANGES.length - 1);
        if (this.mapRangeSetting.value !== newIndex) {
            (_a = this.mapPointerController) === null || _a === void 0 ? void 0 : _a.targetPointer();
            this.mapRangeSetting.value = newIndex;
        }
    }
    /**
     * Handles events that move the map pointer.
     * @param hEvent An interaction event.
     */
    handleMapPointerMoveEvent(hEvent) {
        var _a, _b, _c, _d;
        if (!this.pointerModule.isActive.get()) {
            return;
        }
        switch (hEvent) {
            case 'AS1000_PFD_JOYSTICK_LEFT':
                (_a = this.mapPointerController) === null || _a === void 0 ? void 0 : _a.movePointer(-MapInset.POINTER_MOVE_INCREMENT, 0);
                break;
            case 'AS1000_PFD_JOYSTICK_UP':
                (_b = this.mapPointerController) === null || _b === void 0 ? void 0 : _b.movePointer(0, -MapInset.POINTER_MOVE_INCREMENT);
                break;
            case 'AS1000_PFD_JOYSTICK_RIGHT':
                (_c = this.mapPointerController) === null || _c === void 0 ? void 0 : _c.movePointer(MapInset.POINTER_MOVE_INCREMENT, 0);
                break;
            case 'AS1000_PFD_JOYSTICK_DOWN':
                (_d = this.mapPointerController) === null || _d === void 0 ? void 0 : _d.movePointer(0, MapInset.POINTER_MOVE_INCREMENT);
                break;
        }
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "map-inset", ref: this.el },
            FSComponent.buildComponent(PFDInsetNavMapComponent, { ref: this.mapRef, model: this.mapModel, bus: this.props.bus, updateFreq: 4, projectedWidth: 242, projectedHeight: 230, flightPlanner: this.props.flightPlanner, airspaceSearcher: this.props.airspaceSearcher, id: 'pfd_inset_map', bingId: 'pfd_map', ownAirplaneLayerProps: {
                    imageFilePath: 'coui://html_ui/Pages/VCockpit/Instruments/NavSystems/WTG1000/Assets/own_airplane_icon.svg',
                    iconSize: 30,
                    iconAnchor: new Float64Array([0.5, 0])
                }, trafficIntruderLayerProps: {
                    fontSize: 16,
                    iconSize: 30
                }, drawEntireFlightPlan: Subject.create(false), class: 'pfd-insetmap', settingManager: MapUserSettings.getPfdManager(this.props.bus) })));
    }
}
MapInset.POINTER_MOVE_INCREMENT = 2; // pixels

/** FPL Active Leg States */
var ActiveLegStates;
(function (ActiveLegStates) {
    ActiveLegStates[ActiveLegStates["RANDOM_DIRECT"] = 0] = "RANDOM_DIRECT";
    ActiveLegStates[ActiveLegStates["EXISTING_DIRECT"] = 1] = "EXISTING_DIRECT";
    ActiveLegStates[ActiveLegStates["NORMAL"] = 2] = "NORMAL";
    ActiveLegStates[ActiveLegStates["NONE"] = 3] = "NONE";
})(ActiveLegStates || (ActiveLegStates = {}));
/**
 * The FplActiveLegArrow component.
 */
class FplActiveLegArrow extends DisplayComponent {
    constructor() {
        super(...arguments);
        /** The arrow refs for direct to existing and active leg */
        this.dtoArrowEl = FSComponent.createRef();
        this.fromLegArrow = FSComponent.createRef();
        this.legArrowRectangle = FSComponent.createRef();
        this.toLegArrow = FSComponent.createRef();
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        this.dtoArrowEl.instance.style.display = 'none';
        this.fromLegArrow.instance.style.display = 'none';
        this.toLegArrow.instance.style.display = 'none';
    }
    /**
     * Datermines the location and visibility of the active leg/direct to arrows on the FPL page.
     * @param state Is the ActiveLegState.
     * @param activeLeg Is the ActiveLegDefinition.
     * @param plan Is the flight plan.
     */
    updateArrows(state, activeLeg, plan) {
        try {
            switch (state) {
                case ActiveLegStates.NONE:
                case ActiveLegStates.RANDOM_DIRECT:
                    this.setDirectArrow(false);
                    this.setActiveLegArrow(false);
                    break;
                case ActiveLegStates.NORMAL:
                    this.setDirectArrow(false);
                    this.setActiveLegArrow(true, plan, activeLeg.segmentIndex, activeLeg.legIndex);
                    break;
                case ActiveLegStates.EXISTING_DIRECT:
                    this.setDirectArrow(true, activeLeg.segmentIndex, activeLeg.legIndex);
                    this.setActiveLegArrow(false);
                    break;
            }
        }
        catch (error) {
            console.warn(`updateArrows: ${error}`);
        }
    }
    /**
     * Sets the location and visibility of the direct to arrow in the flight plan display.
     * @param display whether to show or hide the arrow.
     * @param segmentIndex the segment index of the direct fix.
     * @param legIndex the leg index of the direct fix.
     */
    setDirectArrow(display, segmentIndex, legIndex) {
        this.dtoArrowEl.instance.style.display = display ? '' : 'none';
        if (display && segmentIndex !== undefined && legIndex !== undefined) {
            const top = this.props.getLegDomLocation(segmentIndex, legIndex);
            this.dtoArrowEl.instance.style.transform = `translate3d(0,${top}px,0)`;
        }
    }
    /**
     * Sets the location and visibility of the active leg arrow in the flight plan display.
     * @param display whether to show or hide the arrow.
     * @param plan the flight plan to process.
     * @param toSegmentIndex the segment index of the from leg.
     * @param tolegIndex the leg index of the from leg.
     */
    setActiveLegArrow(display, plan, toSegmentIndex = -1, tolegIndex = -1) {
        if (plan && display && ((toSegmentIndex > 0 && tolegIndex >= 0) || (toSegmentIndex == 0 && tolegIndex > 0))) {
            let fromSegmentIndex = -1;
            let fromLegIndex = -1;
            if (toSegmentIndex > 0 && tolegIndex == 0 && plan.getSegment(toSegmentIndex - 1).legs.length < 1 && toSegmentIndex < 2) {
                this.fromLegArrow.instance.style.display = 'none';
                this.toLegArrow.instance.style.display = 'none';
                return;
            }
            else if (tolegIndex == 0 && plan.getSegment(toSegmentIndex - 1).legs.length < 1) {
                fromSegmentIndex = toSegmentIndex - 2;
                fromLegIndex = plan.getSegment(fromSegmentIndex).legs.length - 1;
            }
            else if (tolegIndex == 0) {
                fromSegmentIndex = toSegmentIndex - 1;
                fromLegIndex = plan.getSegment(fromSegmentIndex).legs.length - 1;
            }
            else if (plan.directToData.segmentIndex > -1
                && plan.directToData.segmentLegIndex > -1
                && toSegmentIndex === plan.directToData.segmentIndex
                && tolegIndex === plan.directToData.segmentLegIndex + 4) {
                fromSegmentIndex = toSegmentIndex;
                fromLegIndex = tolegIndex - 4;
            }
            else {
                fromSegmentIndex = toSegmentIndex;
                fromLegIndex = tolegIndex - 1;
            }
            const top = this.props.getLegDomLocation(fromSegmentIndex, fromLegIndex);
            const bottom = this.props.getLegDomLocation(toSegmentIndex, tolegIndex);
            const height = bottom - top - 8;
            this.fromLegArrow.instance.style.transform = `translate3d(0,${top}px,0)`;
            this.legArrowRectangle.instance.setAttribute('height', `${height}`);
            this.toLegArrow.instance.style.transform = `translate3d(0,${bottom}px,0)`;
            this.fromLegArrow.instance.style.display = '';
            this.toLegArrow.instance.style.display = '';
        }
        else {
            this.fromLegArrow.instance.style.display = 'none';
            this.toLegArrow.instance.style.display = 'none';
        }
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", null,
            FSComponent.buildComponent("svg", { class: 'dto-arrow', ref: this.dtoArrowEl },
                FSComponent.buildComponent("path", { d: 'M 20 7 l -7 -7 l 0 5 l -8 0 l 0 4 l 8 0 l 0 5 l 7 -7 z', fill: "magenta" })),
            FSComponent.buildComponent("svg", { class: 'dynamic-from-arrow', ref: this.fromLegArrow },
                FSComponent.buildComponent("path", { d: 'M 20 -2 l -15 0 c -3 0 -5 2 -5 6 l 6 0 c 0 -1 1 -2 3 -2 l 11 0 l 0 -4', fill: "magenta" }),
                FSComponent.buildComponent("rect", { ref: this.legArrowRectangle, x: "0", y: "4", width: "6", height: "18", fill: "magenta" })),
            FSComponent.buildComponent("svg", { class: 'dynamic-to-arrow', ref: this.toLegArrow },
                FSComponent.buildComponent("path", { d: 'M 20 0 l -7 -7 l 0 5 l -4 0 c -2 0 -3 -1 -3 -2 l -6 0 c 0 4 2 6 5 6 l 8 0 l 0 5 l 7 -7', fill: "magenta" }))));
    }
}

/// <reference types="msfstypes/JS/Avionics" />
/**
 * The scroll mode for FPL.
 */
var ScrollMode;
(function (ScrollMode) {
    ScrollMode[ScrollMode["MANUAL"] = 0] = "MANUAL";
    ScrollMode[ScrollMode["AUTO"] = 1] = "AUTO";
})(ScrollMode || (ScrollMode = {}));
/**
 * Controller for FPLDetails
 */
class FPLDetailsController {
    /**
     * Constructor
     * @param store the store instance
     * @param fms the fms
     * @param bus the bus
     * @param scrollToActiveLegCb the callback for scroll to active leg
     */
    constructor(store, fms, bus, scrollToActiveLegCb) {
        this.store = store;
        this.fms = fms;
        this.bus = bus;
        this.scrollToActiveLegCb = scrollToActiveLegCb;
        this.sectionRefs = [];
        this.originRef = FSComponent.createRef();
        this.legArrowRef = FSComponent.createRef();
        this.hasVnav = false;
        this.isInitialized = false;
        this.airwaysCollapsed = false;
        this.scrollMode = ScrollMode.MANUAL;
        /** First time this view is loaded, we need to force scroll to the active leg */
        this.didInitScroll = false;
        if (this.fms.autopilot) {
            this.hasVnav = true;
        }
    }
    /** Initializes fpldetails controller */
    initialize() {
        this.store.activeLegState.sub(() => {
            this.onActiveLegStateChange();
        });
        this.store.activeLeg.sub(() => {
            this.onActiveLegStateChange();
        });
        this.store.segments.sub((index, type) => {
            if (type === SubscribableArrayEventType.Removed) {
                this.sectionRefs.splice(index, 1);
            }
        });
        //Attempt to load the first flight plan on construction
        this.onFlightPlanLoaded({ planIndex: 0 });
        //this.initActiveLeg();
        this.isInitialized = true;
        this.bus.getSubscriber().on('alt').atFrequency(1).handle(alt => this.store.currentAltitude = alt);
        const ap = this.bus.getSubscriber();
        ap.on('alt_select').withPrecision(0).handle((sAlt) => {
            this.store.selectedAltitude = sAlt;
        });
        const fpl = this.bus.getSubscriber();
        fpl.on('fplSegmentChange').handle(this.onSegmentChange.bind(this));
        fpl.on('fplLegChange').handle(this.onLegChange.bind(this));
        fpl.on('fplActiveLegChange').handle(this.updateActiveLegState.bind(this));
        fpl.on('fplOriginDestChanged').handle(this.onOriginDestChanged.bind(this));
        fpl.on('fplCalculated').handle(this.onPlanCalculated.bind(this));
        fpl.on('fplLoaded').handle(this.onFlightPlanLoaded.bind(this));
        fpl.on('fplIndexChanged').handle(this.onPlanIndexChanged.bind(this));
        fpl.on('fplProcDetailsChanged').handle(this.onProcDetailsChanged.bind(this));
        fpl.on('vnavUpdated').handle(this.onVnavUpdated.bind(this));
        fpl.on('fplDirectToDataChanged').handle(this.updateActiveLegState.bind(this));
    }
    /**
     * A method to initialize the active leg.
     * TODO: REMOVE THIS WHEN THE ROOT PROBLEM IS FIXED
     */
    initActiveLeg() {
        this.updateActiveLegState();
    }
    /**
     * A method to initialize the dto leg.
     * TODO: REMOVE THIS WHEN THE ROOT PROBLEM IS FIXED
     */
    initDtoLeg() {
        if (this.fms.flightPlanner.activePlanIndex == 1) {
            const e = {
                planIndex: 1
            };
            this.onPlanIndexChanged(e);
        }
    }
    /**
     * A callback fired when a proc details event is received from the bus.
     * @param e The event that was captured.
     */
    onProcDetailsChanged(e) {
        var _a;
        if (e.planIndex == 0 && e.details.arrivalFacilityIcao !== ((_a = this.store.facilityInfo.arrivalFacility) === null || _a === void 0 ? void 0 : _a.icao)) {
            if (e.details.arrivalFacilityIcao !== undefined) {
                this.store.loader.getFacility(FacilityType.Airport, e.details.arrivalFacilityIcao)
                    .then(facility => {
                    this.store.facilityInfo.arrivalFacility = facility;
                    this.updateSectionsHeaderEmptyRow();
                });
            }
            else {
                this.store.facilityInfo.arrivalFacility = undefined;
                this.updateSectionsHeaderEmptyRow();
            }
        }
        else if (e.planIndex == 0) {
            this.updateSectionsHeaderEmptyRow();
        }
    }
    /**
     * A callback fired when a vnav updated message is recevied from the bus.
     * @param e The event that was captured.
     */
    onVnavUpdated(e) {
        var _a, _b;
        if (this.hasVnav && this.fms.autopilot !== undefined && e === true) {
            const vnav = this.fms.autopilot.directors.vnavDirector;
            const segments = vnav.calculator.getSegments();
            let maxAltitude = UnitType.FOOT.convertTo(Math.max(this.store.selectedAltitude, Math.round(this.store.currentAltitude / 100) * 100), UnitType.METER);
            let minAltitude = vnav.calculator.getFirstDescentConstraintAltitude();
            if (segments && segments.length > 0) {
                //start with segment 1 to skip departure segment for now
                for (let i = 1; i < (segments === null || segments === void 0 ? void 0 : segments.length); i++) {
                    const section = (_a = this.sectionRefs[i]) === null || _a === void 0 ? void 0 : _a.instance;
                    if (section !== undefined) {
                        for (let j = 0; j < segments[i].legs.length; j++) {
                            const segment = segments[i];
                            if (segment !== undefined) {
                                const vnavLeg = segments[i].legs[j];
                                if (vnavLeg) {
                                    if (vnavLeg.altitude && vnavLeg.isAdvisory && vnavLeg.altitude > maxAltitude) {
                                        const newAltitude = minAltitude ? Math.max(minAltitude, maxAltitude) : maxAltitude;
                                        section.setLegAltitude(j, vnavLeg, newAltitude);
                                    }
                                    else {
                                        section.setLegAltitude(j, vnavLeg);
                                    }
                                    if (!vnavLeg.isAdvisory) {
                                        maxAltitude = vnavLeg.altitude;
                                        minAltitude = 0;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (this.fms.getDirectToState() === DirectToState.TOEXISTING) {
                const plan = this.fms.getFlightPlan();
                const vnavLeg = vnav.calculator.getLeg(plan.activeLateralLeg);
                (_b = this.sectionRefs[plan.directToData.segmentIndex]) === null || _b === void 0 ? void 0 : _b.instance.setLegAltitude(plan.directToData.segmentLegIndex, vnavLeg);
            }
        }
    }
    /**
     * A callback fired when a new plan is loaded.
     * @param e The event that was captured.
     */
    onFlightPlanLoaded(e) {
        const plan = this.fms.flightPlanner.getFlightPlan(e.planIndex);
        if (plan.originAirport !== undefined) {
            this.onOriginDestChanged({ planIndex: e.planIndex, airport: plan.originAirport, type: OriginDestChangeType.OriginAdded });
        }
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            this.onSegmentChange({ planIndex: e.planIndex, segmentIndex: i, segment: segment, type: PlanChangeType.Added });
            for (let l = 0; l < segment.legs.length; l++) {
                this.onLegChange({
                    planIndex: e.planIndex,
                    segmentIndex: i, legIndex: l, leg: segment.legs[l], type: PlanChangeType.Added
                });
            }
        }
        if (plan.procedureDetails.arrivalIndex > -1) {
            this.onProcDetailsChanged({ planIndex: e.planIndex, details: plan.procedureDetails });
        }
        if (plan.destinationAirport !== undefined) {
            this.onOriginDestChanged({ planIndex: e.planIndex, airport: plan.destinationAirport, type: OriginDestChangeType.DestinationAdded });
        }
        if (e.planIndex === this.fms.flightPlanner.activePlanIndex) {
            this.updateActiveLegState();
        }
    }
    /**
     * A callback fired when the plan index changes (used for handling direct to display).
     * @param e The event that was captured.
     */
    onPlanIndexChanged(e) {
        if (e.planIndex === 1 && this.isInitialized) {
            const plan = this.fms.getDirectToFlightPlan();
            const segment = plan.getSegment(0);
            if (segment.segmentType === FlightPlanSegmentType.RandomDirectTo) {
                this.originRef.instance.onDirectToRandomActive(ICAO.getIdent(segment.legs[2].leg.fixIcao));
            }
            else {
                this.originRef.instance.removeDirectToRandom(this.fms.getFlightPlan(0));
            }
        }
        else if (this.isInitialized) {
            const plan = this.fms.getFlightPlan(0);
            this.originRef.instance.removeDirectToRandom(plan);
        }
        this.updateActiveLegState();
    }
    /**
     * A callback fired when the plan is calculated.
     * @param e The event that was captured.
     */
    onPlanCalculated(e) {
        var _a;
        if (e.planIndex !== 0) {
            return;
        }
        const plan = this.fms.flightPlanner.getFlightPlan(e.planIndex);
        let sectionIndex = 0;
        for (const segment of plan.segments()) {
            const section = (_a = this.sectionRefs[sectionIndex]) === null || _a === void 0 ? void 0 : _a.instance;
            if (section !== undefined) {
                for (let i = 0; i < segment.legs.length; i++) {
                    const calc = segment.legs[i].calculated;
                    calc && section.updateFromLegCalculations(i);
                }
            }
            else {
                console.warn(`onPlanCalculated: Found no section ref for segment ${segment.segmentIndex} !`);
            }
            sectionIndex++;
        }
        //this.updateActiveLegState();
    }
    /**
     * A callback fired when the origin or destination is updated.
     * @param e The event that was captured.
     */
    onOriginDestChanged(e) {
        if (e.planIndex !== 0) {
            return;
        }
        switch (e.type) {
            case OriginDestChangeType.OriginAdded:
                if (e.airport !== undefined) {
                    this.store.loader.getFacility(FacilityType.Airport, e.airport)
                        .then(facility => {
                        this.store.facilityInfo.originFacility = facility;
                        this.updateSectionsHeaderEmptyRow();
                    });
                }
                break;
            case OriginDestChangeType.DestinationAdded:
                if (e.airport !== undefined) {
                    this.store.loader.getFacility(FacilityType.Airport, e.airport)
                        .then(facility => {
                        this.store.facilityInfo.destinationFacility = facility;
                        this.updateSectionsHeaderEmptyRow();
                    });
                }
                break;
            case OriginDestChangeType.OriginRemoved:
                this.store.facilityInfo.originFacility = undefined;
                this.updateSectionsHeaderEmptyRow();
                break;
            case OriginDestChangeType.DestinationRemoved:
                this.store.facilityInfo.destinationFacility = undefined;
                this.updateSectionsHeaderEmptyRow();
                break;
        }
        this.originRef.instance.onOriginDestChanged(e);
    }
    /**
     * Manages the state of the active/direct leg indications based on the store.activeLegState subject state.
     */
    onActiveLegStateChange() {
        var _a;
        this.clearActiveWaypoints();
        const state = this.store.activeLegState.get();
        const plan = this.fms.getFlightPlan();
        const activeLeg = this.store.activeLeg.get();
        const section = (_a = this.sectionRefs[activeLeg.segmentIndex]) === null || _a === void 0 ? void 0 : _a.instance;
        this.legArrowRef.instance.updateArrows(state, activeLeg, plan);
        switch (state) {
            case ActiveLegStates.NORMAL:
            case ActiveLegStates.EXISTING_DIRECT:
                section && section.setActiveLeg(activeLeg.legIndex);
                break;
        }
        if (!this.didInitScroll || this.scrollMode === ScrollMode.AUTO) {
            this.scrollToActiveLegCb();
            this.didInitScroll = true;
        }
        this.manageCollapsedAirways(plan);
        this.notifyActiveLegState(plan);
    }
    /**
     * Updates the active leg state subjects.
     */
    updateActiveLegState() {
        const plan = this.fms.getFlightPlan();
        const directToState = this.fms.getDirectToState();
        if (directToState === DirectToState.TORANDOM) {
            this.store.activeLegState.set(ActiveLegStates.RANDOM_DIRECT);
            return;
        }
        else if (directToState === DirectToState.TOEXISTING) {
            this.store.activeLegState.set(ActiveLegStates.EXISTING_DIRECT);
            const activeLeg = { legIndex: plan.directToData.segmentLegIndex, segmentIndex: plan.directToData.segmentIndex };
            this.store.activeLeg.set(activeLeg);
            return;
        }
        else if (plan.activeLateralLeg < plan.length) {
            this.store.activeLegState.set(ActiveLegStates.NORMAL);
            const leg = plan.getLeg(plan.activeLateralLeg);
            const activeSegment = plan.getSegmentFromLeg(leg);
            if (activeSegment) {
                const activeLegIndexInSegment = plan.activeLateralLeg - activeSegment.offset;
                const activeLeg = { legIndex: activeLegIndexInSegment, segmentIndex: activeSegment.segmentIndex };
                this.store.activeLeg.set(activeLeg);
                return;
            }
        }
        this.store.activeLegState.set(ActiveLegStates.NONE);
    }
    /**
     * A callback fired when a flight plan leg changes.
     * @param e The event that was captured.
     */
    onLegChange(e) {
        var _a, _b;
        if (e.planIndex !== 0) {
            return;
        }
        const section = (_a = this.sectionRefs[e.segmentIndex]) === null || _a === void 0 ? void 0 : _a.instance;
        switch (e.type) {
            case PlanChangeType.Added: {
                const plan = this.fms.getFlightPlan();
                const segment = plan.getSegment(e.segmentIndex);
                const leg = segment.legs[e.legIndex];
                const isAirwayLeg = segment.airway !== undefined;
                const isExitLeg = isAirwayLeg && (leg === null || leg === void 0 ? void 0 : leg.name) === ((_b = segment.airway) === null || _b === void 0 ? void 0 : _b.split('.')[1]);
                if (this.hasVnav) {
                    section && leg && section.addLeg(e.legIndex, {
                        legDefinition: leg, isActive: false, isDirectTo: false,
                        targetAltitude: -1, isAdvisory: true, isAirwayFix: isAirwayLeg, isAirwayExitFix: isExitLeg
                    });
                }
                else {
                    section && leg && section.addLeg(e.legIndex, {
                        legDefinition: leg, isActive: false, isDirectTo: false,
                        isAirwayFix: isAirwayLeg, isAirwayExitFix: isExitLeg
                    });
                }
                break;
            }
            case PlanChangeType.Removed:
                section && section.removeLeg(e.legIndex);
                break;
        }
    }
    /**
     * A callback fired when a flight plan segment changes.
     * @param e The event that was captured.
     */
    onSegmentChange(e) {
        var _a, _b, _c, _d;
        if (e.planIndex !== 0) {
            return;
        }
        switch (e.type) {
            case PlanChangeType.Added: {
                if (e.segmentIndex < this.sectionRefs.length) {
                    this.store.segments.removeAt(e.segmentIndex);
                }
                e.segment && this.store.segments.insert(e.segment, e.segmentIndex);
                break;
            }
            case PlanChangeType.Inserted: {
                e.segment && this.store.segments.insert(e.segment, e.segmentIndex);
                for (let s = e.segmentIndex; s < this.store.segments.length; s++) {
                    const section = (_a = this.sectionRefs[s]) === null || _a === void 0 ? void 0 : _a.instance;
                    if (section !== undefined) {
                        section.segmentIndex.set(s);
                    }
                }
                break;
            }
            case PlanChangeType.Removed:
                this.store.segments.removeAt(e.segmentIndex);
                for (let s = e.segmentIndex; s < this.store.segments.length; s++) {
                    const section = (_b = this.sectionRefs[s]) === null || _b === void 0 ? void 0 : _b.instance;
                    if (section !== undefined) {
                        section.segmentIndex.set(s);
                    }
                }
                break;
            case PlanChangeType.Changed: {
                const section = (_c = this.sectionRefs[e.segmentIndex]) === null || _c === void 0 ? void 0 : _c.instance;
                if (section !== undefined && e.segment) {
                    section.segmentIndex.set(e.segmentIndex);
                }
                const prevSection = (_d = this.sectionRefs[e.segmentIndex - 1]) === null || _d === void 0 ? void 0 : _d.instance;
                if (prevSection !== undefined) {
                    prevSection.segmentIndex.set(e.segmentIndex - 1);
                }
                break;
            }
        }
        this.updateSectionsHeaderEmptyRow();
    }
    /**
     * Updates all section headers and empty rows.
     */
    updateSectionsHeaderEmptyRow() {
        for (let i = 0; i < this.sectionRefs.length; i++) {
            const sectionRef = this.sectionRefs[i];
            if (sectionRef) {
                sectionRef.instance.updateHeader();
                sectionRef.instance.updateEmptyRowVisibility();
            }
        }
    }
    /**
     * A method called to collapse the airways.
     */
    collapseAirways() {
        var _a;
        this.airwaysCollapsed = !this.airwaysCollapsed;
        const plan = this.fms.getFlightPlan();
        const activeSegmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
        for (let i = 1; i < plan.segmentCount; i++) {
            if (i === activeSegmentIndex) {
                continue;
            }
            const segment = plan.getSegment(i);
            if (segment.segmentType === FlightPlanSegmentType.Enroute && segment.airway !== undefined) {
                const section = (_a = this.sectionRefs[i]) === null || _a === void 0 ? void 0 : _a.instance;
                if (section !== undefined) {
                    section.collapseLegs(this.airwaysCollapsed);
                    continue;
                }
            }
        }
    }
    /**
     * A method called to manage collapsed airways when the active segment changes.
     * @param plan is the flight plan
     */
    manageCollapsedAirways(plan) {
        var _a, _b;
        const activeSegmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
        const fromSegmentIndex = plan.getSegmentIndex(plan.activeLateralLeg - 1);
        for (let i = 1; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            if ((i === activeSegmentIndex || i === fromSegmentIndex) && segment.segmentType === FlightPlanSegmentType.Enroute) {
                const section = (_a = this.sectionRefs[i]) === null || _a === void 0 ? void 0 : _a.instance;
                if (section !== undefined) {
                    section.collapseLegs(false);
                }
            }
            else if (segment.segmentType === FlightPlanSegmentType.Enroute && segment.airway !== undefined) {
                const section = (_b = this.sectionRefs[i]) === null || _b === void 0 ? void 0 : _b.instance;
                if (section !== undefined) {
                    section.collapseLegs(this.airwaysCollapsed);
                }
            }
        }
    }
    /**
     * Notifies this controller's sections of the flight plan's active leg state.
     * @param plan The flight plan.
     */
    notifyActiveLegState(plan) {
        var _a;
        if (plan.length > 0 && plan.segmentCount > 2) {
            const activeSegmentIndex = Utils.Clamp(plan.getSegmentIndex(plan.activeLateralLeg), 0, plan.segmentCount);
            let activeLegIndex = plan.activeLateralLeg - plan.getSegment(activeSegmentIndex).offset;
            if (this.fms.getDirectToState() === DirectToState.TOEXISTING) {
                activeLegIndex -= 3;
            }
            for (let i = 0; i < plan.segmentCount; i++) {
                const section = (_a = this.sectionRefs[i]) === null || _a === void 0 ? void 0 : _a.instance;
                if (section !== undefined) {
                    section.onActiveLegChanged(activeSegmentIndex, activeLegIndex);
                }
            }
        }
    }
    /**
     * Sets all legs in the displayed plan to inactive.
     */
    clearActiveWaypoints() {
        this.sectionRefs.forEach((section) => {
            section.instance.cancelAllActiveLegs();
        });
    }
}

/**
 * The store class for FPLDetails
 */
class FPLDetailsStore {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
        /** Information on our origin, arrival and destination facilities to save lookups. */
        this.facilityInfo = {
            originFacility: undefined,
            destinationFacility: undefined,
            arrivalFacility: undefined
        };
        this.segments = ArraySubject.create();
        this.activeLeg = Subject.create({ segmentIndex: 0, legIndex: 0 });
        this.activeLegState = Subject.create(ActiveLegStates.NONE);
        this.currentAltitude = 0;
        this.selectedAltitude = 0;
        this.loader = new FacilityLoader(FacilityRespository.getRepository(bus));
    }
}

/** A VNode representing a preformated rendering of an approach's name. */
class ApproachNameDisplay extends DisplayComponent {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.nameRef = FSComponent.createRef();
        this.airportRef = FSComponent.createRef();
        this.subTypeRef = FSComponent.createRef();
        this.suffixRef = FSComponent.createRef();
        this.runwayRef = FSComponent.createRef();
        this.flagsRef = FSComponent.createRef();
        this.nullRef = FSComponent.createRef();
        this.airportSub = (_b = (_a = this.props.airport) === null || _a === void 0 ? void 0 : _a.map(airport => airport ? ICAO.getIdent(airport.icao) : '')) !== null && _b !== void 0 ? _b : Subject.create('');
        this.namePartsSub = this.props.approach.map(approach => approach ? FmsUtils.getApproachNameAsParts(approach) : null);
        this.typeSub = this.namePartsSub.map(parts => { var _a; return (_a = parts === null || parts === void 0 ? void 0 : parts.type) !== null && _a !== void 0 ? _a : ''; });
        this.subTypeSub = this.namePartsSub.map(parts => { var _a; return (_a = parts === null || parts === void 0 ? void 0 : parts.subtype) !== null && _a !== void 0 ? _a : ''; });
        this.suffixConnectorSub = this.namePartsSub.map(parts => !parts || parts.runway ? ' ' : '–');
        this.suffixSub = this.namePartsSub.map(parts => { var _a; return (_a = parts === null || parts === void 0 ? void 0 : parts.suffix) !== null && _a !== void 0 ? _a : ''; });
        this.runwaySub = this.namePartsSub.map(parts => { var _a; return (_a = parts === null || parts === void 0 ? void 0 : parts.runway) !== null && _a !== void 0 ? _a : ''; });
        this.flagsSub = this.namePartsSub.map(parts => { var _a; return (_a = parts === null || parts === void 0 ? void 0 : parts.flags) !== null && _a !== void 0 ? _a : ''; });
    }
    /** @inheritdoc */
    onAfterRender() {
        this.namePartsSub.sub(parts => {
            this.nameRef.instance.style.display = parts ? '' : 'none';
            this.nullRef.instance.style.display = this.props.nullText === undefined || parts ? 'none' : '';
        }, true);
        this.airportSub.sub(value => { this.airportRef.instance.style.display = value === '' ? 'none' : ''; }, true);
        this.subTypeSub.sub(value => { this.subTypeRef.instance.style.display = value === '' ? 'none' : ''; }, true);
        this.suffixSub.sub(value => { this.suffixRef.instance.style.display = value === '' ? 'none' : ''; }, true);
        this.runwaySub.sub(value => { this.flagsRef.instance.style.display = value === '' ? 'none' : ''; }, true);
        this.flagsSub.sub(value => { this.flagsRef.instance.style.display = value === '' ? 'none' : ''; }, true);
    }
    /** @inheritdoc */
    render() {
        var _a, _b;
        return (FSComponent.buildComponent("div", { class: `appr-name ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}` },
            FSComponent.buildComponent("span", { ref: this.nameRef },
                FSComponent.buildComponent("span", { ref: this.airportRef },
                    this.airportSub,
                    "\u2013"),
                FSComponent.buildComponent("span", null, this.typeSub),
                FSComponent.buildComponent("span", { ref: this.subTypeRef, class: 'appr-name-subtype' }, this.subTypeSub),
                FSComponent.buildComponent("span", { ref: this.suffixRef },
                    this.suffixConnectorSub,
                    this.suffixSub),
                FSComponent.buildComponent("span", { ref: this.runwayRef },
                    " ",
                    this.runwaySub),
                FSComponent.buildComponent("span", { ref: this.flagsRef },
                    " ",
                    this.flagsSub)),
            FSComponent.buildComponent("span", { ref: this.nullRef }, (_b = this.props.nullText) !== null && _b !== void 0 ? _b : '')));
    }
    /** @inheritdoc */
    destroy() {
        this.namePartsSub.destroy();
    }
}

/**
 * A header for an FPL section.
 */
class FPLHeader extends UiControl {
    constructor() {
        super(...arguments);
        this.rootRef = FSComponent.createRef();
        this.estimatedNameWidth = 0;
        this._isCollapsed = false;
        this.isInit = false;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether this header is collapsed. */
    get isCollapsed() {
        return this._isCollapsed;
    }
    /** @inheritdoc */
    onAfterRender() {
        this.isInit = true;
        super.onAfterRender();
        this.update();
    }
    /** Updates this header */
    update() {
        if (!this.isInit) {
            return;
        }
        this.updateName();
    }
    /**
     * Sets the estimated width of this header's name text.
     * @param width The new estimated width, in pixels.
     */
    setEstimatedNameWidth(width) {
        if (width === this.estimatedNameWidth) {
            return;
        }
        this.estimatedNameWidth = width;
        this.updateNameFontSize();
    }
    /**
     * Updates the font size for this header's name text to ensure the text fits within this header's width.
     */
    updateNameFontSize() {
        if (this.rootRef.getOrDefault() !== null) {
            // fit size
            const clampedWidth = Utils.Clamp(this.estimatedNameWidth, this.rootRef.instance.offsetWidth, 500);
            const clientWidth = this.rootRef.instance.clientWidth;
            if (clientWidth !== 0) {
                this.rootRef.instance.style.fontSize = `${(this.rootRef.instance.clientWidth / clampedWidth) * 100}%`;
            }
        }
    }
    /** @inheritdoc */
    renderControl() {
        return (FSComponent.buildComponent("div", { ref: this.rootRef, class: 'header-name' }, this.renderName()));
    }
}

/**
 * An FPL section header for approaches.
 */
class FPLHeaderApproach extends FPLHeader {
    constructor() {
        super(...arguments);
        this.airportSub = Subject.create(null);
        this.approachSub = Subject.create(null);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setCollapsed(setCollapsed) {
        //noop
    }
    /** @inheritdoc */
    updateName() {
        const plan = this.props.fms.getPrimaryFlightPlan();
        const airport = this.props.facilities.destinationFacility;
        const approach = airport ? FmsUtils.getApproachFromPlan(plan, airport) : undefined;
        this.airportSub.set(airport !== null && airport !== void 0 ? airport : null);
        this.approachSub.set(approach !== null && approach !== void 0 ? approach : null);
        const nameLength = approach
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ? FmsUtils.getApproachNameAsString(approach).length + ICAO.getIdent(airport.icao).length + 1
            : 0;
        this.setEstimatedNameWidth(nameLength * FPLHeaderApproach.ESTIMATED_CHAR_WIDTH);
    }
    /** @inheritdoc */
    renderName() {
        return (FSComponent.buildComponent(ApproachNameDisplay, { approach: this.approachSub, airport: this.airportSub }));
    }
}
FPLHeaderApproach.ESTIMATED_CHAR_WIDTH = 13.2;

/**
 * The GroupBox component.
 */
class GroupBox extends UiControlGroup {
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        var _a, _b, _c;
        return (FSComponent.buildComponent("div", { class: `groupbox-container ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}`, style: (_b = this.props.containerStyle) !== null && _b !== void 0 ? _b : '' },
            FSComponent.buildComponent("div", { class: "groupbox-content", style: (_c = this.props.contentStyle) !== null && _c !== void 0 ? _c : '' }, this.props.children),
            FSComponent.buildComponent("div", { class: "groupbox-title" }, this.props.title))
        // <div>
        //   <fieldset>
        //     <legend>{this.props.title}</legend>
        //     {this.props.children}
        //   </fieldset>
        // </div>
        );
    }
}

/**
 * Dialog used for displaying page menus.
 * @class PageMenuDialog
 * @augments {ListMenuDialog}
 */
class PageMenuDialog extends ListMenuDialog {
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        let className = 'popout-dialog';
        if (this.props.class !== undefined) {
            className += ` ${this.props.class}`;
        }
        return (FSComponent.buildComponent("div", { class: className, ref: this.viewContainerRef },
            FSComponent.buildComponent("div", { class: "popout-pagemenu-background" },
                FSComponent.buildComponent("h1", null, this.props.title),
                FSComponent.buildComponent(GroupBox, { title: "Options", containerStyle: "margin-top:50px;" },
                    FSComponent.buildComponent("div", { class: "popout-pagemenu-listcontainer", ref: this.listContainerRef },
                        FSComponent.buildComponent(List, { ref: this.listRef, onRegister: this.register, data: this.menuItemsSubject, renderItem: this.renderItem, scrollContainer: this.listContainerRef })),
                    FSComponent.buildComponent(ScrollBar, null)))));
    }
}

/** The FixInfo component. */
class FixInfo extends UiControl {
    constructor() {
        var _a, _b, _c, _d, _e, _f, _g;
        super(...arguments);
        this.fixEl = FSComponent.createRef();
        this.highlightElementRef = FSComponent.createRef();
        this.altitudeRef = FSComponent.createRef();
        this.ACTIVE_WPT_CLASS = 'active-wpt';
        this._dtk = ComputedSubject.create((_b = (_a = this.props.data.get().legDefinition.calculated) === null || _a === void 0 ? void 0 : _a.initialDtk) !== null && _b !== void 0 ? _b : -1, (v) => {
            if (v < 0 || this.props.data.get().legIsBehind) {
                return '___';
            }
            else {
                const rounded = Math.round(v);
                return (rounded === 0 ? 360 : rounded).toFixed(0).padStart(3, '0');
            }
        });
        this._distance = ComputedSubject.create((_d = (_c = this.props.data.get().legDefinition.calculated) === null || _c === void 0 ? void 0 : _c.distance) !== null && _d !== void 0 ? _d : -1, (v) => {
            if (v < 0.1 || this.props.data.get().legIsBehind) {
                return '____';
            }
            else {
                // const dis = (v / 1852);
                const dis = Units.Meters.toNauticalMiles(v);
                return dis.toFixed((dis < 100) ? 1 : 0);
            }
        });
        this._altitude = ComputedSubject.create((_e = this.props.data.get().targetAltitude) !== null && _e !== void 0 ? _e : -1, (v) => {
            if (v < 1 || isNaN(v) || this.props.data.get().legIsBehind) {
                return '';
            }
            else {
                return Units.Meters.toFeet(v).toFixed(0);
            }
        });
        this._altitudeUnits = ComputedSubject.create((_f = this.props.data.get().targetAltitude) !== null && _f !== void 0 ? _f : -1, (v) => {
            if (v < 1 || isNaN(v) || this.props.data.get().legIsBehind) {
                return ' ';
            }
            else {
                return 'FT';
            }
        });
        this._fixType = ComputedSubject.create((_g = this.props.data.get().legDefinition.leg.fixTypeFlags) !== null && _g !== void 0 ? _g : FixTypeFlags.None, (v) => {
            const leg = this.props.data.get().legDefinition;
            if (leg.name === 'MANSEQ' && (leg.leg.type === LegType.FM || leg.leg.type === LegType.VM)) {
                return ' hdg';
            }
            switch (v) {
                case FixTypeFlags.FAF:
                    return ' faf';
                case FixTypeFlags.IAF:
                    return ' iaf';
                case FixTypeFlags.MAP:
                    return ' map';
                case FixTypeFlags.MAHP:
                    return ' mahp';
                default:
                    return '';
            }
        });
    }
    /**
     * Resets highlight animation when the leg goes to/from active so the right color variable is used.
     * We need to trigger a reflow so the browser parses the animation again.
     */
    resetHighlightAnimation() {
        const animName = this.highlightElementRef.instance.style.animationName;
        this.highlightElementRef.instance.style.animationName = 'none';
        this.highlightElementRef.instance.offsetHeight;
        this.highlightElementRef.instance.style.animationName = animName;
    }
    /**
     * Gets the container element location
     * @returns An array of x,y.
     */
    getContainerElementLocation() {
        return [this.fixEl.instance.offsetLeft, this.fixEl.instance.offsetTop];
    }
    /** @inheritdoc */
    getHighlightElement() {
        return this.highlightElementRef.instance;
    }
    /** @inheritdoc */
    onAfterRender() {
        super.onAfterRender();
        this.props.data.sub((v) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
            if (v.isAirwayExitFix && v.isCollapsed) {
                this._dtk.set(-1);
                this._distance.set((_a = v.airwayDistance) !== null && _a !== void 0 ? _a : -1);
            }
            else if (v.legDefinition.leg.type === LegType.HF || v.legDefinition.leg.type === LegType.HM || v.legDefinition.leg.type === LegType.HA) {
                this._dtk.set(v.legDefinition.leg.course);
                const lastVectorIndex = ((_b = v.legDefinition.calculated) === null || _b === void 0 ? void 0 : _b.flightPath.length) ? ((_c = v.legDefinition.calculated) === null || _c === void 0 ? void 0 : _c.flightPath.length) - 1 : 0;
                this._distance.set((_e = (_d = v.legDefinition.calculated) === null || _d === void 0 ? void 0 : _d.flightPath[lastVectorIndex].distance) !== null && _e !== void 0 ? _e : 0);
            }
            else {
                this._dtk.set((_g = (_f = v.legDefinition.calculated) === null || _f === void 0 ? void 0 : _f.initialDtk) !== null && _g !== void 0 ? _g : -1);
                this._distance.set((_j = (_h = v.legDefinition.calculated) === null || _h === void 0 ? void 0 : _h.distance) !== null && _j !== void 0 ? _j : 0);
            }
            this._altitude.set((_k = v.targetAltitude) !== null && _k !== void 0 ? _k : -1);
            this._altitudeUnits.set((_l = v.targetAltitude) !== null && _l !== void 0 ? _l : -1);
            if (v.isActive) {
                this.fixEl.instance.classList.add(this.ACTIVE_WPT_CLASS);
                this.highlightElementRef.instance.classList.remove('fix-hold');
            }
            else {
                this.fixEl.instance.classList.remove(this.ACTIVE_WPT_CLASS);
            }
            if (this.getIsFocused()) {
                this.resetHighlightAnimation();
            }
            if ((v.isCollapsed && !v.isAirwayExitFix) || v.legDefinition.isInDirectToSequence) {
                this.setIsVisible(false);
            }
            else {
                this.setIsVisible(true);
            }
            if (v.isAirwayFix) {
                this.highlightElementRef.instance.style.marginLeft = v.isAirwayExitFix ? '5px' : '10px';
            }
            else {
                this.highlightElementRef.instance.style.marginLeft = '0px';
            }
            this._fixType.set((_m = v.legDefinition.leg.fixTypeFlags) !== null && _m !== void 0 ? _m : FixTypeFlags.None);
            if (v.legDefinition.leg.type === LegType.HF || v.legDefinition.leg.type === LegType.HM || v.legDefinition.leg.type === LegType.HA) {
                this.highlightElementRef.instance.classList.add('fix-hold');
            }
            else {
                this.highlightElementRef.instance.classList.remove('fix-hold');
            }
            if (this.props.isExtended && v.isAdvisory) {
                this.altitudeRef.instance.classList.add('alt-advisory');
            }
            else if (this.props.isExtended) {
                this.altitudeRef.instance.classList.remove('alt-advisory');
            }
        });
    }
    /** @inheritdoc */
    renderControl() {
        return (FSComponent.buildComponent("div", { class: 'fix-container', ref: this.fixEl },
            FSComponent.buildComponent("div", { class: 'fix-name' },
                FSComponent.buildComponent("span", { ref: this.highlightElementRef },
                    this.props.data.get().legDefinition.name,
                    FSComponent.buildComponent("span", { class: 'fix-type' }, this._fixType))),
            FSComponent.buildComponent("div", { class: this.props.isExtended ? 'mfd-dtk-value' : 'dtk-value' },
                this._dtk,
                "\u00B0"),
            FSComponent.buildComponent("div", { class: this.props.isExtended ? 'mfd-dis-value' : 'dis-value' },
                this._distance,
                FSComponent.buildComponent("span", { class: "smallText" }, "NM")),
            this.props.isExtended ? FSComponent.buildComponent("div", { ref: this.altitudeRef, class: 'mfd-alt-value' },
                this._altitude,
                FSComponent.buildComponent("span", { class: "smallText" }, this._altitudeUnits)) : null));
    }
}

/**
 * A flight plan detail section, representing a single phase of flight.
 *
 * Individual sections that need to render a dynamic list of fixes can extend
 * this for useful functionality.  They will need to, at the minimum, define
 * the type of segment they are by storing a FlightPlanSegmentType in the
 * segmentType variable.
 *
 * An additional hook is provided for a callback that can be used to render
 * the header for the section dynamically based on the section's needs, since
 * that is something that varies by section type.
 *
 * Descendents must remember to call super.onAfterRender() in their own
 * onAfterRender if they want the magic to happen.
 */
class FPLSection extends UiControlGroup {
    constructor() {
        super(...arguments);
        /** A reference to the header line for the section. */
        this.headerRef = FSComponent.createRef();
        this.emptyRowRef = FSComponent.createRef();
        this.segmentIndex = Subject.create(this.props.segmentIndex);
        this.legs = ArraySubject.create();
        this.listRef = FSComponent.createRef();
        /**
         * Callback for when UpperKnob event happens on a leg.
         * @param node The FixInfo element.
         */
        this.onUpperKnobLegBase = (node) => {
            const idx = (node instanceof FixInfo) ? this.listRef.instance.getListItemIndex(node) : undefined;
            Fms.viewService.open('WptInfo', true)
                .onAccept.on((sender, fac) => {
                this.props.fms.insertWaypoint(this.segmentIndex.get(), fac, idx);
            });
        };
        /**
         * Callback to onUpperKnob on legs for override by sections
         * @param node The FixInfo element.
         */
        this.onUpperKnobLeg = (node) => {
            this.onUpperKnobLegBase(node);
        };
        /**
         * Callback for when CLR event happens on a leg.
         * @param node The FixInfo element.
         * @returns A boolean indicating if the CLR was handled.
         */
        this.onClrLegBase = (node) => {
            const idx = this.listRef.instance.getListItemIndex(node);
            const displayLeg = this.legs.tryGet(idx);
            const isActive = displayLeg !== undefined && displayLeg.get().isActive;
            const selectedLeg = node.props.data.get().legDefinition;
            const isHoldOrPtLegType = [LegType.HM, LegType.HF, LegType.HA, LegType.PI].includes(selectedLeg.leg.type);
            if (selectedLeg !== undefined) {
                Fms.viewService.open('MessageDialog', true).setInput({ inputString: `Remove ${selectedLeg === null || selectedLeg === void 0 ? void 0 : selectedLeg.name}?`, hasRejectButton: true }).onAccept.on((sender, accept) => {
                    if (accept) {
                        if (isActive && !isHoldOrPtLegType && !Simplane.getIsGrounded()) {
                            this.props.fms.buildRandomDirectTo(selectedLeg.leg.fixIcao);
                        }
                        this.props.fms.deleteWaypoint(this.segmentIndex.get(), idx);
                        if (isActive && isHoldOrPtLegType) {
                            this.props.fms.activateLeg(this.segmentIndex.get(), idx);
                        }
                        return true;
                    }
                });
            }
            return false;
        };
        /**
         * Callback to onClr on legs for override by sections
         * @param node The FixInfo element.
         * @returns A boolean indicating if the CLR was handled.
         */
        this.onClrLeg = (node) => {
            return this.onClrLegBase(node);
        };
        /**
         * Renders a Leg in the flight plan.
         * @param data The data object for this leg.
         * @param registerFn The control register function.
         * @returns The rendered VNode.
         */
        this.renderItem = (data, registerFn) => {
            if (this.props.isExtendedView) {
                return FSComponent.buildComponent(FixInfo, { onRegister: registerFn, onUpperKnobInc: this.onUpperKnobLeg, onClr: this.onClrLeg, data: data, isExtended: true });
            }
            else {
                return FSComponent.buildComponent(FixInfo, { onRegister: registerFn, onUpperKnobInc: this.onUpperKnobLeg, onClr: this.onClrLeg, data: data });
            }
        };
    }
    /** @inheritdoc */
    onBeforeRender() {
        if (this.props.fms.getFlightPlan().getSegment(this.segmentIndex.get())) {
            this.segment = this.props.fms.getFlightPlan().getSegment(this.segmentIndex.get());
        }
        super.onBeforeRender();
        if (this.props.scrollContainer) {
            this.scrollController.registerScrollContainer(this.props.scrollContainer.instance);
        }
    }
    /**
     * Gets the ref to the list component for the section.
     * @returns list ref
     */
    getListRef() {
        return this.listRef;
    }
    /**
     * An event called when the dto button is pressed.
     * @returns True if the event was handled in this section.
     */
    onDirectTo() {
        try {
            if (this.hasSelection() && !this.isHeaderSelected() && this.segment !== undefined) {
                const canDirectTo = this.props.fms.canDirectTo(this.segmentIndex.get(), this.listRef.instance.getSelectedIndex());
                if (canDirectTo) {
                    const directToInputData = {
                        segmentIndex: this.segmentIndex.get(),
                        legIndex: this.listRef.instance.getSelectedIndex(),
                        icao: this.legs.get(this.listRef.instance.getSelectedIndex()).get().legDefinition.leg.fixIcao,
                    };
                    Fms.viewService.open('DirectTo', false).setInput(directToInputData);
                    return true;
                }
                else {
                    const selectedLeg = this.segment.legs[this.listRef.instance.getSelectedIndex()];
                    if (selectedLeg !== undefined) {
                        Fms.viewService.open('MessageDialog', true).setInput({ inputString: `Activate Leg to ${selectedLeg.name}?`, hasRejectButton: true }).onAccept.on((sender, accept) => {
                            if (accept) {
                                this.props.fms.activateLeg(this.segmentIndex.get(), this.listRef.instance.getSelectedIndex());
                            }
                        });
                    }
                    return true;
                }
            }
        }
        catch (error) {
            return false;
            // throw something?
        }
        return false;
    }
    /**
     * An event called when the menu button is pressed.
     * @returns True if the event was handled in this section.
     */
    onMenu() {
        if (this.hasSelection() && this.segment !== undefined) {
            const dialog = Fms.viewService.open(PageMenuDialog.name, true);
            const plan = this.props.fms.getFlightPlan();
            dialog.setMenuItems([
                {
                    id: 'activate-leg',
                    renderContent: () => FSComponent.buildComponent("span", null, "Activate Leg"),
                    isEnabled: !this.isHeaderSelected() && !this.isEmptyRowSelected(),
                    action: () => {
                        if (this.segment !== undefined) {
                            const selectedLegIndex = this.listRef.instance.getSelectedIndex();
                            const selectedLeg = this.segment.legs[selectedLegIndex];
                            if (selectedLeg !== undefined) {
                                Fms.viewService.open('MessageDialog', true).setInput({ inputString: `Activate Leg to ${selectedLeg.name}?`, hasRejectButton: true }).onAccept.on((sender, accept) => {
                                    if (accept) {
                                        this.props.fms.activateLeg(this.segmentIndex.get(), selectedLegIndex);
                                    }
                                });
                            }
                        }
                    }
                },
                {
                    id: 'load-airway',
                    renderContent: () => FSComponent.buildComponent("span", null, "Load Airway"),
                    isEnabled: this.canAirwayInsert(this.segmentIndex.get(), this.isEmptyRowSelected()),
                    action: () => {
                        const airwayInsertData = this.getAirwayInsertData(this.segmentIndex.get(), this.listRef.instance.getSelectedIndex(), this.isEmptyRowSelected());
                        Fms.viewService.open('SelectAirway', true).setInput(airwayInsertData);
                    }
                },
                {
                    id: 'collapse-airways',
                    renderContent: () => { var _a; return FSComponent.buildComponent("span", null, ((_a = this.props.detailsController) === null || _a === void 0 ? void 0 : _a.airwaysCollapsed) ? 'Expand Airways' : 'Collapse Airways'); },
                    isEnabled: true,
                    action: () => {
                        var _a;
                        (_a = this.props.detailsController) === null || _a === void 0 ? void 0 : _a.collapseAirways();
                    }
                },
                {
                    id: 'hold-waypoint', renderContent: () => FSComponent.buildComponent("span", null, "Hold At Waypoint"),
                    isEnabled: !this.isHeaderSelected() && !this.isEmptyRowSelected(),
                    action: () => {
                        Fms.viewService.open('HoldAt', true).setInput({ segmentIndex: this.segmentIndex.get(), legIndex: this.listRef.instance.getSelectedIndex() });
                    }
                },
                { id: 'hold-ppos', renderContent: () => FSComponent.buildComponent("span", null, "Hold At Present Position"), isEnabled: false },
                { id: 'create-atk', renderContent: () => FSComponent.buildComponent("span", null, "Create ATK Offset WPT"), isEnabled: false },
                {
                    id: 'delete-fpln', renderContent: () => FSComponent.buildComponent("span", null, "Delete Flight Plan"), isEnabled: true, action: () => {
                        this.props.fms.emptyPrimaryFlightPlan();
                    }
                },
                { id: 'store-fpln', renderContent: () => FSComponent.buildComponent("span", null, "Store Flight Plan"), isEnabled: false },
                {
                    id: 'invert-fpln', renderContent: () => FSComponent.buildComponent("span", null, "Invert Flight Plan"), isEnabled: true, action: () => {
                        this.props.fms.invertFlightplan();
                    }
                },
                { id: 'temp-comp', renderContent: () => FSComponent.buildComponent("span", null, "Temperature Compensation"), isEnabled: false },
                { id: 'usr-wpt', renderContent: () => FSComponent.buildComponent("span", null, "Create New User Waypoint"), isEnabled: false },
                {
                    id: 'remove-dep', renderContent: () => FSComponent.buildComponent("span", null, "Remove Departure"), isEnabled: plan.procedureDetails.departureIndex > -1, action: () => {
                        var _a;
                        const departure = (_a = this.props.facilities.originFacility) === null || _a === void 0 ? void 0 : _a.departures[plan.procedureDetails.departureIndex];
                        Fms.viewService.open('MessageDialog', true).setInput({ inputString: `Remove ${departure === null || departure === void 0 ? void 0 : departure.name} from flight plan?`, hasRejectButton: true }).onAccept.on((sender, accept) => {
                            if (accept) {
                                this.props.fms.removeDeparture();
                            }
                        });
                    }
                },
                {
                    id: 'remove-arr', renderContent: () => FSComponent.buildComponent("span", null, "Remove Arrival"), isEnabled: plan.procedureDetails.arrivalIndex > -1, action: () => {
                        var _a;
                        const arrival = (_a = this.props.facilities.arrivalFacility) === null || _a === void 0 ? void 0 : _a.arrivals[plan.procedureDetails.arrivalIndex];
                        Fms.viewService.open('MessageDialog', true).setInput({ inputString: `Remove ${arrival === null || arrival === void 0 ? void 0 : arrival.name} from flight plan?`, hasRejectButton: true }).onAccept.on((sender, accept) => {
                            if (accept) {
                                this.props.fms.removeArrival();
                            }
                        });
                    }
                },
                {
                    id: 'remove-app', renderContent: () => FSComponent.buildComponent("span", null, "Remove Approach"), isEnabled: this.isApproachLoaded(plan), action: () => {
                        Fms.viewService.open('MessageDialog', true).setInput({
                            renderContent: () => {
                                return (FSComponent.buildComponent("div", { style: 'display: inline-block;' },
                                    "Remove ",
                                    this.renderApproachName(plan),
                                    " from flight plan?"));
                            },
                            hasRejectButton: true
                        }).onAccept.on((sender, accept) => {
                            if (accept) {
                                this.props.fms.removeApproach();
                            }
                        });
                    }
                },
                { id: 'parallel-track', renderContent: () => FSComponent.buildComponent("span", null, "Parallel Track"), isEnabled: false },
                { id: 'closest-point', renderContent: () => FSComponent.buildComponent("span", null, "Closest Point Of FPL"), isEnabled: false }
            ]);
            return true;
        }
        return false;
    }
    // TODO Remove when all events converted
    /**
     * Checks if there is a highlighted element in this section
     * @protected
     * @returns A boolean indicating if an element is highlighted in this section.
     */
    hasSelection() {
        return this.isHeaderSelected() || this.listRef.instance.getSelectedIndex() > -1 || this.isEmptyRowSelected();
    }
    /**
     * Adds a leg to the flight plan display segment.
     * @param index The index to add at.
     * @param leg The leg to add.
     */
    addLeg(index, leg) {
        const currentLeg = this.legs.tryGet(index);
        if (currentLeg !== undefined && currentLeg.get().isActive) {
            currentLeg.apply({ isActive: false });
            leg.isActive = true;
        }
        this.legs.insert(Subject.create(leg), index);
        this.updateEmptyRowVisibility();
    }
    /**
     * Removes a leg from the flight plan display segment.
     * @param index The index to remove at.
     */
    removeLeg(index) {
        let currentLeg = this.legs.tryGet(index);
        const isActive = currentLeg !== undefined && currentLeg.get().isActive;
        this.legs.removeAt(index);
        currentLeg = this.legs.tryGet(index);
        if (currentLeg !== undefined && isActive) {
            currentLeg.apply({ isActive });
        }
        this.updateEmptyRowVisibility();
    }
    /**
     * Refreshes this section's header.
     */
    updateHeader() {
        this.headerRef.instance.update();
    }
    /**
     * Updates the visibility of this section's empty row.
     */
    updateEmptyRowVisibility() {
        const emptyRow = this.emptyRowRef.getOrDefault();
        if (emptyRow !== null) {
            emptyRow.setIsVisible(this.getEmptyRowVisbility());
        }
    }
    /**
     * A callback which responds to changes in the active flight plan leg.
     * @param activeSegmentIndex The index of the active leg segment.
     * @param activeLegIndex The index of the active leg in its segment.
     */
    onActiveLegChanged(activeSegmentIndex, activeLegIndex) {
        var _a;
        this.updateLegInfoVisibility(activeSegmentIndex, activeLegIndex);
        // Refresh flight plan focus if the header or empty row is focused
        if (this.headerRef.instance.getIsFocused()) {
            this.onHeaderFocused();
        }
        else if ((_a = this.emptyRowRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.getIsFocused()) {
            this.onEmptyRowFocused();
        }
    }
    /**
     * Updates this section's leg information visibility based on the current active flight plan leg.
     * @param activeSegmentIndex The index of the active leg segment.
     * @param activeLegIndex The index of the active leg in its segment.
     */
    updateLegInfoVisibility(activeSegmentIndex, activeLegIndex) {
        for (let l = 0; l < this.legs.length; l++) {
            const leg = this.legs.tryGet(l);
            if (leg) {
                if (this.segmentIndex.get() < activeSegmentIndex || (this.segmentIndex.get() === activeSegmentIndex && l < activeLegIndex)) {
                    leg.apply({ legIsBehind: true });
                }
                else if (leg.get().legIsBehind) {
                    leg.apply({ legIsBehind: false });
                }
                leg.notify();
            }
        }
    }
    /**
     * Sets the active leg in the flight plan display segment.
     * @param index The index of the leg to set as active.
     */
    setActiveLeg(index) {
        const legInfo = this.legs.tryGet(index);
        if (legInfo !== undefined) {
            legInfo.apply({ isActive: true });
        }
        // Set flight plan focus
        if (legInfo && this.listRef.instance.getSelectedItem() === legInfo && this.props.onFlightPlanFocusSelected) {
            this.props.onFlightPlanFocusSelected(this.getFlightPlanFocusFromLeg(legInfo.get().legDefinition));
        }
    }
    /**
     * Cancels an active leg display in the flight plan display segment.
     * @param index The index of the leg to set as inactive.
     */
    cancelActiveLeg(index) {
        const leg = this.legs.tryGet(index);
        if (leg !== undefined && leg.get().isActive) {
            leg.apply({ isActive: false });
        }
    }
    /**
     * Cancels all active leg displays in section.
     */
    cancelAllActiveLegs() {
        for (let i = 0; i < this.legs.length; i++) {
            const leg = this.legs.tryGet(i);
            if (leg !== undefined && leg.get().isActive) {
                leg.apply({ isActive: false });
            }
        }
    }
    /**
     * Returns the index of the active leg in this section.
     * @returns the index of the active lege, otherwise -1
     */
    getActiveLegIndex() {
        return this.legs.getArray().findIndex(leg => leg.get().isActive);
    }
    /**
     * Scrolls to the active leg.
     */
    scrollToActiveLeg() {
        this.scrollController.gotoIndex(1);
        this.listRef.instance.scrollToIndex(this.getActiveLegIndex());
    }
    /**
     * Ensures the active leg is in view.
     */
    ensureActiveLegInView() {
        this.listRef.instance.ensureIndexInView(this.getActiveLegIndex());
    }
    /**
     * Updates a given leg's row from the leg's current calculations.
     * @param index The index of the leg.
     */
    updateFromLegCalculations(index) {
        var _a;
        const leg = this.legs.tryGet(index);
        if (leg !== undefined) {
            if (((_a = this.segment) === null || _a === void 0 ? void 0 : _a.airway) && index === this.legs.length - 1) {
                leg.apply({ airwayDistance: this.props.fms.getAirwayDistance(this.segment.segmentIndex) });
            }
            else {
                leg.notify();
            }
        }
    }
    /**
     * Sets the leg altitude for a given leg.
     * @param index The index of the leg.
     * @param vnavLeg The vnav leg data.
     * @param revisedAltitude The optional replacement display altitude.
     */
    setLegAltitude(index, vnavLeg, revisedAltitude) {
        const leg = this.legs.tryGet(index);
        if (leg !== undefined) {
            leg.apply({ targetAltitude: revisedAltitude ? revisedAltitude : vnavLeg.altitude, isAdvisory: vnavLeg.isAdvisory });
        }
    }
    /**
     * Gets the number of legs in this section.
     * @returns the number of legs in this section.
     */
    getLegsLength() {
        if (this.legs) {
            return this.legs.length;
        }
        else {
            return 0;
        }
    }
    /**
     * Creates the SelectAirwayInputData when insert airway is selected.
     * @param segmentIndex The index of the segment.
     * @param selectedIndex The selected item index.
     * @param emptyRowSelected Whether the empty row is selected.
     * @returns the SelectAirwayInputData object
     */
    getAirwayInsertData(segmentIndex, selectedIndex, emptyRowSelected) {
        const plan = this.props.fms.getFlightPlan();
        if (emptyRowSelected) {
            const segment = plan.getSegment(segmentIndex);
            if (segment.legs && segment.legs.length < 1) {
                const previousSegment = plan.getSegment(segmentIndex - 1);
                const previousSegmentLastLeg = previousSegment.legs.length - 1;
                return { segmentIndex: segmentIndex - 1, legIndex: previousSegmentLastLeg };
            }
            else {
                const segmentLastLeg = segment.legs.length - 1;
                return { segmentIndex: segmentIndex, legIndex: segmentLastLeg };
            }
        }
        else if (selectedIndex === 0 && segmentIndex > 0) {
            const previousSegment = plan.getSegment(segmentIndex - 1);
            const previousSegmentLastLeg = previousSegment.legs.length - 1;
            return { segmentIndex: segmentIndex - 1, legIndex: previousSegmentLastLeg };
        }
        return { segmentIndex: segmentIndex, legIndex: selectedIndex - 1 };
    }
    /**
     * Checks whether an airway can be inserted from this selected index.
     * @param segmentIndex The index of the segment.
     * @param isEmptyRowSelected If an empty row is selected.
     * @returns the SelectAirwayInputData object
     */
    canAirwayInsert(segmentIndex, isEmptyRowSelected) {
        if (this.isHeaderSelected()) {
            return false;
        }
        const plan = this.props.fms.getFlightPlan();
        if (plan.getSegment(segmentIndex).segmentType !== FlightPlanSegmentType.Enroute) {
            return false;
        }
        if (isEmptyRowSelected) {
            const segment = plan.getSegment(segmentIndex);
            if (segment.legs.length > 0) {
                return true;
            }
        }
        const lastSegment = plan.getSegment(segmentIndex - 1);
        if (lastSegment.legs.length < 1 || lastSegment.legs[lastSegment.legs.length - 1].leg.fixIcao[0] === ' ') {
            return false;
        }
        return true;
    }
    /**
     * Checks if an approach is loaded.
     * @param plan The Flight Plan.
     * @returns A boolean indicating if an approach is loaded.
     */
    isApproachLoaded(plan) {
        if (plan.procedureDetails.approachIndex > -1) {
            return true;
        }
        if (plan.getUserData('visual_approach') && plan.destinationAirport) {
            return true;
        }
        return false;
    }
    /**
     * Gets the loaded approach name.
     * @param plan The Flight Plan.
     * @returns The approach name as a string.
     */
    renderApproachName(plan) {
        const approach = this.props.facilities.destinationFacility ? FmsUtils.getApproachFromPlan(plan, this.props.facilities.destinationFacility) : undefined;
        return (FSComponent.buildComponent(ApproachNameDisplay, { approach: Subject.create(approach !== null && approach !== void 0 ? approach : null) }));
    }
    // TODO remove when all events converted
    /**
     * Checks if the header of this section is selected.
     * @protected
     * @returns A boolean indicating if the header is selected.
     */
    isHeaderSelected() {
        var _a, _b;
        return (_b = (_a = this.headerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.getIsFocused()) !== null && _b !== void 0 ? _b : false;
    }
    // TODO remove when all events converted
    /**
     * Checks if the empty row of this section is selected.
     * @protected
     * @returns A boolean indicating if the empty row is selected.
     */
    isEmptyRowSelected() {
        var _a, _b;
        return (_b = (_a = this.emptyRowRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.getIsFocused()) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * A callback which is called when a leg selection changes.
     * @param item The selected item.
     */
    onLegItemSelected(item) {
        // If selection is null because this section has no existing legs, force focus the empty leg row if it exists.
        if (this.emptyRowRef.getOrDefault() && !item && this.listRef.instance.getIsFocused() && this.legs.length === 0) {
            this.scrollController.gotoIndex(2);
        }
        // Notify flight plan element selection
        if (item && this.props.onFlightPlanElementSelected) {
            this.props.onFlightPlanElementSelected(item.get().legDefinition);
        }
        // Notify flight plan focus
        if (item && this.props.onFlightPlanFocusSelected) {
            this.props.onFlightPlanFocusSelected(this.getFlightPlanFocusFromLeg(item.get().legDefinition));
        }
    }
    /**
     * Gets a flight plan focus from a selected flight plan leg.
     * @param leg The selected flight plan leg.
     * @returns The flight plan focus given the selected leg.
     */
    getFlightPlanFocusFromLeg(leg) {
        const plan = this.props.fms.getFlightPlan();
        if (plan.directToData.segmentIndex >= 0) {
            const dtoSegment = plan.getSegment(plan.directToData.segmentIndex);
            // If the DTO target leg is selected and the DTO is active, focus on the DTO leg instead to show the DTO path.
            if (dtoSegment.legs[plan.directToData.segmentLegIndex] === leg && dtoSegment.offset + plan.directToData.segmentLegIndex + 3 === plan.activeLateralLeg) {
                leg = dtoSegment.legs[plan.directToData.segmentLegIndex + 3];
            }
        }
        return [leg];
    }
    /**
     * A callback which is called when this section's header is focused.
     */
    onHeaderFocused() {
        var _a;
        this.props.onFlightPlanElementSelected && this.props.onFlightPlanElementSelected((_a = this.segment) !== null && _a !== void 0 ? _a : null);
    }
    /**
     * A callback which is called when this section's empty row is focused.
     */
    onEmptyRowFocused() {
        this.props.onFlightPlanElementSelected && this.props.onFlightPlanElementSelected(null);
        this.props.onFlightPlanFocusSelected && this.props.onFlightPlanFocusSelected(this.getFlightPlanFocusWhenEmpty());
    }
    /**
     * Gets a flight plan focus when empty.
     * @returns A flight plan focus.
     */
    getFlightPlanFocusWhenEmpty() {
        var _a;
        if (!this.segment) {
            return [];
        }
        // Try to focus on the leg immediately after where the empty leg row would insert a leg into the plan.
        // If such a leg does not exist, try to focus on the leg immediately before that position.
        const flightPlan = this.props.fms.getFlightPlan();
        const legToFocus = (_a = flightPlan.getNextLeg(this.segment.segmentIndex, this.segment.legs.length - 1)) !== null && _a !== void 0 ? _a : flightPlan.getPrevLeg(this.segment.segmentIndex, this.segment.legs.length);
        return legToFocus ? [legToFocus] : null;
    }
}

/**
 * Render the approach phase of a flight plan.
 */
class FPLApproach extends FPLSection {
    constructor() {
        super(...arguments);
        /**
         * Callback for when CLR is pressed on the header.
         * @returns true if event was handled, false otherwise.
         */
        this.onClrHeader = () => {
            const plan = this.props.fms.getPrimaryFlightPlan();
            const airport = this.props.facilities.destinationFacility;
            const approach = airport ? FmsUtils.getApproachFromPlan(plan, airport) : undefined;
            if (approach) {
                Fms.viewService.open('MessageDialog', true).setInput({
                    renderContent: () => {
                        return (FSComponent.buildComponent("div", { style: 'display: inline-block;' },
                            "Remove ",
                            FSComponent.buildComponent(ApproachNameDisplay, { approach: Subject.create(approach) }),
                            " from flight plan?"));
                    },
                    hasRejectButton: true
                })
                    .onAccept.on((sender, accept) => {
                    if (accept) {
                        this.props.fms.removeApproach();
                        return true;
                    }
                });
            }
            return false;
        };
    }
    /** @inheritdoc */
    getEmptyRowVisbility() {
        return false;
    }
    /** @inheritdoc */
    onHeaderFocused() {
        var _a;
        super.onHeaderFocused();
        const focus = ((_a = this.segment) === null || _a === void 0 ? void 0 : _a.legs.length) ? this.segment.legs : this.getFlightPlanFocusWhenEmpty();
        this.props.onFlightPlanFocusSelected && this.props.onFlightPlanFocusSelected(focus);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    collapseLegs(setHidden) {
        //noop
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { id: 'fpln-approach' },
            FSComponent.buildComponent(FPLHeaderApproach, { ref: this.headerRef, onRegister: this.register, onClr: this.onClrHeader, fms: this.props.fms, facilities: this.props.facilities, onFocused: this.onHeaderFocused.bind(this) }),
            FSComponent.buildComponent(List, { ref: this.listRef, onRegister: this.register, data: this.legs, renderItem: this.renderItem, onItemSelected: this.onLegItemSelected.bind(this), scrollContainer: this.props.scrollContainer })));
    }
}

/**
 * An FPL section header which displays simple strings.
 */
class FPLStringHeader extends FPLHeader {
    constructor() {
        super(...arguments);
        this.textSub = Subject.create('');
        this.textLengthSub = this.textSub.map(text => text.length);
    }
    /** @inheritdoc */
    onAfterRender() {
        super.onAfterRender();
        this.textLengthSub.sub(length => this.setEstimatedNameWidth(length * FPLStringHeader.ESTIMATED_CHAR_WIDTH));
    }
    /** @inheritdoc */
    renderName() {
        return (FSComponent.buildComponent("span", null, this.textSub));
    }
}
FPLStringHeader.ESTIMATED_CHAR_WIDTH = 13.2;

/**
 * An FPL section header for arrivals.
 */
class FPLHeaderArrival extends FPLStringHeader {
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setCollapsed(setCollapsed) {
        //noop
    }
    /** @inheritdoc */
    updateName() {
        var _a;
        let name;
        const plan = this.props.fms.getPrimaryFlightPlan();
        const arrival = (_a = this.props.facilities.arrivalFacility) === null || _a === void 0 ? void 0 : _a.arrivals[plan.procedureDetails.arrivalIndex];
        if (arrival) {
            name = FmsUtils.getArrivalNameAsString(
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.props.facilities.arrivalFacility, arrival, plan.procedureDetails.arrivalTransitionIndex, plan.procedureDetails.destinationRunway);
        }
        else {
            name = '';
        }
        this.textSub.set(name);
    }
}

/**
 * Render the arrival phase of a flight plan.
 */
class FPLArrival extends FPLSection {
    constructor() {
        super(...arguments);
        /**
         * Callback for when CLR is pressed on the header.
         * @returns true if event was handled, false otherwise.
         */
        this.onClrHeader = () => {
            const plan = this.props.fms.getPrimaryFlightPlan();
            const airport = this.props.facilities.arrivalFacility;
            const arrival = airport === null || airport === void 0 ? void 0 : airport.arrivals[plan.procedureDetails.arrivalIndex];
            if (arrival) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const name = FmsUtils.getArrivalNameAsString(airport, arrival, plan.procedureDetails.arrivalTransitionIndex, plan.procedureDetails.destinationRunway);
                Fms.viewService.open('MessageDialog', true).setInput({ inputString: `Remove ${name} from flight plan?`, hasRejectButton: true })
                    .onAccept.on((sender, accept) => {
                    if (accept) {
                        this.props.fms.removeArrival();
                        return true;
                    }
                });
            }
            return false;
        };
    }
    /** @inheritdoc */
    getEmptyRowVisbility() {
        return false;
    }
    /** @inheritdoc */
    onHeaderFocused() {
        var _a;
        super.onHeaderFocused();
        const focus = ((_a = this.segment) === null || _a === void 0 ? void 0 : _a.legs.length) ? this.segment.legs : this.getFlightPlanFocusWhenEmpty();
        this.props.onFlightPlanFocusSelected && this.props.onFlightPlanFocusSelected(focus);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    collapseLegs(setHidden) {
        //noop
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { id: 'fpln-arrival' },
            FSComponent.buildComponent(FPLHeaderArrival, { ref: this.headerRef, onRegister: this.register, onClr: this.onClrHeader, fms: this.props.fms, facilities: this.props.facilities, onFocused: this.onHeaderFocused.bind(this) }),
            FSComponent.buildComponent(List, { ref: this.listRef, onRegister: this.register, data: this.legs, renderItem: this.renderItem, onItemSelected: this.onLegItemSelected.bind(this), scrollContainer: this.props.scrollContainer })));
    }
}

/** The FPLEmptyRow component. */
class FPLEmptyRow extends UiControl {
    constructor() {
        super(...arguments);
        this.nameContainerRef = FSComponent.createRef();
    }
    /** @inheritdoc */
    getHighlightElement() {
        return this.nameContainerRef.instance;
    }
    /** @inheritdoc */
    renderControl() {
        return (FSComponent.buildComponent("div", { class: 'fix-container' },
            FSComponent.buildComponent("div", { class: 'fix-name', ref: this.nameContainerRef },
                FSComponent.buildComponent("span", { style: 'padding-right:5em' }, "______"))));
    }
}

/**
 * An FPL section header for departures.
 */
class FPLHeaderDeparture extends FPLStringHeader {
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setCollapsed(setCollapsed) {
        //noop
    }
    /** @inheritdoc */
    updateName() {
        var _a;
        let name;
        const plan = this.props.fms.getPrimaryFlightPlan();
        const origin = plan.originAirport;
        const hasRunway = plan.procedureDetails.originRunway != undefined;
        const departure = (_a = this.props.facilities.originFacility) === null || _a === void 0 ? void 0 : _a.departures[plan.procedureDetails.departureIndex];
        if (departure && origin !== undefined) {
            name = FmsUtils.getDepartureNameAsString(
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.props.facilities.originFacility, departure, plan.procedureDetails.departureTransitionIndex, plan.procedureDetails.originRunway);
        }
        else if (origin !== undefined && origin != '' && !hasRunway) {
            name = 'Origin – RW _ _';
        }
        else if (origin && origin !== undefined && hasRunway) {
            name = 'Origin – ' + ICAO.getIdent(origin);
        }
        else {
            name = 'Origin – _ _ _ _';
        }
        this.textSub.set(name);
    }
}

/**
 * Render the departure phase of the flight plan.
 */
class FPLDeparture extends FPLSection {
    constructor() {
        super(...arguments);
        /** @inheritdoc */
        this.onUpperKnobLeg = (node) => {
            const legIndex = this.listRef.instance.getListItemIndex(node);
            const plan = this.props.fms.getFlightPlan();
            const origin = plan.originAirport;
            if (origin && legIndex === 0) {
                Fms.viewService.open('SetRunway', true).setInput(this.props.facilities.originFacility)
                    .onAccept.on((sender, data) => {
                    this.props.fms.setOrigin(this.props.facilities.originFacility, data);
                });
            }
            else {
                this.onUpperKnobLegBase(node);
            }
        };
        /** Callback firing when upper knob event on the header is fired. */
        this.onUpperKnobEmptyRow = () => {
            const plan = this.props.fms.getFlightPlan();
            const origin = plan.originAirport;
            if (!origin || origin === undefined) {
                Fms.viewService.open('WptInfo', true)
                    .onAccept.on((sender, fac) => {
                    // check if its airportfacility interface
                    if ('bestApproach' in fac) {
                        this.props.fms.setOrigin(fac);
                        Fms.viewService.open('SetRunway', true).setInput(fac)
                            .onAccept.on((subSender, data) => {
                            this.props.fms.setOrigin(this.props.facilities.originFacility, data);
                        });
                    }
                    else {
                        const firstEnrSegment = this.props.fms.getFlightPlan().segmentsOfType(FlightPlanSegmentType.Enroute).next().value;
                        if (firstEnrSegment) {
                            this.props.fms.insertWaypoint(firstEnrSegment.segmentIndex, fac, 0);
                        }
                    }
                });
            }
        };
        /**
         * Callback firing when CLR on the header is pressed.
         * @returns true if CLR is handeled, false if not.
         */
        this.onClrHeader = () => {
            const plan = this.props.fms.getPrimaryFlightPlan();
            const airport = this.props.facilities.originFacility;
            const departure = airport === null || airport === void 0 ? void 0 : airport.departures[plan.procedureDetails.departureIndex];
            if (departure) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const name = FmsUtils.getDepartureNameAsString(airport, departure, plan.procedureDetails.departureTransitionIndex, plan.procedureDetails.originRunway);
                Fms.viewService.open('MessageDialog', true).setInput({ inputString: `Remove ${name} from flight plan?`, hasRejectButton: true })
                    .onAccept.on((sender, accept) => {
                    if (accept) {
                        this.props.fms.removeDeparture();
                        return true;
                    }
                });
            }
            return false;
        };
        /** @inheritdoc */
        this.onClrLeg = (node) => {
            const legIndex = this.listRef.instance.getListItemIndex(node);
            const plan = this.props.fms.getFlightPlan();
            const origin = plan.originAirport;
            if (origin && legIndex == 0) {
                Fms.viewService.open('MessageDialog', true).setInput({ inputString: `Remove ${ICAO.getIdent(origin)}?`, hasRejectButton: true })
                    .onAccept.on((sender, accept) => {
                    if (accept) {
                        this.props.fms.setOrigin(undefined);
                        return true;
                    }
                });
            }
            else {
                return this.onClrLegBase(node);
            }
            return false;
        };
    }
    /** @inheritdoc */
    getEmptyRowVisbility() {
        const plan = this.props.fms.getFlightPlan(0);
        const origin = plan.originAirport;
        const hasRunway = plan.procedureDetails.originRunway != undefined;
        return !hasRunway && (!origin || origin == '');
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    collapseLegs(setHidden) {
        //noop
    }
    /** @inheritdoc */
    onHeaderFocused() {
        var _a;
        super.onHeaderFocused();
        let focus;
        if (this.segment && this.segment.segmentType === FlightPlanSegmentType.Departure) {
            focus = ((_a = this.segment) === null || _a === void 0 ? void 0 : _a.legs.length) ? this.segment.legs : this.getFlightPlanFocusWhenEmpty();
        }
        else {
            // Only an origin airport exists.
            const origin = this.props.facilities.originFacility;
            focus = origin !== null && origin !== void 0 ? origin : this.getFlightPlanFocusWhenEmpty();
        }
        this.props.onFlightPlanFocusSelected && this.props.onFlightPlanFocusSelected(focus);
    }
    /**
     * Render the departure section.
     * @returns A VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { id: 'fpln-departure' },
            FSComponent.buildComponent(FPLHeaderDeparture, { ref: this.headerRef, onRegister: this.register, facilities: this.props.facilities, fms: this.props.fms, onClr: this.onClrHeader, onFocused: this.onHeaderFocused.bind(this) }),
            FSComponent.buildComponent(List, { ref: this.listRef, onRegister: this.register, data: this.legs, renderItem: this.renderItem, onItemSelected: this.onLegItemSelected.bind(this), scrollContainer: this.props.scrollContainer }),
            FSComponent.buildComponent(FPLEmptyRow, { onRegister: this.register, ref: this.emptyRowRef, onUpperKnobInc: this.onUpperKnobEmptyRow, onFocused: this.onEmptyRowFocused.bind(this) })));
    }
}

/**
 * An FPL section header for destination segments.
 */
class FPLHeaderDestination extends FPLStringHeader {
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setCollapsed(setCollapsed) {
        //noop
    }
    /** @inheritdoc */
    updateName() {
        let name;
        const plan = this.props.fms.getFlightPlan();
        const destination = plan.destinationAirport;
        const hasRunway = plan.procedureDetails.destinationRunway != undefined;
        if (destination && destination !== undefined && (plan.procedureDetails.arrivalIndex > -1 || plan.procedureDetails.approachIndex > -1)) {
            name = 'Destination – ' + ICAO.getIdent(destination);
        }
        else if (destination && destination !== undefined && !hasRunway) {
            name = 'Destination – RW _ _';
        }
        else if (destination && destination !== undefined && hasRunway) {
            name = 'Destination – ' + ICAO.getIdent(destination);
        }
        else {
            name = 'Destination – _ _ _ _';
        }
        this.textSub.set(name);
    }
}

/**
 * Render the destination info for a flight plan.
 */
class FPLDestination extends FPLSection {
    constructor() {
        super(...arguments);
        /** @inheritdoc */
        this.onUpperKnobLegBase = (node) => {
            const legIndex = this.listRef.instance.getListItemIndex(node);
            const plan = this.props.fms.getFlightPlan();
            const destination = plan.destinationAirport;
            if (destination && legIndex == 0) {
                Fms.viewService.open('SetRunway', true).setInput(this.props.facilities.destinationFacility)
                    .onAccept.on((subSender, data) => {
                    this.props.fms.setDestination(this.props.facilities.destinationFacility, data);
                });
            }
        };
        /** Callback firing when upper knob event on the header is fired. */
        this.onUpperKnobEmptyRow = () => {
            const plan = this.props.fms.getFlightPlan();
            const destination = plan.destinationAirport;
            if (!destination || destination === undefined) {
                // EMPTY ROW
                Fms.viewService.open('WptInfo', true)
                    .onAccept.on((sender, fac) => {
                    this.props.fms.setDestination(fac);
                    Fms.viewService.open('SetRunway', true).setInput(fac).onAccept.on((subSender, data) => {
                        this.props.fms.setDestination(this.props.facilities.destinationFacility, data);
                    });
                });
            }
        };
        /** @inheritdoc */
        this.onClrLeg = (node) => {
            const legIndex = this.listRef.instance.getListItemIndex(node);
            const plan = this.props.fms.getFlightPlan();
            const destination = plan.destinationAirport;
            if (destination && legIndex == 0) {
                Fms.viewService.open('MessageDialog', true).setInput({ inputString: `Remove ${ICAO.getIdent(destination)}?`, hasRejectButton: true }).onAccept.on((sender, accept) => {
                    if (accept) {
                        this.props.fms.setDestination(undefined);
                        return true;
                    }
                });
            }
            else {
                return this.onClrLegBase(node);
            }
            return false;
        };
    }
    /** @inheritdoc */
    getEmptyRowVisbility() {
        const plan = this.props.fms.getFlightPlan();
        const destination = plan.destinationAirport;
        const hasRunway = plan.procedureDetails.destinationRunway != undefined;
        const noAppArr = plan.procedureDetails.arrivalIndex < 0 && plan.procedureDetails.approachIndex < 0;
        return noAppArr && !hasRunway && (!destination || destination == '');
    }
    /** @inheritdoc */
    onHeaderFocused() {
        super.onHeaderFocused();
        const destination = this.props.facilities.destinationFacility;
        const focus = destination !== null && destination !== void 0 ? destination : this.getFlightPlanFocusWhenEmpty();
        this.props.onFlightPlanFocusSelected && this.props.onFlightPlanFocusSelected(focus);
    }
    /** @inheritdoc */
    collapseLegs() {
        //noop
    }
    /**
     * Render a destination line.
     * @returns a VNode
     */
    render() {
        return (FSComponent.buildComponent("div", { id: 'fpln-destination' },
            FSComponent.buildComponent(FPLHeaderDestination, { ref: this.headerRef, onRegister: this.register, fms: this.props.fms, facilities: this.props.facilities, onFocused: this.onHeaderFocused.bind(this) }),
            FSComponent.buildComponent(List, { ref: this.listRef, onRegister: this.register, data: this.legs, renderItem: this.renderItem, onItemSelected: this.onLegItemSelected.bind(this), scrollContainer: this.props.scrollContainer }),
            FSComponent.buildComponent(FPLEmptyRow, { onRegister: this.register, ref: this.emptyRowRef, onUpperKnobInc: this.onUpperKnobEmptyRow, onFocused: this.onEmptyRowFocused.bind(this) })));
    }
}

/**
 * An FPL section header for enroute segments.
 */
class FPLHeaderEnroute extends FPLStringHeader {
    /** @inheritdoc */
    setCollapsed(setCollapsed) {
        this._isCollapsed = setCollapsed;
        this.updateName();
    }
    /** @inheritdoc */
    updateName() {
        var _a;
        const segment = this.props.fms.getFlightPlan().getSegment((_a = this.props.segmentIndex) === null || _a === void 0 ? void 0 : _a.get());
        this.setIsVisible(segment.airway !== undefined || this.props.fms.isFirstEnrouteSegment(segment.segmentIndex));
        let name = '';
        if (segment !== undefined) {
            if (segment.airway !== undefined) {
                name = 'Airway - ' + segment.airway;
            }
            else {
                name = 'Enroute';
            }
            if (this.isCollapsed) {
                name += ' (collapsed)';
            }
        }
        this.textSub.set(name);
    }
}

/** Render the enroute phase of the flight plan. */
class FPLEnroute extends FPLSection {
    constructor() {
        super(...arguments);
        this.isCollapsed = false;
        /**
         * Callback firing when CLR on the header is pressed.
         * @returns true if CLR is handeled, false if not.
         */
        this.onClrHeader = () => {
            if (this.segment !== undefined && this.segment.airway !== undefined) {
                Fms.viewService.open('MessageDialog', true).setInput({ inputString: `Remove ${this.segment.airway} from flight plan?`, hasRejectButton: true })
                    .onAccept.on((sender, accept) => {
                    if (accept) {
                        this.props.fms.removeAirway(this.segmentIndex.get());
                        return true;
                    }
                });
            }
            return false;
        };
    }
    /** @inheritdoc */
    getEmptyRowVisbility() {
        var _a;
        let showEmptyRow = true;
        const plan = this.props.fms.getFlightPlan();
        const segmentIndex = this.segmentIndex.get();
        if (((_a = this.segment) === null || _a === void 0 ? void 0 : _a.airway) !== undefined) {
            showEmptyRow = false;
        }
        else if (segmentIndex + 1 < plan.segmentCount && plan.getSegment(segmentIndex + 1).airway !== undefined) {
            showEmptyRow = false;
        }
        return showEmptyRow;
    }
    /**
     * Adds a leg to the flight plan display segment.
     * @param index The index to add at.
     * @param leg The leg to add.
     */
    addLeg(index, leg) {
        super.addLeg(index, leg);
        this.updateHeader();
        this.updateAirwayLegs();
    }
    /**
     * Removes a leg from the flight plan display segment.
     * @param index The index to remove at.
     */
    removeLeg(index) {
        super.removeLeg(index);
        this.updateHeader();
        this.updateAirwayLegs();
    }
    /**
     * Updates this section's airway legs.
     */
    updateAirwayLegs() {
        var _a, _b;
        if (((_a = this.segment) === null || _a === void 0 ? void 0 : _a.airway) === undefined) {
            return;
        }
        for (let l = 0; l < this.legs.length; l++) {
            const leg = this.legs.tryGet(l);
            if (leg) {
                const info = { isAirwayFix: true };
                leg.apply({ isAirwayFix: true });
                if (leg.get().legDefinition.name == ((_b = this.segment) === null || _b === void 0 ? void 0 : _b.airway.split('.')[1])) {
                    info.isAirwayExitFix = true;
                }
                leg.apply(info);
            }
        }
    }
    /**
     * Method called to collapse or uncollapse this section.
     * @param setCollapsed is whether to set the legs hidden or not
     */
    collapseLegs(setCollapsed) {
        for (let i = 0; i < this.legs.getArray().length; i++) {
            const leg = this.legs.tryGet(i);
            if (leg !== undefined) {
                leg.apply({ isCollapsed: setCollapsed });
            }
        }
        this.isCollapsed = setCollapsed;
        this.headerRef.instance.setCollapsed(setCollapsed);
    }
    /** @inheritdoc */
    onHeaderFocused() {
        var _a, _b, _c;
        super.onHeaderFocused();
        let focus = null;
        if (((_a = this.segment) === null || _a === void 0 ? void 0 : _a.airway) === undefined) {
            const plan = this.props.fms.getFlightPlan();
            for (const segment of plan.segmentsOfType(FlightPlanSegmentType.Enroute)) {
                if (segment.legs.length > 0) {
                    (focus !== null && focus !== void 0 ? focus : (focus = [])).push(...segment.legs);
                }
            }
        }
        else {
            focus = (_c = (_b = this.segment) === null || _b === void 0 ? void 0 : _b.legs) !== null && _c !== void 0 ? _c : null;
        }
        this.props.onFlightPlanFocusSelected && this.props.onFlightPlanFocusSelected(focus);
    }
    /**
     * Render an enroute container.
     * @returns a VNode
     */
    render() {
        return (FSComponent.buildComponent("div", { id: 'fpln-enroute' },
            FSComponent.buildComponent(FPLHeaderEnroute, { ref: this.headerRef, onRegister: this.register, facilities: this.props.facilities, fms: this.props.fms, onClr: this.onClrHeader, segmentIndex: this.segmentIndex, onFocused: this.onHeaderFocused.bind(this) }),
            FSComponent.buildComponent(List, { ref: this.listRef, onRegister: this.register, data: this.legs, renderItem: this.renderItem, onItemSelected: this.onLegItemSelected.bind(this), scrollContainer: this.props.scrollContainer }),
            FSComponent.buildComponent(FPLEmptyRow, { onRegister: this.register, ref: this.emptyRowRef, onUpperKnobInc: this.onUpperKnobLegBase, onFocused: this.onEmptyRowFocused.bind(this) })));
    }
}

/**
 * Represent the origin segment of a flight plan listing.
 */
class FPLOrigin extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.origin = Subject.create('_____');
        this.destination = Subject.create('_____');
        this.fplDirectTo = FSComponent.createRef();
        this.origDestRef = FSComponent.createRef();
    }
    /**
     * Handles a origin/dest change event.
     * @param e The change event itself.
     */
    onOriginDestChanged(e) {
        switch (e.type) {
            case OriginDestChangeType.OriginAdded:
                e.airport && this.origin.set(ICAO.getIdent(e.airport) + ' /');
                break;
            case OriginDestChangeType.OriginRemoved:
                this.origin.set('_____ /');
                break;
            case OriginDestChangeType.DestinationAdded:
                e.airport && this.destination.set(ICAO.getIdent(e.airport));
                break;
            case OriginDestChangeType.DestinationRemoved:
                this.destination.set('_____');
                break;
        }
    }
    /**
     * Handles when a random direct to is active and the FPL header should indicate such.
     * @param dtoIdent The ident for the direct to waypoint.
     */
    onDirectToRandomActive(dtoIdent) {
        this.origin.set('');
        this.destination.set(dtoIdent);
        this.fplDirectTo.instance.style.display = '';
        this.origDestRef.instance.style.color = 'white';
    }
    /**
     * Handles when a random direct to is canceled.
     * @param plan is the Flightplan
     */
    removeDirectToRandom(plan) {
        this.fplDirectTo.instance.style.display = 'none';
        this.origDestRef.instance.style.color = 'cyan';
        const origin = plan.originAirport;
        if (origin !== undefined) {
            this.setOrigin(ICAO.getIdent(origin));
        }
        else {
            this.setOrigin('_____');
        }
        const destination = plan.destinationAirport;
        if (destination !== undefined) {
            this.setDestination(ICAO.getIdent(destination));
        }
        else {
            this.setDestination('_____');
        }
    }
    /**
     * Handles setting the origin string.
     * @param origin The ident for the origin.
     */
    setOrigin(origin) {
        this.origin.set(origin + ' /');
    }
    /**
     * Handles setting the destination string.
     * @param destination The ident for the origin.
     */
    setDestination(destination) {
        this.destination.set(destination);
    }
    /**
     * Initializes the Direct To symbol to hidden
     */
    onAfterRender() {
        this.fplDirectTo.instance.style.display = 'none';
    }
    /**
     * Render an origin block.
     * @returns a VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { id: "origDest", ref: this.origDestRef },
            FSComponent.buildComponent("span", null, this.origin),
            FSComponent.buildComponent("span", null, this.destination),
            FSComponent.buildComponent("div", { class: "fpl-directTo", ref: this.fplDirectTo },
                FSComponent.buildComponent("svg", null,
                    FSComponent.buildComponent("path", { d: 'm 27 13 l -7.2 -7.2 l 0 5.04 l -19.04 0 l 0 4.32 l 19.04 0 l 0 5.04 l 7.2 -7.2 z', fill: "magenta", scale: "1" }),
                    FSComponent.buildComponent("text", { x: "4", y: "20", fill: "magenta", size: "12" }, "D")))));
    }
}

/// <reference types="msfstypes/JS/Avionics" />
/**
 * FPLDetails holds the core logic of the flight plan display and interacts with button events.
 */
class FPLDetails extends DisplayComponent {
    /**
     * Constructor
     * @param props the props
     */
    constructor(props) {
        super(props);
        this.isExtendedView = false;
        /** The complete flight plan container, including origin and destination info. */
        this.fplnContainer = FSComponent.createRef();
        /** The departure through arrival phases, all of the FPLSections. */
        this.fplDetailsContainer = FSComponent.createRef();
        this.sectionListRef = FSComponent.createRef();
        /**
         * Gets the top location of the list element for the specified segment and leg.
         * @param segmentIndex The segment index.
         * @param legIndex The leg index.
         * @returns list element y coordinate
         */
        this.getListElementTopLocation = (segmentIndex, legIndex) => {
            const section = this.controller.sectionRefs[segmentIndex];
            if (section) {
                if (section.instance.getLegsLength() > 0) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    return section.instance.getListRef().instance.getListItemInstance(legIndex).getContainerElementLocation()[1] + 4;
                }
                else {
                    console.warn('getListElementTopLocation: Section exists, but there are no legs in this segment');
                    return -1;
                }
            }
            else {
                console.error('getListElementTopLocation: Section Ref could not be found');
                return -1;
            }
        };
        this.store = new FPLDetailsStore(props.bus);
        this.controller = new FPLDetailsController(this.store, props.fms, props.bus, this.scrollToActiveLeg.bind(this));
    }
    /**
     * Do stuff after rendering.
     */
    onAfterRender() {
        super.onAfterRender();
        this.controller.initialize();
    }
    /** Called when the fpl view is resumed. */
    fplViewResumed() {
        this.controller.initDtoLeg();
    }
    /** Called when the fpl view is opened. */
    fplViewOpened() {
        this.scrollToActiveLeg();
    }
    /**
     * A method called when the view scroll is toggled.
     * @param enabled if the scroll is enabled.
     */
    onScrollToggled(enabled) {
        this.controller.scrollMode = enabled ? ScrollMode.MANUAL : ScrollMode.AUTO;
        this.scrollToActiveLeg();
    }
    /** Scrolls to the active leg in the flight plan. */
    scrollToActiveLeg() {
        for (let i = 0; i < this.controller.sectionRefs.length; i++) {
            const section = this.controller.sectionRefs[i];
            const activeLegIndex = section.instance.getActiveLegIndex();
            if (activeLegIndex > -1) {
                if (this.controller.scrollMode === ScrollMode.MANUAL) {
                    this.sectionListRef.instance.scrollToIndex(i);
                    section.instance.scrollToActiveLeg();
                }
                else {
                    section.instance.ensureActiveLegInView();
                }
                return;
            }
        }
        // No active leg was found.
        if (this.controller.scrollMode === ScrollMode.MANUAL && !this.sectionListRef.instance.getSelectedElement()) {
            this.sectionListRef.instance.scrollToIndex(0);
        }
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.MENU:
                this.sendActionToSections(s => s.instance.onMenu());
                return true;
            case FmsHEvent.DIRECTTO: {
                this.sendActionToSections((s) => { return s.instance.onDirectTo(); });
                return true;
            }
        }
        return false;
    }
    /**
     * Calls all sections with the specified function.
     * @param fn A function returning a boolean indicating if the calls to other sections should continue.
     */
    sendActionToSections(fn) {
        const sectionLen = this.controller.sectionRefs.length;
        for (let i = 0; i < sectionLen; i++) {
            if (fn(this.controller.sectionRefs[i])) {
                break;
            }
        }
    }
    /**
     * Responds to a flight plan element selections.
     * @param selection The selection that was made.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onFlightPlanElementSelected(selection) {
        // noop
    }
    /**
     * Responds to flight plan focus selections.
     * @param focus The focus selection that was made.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onFlightPlanFocusSelected(focus) {
        // noop
    }
    /**
     * Renders a section in the flight plan.
     * @param data The data object for this section.
     * @param registerFn The control register function.
     * @param index The index.
     * @returns The rendered VNode.
     */
    renderItem(data, registerFn, index) {
        let section;
        const ref = FSComponent.createRef();
        // select datatemplate
        switch (data.segmentType) {
            case FlightPlanSegmentType.Departure:
                section = (FSComponent.buildComponent(FPLDeparture, { onRegister: registerFn, ref: ref, fms: this.props.fms, detailsController: this.controller, facilities: this.store.facilityInfo, segmentIndex: data.segmentIndex, scrollContainer: this.fplnContainer, isExtendedView: this.isExtendedView, onFlightPlanElementSelected: this.onFlightPlanElementSelected.bind(this), onFlightPlanFocusSelected: this.onFlightPlanFocusSelected.bind(this) }));
                break;
            case FlightPlanSegmentType.Arrival:
                section = (FSComponent.buildComponent(FPLArrival, { onRegister: registerFn, ref: ref, fms: this.props.fms, detailsController: this.controller, facilities: this.store.facilityInfo, segmentIndex: data.segmentIndex, scrollContainer: this.fplnContainer, isExtendedView: this.isExtendedView, onFlightPlanElementSelected: this.onFlightPlanElementSelected.bind(this), onFlightPlanFocusSelected: this.onFlightPlanFocusSelected.bind(this) }));
                break;
            case FlightPlanSegmentType.Approach:
                section = (FSComponent.buildComponent(FPLApproach, { onRegister: registerFn, ref: ref, fms: this.props.fms, detailsController: this.controller, facilities: this.store.facilityInfo, segmentIndex: data.segmentIndex, scrollContainer: this.fplnContainer, isExtendedView: this.isExtendedView, onFlightPlanElementSelected: this.onFlightPlanElementSelected.bind(this), onFlightPlanFocusSelected: this.onFlightPlanFocusSelected.bind(this) }));
                break;
            case FlightPlanSegmentType.Destination:
                section = (FSComponent.buildComponent(FPLDestination, { onRegister: registerFn, ref: ref, fms: this.props.fms, detailsController: this.controller, facilities: this.store.facilityInfo, segmentIndex: data.segmentIndex, scrollContainer: this.fplnContainer, isExtendedView: this.isExtendedView, onFlightPlanElementSelected: this.onFlightPlanElementSelected.bind(this), onFlightPlanFocusSelected: this.onFlightPlanFocusSelected.bind(this) }));
                break;
            default:
                section = (FSComponent.buildComponent(FPLEnroute, { onRegister: registerFn, ref: ref, fms: this.props.fms, detailsController: this.controller, facilities: this.store.facilityInfo, segmentIndex: data.segmentIndex, scrollContainer: this.fplnContainer, isExtendedView: this.isExtendedView, onFlightPlanElementSelected: this.onFlightPlanElementSelected.bind(this), onFlightPlanFocusSelected: this.onFlightPlanFocusSelected.bind(this) }));
        }
        this.controller.sectionRefs.splice(index, 0, section);
        return section;
    }
    /**
     * A callback which is called when a flight plan segment is selected.
     * @param segment The selected segment.
     */
    onSegmentSelected(segment) {
        if (!segment && this.store.segments.length > 0 && this.sectionListRef.instance.getIsFocused()) {
            this.sectionListRef.instance.scrollToIndex(0);
        }
    }
    /**
     * Render the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { id: 'fpl-details-container', ref: this.fplDetailsContainer },
            FSComponent.buildComponent(FPLOrigin, { onRegister: this.props.onRegister, ref: this.controller.originRef, fms: this.props.fms, facilities: this.store.facilityInfo, segmentIndex: -1 }),
            FSComponent.buildComponent("hr", null),
            FSComponent.buildComponent("div", null,
                FSComponent.buildComponent("span", { id: "dtk", class: "smallText white" }, "DTK"),
                FSComponent.buildComponent("span", { id: "dis", class: "smallText white" }, "DIS")),
            FSComponent.buildComponent("div", { class: 'fpln-container', ref: this.fplnContainer },
                FSComponent.buildComponent(List, { ref: this.sectionListRef, onRegister: this.props.onRegister, data: this.store.segments, renderItem: this.renderItem.bind(this), onItemSelected: this.onSegmentSelected.bind(this), scrollContainer: this.fplnContainer }),
                FSComponent.buildComponent(FplActiveLegArrow, { ref: this.controller.legArrowRef, getLegDomLocation: this.getListElementTopLocation })),
            FSComponent.buildComponent(ScrollBar, null)));
    }
}

/**
 * The FPL popup container encapsulates the actual popup logic.
 */
class FPL extends UiView {
    constructor() {
        super(...arguments);
        this.fplDetailsRef = FSComponent.createRef();
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        if (evt === FmsHEvent.UPPER_PUSH) {
            this.toggleScroll();
            return true;
        }
        return this.fplDetailsRef.instance.onInteractionEvent(evt) || super.onInteractionEvent(evt);
    }
    /** Called when the view is resumed. */
    onViewResumed() {
        if (this.fplDetailsRef.instance !== undefined) {
            this.fplDetailsRef.instance.fplViewResumed();
        }
    }
    /** Called when the view is closed. */
    onViewClosed() {
        this.setScrollEnabled(true);
    }
    /** Called when the view is opened. */
    onViewOpened() {
        if (this.fplDetailsRef.instance !== undefined) {
            this.fplDetailsRef.instance.fplViewOpened();
        }
    }
    /**
     * A method called when the control group scroll is toggled.
     * @param enabled if the scroll is enabled.
     */
    onScrollToggled(enabled) {
        this.fplDetailsRef.instance.onScrollToggled(enabled);
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: 'popout-dialog', ref: this.viewContainerRef },
            FSComponent.buildComponent("h1", null, this.props.title),
            FSComponent.buildComponent(FPLDetails, { onRegister: this.register, ref: this.fplDetailsRef, bus: this.props.bus, fms: this.props.fms })));
    }
}

/** The two states an alert can be in. */
var AlertState;
(function (AlertState) {
    /** A newly arrived, unackowledged alert message. */
    AlertState[AlertState["New"] = 0] = "New";
    /** An alert message that has been acknowledged with the Alert softkey. */
    AlertState[AlertState["Acked"] = 1] = "Acked";
})(AlertState || (AlertState = {}));
/** A G1000 PFD CAS display. */
class CAS extends DisplayComponent {
    constructor() {
        super(...arguments);
        /** The overall container for the CAS elements. */
        this.divRef = FSComponent.createRef();
        /** The div for new, unacked annunciations. */
        this.newRef = FSComponent.createRef();
        /** The div for acknowledged but still active annunciations. */
        this.ackRef = FSComponent.createRef();
        /** The well little div for the divider bar beween acked and unacked. */
        this.dividerRef = FSComponent.createRef();
        /** The number of unacked messages currently displayed. */
        this.numNewDisplayed = 0;
        /** The number of acked messages currently displayed. */
        this.numAckedDisplayed = 0;
    }
    /**
     * Determine whether we need to hide or unhide ourselves when a child's state changes.
     * @param state Whether the alert is acknowledged or not.
     * @param active Whether the child has going active.
     */
    setDisplayed(state, active) {
        switch (state) {
            case AlertState.New:
                if (active) {
                    // A new alert has been displayed.
                    this.numNewDisplayed++;
                    // If we are adding our first active alert, we need to display the full CAS block.
                    if (this.numNewDisplayed == 1) {
                        this.divRef.instance.style.display = 'block';
                    }
                    // If we have any acked messages displayed, we'll show the divider.
                    if (this.numAckedDisplayed > 0) {
                        this.dividerRef.instance.style.display = 'block';
                    }
                }
                else {
                    // A previously displayed alert has been hidden.
                    this.numNewDisplayed--;
                    // If nothing other new alerts are displayed we can hide divider block.
                    if (this.numNewDisplayed == 0) {
                        this.dividerRef.instance.style.display = 'none';
                        // We'll also go ahead and hide the whole CAS div if there's nothing else displayed.
                        if (this.numAckedDisplayed == 0) {
                            this.divRef.instance.style.display = 'none';
                        }
                    }
                }
                break;
            case AlertState.Acked:
                if (active) {
                    // A new acked alert has been displayed.
                    this.numAckedDisplayed++;
                    // If we're adding our first acked alert, we need to display the full CAS block.
                    if (this.numAckedDisplayed == 1) {
                        this.divRef.instance.style.display = 'block';
                    }
                    if (this.numNewDisplayed > 0) {
                        // If there are also unacked messages displayed, activate the divider.
                        this.dividerRef.instance.style.display = 'block';
                    }
                    else {
                        // Otherwise, make sure it's turned off.
                        this.dividerRef.instance.style.display = 'none';
                    }
                }
                else {
                    // A previously acked alert has been hidden.
                    this.numAckedDisplayed--;
                    // If that was the last one, hide the divider.
                    if (this.numAckedDisplayed == 0) {
                        this.dividerRef.instance.style.display = 'none';
                        // And if there are also no new ones, hide the full div.
                        if (this.numNewDisplayed == 0) {
                            this.divRef.instance.style.display = 'none';
                        }
                    }
                }
                break;
        }
    }
    /** Iterate through the configured annunciations and render each into the new and acked divs. */
    onAfterRender() {
        for (const ann of this.props.annunciations) {
            FSComponent.render(FSComponent.buildComponent(CASAnnunciation, { bus: this.props.bus, logicHandler: this.props.logicHandler, config: ann, stateCb: this.setDisplayed.bind(this, AlertState.New), stateShown: AlertState.New }), this.newRef.instance);
            FSComponent.render(FSComponent.buildComponent(CASAnnunciation, { bus: this.props.bus, logicHandler: this.props.logicHandler, config: ann, stateCb: this.setDisplayed.bind(this, AlertState.Acked), stateShown: AlertState.Acked }), this.ackRef.instance);
        }
    }
    /**
     * Render the CAS.
     * @returns A VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "annunciations", ref: this.divRef },
            FSComponent.buildComponent("div", { class: "annunciations-new", ref: this.newRef }),
            FSComponent.buildComponent("div", { class: "annunciations-divider", ref: this.dividerRef }),
            FSComponent.buildComponent("div", { class: "annunciations-acked", ref: this.ackRef })));
    }
}
/** An individual annunciation. */
class CASAnnunciation extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.divRef = FSComponent.createRef();
        /** Whether or not the actual alert condition is currently active. */
        this.active = false;
        /** Whether or not we are currently showing ourselves. */
        this.shown = false;
    }
    /** Show ourselves and let the CAS know, if we're not already shown. */
    showSelf() {
        if (!this.shown) {
            this.divRef.instance.style.display = 'block';
            this.props.stateCb(true);
            this.shown = true;
        }
    }
    /** Hide ourselves and let the CAS know, if we're currently shown. */
    hideSelf() {
        if (this.shown) {
            this.divRef.instance.style.display = 'none';
            this.props.stateCb(false);
            this.shown = false;
        }
    }
    /** Register our alert logic handlers and subscribe to the G1000 bus for alert push events. */
    onAfterRender() {
        const g1000ControlEvents = this.props.bus.getSubscriber();
        g1000ControlEvents.on('pfd_alert_push').handle((evt) => {
            if (evt) {
                // If we are the new alert, we need to hide ourselves so the acked version can show.
                if (this.props.stateShown == AlertState.New) {
                    this.hideSelf();
                }
                else {
                    // But if we're the acked div, we need to activate ourselves, assuming the alert is hot.
                    if (this.active) {
                        this.showSelf();
                    }
                }
            }
        });
        // The composite logic host passes a 1 in the callback if the alert has entered an active state,
        // or 0 if it has become inactive.
        this.props.logicHandler.addLogicAsNumber(this.props.config.condition, (v) => {
            if (v == 1) {
                this.active = true;
                // We're going active, which means we can't be acked yet.  In this case, we only need to
                // take action if we show the new alerts;  acked alert divs stay idle.
                if (this.props.stateShown == AlertState.New) {
                    this.showSelf();
                }
            }
            else {
                this.active = false;
                // We're toggling false.  Whether we're acked or unacked, we need to hide ourselves and
                // let the CAS know.
                this.hideSelf();
            }
        }, 0);
    }
    /**
     * Render an annunciation.
     * @returns A VNode.
     */
    render() {
        let type;
        switch (this.props.config.type) {
            case AnnunciationType.Advisory:
                type = 'advisory';
                break;
            case AnnunciationType.Caution:
                type = 'caution';
                break;
            case AnnunciationType.SafeOp:
                type = 'safeop';
                break;
            case AnnunciationType.Warning:
                type = 'warning';
                break;
        }
        return (FSComponent.buildComponent("div", { class: `annunciation ${type}`, style: "display: none;", ref: this.divRef }, this.props.config.text));
    }
}

/**
 * A class to define an arrow toggle/select UI element
 */
class ArrowToggle extends UiControl {
    /**
     * Ctor
     * @param props The props.
     */
    constructor(props) {
        var _a, _b;
        super(props);
        this.valueContainerRef = FSComponent.createRef();
        this.selectedOption = ComputedSubject.create((_b = (_a = this.props.dataref) === null || _a === void 0 ? void 0 : _a.get()) !== null && _b !== void 0 ? _b : 0, (v) => {
            return this.props.options[v];
        });
        this.leftArrEnabled = ComputedSubject.create(false, (v) => {
            return v ? 'rgb(0,255,0)' : 'rgb(50,50,50)';
        });
        this.rightArrEnabled = ComputedSubject.create(true, (v) => {
            return v ? 'rgb(0,255,0)' : 'rgb(50,50,50)';
        });
        this.setArrows();
        this.selectedOption.sub(() => {
            this.setArrows();
        });
        if (this.props.dataref) {
            this.props.dataref.sub((v) => {
                this.selectedOption.set(v);
            });
        }
    }
    /** @inheritdoc */
    onUpperKnobInc() {
        this.scrollOption('next');
    }
    /** @inheritdoc */
    onUpperKnobDec() {
        this.scrollOption('prev');
    }
    /**
     * Sets the next option in the direction.
     * @param direction is the direction to scroll
     */
    scrollOption(direction) {
        var _a;
        let idx = this.selectedOption.getRaw();
        idx = Math.max(0, Math.min(this.props.options.length - 1, ((direction === 'next') ? idx + 1 : idx - 1)));
        this.selectedOption.set(idx);
        (_a = this.props.dataref) === null || _a === void 0 ? void 0 : _a.set(idx);
        if (this.props.onOptionSelected !== undefined) {
            this.props.onOptionSelected(idx);
        }
    }
    /** Enables/Disables the arrows. */
    setArrows() {
        this.leftArrEnabled.set(this.selectedOption.getRaw() > 0);
        this.rightArrEnabled.set(this.selectedOption.getRaw() < this.props.options.length - 1);
    }
    /** @inheritdoc */
    getHighlightElement() {
        return this.valueContainerRef.instance;
    }
    /** @inheritdoc */
    renderControl() {
        return (FSComponent.buildComponent("div", { class: "arrow-toggle-container" },
            FSComponent.buildComponent("svg", { width: "5", height: "10" },
                FSComponent.buildComponent("path", { d: 'M 0 0 l 0 10 l 5 -5 z', fill: this.rightArrEnabled })),
            FSComponent.buildComponent("div", { ref: this.valueContainerRef, class: "arrow-toggle-value" }, this.selectedOption),
            FSComponent.buildComponent("svg", { width: "5", height: "10" },
                FSComponent.buildComponent("path", { d: 'M 0 0 m 5 0 l 0 10 l -5 -5 z', fill: this.leftArrEnabled }))));
    }
}

/**
 * The NumberInput component.
 */
class NumberInput extends UiControl {
    constructor() {
        super(...arguments);
        this.displaySubject = Subject.create('');
        // If increment doesn't divide evenly into range, this will have unexpected behavior!
        this.range = this.props.maxValue - this.props.minValue + this.props.increment;
    }
    /** @inheritdoc */
    onAfterRender() {
        super.onAfterRender();
        this.displaySubject.set(this.getDisplaySubject());
        this.props.dataSubject.sub(() => {
            this.displaySubject.set(this.getDisplaySubject());
        });
    }
    /**
     * Method to get the display subject
     * @returns a string to set the display subject
     */
    getDisplaySubject() {
        if (this.props.defaultDisplayValue !== undefined && this.props.dataSubject.get() == 0) {
            return this.props.defaultDisplayValue;
        }
        else {
            if (this.props.formatter) {
                return this.props.formatter(this.props.dataSubject.get());
            }
            else {
                return `${this.props.dataSubject.get()}`;
            }
        }
    }
    /** @inheritdoc */
    onUpperKnobInc() {
        const newValue = this.props.wrap
            ? ((this.props.dataSubject.get() + this.props.increment) - this.props.minValue) % this.range + this.props.minValue
            : Math.min(this.props.dataSubject.get() + this.props.increment, this.props.maxValue);
        this.props.dataSubject.set(newValue);
        if (this.props.onValueChanged !== undefined) {
            this.props.onValueChanged(this.props.dataSubject.get());
            this.displaySubject.set(this.getDisplaySubject());
        }
    }
    /** @inheritdoc */
    onUpperKnobDec() {
        const newValue = this.props.wrap
            ? this.props.maxValue - (this.props.maxValue - (this.props.dataSubject.get() - this.props.increment)) % this.range
            : Math.max(this.props.dataSubject.get() - this.props.increment, this.props.minValue);
        this.props.dataSubject.set(newValue);
        if (this.props.onValueChanged !== undefined) {
            this.props.onValueChanged(this.props.dataSubject.get());
            this.displaySubject.set(this.getDisplaySubject());
        }
    }
    /** @inheritdoc */
    renderControl() {
        return (FSComponent.buildComponent("div", null, this.displaySubject));
    }
}

/**
 * Timer modes enum.
 */
var TimerMode;
(function (TimerMode) {
    TimerMode[TimerMode["UP"] = 0] = "UP";
    TimerMode[TimerMode["DOWN"] = 1] = "DOWN";
})(TimerMode || (TimerMode = {}));
/**
 * This is a timer that can count up or down based on the mode.
 */
class Timer {
    /**
     * Builds an instance of a Timer
     * @param bus is the EventBus
     * @param g1000Publisher is the g1000 event publisher
     * @param onModeChanged is the onModeChanged callback when the timer mode changes
     * @param onValueChanged is the onValuaChanged callback when the timer value changes
     */
    constructor(bus, g1000Publisher, onModeChanged, onValueChanged) {
        this.onModeChanged = onModeChanged;
        this.onValueChanged = onValueChanged;
        this._mode = TimerMode.UP;
        this._timerRunning = false;
        this._worldTime = 0;
        this._timerValue = 0;
        this._startTime = 0;
        this._canReset = false;
        this.g1000Publisher = g1000Publisher;
        const gnss = bus.getSubscriber();
        gnss.on('zulu_time')
            .withPrecision(0)
            .whenChangedBy(1)
            .handle((time) => {
            this._worldTime = time;
            if (this._timerRunning) {
                this.updateTimer();
            }
        });
    }
    /**
     * Get method for timer mode.
     * @returns this._mode value
     */
    get mode() {
        return this._mode;
    }
    /**
     * Get method for timer mode.
     * @param mode new mode value
     */
    set mode(mode) {
        this._mode = mode;
    }
    /**
     * Get method for timer state (running or not true/false).
     * @returns this._timerValue value
     */
    get timerRunning() {
        return this._timerRunning;
    }
    /**
     * Set method for timer state (running or not true/false).
     * @param state the state to set the timer (true = running, false = stopped).
     */
    set timerRunning(state) {
        this._timerRunning = state;
    }
    /**
     * Get the timer value in seconds.
     * @returns this._timerValue value
     */
    get timerValue() {
        return this._timerValue;
    }
    /**
     * Set method for setting whether the timer can be reset.
     * @param state (true = stopped, can be reset, false = has been reset).
     */
    set canReset(state) {
        this._canReset = state;
    }
    /**
     * Set method for setting whether the timer can be reset.
     * @returns this._canReset value
     */
    get canReset() {
        return this._canReset;
    }
    /**
     * Method to update the timer based on mode and current utc time.
     */
    updateTimer() {
        switch (this._mode) {
            case TimerMode.UP:
                this._timerValue++;
                break;
            case TimerMode.DOWN:
                this._timerValue--;
                if (this._timerValue <= 0) {
                    this.mode = TimerMode.UP;
                    this.onModeChanged(this.mode);
                }
                break;
        }
        this.onValueChanged(this._timerValue);
        this.g1000Publisher.publishEvent('timer_value', this._timerValue);
    }
    /**
     * Method to set timer value
     * @param time is the time to set the timer in seconds
     */
    setTimerValue(time) {
        this._timerValue = time;
    }
    /**
     * Method to reset all timer values
     */
    resetTimer() {
        this._timerValue = 0;
        this.canReset = false;
        this.g1000Publisher.publishEvent('timer_value', 0);
    }
    /**
     * Utility method to get H:M:S values from seconds.
     * @param totalSeconds is the value in seconds
     * @returns an object of hours minutes and seconds as numbers
     */
    static SecondsToHMMSS(totalSeconds) {
        const time = {
            hours: Math.floor(totalSeconds / 3600),
            minutesTens: 0,
            minutesOnes: 0,
            secondsTens: 0,
            secondsOnes: 0
        };
        time.minutesTens = Math.floor((totalSeconds - (time.hours * 3600)) / 600);
        time.minutesOnes = Math.floor((totalSeconds - (time.hours * 3600)) / 60) % 10;
        time.secondsTens = Math.floor((totalSeconds - (time.hours * 3600) - (time.minutesTens * 600) - (time.minutesOnes * 60)) / 10);
        time.secondsOnes = Math.floor((totalSeconds - (time.hours * 3600) - (time.minutesTens * 600) - (time.minutesOnes * 60)) % 10);
        return time;
    }
}

/**
 * The TimerInput Component.
 */
class TimerInput extends UiControl {
    constructor() {
        super(...arguments);
        this.inputCtrls = [];
        this.activeInput = undefined;
        this.highlightIndex = 0;
        this.timerSubjects = [
            Subject.create(0),
            Subject.create(0),
            Subject.create(0),
            Subject.create(0),
            Subject.create(0),
        ];
        /**
         * Registers the inputs with this control
         * @param ctrl The number input to register.
         */
        this.register = (ctrl) => {
            this.inputCtrls.push(ctrl);
        };
    }
    /**
     * A method called to get the current timer mode.
     * @returns the current TimerMode
     */
    getTimerMode() {
        return this.props.timer.mode;
    }
    /**
     * A method called to get the current timer mode.
     * @returns the current TimerMode
     */
    getTimerState() {
        return this.props.timer.timerRunning;
    }
    /**
     * A method called to get the current timer reset state.
     * @returns the current timer reset state
     */
    getTimerResetState() {
        return this.props.timer.canReset;
    }
    /**
     * Sets this control's input value to a specific duration.
     * @param seconds The input to set in seconds.
     */
    setInput(seconds) {
        const timerValues = Timer.SecondsToHMMSS(seconds);
        this.timerSubjects[0].set(timerValues.hours);
        this.timerSubjects[1].set(timerValues.minutesTens);
        this.timerSubjects[2].set(timerValues.minutesOnes);
        this.timerSubjects[3].set(timerValues.secondsTens);
        this.timerSubjects[4].set(timerValues.secondsOnes);
    }
    /**
     * A method called to stop the timer.
     */
    stopTimer() {
        this.props.timer.timerRunning = false;
        this.props.timer.canReset = true;
    }
    /**
     * A method called to start the timer.
     */
    startTimer() {
        this.props.timer.timerRunning = true;
    }
    /**
     * A method called to reset the timer.
     */
    resetTimer() {
        this.timerSubjects[0].set(0);
        this.timerSubjects[1].set(0);
        this.timerSubjects[2].set(0);
        this.timerSubjects[3].set(0);
        this.timerSubjects[4].set(0);
        this.props.timer.resetTimer();
    }
    /**
     * Sets the value of this control's timer to the current input value.
     */
    setTimerFromInput() {
        const hours = this.timerSubjects[0].get();
        const minutes = 10 * this.timerSubjects[1].get() + this.timerSubjects[2].get();
        const seconds = 10 * this.timerSubjects[3].get() + this.timerSubjects[4].get();
        this.props.timer.setTimerValue(hours * 3600 + minutes * 60 + seconds);
    }
    /** @inheritdoc */
    onUpperKnobInc() {
        var _a;
        if (!this.isActivated) {
            this.activate();
        }
        else {
            (_a = this.activeInput) === null || _a === void 0 ? void 0 : _a.onUpperKnobInc();
        }
    }
    /** @inheritdoc */
    onUpperKnobDec() {
        var _a;
        if (!this.isActivated) {
            this.activate();
        }
        else {
            (_a = this.activeInput) === null || _a === void 0 ? void 0 : _a.onUpperKnobDec();
        }
    }
    /** @inheritdoc */
    onLowerKnobInc() {
        this.highlightIndex++;
        this.highlightInput(this.highlightIndex);
    }
    /** @inheritdoc */
    onLowerKnobDec() {
        this.highlightIndex--;
        this.highlightInput(this.highlightIndex);
    }
    /** @inheritdoc */
    onEnter() {
        if (this.isActivated) {
            this.setTimerFromInput();
            this.deactivate();
            return true;
        }
        else {
            return false;
        }
    }
    /** @inheritdoc */
    onClr() {
        if (this.isActivated) {
            this.deactivate();
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Highlights the specified input control.
     * @param index The index of the input to highlight.
     */
    highlightInput(index) {
        if (this.activeInput) {
            this.activeInput.blur();
        }
        this.highlightIndex = MathUtils.clamp(index, 0, this.inputCtrls.length - 1);
        this.activeInput = this.inputCtrls[this.highlightIndex];
        this.activeInput.focus();
    }
    /** @inheritdoc */
    onActivated() {
        var _a;
        this.highlightIndex = 0;
        (_a = this.getHighlightElement()) === null || _a === void 0 ? void 0 : _a.classList.remove(UiControl.FOCUS_CLASS);
        this.highlightInput(this.highlightIndex);
    }
    /** @inheritdoc */
    onDeactivated() {
        var _a, _b;
        (_a = this.activeInput) === null || _a === void 0 ? void 0 : _a.blur();
        if (this.getIsFocused()) {
            (_b = this.getHighlightElement()) === null || _b === void 0 ? void 0 : _b.classList.add(UiControl.FOCUS_CLASS);
        }
        this.setInput(this.props.timer.timerValue);
    }
    /** @inheritdoc */
    renderControl() {
        return (FSComponent.buildComponent("div", { class: "timerref-timer-container" },
            FSComponent.buildComponent(NumberInput, { onRegister: this.register, dataSubject: this.timerSubjects[0], minValue: 0, maxValue: 99, increment: 1, wrap: true, class: 'timerref-timer-number' }),
            ":",
            FSComponent.buildComponent(NumberInput, { onRegister: this.register, dataSubject: this.timerSubjects[1], minValue: 0, maxValue: 5, increment: 1, wrap: true, class: 'timerref-timer-number' }),
            FSComponent.buildComponent(NumberInput, { onRegister: this.register, dataSubject: this.timerSubjects[2], minValue: 0, maxValue: 9, increment: 1, wrap: true, class: 'timerref-timer-number' }),
            ":",
            FSComponent.buildComponent(NumberInput, { onRegister: this.register, dataSubject: this.timerSubjects[3], minValue: 0, maxValue: 5, increment: 1, wrap: true, class: 'timerref-timer-number' }),
            FSComponent.buildComponent(NumberInput, { onRegister: this.register, dataSubject: this.timerSubjects[4], minValue: 0, maxValue: 9, increment: 1, wrap: true, class: 'timerref-timer-number' })));
    }
}

/** The context menu position. */
var ContextMenuPosition;
(function (ContextMenuPosition) {
    // TOP = 0,
    ContextMenuPosition[ContextMenuPosition["BOTTOM"] = 1] = "BOTTOM";
    ContextMenuPosition[ContextMenuPosition["LEFT"] = 2] = "LEFT";
    // RIGHT = 3,
    ContextMenuPosition[ContextMenuPosition["CENTER"] = 4] = "CENTER";
})(ContextMenuPosition || (ContextMenuPosition = {}));
/** A dialog that displays a context menu. */
class ContextMenuDialog extends UiView {
    /**
     * Constructor
     * @param props The view props.
     */
    constructor(props) {
        super(props);
        this.listRef = FSComponent.createRef();
        this.listContainerRef = FSComponent.createRef();
        this.popoutContainerBgRef = FSComponent.createRef();
        this.menuItemsSubject = ArraySubject.create();
        this.assumedWidth = 0;
        this.assumedHeight = 0;
        this.viewport = {
            height: Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0),
            width: Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0)
        };
        this.SAFETY_MARGIN = 28;
        this.CHAR_WIDTH = 12;
        this.ROW_HEIGHT = 26;
        this.MAX_WIDTH = 320;
        this.MAX_HEIGHT = 260;
        this.onItemSelected = (sender) => {
            this.accept(this.listRef.instance.getListItemIndex(sender), true);
            return true;
        };
        /**
         * A callback called to render the menu items.
         * @param d is the menu item
         * @param registerFn The control register function.
         * @returns a vnode for display in the menu
         */
        this.renderItem = (d, registerFn) => {
            return FSComponent.buildComponent(PopoutMenuItem, { onRegister: registerFn, onEnter: this.onItemSelected, parent: this, def: d });
        };
        this.inputData.sub((v) => {
            this.menuItemsSubject.clear();
            if (v !== undefined) {
                if (v.items.length > 0) {
                    this.menuItemsSubject.insertRange(0, v.items);
                }
                this.scrollController.gotoFirst();
            }
        });
    }
    /** @inheritdoc */
    onInputDataSet(data) {
        if (data) {
            if (data.element) {
                this.containerRect = data.outerContainer.getBoundingClientRect();
                this.assumedWidth = MathUtils.clamp(data.items.reduce((maxWidth, item) => item.estimatedWidth > maxWidth ? item.estimatedWidth : maxWidth, 0) + this.SAFETY_MARGIN, 0, this.containerRect.width);
                this.assumedHeight = MathUtils.clamp(this.menuItemsSubject.length * this.ROW_HEIGHT + this.SAFETY_MARGIN, 0, Math.min(this.containerRect.height, this.MAX_HEIGHT));
                // just center it there for now
                const selectElRect = data.element.getBoundingClientRect();
                switch (data.position) {
                    case ContextMenuPosition.LEFT:
                        // position dialog left of element
                        this.viewContainerRef.instance.style.top = `${((this.containerRect.height / 2) - (this.assumedHeight / 2)) + this.containerRect.top + 12}px`;
                        this.setContainerLeftPos(selectElRect.left - this.assumedWidth - 8, data);
                        break;
                    case ContextMenuPosition.CENTER:
                        this.viewContainerRef.instance.style.top = `${((this.containerRect.height / 2) - (this.assumedHeight / 2)) + this.containerRect.top + 12}px`;
                        this.setContainerLeftPos(this.containerRect.left + (this.containerRect.width / 2) - (this.assumedWidth / 2), data);
                        break;
                    case ContextMenuPosition.BOTTOM:
                    default:
                        // position dialog below the element
                        this.viewContainerRef.instance.style.top = `${selectElRect.bottom + 10}px`;
                        this.setContainerLeftPos(selectElRect.left + 8, data);
                        break;
                }
                const viewContainerRect = this.viewContainerRef.instance.getBoundingClientRect();
                const remHeight = this.containerRect.bottom - viewContainerRect.top;
                this.popoutContainerBgRef.instance.style.maxHeight = `${MathUtils.clamp(remHeight - this.SAFETY_MARGIN, this.ROW_HEIGHT + this.SAFETY_MARGIN, this.MAX_HEIGHT)}px`;
            }
            if (data.initialScrollPosition) {
                this.listRef.instance.scrollToIndex(data.initialScrollPosition);
            }
        }
    }
    /**
     * Sets and clamps the left position of the container.
     * @param left The desired left position.
     * @param data The context menu options data.
     */
    setContainerLeftPos(left, data) {
        const minLeft = data.outerContainer ? data.outerContainer.getBoundingClientRect().left + 10 : 0;
        this.viewContainerRef.instance.style.left = `${MathUtils.clamp(left, minLeft, this.viewport.width - this.assumedWidth)}px`;
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.CLR:
                this.close();
                return true;
        }
        return false;
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: 'popout-contextmenu-dialog', ref: this.viewContainerRef },
            FSComponent.buildComponent("div", { class: 'popout-contextmenu-background', ref: this.popoutContainerBgRef },
                FSComponent.buildComponent("div", { class: "popout-contextmenu-container", ref: this.listContainerRef },
                    FSComponent.buildComponent(List, { onRegister: this.register, ref: this.listRef, data: this.menuItemsSubject, renderItem: this.renderItem, upperKnobCanScroll: this.props.upperKnobCanScroll, scrollContainer: this.popoutContainerBgRef }))),
            FSComponent.buildComponent(ScrollBar, null)));
    }
}
ContextMenuDialog.CHAR_WIDTH = 12;

/**
 * A control which allows the user to select one of multiple items through a pop-up dialog and which also displays the
 * currently selected value.
 */
class SelectControl extends UiControl {
    constructor() {
        super(...arguments);
        this.valueRef = FSComponent.createRef();
        this.renderedValueNode = null;
        this.MenuItems = [];
        this.SelectedValue = Subject.create(-1);
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        super.onAfterRender();
        this.SelectedValue.sub(this.renderSelectedItem.bind(this));
        this.props.data.sub(() => {
            this.MenuItems = this.buildMenuItems();
            this.SelectedValue.set((this.MenuItems.length > 0) ? 0 : -1);
            this.setIsEnabled(this.MenuItems.length > 0);
            const selectedIndex = this.SelectedValue.get();
            this.renderSelectedItem(selectedIndex);
            this.props.onItemSelected(selectedIndex, this.props.data.tryGet(selectedIndex), true);
        }, true);
        this.isEnabledSubject.sub((v) => {
            if (v) {
                this.valueRef.instance.classList.add('cyan');
            }
            else {
                this.valueRef.instance.classList.remove('cyan');
            }
        });
    }
    /** @inheritdoc */
    onUpperKnob() {
        var _a, _b, _c;
        // open dialog
        if (this.MenuItems.length > 0) {
            const selectCb = (sender, index) => {
                this.SelectedValue.set(index);
                this.props.onItemSelected(index, this.props.data.tryGet(index), false);
            };
            this.activate();
            const dialogOptions = {
                items: this.MenuItems,
                element: this.valueRef.instance,
                position: (_a = this.props.dialogPosition) !== null && _a !== void 0 ? _a : ContextMenuPosition.BOTTOM,
                outerContainer: this.props.outerContainer.instance,
                initialScrollPosition: (_c = (_b = this.props.dialogScrollStartIndex) === null || _b === void 0 ? void 0 : _b.get()) !== null && _c !== void 0 ? _c : this.SelectedValue.get()
            };
            const dialog = Fms.viewService.open(ContextMenuDialog.name, true).setInput(dialogOptions);
            dialog.onAccept.on(selectCb);
            dialog.onClose.on(() => {
                this.deactivate();
            });
        }
    }
    /**
     * Builds the menu item definitions.
     * @returns An array of menu item definitions.
     */
    buildMenuItems() {
        const defs = [];
        const dataLen = this.props.data.length;
        for (let i = 0; i < dataLen; i++) {
            defs.push(this.props.buildMenuItem(this.props.data.get(i), i));
        }
        return defs;
    }
    /**
     * Renders the selected item.
     * @param index The index of the selected item.
     */
    renderSelectedItem(index) {
        var _a, _b;
        while (this.valueRef.instance.firstChild) {
            this.valueRef.instance.removeChild(this.valueRef.instance.firstChild);
        }
        if (this.renderedValueNode) {
            if (this.renderedValueNode.instance instanceof DisplayComponent) {
                this.renderedValueNode.instance.destroy();
            }
            this.renderedValueNode = null;
        }
        const item = this.props.data.tryGet(index);
        const node = item === undefined
            ? FSComponent.buildComponent("span", null, (_b = (_a = this.props.nullSelectionText) === null || _a === void 0 ? void 0 : _a.get()) !== null && _b !== void 0 ? _b : 'NONE')
            : this.props.renderSelectedItem
                ? this.props.renderSelectedItem(item, index)
                : this.MenuItems[index].renderContent();
        FSComponent.render(node, this.valueRef.instance);
        this.renderedValueNode = node;
    }
    /** @inheritdoc */
    renderControl() {
        return (FSComponent.buildComponent("div", { ref: this.valueRef }));
    }
}

/**
 * The PFD timer ref popout.
 */
class TimerRef extends UiView {
    constructor() {
        super(...arguments);
        this.popoutRef = FSComponent.createRef();
        this.containerRef = FSComponent.createRef();
        this.glideRef = Subject.create(1);
        this.glideRefChanged = ComputedSubject.create(false, (v) => { return v ? ' *' : ''; });
        this.vrRef = Subject.create(1);
        this.vrRefChanged = ComputedSubject.create(false, (v) => { return v ? ' *' : ''; });
        this.vxRef = Subject.create(1);
        this.vxRefChanged = ComputedSubject.create(false, (v) => { return v ? ' *' : ''; });
        this.vyRef = Subject.create(1);
        this.vyRefChanged = ComputedSubject.create(false, (v) => { return v ? ' *' : ''; });
        this.minsRef = Subject.create(0);
        this.timerComponentRef = FSComponent.createRef();
        this.upDownItems = ArraySubject.create();
        this.buttonRef = FSComponent.createRef();
        this.upDownControlRef = FSComponent.createRef();
        this.timerButtonSubject = Subject.create('Start?');
        /**
         * Callback to handle when Timer changes the mode after reaching 0.
         * @param mode is the TimerMode
         */
        this.onTimerModeChanged = (mode) => {
            this.upDownControlRef.instance.SelectedValue.set(mode);
        };
        /**
         * Callback to handle when Timer value changes.
         * @param seconds is the new timer time value in seconds.
         */
        this.onTimerValueChanged = (seconds) => {
            if (!this.timerComponentRef.instance.getIsActivated()) {
                this.timerComponentRef.instance.setInput(seconds);
            }
        };
        this.timer = new Timer(this.props.bus, Fms.g1000EvtPub, this.onTimerModeChanged, this.onTimerValueChanged);
        this.vSpeeds = [
            { type: VSpeedType.Vx, value: Math.round(Simplane.getDesignSpeeds().Vx), modified: Subject.create(false), display: true },
            { type: VSpeedType.Vy, value: Math.round(Simplane.getDesignSpeeds().Vy), modified: Subject.create(false), display: true },
            { type: VSpeedType.Vr, value: Math.round(Simplane.getDesignSpeeds().Vr), modified: Subject.create(false), display: true },
            { type: VSpeedType.Vglide, value: Math.round(Simplane.getDesignSpeeds().BestGlide), modified: Subject.create(false), display: true },
            { type: VSpeedType.Vapp, value: Math.round(Simplane.getDesignSpeeds().Vapp), modified: Subject.create(false), display: false }
        ];
        this.vSpeedSubjects = {
            vx: Subject.create(this.vSpeeds[0].value),
            vy: Subject.create(this.vSpeeds[1].value),
            vr: Subject.create(this.vSpeeds[2].value),
            vg: Subject.create(this.vSpeeds[3].value),
            vapp: Subject.create(this.vSpeeds[4].value)
        };
        this.minimumsSubject = Subject.create(0);
        this.vSpeedToggleMap = new Map();
        this.vSpeedSubjectMap = new Map();
        this.vSpeedObjectMap = new Map();
        this.onOffToggleOptions = ['Off', 'On'];
        this.minsToggleOptions = ['Off', 'BARO', 'TEMP COMP'];
        /**
         * Callback to handle when Timer Button is Pressed.
         */
        this.onTimerButtonPressed = () => {
            if (this.timerComponentRef.instance.getTimerState()) {
                this.timerComponentRef.instance.stopTimer();
                this.timerButtonSubject.set('Reset?');
            }
            else if (this.timerComponentRef.instance.getTimerResetState()) {
                this.timerComponentRef.instance.resetTimer();
                this.timerButtonSubject.set('Start?');
            }
            else {
                this.timerComponentRef.instance.startTimer();
                this.timerButtonSubject.set('Stop?');
            }
        };
        // ---- TOGGLE Vg CALLBACK
        this.onGlideRefOptionSelected = (index) => {
            console.log('INDEX HERE -- ', index);
            this.glideRef.set(index);
            const vSpeed = this.vSpeedObjectMap.get(VSpeedType.Vglide);
            if (vSpeed !== undefined) {
                vSpeed.value = this.vSpeedSubjects.vg.get();
                vSpeed.display = index === 1;
                Fms.g1000EvtPub.publishEvent('vspeed_display', vSpeed);
            }
        };
        // ---- TOGGLE Vr CALLBACK
        this.onVrRefOptionSelected = (index) => {
            this.vrRef.set(index);
            const vSpeed = this.vSpeedObjectMap.get(VSpeedType.Vr);
            if (vSpeed !== undefined) {
                vSpeed.value = this.vSpeedSubjects.vr.get();
                vSpeed.display = index === 1;
                Fms.g1000EvtPub.publishEvent('vspeed_display', vSpeed);
            }
        };
        // ---- TOGGLE Vx CALLBACK
        this.onVxRefOptionSelected = (index) => {
            this.vxRef.set(index);
            const vSpeed = this.vSpeedObjectMap.get(VSpeedType.Vx);
            if (vSpeed !== undefined) {
                vSpeed.value = this.vSpeedSubjects.vx.get();
                vSpeed.display = index === 1;
                Fms.g1000EvtPub.publishEvent('vspeed_display', vSpeed);
            }
        };
        // ---- TOGGLE Vy CALLBACK
        this.onVyRefOptionSelected = (index) => {
            this.vyRef.set(index);
            const vSpeed = this.vSpeedObjectMap.get(VSpeedType.Vy);
            if (vSpeed !== undefined) {
                vSpeed.value = this.vSpeedSubjects.vy.get();
                vSpeed.display = index === 1;
                Fms.g1000EvtPub.publishEvent('vspeed_display', vSpeed);
            }
        };
        // ---- TOGGLE MINIMUMS CALLBACK
        this.onMinimumsRefOptionSelected = (index) => {
            this.minsRef.set(index);
            Fms.g1000EvtPub.publishEvent('show_minimums', index !== 0 ? true : false);
        };
        // ---- CHANGE MINIMUMS VALUE CALLBACK
        this.updateMinimumsValue = () => {
            Fms.g1000EvtPub.publishEvent('set_minimums', this.minimumsSubject.get());
        };
        // ---- UpDown Menu Item Select CALLBACK
        this.onUpDownMenuSelected = (index) => {
            if (index === 1) {
                this.timer.mode = TimerMode.DOWN;
            }
            else {
                this.timer.mode = TimerMode.UP;
            }
        };
        // ---- UpDown Menu Item List Build
        this.buildUpDownMenuItems = (item, index) => {
            return { id: index.toString(), renderContent: () => FSComponent.buildComponent("span", null, item), estimatedWidth: item.length * ContextMenuDialog.CHAR_WIDTH };
        };
        // ---- updateVy Callback method
        this.updateVy = (value) => {
            this.updateVSpeed(VSpeedType.Vy, value);
        };
        // ---- updateVy Callback method
        this.updateVx = (value) => {
            this.updateVSpeed(VSpeedType.Vx, value);
        };
        // ---- updateVy Callback method
        this.updateVr = (value) => {
            this.updateVSpeed(VSpeedType.Vr, value);
        };
        // ---- updateVy Callback method
        this.updateVglide = (value) => {
            this.updateVSpeed(VSpeedType.Vglide, value);
        };
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.CLR:
                this.close();
                return true;
            case FmsHEvent.MENU:
                this.onMenu();
                return true;
        }
        return false;
    }
    /**
     * An event called when the menu button is pressed.
     * @returns True if the event was handled in this section.
     */
    onMenu() {
        console.log('called menu');
        const dialog = Fms.viewService.open(PageMenuDialog.name, true);
        dialog.setMenuItems([
            {
                id: 'enable-all',
                renderContent: () => FSComponent.buildComponent("span", null, "All References On"),
                isEnabled: true,
                action: () => {
                    this.enableAllRefSpeeds(true);
                }
            },
            {
                id: 'disable-all',
                renderContent: () => FSComponent.buildComponent("span", null, "All References Off"),
                isEnabled: true,
                action: () => {
                    this.enableAllRefSpeeds(false);
                }
            },
            {
                id: 'restore-defaults',
                renderContent: () => FSComponent.buildComponent("span", null, "Restore Defaults"),
                isEnabled: true,
                action: () => {
                    console.log('Restore defaults');
                    this.resetVSpeeds();
                }
            },
        ]);
        return true;
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        super.onAfterRender();
        this.upDownItems.set(['Up', 'Dn']);
        this.vSpeedToggleMap.set(3, this.vSpeeds[3]);
        this.vSpeedToggleMap.set(5, this.vSpeeds[2]);
        this.vSpeedToggleMap.set(7, this.vSpeeds[0]);
        this.vSpeedToggleMap.set(9, this.vSpeeds[1]);
        this.vSpeedSubjectMap.set(VSpeedType.Vglide, this.vSpeedSubjects.vg);
        this.vSpeedSubjectMap.set(VSpeedType.Vr, this.vSpeedSubjects.vr);
        this.vSpeedSubjectMap.set(VSpeedType.Vx, this.vSpeedSubjects.vx);
        this.vSpeedSubjectMap.set(VSpeedType.Vy, this.vSpeedSubjects.vy);
        this.vSpeedObjectMap.set(VSpeedType.Vglide, this.vSpeeds[3]);
        this.vSpeedObjectMap.set(VSpeedType.Vr, this.vSpeeds[2]);
        this.vSpeedObjectMap.set(VSpeedType.Vx, this.vSpeeds[0]);
        this.vSpeedObjectMap.set(VSpeedType.Vy, this.vSpeeds[1]);
        this.vSpeeds[0].modified.sub(v => this.vxRefChanged.set(v));
        this.vSpeeds[1].modified.sub(v => this.vyRefChanged.set(v));
        this.vSpeeds[2].modified.sub(v => this.vrRefChanged.set(v));
        this.vSpeeds[3].modified.sub(v => this.glideRefChanged.set(v));
        const g1000Events = this.props.bus.getSubscriber();
        g1000Events.on('set_minimums').handle((set) => {
            if (set !== this.minimumsSubject.get()) {
                this.minimumsSubject.set(set);
            }
        });
        g1000Events.on('show_minimums').handle((show) => {
            const option = show ? 1 : 0;
            if (option !== this.minsRef.get()) {
                this.minsRef.set(option);
            }
        });
    }
    /** Method to reset all v speeds to defaults */
    resetVSpeeds() {
        this.vSpeeds[0].value = Math.round(Simplane.getDesignSpeeds().Vx);
        this.vSpeedSubjects.vx.set(this.vSpeeds[0].value);
        this.vSpeeds[0].modified.set(false);
        Fms.g1000EvtPub.publishEvent('vspeed_set', this.vSpeeds[0]);
        this.vSpeeds[1].value = Math.round(Simplane.getDesignSpeeds().Vy);
        this.vSpeedSubjects.vy.set(this.vSpeeds[1].value);
        this.vSpeeds[1].modified.set(false);
        Fms.g1000EvtPub.publishEvent('vspeed_set', this.vSpeeds[1]);
        this.vSpeeds[2].value = Math.round(Simplane.getDesignSpeeds().Vr);
        this.vSpeedSubjects.vr.set(this.vSpeeds[2].value);
        this.vSpeeds[2].modified.set(false);
        Fms.g1000EvtPub.publishEvent('vspeed_set', this.vSpeeds[2]);
        this.vSpeeds[3].value = Math.round(Simplane.getDesignSpeeds().BestGlide);
        this.vSpeedSubjects.vg.set(this.vSpeeds[3].value);
        this.vSpeeds[3].modified.set(false);
        Fms.g1000EvtPub.publishEvent('vspeed_set', this.vSpeeds[3]);
        this.vSpeeds[4].value = Math.round(Simplane.getDesignSpeeds().Vapp);
        this.vSpeeds[4].modified.set(false);
    }
    /**
     * Method enable or disable all ref speeds.
     * @param enable Whether to enable or disable the ref speeds.
     */
    enableAllRefSpeeds(enable) {
        const value = enable ? 1 : 0;
        this.onVyRefOptionSelected(value);
        this.onVxRefOptionSelected(value);
        this.onVrRefOptionSelected(value);
        this.onGlideRefOptionSelected(value);
    }
    /**
     * Method to set vspeed asterisk visibility.
     * @param vspeed is the VSpeedType to be updated
     * @param value is the vspeed value
     */
    updateVSpeed(vspeed, value) {
        const object = this.vSpeedObjectMap.get(vspeed);
        if (object !== undefined) {
            object.value = value;
            object.modified.set(true);
            Fms.g1000EvtPub.publishEvent('vspeed_set', object);
        }
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: 'popout-dialog', ref: this.viewContainerRef },
            FSComponent.buildComponent("div", { ref: this.containerRef, class: "timerref-container" },
                FSComponent.buildComponent("div", { class: "timerref-timer-title" }, "Timer"),
                FSComponent.buildComponent(TimerInput, { ref: this.timerComponentRef, timer: this.timer, onRegister: this.register }),
                FSComponent.buildComponent(SelectControl, { ref: this.upDownControlRef, onRegister: this.register, class: "timerref-timer-updown", outerContainer: this.viewContainerRef, data: this.upDownItems, onItemSelected: this.onUpDownMenuSelected, buildMenuItem: this.buildUpDownMenuItems }),
                FSComponent.buildComponent(ActionButton, { class: "timerref-timer-button", onRegister: this.register, ref: this.buttonRef, text: this.timerButtonSubject, onExecute: this.onTimerButtonPressed }),
                FSComponent.buildComponent("hr", { class: "timerref-hr1" }),
                FSComponent.buildComponent("div", { class: "timerref-glide-title" }, "GLIDE"),
                FSComponent.buildComponent("div", { class: "timerref-glide-value" },
                    FSComponent.buildComponent(NumberInput, { onRegister: this.register, onValueChanged: this.updateVglide, dataSubject: this.vSpeedSubjects.vg, minValue: 0, maxValue: 999, increment: 1, wrap: false, class: 'timerref-ref-number' }),
                    FSComponent.buildComponent("span", { class: "size14" },
                        "KT",
                        FSComponent.buildComponent("span", { class: "timerref-asterisk" }, this.glideRefChanged))),
                FSComponent.buildComponent(ArrowToggle, { class: "timerref-glide-toggle", onRegister: this.register, onOptionSelected: this.onGlideRefOptionSelected, options: this.onOffToggleOptions, dataref: this.glideRef }),
                FSComponent.buildComponent("div", { class: "timerref-vr-title" }, "Vr"),
                FSComponent.buildComponent("div", { class: "timerref-vr-value" },
                    FSComponent.buildComponent(NumberInput, { onRegister: this.register, onValueChanged: this.updateVr, dataSubject: this.vSpeedSubjects.vr, minValue: 0, maxValue: 999, increment: 1, wrap: false, class: 'timerref-ref-number' }),
                    FSComponent.buildComponent("span", { class: "size14" },
                        "KT",
                        FSComponent.buildComponent("span", { class: "timerref-asterisk" }, this.vrRefChanged))),
                FSComponent.buildComponent(ArrowToggle, { class: "timerref-vr-toggle", onRegister: this.register, onOptionSelected: this.onVrRefOptionSelected, options: this.onOffToggleOptions, dataref: this.vrRef }),
                FSComponent.buildComponent("div", { class: "timerref-vx-title" }, "Vx"),
                FSComponent.buildComponent("div", { class: "timerref-vx-value" },
                    FSComponent.buildComponent(NumberInput, { onRegister: this.register, onValueChanged: this.updateVx, dataSubject: this.vSpeedSubjects.vx, minValue: 0, maxValue: 999, increment: 1, wrap: false, class: 'timerref-ref-number' }),
                    FSComponent.buildComponent("span", { class: "size14" },
                        "KT",
                        FSComponent.buildComponent("span", { class: "timerref-asterisk" }, this.vxRefChanged))),
                FSComponent.buildComponent(ArrowToggle, { class: "timerref-vx-toggle", onRegister: this.register, onOptionSelected: this.onVxRefOptionSelected, options: this.onOffToggleOptions, dataref: this.vxRef }),
                FSComponent.buildComponent("div", { class: "timerref-vy-title" }, "Vy"),
                FSComponent.buildComponent("div", { class: "timerref-vy-value" },
                    FSComponent.buildComponent(NumberInput, { onRegister: this.register, onValueChanged: this.updateVy, dataSubject: this.vSpeedSubjects.vy, minValue: 0, maxValue: 999, increment: 1, wrap: false, class: 'timerref-ref-number' }),
                    FSComponent.buildComponent("span", { class: "size14" },
                        "KT",
                        FSComponent.buildComponent("span", { class: "timerref-asterisk" }, this.vyRefChanged))),
                FSComponent.buildComponent(ArrowToggle, { class: "timerref-vy-toggle", onRegister: this.register, onOptionSelected: this.onVyRefOptionSelected, options: this.onOffToggleOptions, dataref: this.vyRef }),
                FSComponent.buildComponent("hr", { class: "timerref-hr2" }),
                FSComponent.buildComponent("div", { class: "timerref-mins-title" }, "MINS"),
                FSComponent.buildComponent(ArrowToggle, { class: "timerref-mins-toggle", onRegister: this.register, onOptionSelected: this.onMinimumsRefOptionSelected, options: this.minsToggleOptions, dataref: this.minsRef }),
                FSComponent.buildComponent("div", { class: "timerref-mins-value" },
                    FSComponent.buildComponent(NumberInput, { onRegister: this.register, onValueChanged: this.updateMinimumsValue, dataSubject: this.minimumsSubject, minValue: -1000, maxValue: 10000, increment: 10, wrap: false, defaultDisplayValue: '_ _ _ _ _', class: 'timerref-ref-number' }),
                    FSComponent.buildComponent("span", { class: "size12" }, "FT")),
                FSComponent.buildComponent("div", { class: "timerref-temp-comp-container" },
                    FSComponent.buildComponent("div", { class: "temp-comp-title" }, "Temp At"),
                    FSComponent.buildComponent("div", { class: "temp-comp-dest" }, "_ _ _ _ _ _"),
                    FSComponent.buildComponent("div", { class: "temp-comp-temp" },
                        "_ _ _\u00B0",
                        FSComponent.buildComponent("span", { class: "size12" }, "C")),
                    FSComponent.buildComponent("div", { class: "temp-comp-corrected-alt" },
                        "_ _ _ _ _ _",
                        FSComponent.buildComponent("span", { class: "size12" }, "FT")),
                    FSComponent.buildComponent("div", { class: "temp-comp-snowflake" },
                        FSComponent.buildComponent("svg", null,
                            FSComponent.buildComponent("path", { d: 'M 0 0 l 10 0 l 0 10 l -10 0 z', fill: "white" })))))));
    }
}

/**
 * The kind of runways we can filter on for nearest display.  This is meant to be used
 * as a bitfield.  For the Soft/Hard combo, use SurfaceType.Soft | SurfaceType.Hard.
 **/
var SurfaceType;
(function (SurfaceType) {
    SurfaceType[SurfaceType["Any"] = 1] = "Any";
    SurfaceType[SurfaceType["Hard"] = 2] = "Hard";
    SurfaceType[SurfaceType["Soft"] = 4] = "Soft";
    SurfaceType[SurfaceType["Water"] = 8] = "Water";
})(SurfaceType || (SurfaceType = {}));
/**
 * A filter to be injected into a NearestStore.  This will allow the filtering
 * of a list of airports based upon their longest runway and its surface type.
 * This includes result cacheing to optimize performance of repeated filters.
 * Search parameters may be tweaked, and doing so will automatically invalidate
 * the cache.
 */
class AirportFilter {
    /**
     * Construct an airport filter.
     * @param minLength The minimum length in meters.
     * @param surfaceType The type of surfaces to look for.
     */
    constructor(minLength, surfaceType) {
        this.cache = new Map();
        this._minLength = minLength || UnitType.FOOT.convertTo(3000, UnitType.METER);
        this._surfaceType = surfaceType || SurfaceType.Hard;
    }
    /**
     * Perform the filter on a given list of airports.
     * @param airports An array of AirportFacilities.
     * @returns A list of airports meeting the filter criteria.
     */
    filter(airports) {
        const filtered = [];
        for (const airport of airports) {
            if (!airport) {
                continue;
            }
            let good = this.cache.get(airport.icao);
            if (good === undefined) {
                this.cache.set(airport.icao, good = this.filterAirport(airport));
            }
            if (good) {
                filtered.push(airport);
            }
        }
        return filtered;
    }
    /**
     * Filter a given airport using the current criteria.
     * @param airport The airport to filter.
     * @returns True if the filter is passed, else false.
     */
    filterAirport(airport) {
        const longest = airport.runways.sort((a, b) => b.length - a.length)[0];
        if (longest) {
            if (longest.length < this._minLength) {
                return false;
            }
            if (this.filterRunway(longest, this._surfaceType)) {
                return true;
            }
        }
        return false;
    }
    /**
     * See if a runway matches a given surface type.
     * @param runway The runway to check.
     * @param filter A bitfield of the surface types to allow.
     * @returns True if the runway passes the filter, else false.
     */
    filterRunway(runway, filter) {
        if (filter & SurfaceType.Any) {
            return true;
        }
        if (filter & SurfaceType.Soft && AirportFilter.surfacesSoft.includes(runway.surface)) {
            return true;
        }
        if (filter & SurfaceType.Hard && AirportFilter.surfacesHard.includes(runway.surface)) {
            return true;
        }
        if (filter & SurfaceType.Water && AirportFilter.surfacesWater.includes(runway.surface)) {
            return true;
        }
        return false;
    }
    /**
     * Set a new minimum length and clear the cache.
     * @param minLength The new minimum length in meters.
     */
    set minLength(minLength) {
        this._minLength = minLength;
        this.cache.clear();
    }
    /**
     * Get the current minimum length.
     * @returns The minimum length in meters.
     */
    get minLength() {
        return this._minLength;
    }
    /**
     * Set a new surface type filter and clear the cache.
     * @param surfaceType The new surface type options.
     */
    set surfaceType(surfaceType) {
        this._surfaceType = surfaceType;
        this.cache.clear();
    }
    /**
     * Get the current surface type filter.
     * @returns A bitfield of the surface types to allow.
     */
    get surfaceType() {
        return this._surfaceType;
    }
}
// These are best guesses as to the proper categorization.   They may need to
// be tweaked.
AirportFilter.surfacesHard = [
    RunwaySurfaceType.Asphalt,
    RunwaySurfaceType.Bituminous,
    RunwaySurfaceType.Brick,
    RunwaySurfaceType.Concrete,
    RunwaySurfaceType.Ice,
    RunwaySurfaceType.Macadam,
    RunwaySurfaceType.Paint,
    RunwaySurfaceType.Planks,
    RunwaySurfaceType.SteelMats,
    RunwaySurfaceType.Tarmac,
    RunwaySurfaceType.Urban,
];
AirportFilter.surfacesSoft = [
    RunwaySurfaceType.Coral,
    RunwaySurfaceType.Dirt,
    RunwaySurfaceType.Forest,
    RunwaySurfaceType.Grass,
    RunwaySurfaceType.GrassBumpy,
    RunwaySurfaceType.Gravel,
    RunwaySurfaceType.HardTurf,
    RunwaySurfaceType.LongGrass,
    RunwaySurfaceType.OilTreated,
    RunwaySurfaceType.Sand,
    RunwaySurfaceType.Shale,
    RunwaySurfaceType.ShortGrass,
    RunwaySurfaceType.Snow,
    RunwaySurfaceType.WrightFlyerTrack
];
AirportFilter.surfacesWater = [
    RunwaySurfaceType.WaterFSX,
    RunwaySurfaceType.Lake,
    RunwaySurfaceType.Ocean,
    RunwaySurfaceType.Pond,
    RunwaySurfaceType.River,
    RunwaySurfaceType.WasteWater,
    RunwaySurfaceType.Water
];
/** A nearest store. */
class NearestStore {
    /**
     * Create a NearestStore.
     * @param loader A facility loader.
     * @param filter An instance of AirportFilter to use for filtration.
     */
    constructor(loader, filter) {
        this.planePos = GeoPointSubject.createFromGeoPoint(new GeoPoint(NaN, NaN));
        this.planeHeading = Subject.create(0);
        this.nearestFacilities = new Map();
        this.nearestAirports = new Map();
        this.nearestSubjects = new Array();
        this.nearestSubjectList = ArraySubject.create();
        this.airportCountSub = Subject.create(0);
        this.airportCount = this.airportCountSub;
        this.loader = loader;
        this.filter = filter || new AirportFilter();
        for (let i = 0; i < NearestStore.maxReturned; i++) {
            this.nearestSubjects.push(Subject.create({
                facility: null,
                distance: -1,
                bearing: -1,
                bestHdg: -1,
                bestLength: -1
            }));
            this.nearestSubjectList.insert(this.nearestSubjects[i]);
        }
        this.planePos.sub(pos => {
            if (isNaN(pos.lat) || isNaN(pos.lon)) {
                return;
            }
            this.searchNearest();
        });
    }
    /**
     * Update our nearest airport list.
     */
    searchNearest() {
        var _a;
        if (!this.session) {
            (_a = this.loader) === null || _a === void 0 ? void 0 : _a.startNearestSearchSession(FacilitySearchType.Airport).then(session => {
                this.session = session;
                this.searchNearest();
            });
        }
        else {
            const planePos = this.planePos.get();
            this.session.searchNearest(planePos.lat, planePos.lon, NearestStore.searchRange, NearestStore.maxFound)
                .then(results => { return this.updateNearestFacilities(results); })
                .then(() => {
                this.updateNearestAirports();
                this.updateNearestSubjectList();
            });
        }
    }
    /**
     * Update our nearest list with the latest search results.
     * @param results The results from a nearest search.
     * @returns A promise that resolves when the nearest list is updated.
     */
    updateNearestFacilities(results) {
        var _a;
        // The results of a search contains only the elements added or removed from the last
        // search in the session.   So we need to keep track of everythign that's been returned
        // in this session and add and delete as needed.
        for (const icao of results.removed) {
            this.nearestFacilities.delete(icao);
            this.nearestAirports.delete(icao);
        }
        // Get facility information for all the newly added airports.  The facility loader
        // caches search results internally, so we're not going to worry about optimizing
        // that here as well.
        const searches = new Array();
        for (const icao of results.added) {
            searches.push((_a = this.loader) === null || _a === void 0 ? void 0 : _a.getFacility(FacilityType.Airport, icao));
        }
        return new Promise((resolve) => {
            Promise.all(searches).then(facilities => {
                for (const facility of this.filter.filter(facilities)) {
                    if (facility) {
                        this.nearestFacilities.set(facility.icao, facility);
                    }
                }
                resolve();
            });
        });
    }
    /**
     * Onces the nearby facilities have been updated, we need to update our
     * set of NearbyAirports to account for distance/bearing changes.
     */
    updateNearestAirports() {
        for (const [icao, facility] of this.nearestFacilities.entries()) {
            const nearest = this.nearestAirports.get(icao);
            if (nearest) {
                this.nearestAirports.set(icao, this.updateNearbyAirport(nearest) || this.createNearbyAirport(facility));
            }
            else {
                this.nearestAirports.set(icao, this.createNearbyAirport(facility));
            }
        }
    }
    /**
     * Update our array of nearest airports sorted by distance.
     * @returns An array of nearby airports sorted by distance.
     */
    get nearestByDistance() {
        return [...this.nearestAirports.values()].sort((a, b) => {
            return a.distance - b.distance;
        }).slice(0, NearestStore.maxReturned);
    }
    /**
     * Get the contact frequency for an aiport.  Since this really isn't defined
     * in the scenery details, we implement a pretty simple algorithm for determining
     * it:  iterate through al the frequencies and return the first of a) tower,
     * b) unicom, c) mulicom, d) ctaf that is found.
     * @param airport An airport.
     * @returns frequency The best frequency to use.
     */
    getContactFrequency(airport) {
        const priority = new Map([[FacilityFrequencyType.Tower, 1],
            [FacilityFrequencyType.Unicom, 2],
            [FacilityFrequencyType.Multicom, 3],
            [FacilityFrequencyType.CTAF, 4]]);
        const foundFreqs = new Array();
        const usableTypes = [FacilityFrequencyType.Tower, FacilityFrequencyType.Unicom, FacilityFrequencyType.Multicom, FacilityFrequencyType.CTAF];
        for (const freq of airport.frequencies) {
            if (usableTypes.includes(freq.type)) {
                foundFreqs.push(freq);
            }
        }
        if (foundFreqs.length === 0) {
            return undefined;
        }
        else {
            return foundFreqs.sort((a, b) => {
                return (priority.get(a.type) || 5) - (priority.get(b.type) || 5);
            })[0];
        }
    }
    /**
     * Create a NearbyAirport from an AirportFacility.
     * @param facility The AirportFacility record.
     * @returns The populated NearbyAirport
     */
    createNearbyAirport(facility) {
        const bestRunway = facility.runways.sort((a, b) => b.length - a.length)[0];
        const bestRwyApps = RunwayUtils.getProceduresForRunway(facility.approaches, bestRunway);
        let bestApproach = 'VFR';
        for (const approach of bestRwyApps) {
            switch (approach.name.substring(0, 3)) {
                case 'ILS':
                    bestApproach = 'ILS';
                    break;
                case 'LOC':
                    if (bestApproach !== 'ILS') {
                        bestApproach = 'LOC';
                    }
                    break;
                case 'RNA':
                    if (bestApproach != 'ILS' && bestApproach !== 'LOC') {
                        bestApproach = 'RNA';
                    }
                    break;
                case 'VOR':
                    if (bestApproach !== 'ILS' && bestApproach !== 'LOC' && bestApproach !== 'RNA') {
                        bestApproach = 'VOR';
                    }
                    break;
                case 'NDB':
                    if (bestApproach !== 'ILS' && bestApproach !== 'LOC' && bestApproach !== 'RNA' && bestApproach !== 'VOR') {
                        bestApproach = 'NDB';
                    }
                    break;
            }
        }
        const planePos = this.planePos.get();
        return {
            facility: facility,
            distance: UnitType.GA_RADIAN.convertTo(planePos.distance(facility.lat, facility.lon), UnitType.METER),
            bearing: MagVar.trueToMagnetic(planePos.bearingTo(facility), planePos),
            bestHdg: bestRunway.direction,
            bestLength: bestRunway.length,
            frequency: this.getContactFrequency(facility),
            bestApproach: bestApproach,
        };
    }
    /**
     * Update the dynamic data on a nearby airport.
     * @param airport The airport to update.
     * @returns An updated airport or undefined.
     */
    updateNearbyAirport(airport) {
        const facility = airport.facility && this.nearestFacilities.get(airport.facility.icao);
        if (facility) {
            const newAirport = {
                facility: {},
                distance: -1,
                bearing: -1,
                bestHdg: -1,
                bestLength: -1,
            };
            const planePos = this.planePos.get();
            Object.assign(newAirport, airport);
            newAirport.distance = UnitType.GA_RADIAN.convertTo(planePos.distance(facility.lat, facility.lon), UnitType.METER);
            newAirport.bearing = MagVar.trueToMagnetic(planePos.bearingTo(facility), planePos);
            return newAirport;
        }
        else {
            return undefined;
        }
    }
    /**
     * Update the nearest list with the current nearby airports.
     */
    updateNearestSubjectList() {
        let airportCount = 0;
        const nearestSorted = this.nearestByDistance;
        for (let i = 0; i < NearestStore.maxReturned; i++) {
            if (i < nearestSorted.length) {
                this.nearestSubjects[i].set(nearestSorted[i]);
                airportCount++;
            }
            else {
                this.nearestSubjects[i].set({
                    facility: null,
                    distance: -1,
                    bearing: -1,
                    bestHdg: -1,
                    bestLength: -1
                });
            }
        }
        this.airportCountSub.set(airportCount);
    }
}
// G1000 has a 200nm search radius.
NearestStore.searchRange = UnitType.NMILE.convertTo(200, UnitType.METER);
NearestStore.maxFound = 200;
NearestStore.maxReturned = 25;

/** A nearest controleer */
class NearestController {
    /**
     * Creates one.
     * @param store the store
     * @param publisher A ControlPublisher for freq set events.
     */
    constructor(store, publisher) {
        this.onDirectIdentHandler = this.onDirectIdent.bind(this);
        this.onEnterFreqHandler = this.onEnterFreq.bind(this);
        this.store = store;
        this.publisher = publisher;
    }
    /**
     * A callback which is called when a DRCT input is made on a nearest airport.
     * @param airport The airport.
     * @returns Whether the event was handled.
     */
    onDirectIdent(airport) {
        if (airport) {
            Fms.viewService.open('DirectTo').setInput({
                icao: airport.icao
            });
        }
        return true;
    }
    /**
     * A callback which is called when an ENTER input is made on a nearest airport frequency.
     * @param value The frequency.
     * @returns Whether the event was handled.
     */
    onEnterFreq(value) {
        this.publisher.publishEvent('standby_com_freq', value);
        return true;
    }
}

/** A silly generic control */
class GenericControl extends UiControl {
    /** @inheritdoc */
    renderControl() {
        return (FSComponent.buildComponent("div", null, this.props.children));
    }
}

/** The Nearest Airport component. */
class NearestAirportItem extends UiControlGroup {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.fixEl = FSComponent.createRef();
        this.facWaypointCache = FacilityWaypointCache.getCache();
        this.ident = ComputedSubject.create((_a = this.props.data.get().facility) === null || _a === void 0 ? void 0 : _a.icao, (v) => {
            if (v) {
                return ICAO.getIdent(v);
            }
            else {
                return '____';
            }
        });
        this.bearing = ComputedSubject.create((_b = this.props.data.get().bearing) !== null && _b !== void 0 ? _b : -1, (v) => {
            if (isNaN(v)) {
                return '___';
            }
            else {
                const norm = NavMath.normalizeHeading(Math.round(v));
                return (norm === 0 ? 360 : norm).toString().padStart(3, '0');
            }
        });
        this.distance = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(NaN));
        this.approach = ComputedSubject.create(this.props.data.get().bestApproach, (v) => {
            if (v) {
                return v;
            }
            else {
                return 'VFR';
            }
        });
        this.freqType = ComputedSubject.create(this.props.data.get().frequency, (v) => {
            switch (v === null || v === void 0 ? void 0 : v.type) {
                case FacilityFrequencyType.Tower:
                    return 'TOWER';
                case FacilityFrequencyType.Unicom:
                    return 'UNICOM';
                case FacilityFrequencyType.Multicom:
                case FacilityFrequencyType.CTAF:
                    return 'MULTICOM';
                default:
                    return '';
            }
        });
        this.frequency = ComputedSubject.create(this.props.data.get().frequency, (v) => {
            if (v === null || v === void 0 ? void 0 : v.freqMHz) {
                return v.freqMHz.toFixed(3);
            }
            else {
                return '';
            }
        });
        this.rwyLength = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(NaN));
        this.frequencyControlRef = FSComponent.createRef();
        this.isVisible = true;
    }
    /**
     * Gets a boolean indicating if this control is able to be focused.
     * @returns true
     */
    getIsFocusable() {
        return this.isVisible && super.getIsFocusable();
    }
    /**
     * Hide this after render, until we get our first update, to avoid showing empty fields.
     */
    onAfterRender() {
        this.props.data.sub((v) => { this.updateData(v); }, true);
    }
    /** @inheritdoc */
    getHighlightElement() {
        return this.fixEl.instance.firstElementChild;
    }
    /**
     * Update our data when the subbed item changes.
     * @param v The new data.
     */
    updateData(v) {
        var _a;
        this.ident.set((_a = v.facility) === null || _a === void 0 ? void 0 : _a.icao);
        if (v.facility) {
            this.bearing.set(v.bearing);
            this.distance.set(v.distance, UnitType.METER);
            this.approach.set(v.bestApproach);
            this.freqType.set(v.frequency);
            this.frequency.set(v.frequency);
            if (v.frequency) {
                this.frequencyControlRef.instance.setIsEnabled(true);
            }
            else {
                this.frequencyControlRef.instance.setIsEnabled(false);
            }
            this.rwyLength.set(v.bestLength, UnitType.METER);
            this.setVisibility(true);
        }
        else {
            this.setVisibility(false);
        }
    }
    /**
     * Sets the visibility of this item.
     * @param value Whether this item should be visible.
     */
    setVisibility(value) {
        if (this.isVisible === value) {
            return;
        }
        if (value) {
            this.fixEl.instance.style.display = '';
        }
        else {
            this.blur();
            this.fixEl.instance.style.display = 'none';
        }
        this.isVisible = value;
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: 'nearest-airport-item', ref: this.fixEl },
            FSComponent.buildComponent("div", { class: 'nearest-airport-row nearest-airport-row1' },
                FSComponent.buildComponent(GenericControl, { onRegister: this.register, onDirectTo: () => this.props.directToHandler(this.props.data.get().facility), class: 'nearest-airport-name' },
                    FSComponent.buildComponent("span", null, this.ident)),
                FSComponent.buildComponent(WaypointIcon, { waypoint: this.props.data.map(v => v.facility ? this.facWaypointCache.get(v.facility) : null), planeHeading: this.props.planeHeading, class: 'nearest-airport-symbol' }),
                FSComponent.buildComponent("span", { class: 'nearest-airport-bearing' },
                    this.bearing,
                    "\u00B0"),
                FSComponent.buildComponent(NumberUnitDisplay, { value: this.distance, displayUnit: Subject.create(UnitType.NMILE), formatter: NumberFormatter.create({ precision: 0.1, maxDigits: 3, forceDecimalZeroes: false, nanString: '__._' }), class: 'nearest-airport-distance' }),
                FSComponent.buildComponent("span", { class: 'nearest-airport-approach' }, this.approach)),
            FSComponent.buildComponent("div", { class: 'nearest-airport-row nearest-airport-row2' },
                FSComponent.buildComponent("span", { class: 'nearest-airport-freqtype' }, this.freqType),
                FSComponent.buildComponent(GenericControl, { ref: this.frequencyControlRef, onRegister: this.register, onEnter: () => this.props.frequencyHandler(this.frequency.get()) },
                    FSComponent.buildComponent("span", { class: 'nearest-airport-frequency cyan' }, this.frequency)),
                FSComponent.buildComponent("div", { class: 'nearest-airport-rwy' },
                    FSComponent.buildComponent("span", { class: 'nearest-airport-rwy-title' }, "RWY"),
                    " ",
                    FSComponent.buildComponent(NumberUnitDisplay, { value: this.rwyLength, displayUnit: Subject.create(UnitType.FOOT), formatter: NumberFormatter.create({ precision: 1, nanString: '_____' }), class: 'nearest-airport-rwy-number' })))));
    }
}

/**
 * The PFD nearest airports popout.
 */
class Nearest extends UiView {
    /**
     * Creates an instance of a nearest airport box.
     * @param props The props.
     */
    constructor(props) {
        super(props);
        this.nearestListContainerRef = FSComponent.createRef();
        this.noneMsgRef = FSComponent.createRef();
        this.planePosHandler = this.onGps.bind(this);
        this.planeHeadingHandler = this.onPlaneHeadingChanged.bind(this);
        this.buildNearestItem = (data, registerFn) => {
            return (FSComponent.buildComponent(NearestAirportItem, { onRegister: registerFn, data: data, planeHeading: this.store.planeHeading, directToHandler: this.controller.onDirectIdentHandler, frequencyHandler: this.controller.onEnterFreqHandler }));
        };
        this.store = new NearestStore(this.props.loader);
        this.publisher = this.props.publisher;
        this.controller = new NearestController(this.store, this.publisher);
        this.planePosConsumer = this.props.bus.getSubscriber().on('gps-position').atFrequency(1);
        this.planeHeadingConsumer = this.props.bus.getSubscriber().on('hdg_deg_true').atFrequency(1);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAfterRender() {
        this.store.airportCount.sub(this.onAirportCountChanged.bind(this), true);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.UPPER_PUSH:
                this.toggleScroll();
                return true;
            case FmsHEvent.CLR:
                this.close();
                return true;
        }
        return false;
    }
    /**
     * Set up the strobed update when the nearest popup is open.
     */
    onViewOpened() {
        this.setScrollEnabled(true);
        this.scrollController.gotoFirst();
        this.planePosConsumer.handle(this.planePosHandler);
        this.planeHeadingConsumer.handle(this.planeHeadingHandler);
    }
    /**
     * When the popup is closed, kill the update to save cycles.
     */
    onViewClosed() {
        this.planePosConsumer.off(this.planePosHandler);
        this.planeHeadingConsumer.off(this.planeHeadingHandler);
    }
    /**
     * Handle a GPS update.
     * @param pos The current LatLongAlt
     */
    onGps(pos) {
        this.store.planePos.set(pos.lat, pos.long);
    }
    /**
     * A callback which is called when the airplane's true heading changes.
     * @param heading The airplane's current true heading.
     */
    onPlaneHeadingChanged(heading) {
        this.store.planeHeading.set(heading);
    }
    /**
     * A callback which is called when the number of airports in the nearest list changes.
     * @param count The number of airports in the nearest list.
     */
    onAirportCountChanged(count) {
        if (count === 0) {
            this.noneMsgRef.instance.style.display = '';
        }
        else {
            this.noneMsgRef.instance.style.display = 'none';
        }
    }
    /**
     * Render the component.
     * @returns a VNode
     */
    render() {
        return (FSComponent.buildComponent("div", { class: 'popout-dialog pfd-nearest-airport', ref: this.viewContainerRef },
            FSComponent.buildComponent("h1", null, this.props.title),
            FSComponent.buildComponent("div", { class: 'nearest-airport-popout-container', ref: this.nearestListContainerRef },
                FSComponent.buildComponent(List, { onRegister: this.register, data: this.store.nearestSubjectList, renderItem: this.buildNearestItem, scrollContainer: this.nearestListContainerRef }),
                FSComponent.buildComponent("div", { ref: this.noneMsgRef, class: 'nearest-airport-none' },
                    "None within 200",
                    FSComponent.buildComponent("span", { class: 'nearest-airport-none-unit' }, "NM"))),
            FSComponent.buildComponent(ScrollBar, null)));
    }
}

/** Select approach store */
class SelectApproachStore {
    /**
     * Constructor.
     */
    constructor() {
        this.minimumsSubject = Subject.create(0);
        this.frequencySubject = ComputedSubject.create(undefined, (v) => {
            if (v !== undefined && v.freqMHz) {
                return v.freqMHz.toFixed(2);
            }
            return '___.__';
        });
        this.minsToggleOptions = ['Off', 'BARO']; //, 'TEMP COMP'];
        this.minimumsMode = Subject.create(0);
        this.selectedApproach = Subject.create(undefined);
        this.selectedTransIndex = Subject.create(-1);
        this._approaches = ArraySubject.create();
        this.approaches = this._approaches;
        this._transitions = ArraySubject.create();
        this.transitions = this._transitions;
        this.inputValue = Subject.create('');
        this.sequence = ArraySubject.create();
        this.selectedApproach.sub(this.onSelectedApproachChanged.bind(this));
    }
    /**
     * Sets the data to display the facility.
     * @param facility The airport facility to be shown.
     */
    loadFacility(facility) {
        this.selectedFacility = facility;
        this._approaches.clear();
        this._transitions.clear();
        this._approaches.set(this.getApproaches());
    }
    /**
     * Empties the display content when no facility is selected
     */
    clearFacility() {
        this.selectedFacility = undefined;
        this._approaches.clear();
        this._transitions.clear();
    }
    /**
     * Gets the approaches array.
     * @returns The approaches.
     */
    getApproaches() {
        if (this.selectedFacility !== undefined) {
            const ilsFound = new Set();
            for (const approach of this.selectedFacility.approaches) {
                if (approach.approachType == ApproachType.APPROACH_TYPE_ILS) {
                    ilsFound.add(approach.runway);
                }
            }
            const approaches = [];
            this.selectedFacility.approaches.forEach((approach, index) => {
                if (approach.approachType !== ApproachType.APPROACH_TYPE_LOCALIZER || !ilsFound.has(approach.runway)) {
                    approaches.push({
                        approach,
                        index,
                        isVisualApproach: false
                    });
                }
            });
            this.getVisualApproaches(this.selectedFacility).forEach(va => {
                approaches.push({
                    approach: va,
                    index: -1,
                    isVisualApproach: true
                });
            });
            return approaches;
        }
        return [];
    }
    /**
     * Gets the visual approaches for the facility.
     * @param facility is the facility.
     * @returns The Approach Procedures.
     */
    getVisualApproaches(facility) {
        const runways = [];
        for (let i = 0; i < facility.runways.length; i++) {
            RunwayUtils.getOneWayRunways(facility.runways[i], i).forEach(rw => { runways.push(rw); });
        }
        const approaches = [];
        runways.forEach(r => {
            approaches.push({
                name: `VISUAL ${r.designation}`,
                runway: r.designation,
                icaos: [],
                transitions: [],
                finalLegs: [],
                missedLegs: [],
                approachType: AdditionalApproachType.APPROACH_TYPE_VISUAL,
                approachSuffix: '',
                runwayDesignator: r.runwayDesignator,
                runwayNumber: r.direction,
                rnavTypeFlags: RnavTypeFlags.None
            });
        });
        return approaches;
    }
    /**
     * Responds to changes in the selected approach.
     */
    onSelectedApproachChanged() {
        this.refreshTransitions();
        this.refreshApproachFrequencyText();
    }
    /**
     * Refreshes the transitions array to reflect the transition list of the currently selected approach.
     */
    refreshTransitions() {
        var _a;
        const approach = (_a = this.selectedApproach.get()) === null || _a === void 0 ? void 0 : _a.approach;
        const transitions = [];
        if (approach) {
            for (let i = 0; i < approach.transitions.length; i++) {
                const listItems = FmsUtils.getOffsetTransitions(approach, i);
                listItems.forEach(item => transitions.push(item));
            }
            transitions.splice(0, 0, { name: 'VECTORS', transitionIndex: -1 });
        }
        this._transitions.set(transitions);
    }
    /**
     * Refreshes the approach frequency text to reflect the frequency of the currently selected approach.
     */
    refreshApproachFrequencyText() {
        const selectedApproach = this.selectedApproach.get();
        if (this.selectedFacility && selectedApproach) {
            this.frequencySubject.set(FmsUtils.getApproachFrequency(this.selectedFacility, selectedApproach.index));
        }
        else {
            this.frequencySubject.set(undefined);
        }
    }
}

/**
 * A view for selecting approaches.
 */
class SelectApproach extends UiView {
    constructor() {
        super(...arguments);
        this.store = new SelectApproachStore();
        this.controller = this.createController();
        this.sortedApproachSub = SortedMappedSubscribableArray.create(this.store.approaches, this.sortApproaches.bind(this));
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.CLR:
                this.close();
                return true;
        }
        return false;
    }
    /** @inheritdoc */
    onViewOpened() {
        this.controller.initialize();
    }
    /** Goto and activate next select control. */
    gotoNextSelect() {
        this.scrollController.gotoNext();
        setTimeout(() => {
            const focusedCtrl = this.scrollController.getFocusedUiControl();
            if (focusedCtrl instanceof SelectControl) {
                if (focusedCtrl.MenuItems.length > 1) {
                    focusedCtrl.onUpperKnob();
                }
                else {
                    this.gotoNextSelect();
                }
            }
        }, 50);
    }
    /** @inheritdoc */
    onAfterRender() {
        super.onAfterRender();
        const g1000Events = this.props.bus.getSubscriber();
        g1000Events.on('set_minimums').handle((set) => {
            if (set !== this.store.minimumsSubject.get()) {
                this.store.minimumsSubject.set(set);
            }
        });
        g1000Events.on('show_minimums').handle((mode) => {
            const option = mode ? 1 : 0;
            this.store.minimumsMode.set(option);
        });
    }
    /**
     * Sorts approaches into the order they should appear in the approach list.
     * @param a An approach list item.
     * @param b An approach list item.
     * @returns 0 if the two approaches are to be sorted identically, a negative number if approach `a` is to be sorted
     * before `b`, or a positive number if approach `a` is to be sorted after `b`.
     */
    sortApproaches(a, b) {
        // sort first by approach type (ILS, LOC, RNAV, etc)
        let compare = SelectApproach.APPROACH_TYPE_PRIORITIES[a.approach.approachType] - SelectApproach.APPROACH_TYPE_PRIORITIES[b.approach.approachType];
        if (compare === 0) {
            // then sort by runway (circling approaches go last)
            compare = (a.approach.runwayNumber === 0 ? 37 : a.approach.runwayNumber) - (b.approach.runwayNumber === 0 ? 37 : b.approach.runwayNumber);
            if (compare === 0) {
                // then sort by L, C, R (order depends on if runway number is <= 18)
                const priorities = a.approach.runwayNumber <= 18
                    ? SelectApproach.APPROACH_RUNWAY_DESIGNATOR_PRIORITIES_FWD
                    : SelectApproach.APPROACH_RUNWAY_DESIGNATOR_PRIORITIES_REV;
                compare = priorities[a.approach.runwayDesignator] - priorities[b.approach.runwayDesignator];
                if (compare === 0) {
                    // finally sort by approach suffix
                    compare = a.approach.approachSuffix.localeCompare(b.approach.approachSuffix);
                }
            }
        }
        return compare;
    }
    /**
     * Renders the waypoint input component.
     * @returns The rendered waypoint input component, as a VNode.
     */
    renderWaypointInput() {
        return (FSComponent.buildComponent(WaypointInput, { bus: this.props.bus, onRegister: this.register, onInputEnterPressed: this.gotoNextSelect.bind(this), selectedIcao: this.controller.inputIcao, onFacilityChanged: this.controller.facilityChangedHandler, filter: FacilitySearchType.Airport }));
    }
    /**
     * Renders the approach select control component.
     * @param dialogPosition The position of the pop-up context menu dialog spawned by the select control.
     * @returns The rendered approach select control component, as a VNode.
     */
    renderApproachSelectControl(dialogPosition) {
        return (FSComponent.buildComponent(SelectControl, { onRegister: this.register, outerContainer: this.viewContainerRef, data: this.sortedApproachSub, onItemSelected: this.controller.onApproachSelected, buildMenuItem: this.controller.buildApprMenuItem, dialogPosition: dialogPosition, class: 'slct-appr-value' }));
    }
    /**
     * Renders the transition select control component.
     * @param dialogPosition The position of the pop-up context menu dialog spawned by the select control.
     * @returns The rendered transition select control component, as a VNode.
     */
    renderTransitionSelectControl(dialogPosition) {
        return (FSComponent.buildComponent(SelectControl, { onRegister: this.register, outerContainer: this.viewContainerRef, data: this.store.transitions, onItemSelected: this.controller.onTransSelected, buildMenuItem: this.controller.buildTransMenuItem, dialogPosition: dialogPosition, class: 'slct-appr-trans-value' }));
    }
    /**
     * Renders the minimums number input component.
     * @param cssClass CSS class(es) to apply to the number input component.
     * @returns The minimums number input component, as a VNode.
     */
    renderMinimumsNumberInput(cssClass) {
        return (FSComponent.buildComponent(NumberInput, { onRegister: this.register, onValueChanged: this.controller.updateMinimumsValue, dataSubject: this.store.minimumsSubject, minValue: -1000, maxValue: 10000, increment: 10, wrap: false, defaultDisplayValue: '_ _ _ _ _', class: cssClass }));
    }
}
SelectApproach.APPROACH_TYPE_PRIORITIES = {
    [ApproachType.APPROACH_TYPE_ILS]: 0,
    [ApproachType.APPROACH_TYPE_LOCALIZER]: 1,
    [ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE]: 2,
    [ApproachType.APPROACH_TYPE_LDA]: 3,
    [ApproachType.APPROACH_TYPE_SDF]: 4,
    [ApproachType.APPROACH_TYPE_RNAV]: 5,
    [ApproachType.APPROACH_TYPE_GPS]: 6,
    [ApproachType.APPROACH_TYPE_VORDME]: 7,
    [ApproachType.APPROACH_TYPE_VOR]: 8,
    [ApproachType.APPROACH_TYPE_NDBDME]: 9,
    [ApproachType.APPROACH_TYPE_NDB]: 10,
    [AdditionalApproachType.APPROACH_TYPE_VISUAL]: 11,
    [ApproachType.APPROACH_TYPE_UNKNOWN]: 12
};
SelectApproach.APPROACH_RUNWAY_DESIGNATOR_PRIORITIES_FWD = {
    [RunwayDesignator.RUNWAY_DESIGNATOR_NONE]: 0,
    [RunwayDesignator.RUNWAY_DESIGNATOR_CENTER]: 1,
    [RunwayDesignator.RUNWAY_DESIGNATOR_LEFT]: 2,
    [RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT]: 3,
    [RunwayDesignator.RUNWAY_DESIGNATOR_WATER]: 4,
    [RunwayDesignator.RUNWAY_DESIGNATOR_B]: 5,
    [RunwayDesignator.RUNWAY_DESIGNATOR_A]: 6,
};
SelectApproach.APPROACH_RUNWAY_DESIGNATOR_PRIORITIES_REV = {
    [RunwayDesignator.RUNWAY_DESIGNATOR_NONE]: 0,
    [RunwayDesignator.RUNWAY_DESIGNATOR_CENTER]: 1,
    [RunwayDesignator.RUNWAY_DESIGNATOR_LEFT]: 3,
    [RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT]: 2,
    [RunwayDesignator.RUNWAY_DESIGNATOR_WATER]: 4,
    [RunwayDesignator.RUNWAY_DESIGNATOR_B]: 5,
    [RunwayDesignator.RUNWAY_DESIGNATOR_A]: 6,
};

/** Select approach controller */
class SelectApproachController {
    /**
     * Creates an instance of select approach controller.
     * @param store The store.
     * @param selectNextCb Callback when the next control should be focused.
     * @param fms Instance of FMS.
     * @param fplKey The FPL ViewService Key.
     * @param hasSequence If this instance of the controller should support a sequence display.
     */
    constructor(store, selectNextCb, fms, fplKey, hasSequence = false) {
        this.store = store;
        this.selectNextCb = selectNextCb;
        this.fms = fms;
        this.fplKey = fplKey;
        this.hasSequence = hasSequence;
        this.inputIcao = Subject.create('');
        this.canLoad = Subject.create(false);
        this.canActivate = Subject.create(false);
        this.canLoadOrText = ComputedSubject.create(false, (v) => { return v ? 'OR' : ''; });
        this.skipCourseReversal = false;
        /**
         * Handler method to handle when the facility in wpt input changed.
         * @param facility The facility selected in wpt input.
         */
        this.facilityChangedHandler = async (facility) => {
            this.store.clearFacility();
            if (facility !== undefined) {
                this.store.loadFacility(facility);
                this.skipCourseReversal = false;
            }
        };
        /**
         * Evaluates if the next select should be focused.
         * @param isRefresh If select event happened based on a data refresh.
         */
        this.gotoNextSelect = (isRefresh) => {
            if (!isRefresh) {
                this.selectNextCb();
            }
        };
        /**
         * Callback handler for when a minimums option is selected.
         * @param index The index of the option selected.
         */
        this.onMinimumsOptionSelected = (index) => {
            this.store.minimumsMode.set(index);
            Fms.g1000EvtPub.publishEvent('show_minimums', index === 1);
        };
        /** Callback handler for  when a minimums value is selected. */
        this.updateMinimumsValue = () => {
            Fms.g1000EvtPub.publishEvent('set_minimums', this.store.minimumsSubject.get());
        };
        /**
         * Callback handler for when a approach procedure is selected.
         * @param index The index of the procedure selected.
         * @param item The item selected.
         * @param isRefresh If select event happened based on a data refresh.
         */
        this.onApproachSelected = (index, item, isRefresh) => {
            this.store.selectedApproach.set(item);
            const validApproachSelected = !!item;
            this.canActivate.set(validApproachSelected);
            this.canLoad.set(validApproachSelected && this.fms.canApproachLoad());
            this.gotoNextSelect(isRefresh);
            this.buildSequence();
        };
        /**
         * Builds a approach procedure menu item.
         * @param proc The approach procedure.
         * @param index The index of the procedure.
         * @returns A menu item definition.
         */
        this.buildApprMenuItem = (proc, index) => {
            return {
                id: index.toString(), renderContent: () => (FSComponent.buildComponent(ApproachNameDisplay, { approach: Subject.create(proc.approach) })),
                estimatedWidth: proc.approach.name.length * ContextMenuDialog.CHAR_WIDTH
            };
        };
        /**
         * Callback handler for when a transition is selected.
         * @param index The index of the transition selected.
         * @param item The item selected.
         * @param isRefresh If select event happened based on a data refresh.
         */
        this.onTransSelected = (index, item, isRefresh) => {
            var _a;
            this.store.selectedTransIndex.set(index);
            this.buildSequence();
            if (this.hasSequence && this.checkForCourseReversal()) {
                const icao = (_a = this.store.sequence.tryGet(1)) === null || _a === void 0 ? void 0 : _a.get().leg.fixIcao;
                Fms.viewService.open('MessageDialog', true).setInput(this.getCourseReversalDialogDef(ICAO.getIdent(icao !== null && icao !== void 0 ? icao : ''))).onAccept.on((sender, accept) => {
                    this.skipCourseReversal = !accept;
                    if (this.skipCourseReversal) {
                        this.store.sequence.removeAt(1);
                    }
                    this.gotoNextSelect(isRefresh);
                });
            }
            else {
                this.gotoNextSelect(isRefresh);
            }
        };
        /**
         * Builds a trans menu item.
         * @param trans The transition.
         * @param index The index of the transition.
         * @returns A menu item definition.
         */
        this.buildTransMenuItem = (trans, index) => {
            var _a;
            const transition = (_a = this.store.selectedApproach.get()) === null || _a === void 0 ? void 0 : _a.approach.transitions[trans.transitionIndex];
            const name = !transition ? 'VECTORS' : transition.legs.length == 0 ? 'NOLEGS' : trans.name && trans.name.length > 0 ? trans.name : 'NONAME';
            return { id: index.toString(), renderContent: () => FSComponent.buildComponent("span", null, name), estimatedWidth: name.length * ContextMenuDialog.CHAR_WIDTH };
        };
        /** Callback handler for when load is pressed. */
        this.onLoadExecuted = () => {
            const selectedFacility = this.store.selectedFacility;
            const approach = this.store.selectedApproach.get();
            if (selectedFacility && approach) {
                const transIndex = this.store.transitions.get(this.store.selectedTransIndex.get()).transitionIndex;
                const legOffset = this.store.transitions.get(this.store.selectedTransIndex.get()).startIndex;
                this.handleExecute(false, selectedFacility, approach, transIndex, legOffset);
            }
        };
        /** Callback handler for when activate is pressed. */
        this.onActivateExecuted = () => {
            const selectedFacility = this.store.selectedFacility;
            const approach = this.store.selectedApproach.get();
            if (selectedFacility && approach) {
                const transIndex = this.store.transitions.get(this.store.selectedTransIndex.get()).transitionIndex;
                const legOffset = this.store.transitions.get(this.store.selectedTransIndex.get()).startIndex;
                this.handleExecute(true, selectedFacility, approach, transIndex, legOffset);
            }
        };
        /**
         * Renders the procedure warning vnode (when we need to pass HTML).
         * @param warningMessage The dialog message content.
         * @param warningTitle The dialog message title content.
         * @returns A VNode to be rendered in the MessageDialog.
         */
        this.renderProcedureWarningDialogContent = (warningMessage, warningTitle) => {
            return (FSComponent.buildComponent("div", null,
                warningTitle,
                FSComponent.buildComponent("p", null),
                warningMessage));
        };
        const fpl = this.fms.bus.getSubscriber();
        fpl.on('fplCalculated').handle((e) => {
            if (e.planIndex == 2) {
                const plan = this.fms.flightPlanner.getFlightPlan(2);
                if (plan.segmentCount > 0) {
                    const segment = plan.getSegment(0);
                    for (let i = 0; i < segment.legs.length; i++) {
                        const leg = this.store.sequence.tryGet(i);
                        if (leg !== undefined) {
                            leg.get().calculated = segment.legs[i].calculated;
                            leg.notify();
                        }
                    }
                }
            }
        });
        this.canLoad.sub(v => this.canLoadOrText.set(v));
    }
    /** Initialize the controller. */
    initialize() {
        var _a;
        const initIcao = (_a = this.getInitialICAO()) !== null && _a !== void 0 ? _a : '';
        this.inputIcao.set(initIcao);
        if (initIcao !== '') {
            setTimeout(() => {
                this.gotoNextSelect(false);
            }, 100);
        }
    }
    /** @inheritdoc */
    getInitialICAO() {
        let icao;
        const dtoTargetIcao = this.fms.getDirectToTargetIcao();
        if (dtoTargetIcao !== undefined && ICAO.isFacility(dtoTargetIcao) && ICAO.getFacilityType(dtoTargetIcao) === FacilityType.Airport) {
            icao = dtoTargetIcao;
        }
        else if (this.fms.hasPrimaryFlightPlan()) {
            const plan = this.fms.getPrimaryFlightPlan();
            icao = plan.destinationAirport;
            if (icao === undefined) {
                // get the LAST airport in the flight plan.
                // TODO: would be nice to be able to iterate thru legs in reverse order
                for (const leg of plan.legs()) {
                    if (leg.isInDirectToSequence) {
                        continue;
                    }
                    switch (leg.leg.type) {
                        case LegType.IF:
                        case LegType.TF:
                        case LegType.DF:
                        case LegType.CF:
                        case LegType.AF:
                        case LegType.RF:
                            if (ICAO.isFacility(leg.leg.fixIcao) && ICAO.getFacilityType(leg.leg.fixIcao) === FacilityType.Airport) {
                                icao = leg.leg.fixIcao;
                            }
                            break;
                    }
                }
            }
        }
        return icao;
    }
    /**
     * Builds the sequence list for the approach preview
     */
    buildSequence() {
        const approach = this.store.selectedApproach.get();
        if (!approach) {
            return;
        }
        const legs = [];
        if (this.store.selectedFacility !== undefined) {
            let previewPlanIndex = -1;
            if (approach.isVisualApproach) {
                previewPlanIndex = this.fms.buildProcedurePreviewPlan(this.store.selectedFacility, ProcedureType.VISUALAPPROACH, -1, -1, undefined, undefined, approach.approach.runwayNumber, approach.approach.runwayDesignator);
            }
            else {
                const selectedTransIndex = this.store.selectedTransIndex.get();
                const transIndex = selectedTransIndex > -1 ? this.store.transitions.get(selectedTransIndex).transitionIndex : -1;
                const legOffset = selectedTransIndex > -1 ? this.store.transitions.get(selectedTransIndex).startIndex : 0;
                previewPlanIndex = this.fms.buildProcedurePreviewPlan(this.store.selectedFacility, ProcedureType.APPROACH, approach.index, transIndex, undefined, undefined, undefined, legOffset !== undefined ? legOffset : 0);
            }
            const previewPlan = this.fms.getFlightPlan(previewPlanIndex);
            previewPlan.getSegment(0).legs.forEach((l) => {
                legs.push(Subject.create(l));
            });
            this.store.sequence.set(legs);
        }
    }
    /**
     * Checks for a course reversal in the procedure.
     * @returns true if there is an optional course reversal.
     */
    checkForCourseReversal() {
        const legs = this.store.sequence.getArray();
        if (legs && legs.length > 0) {
            const leg = legs[1].get();
            switch (leg.leg.type) {
                case LegType.HA:
                case LegType.HF:
                case LegType.HM:
                    return true;
            }
        }
        return false;
    }
    /**
     * Handles loading and executing the approach with appropriate warning messages.
     * @param activate Whether or not to activate this approach.
     * @param facility The facility for the approach.
     * @param approach The Approach List Item to execute with.
     * @param approachTransitionIndex The transition index for the approach procedure.
     * @param transStartIndex The transition start index, if specified.
     */
    handleExecute(activate, facility, approach, approachTransitionIndex, transStartIndex) {
        var _a;
        const trueApproachIndex = approach.index;
        if (!approach.isVisualApproach) {
            const procedure = approach.approach;
            const insertApproach = (skipReversal) => {
                if (!FmsUtils.isGpsApproach(procedure)) {
                    const input = {
                        renderContent: () => this.renderProcedureWarningDialogContent('GPS guidance is for monitoring only. Load approach?', '- NOT APPROVED FOR GPS -'),
                        confirmButtonText: 'YES',
                        hasRejectButton: true,
                        rejectButtonText: 'NO'
                    };
                    Fms.viewService.open('MessageDialog', true).setInput(input).onAccept.on((sender, accept) => {
                        if (accept) {
                            this.fms.insertApproach(facility, trueApproachIndex, approachTransitionIndex, undefined, undefined, transStartIndex, skipReversal);
                            if (activate) {
                                this.fms.activateApproach();
                            }
                            Fms.viewService.open(this.fplKey);
                        }
                    });
                }
                else {
                    this.fms.insertApproach(facility, trueApproachIndex, approachTransitionIndex, undefined, undefined, transStartIndex, skipReversal);
                    if (activate) {
                        this.fms.activateApproach();
                    }
                    Fms.viewService.open(this.fplKey);
                }
            };
            if (this.checkForCourseReversal() && !this.hasSequence) {
                const icao = (_a = this.store.sequence.tryGet(1)) === null || _a === void 0 ? void 0 : _a.get().leg.fixIcao;
                const input = this.getCourseReversalDialogDef(ICAO.getIdent(icao !== null && icao !== void 0 ? icao : ''));
                input.closeOnAccept = false;
                Fms.viewService.open('MessageDialog', true).setInput(input).onAccept.on((sender, accept) => {
                    const skipReversal = !accept;
                    insertApproach(skipReversal);
                });
            }
            else if (this.hasSequence) {
                insertApproach(this.skipCourseReversal);
            }
            else {
                insertApproach(false);
            }
        }
        else {
            const runwayNumber = approach.approach.runwayNumber;
            const RunwayDesignator = approach.approach.runwayDesignator;
            Fms.viewService.open('MessageDialog', true).setInput({ inputString: 'Obstacle clearance is not provided for visual approaches', hasRejectButton: true })
                .onAccept.on((sender, accept) => {
                if (accept) {
                    this.fms.insertApproach(facility, -1, -1, runwayNumber, RunwayDesignator);
                    if (activate) {
                        this.fms.activateApproach();
                    }
                    Fms.viewService.open(this.fplKey);
                }
            });
        }
    }
    /**
     * Gets the MenuDialogDefinition for a course reversal dialog message.
     * @param fixName The name of the fix where the course reversal is.
     * @returns A MessageDialogDefinition.
     */
    getCourseReversalDialogDef(fixName) {
        return { inputString: `Fly Course Reversal at ${fixName}?`, confirmButtonText: 'YES', hasRejectButton: true, rejectButtonText: 'NO' };
    }
}

/**
 * A PFD view for selecting approaches.
 */
class PFDSelectApproach extends SelectApproach {
    /** @inheritdoc */
    createController() {
        return new SelectApproachController(this.store, this.gotoNextSelect.bind(this), this.props.fms, 'FPL', false);
    }
    /**
     * A callback which is called when the Load action is executed.
     */
    onLoadExecuted() {
        this.controller.onLoadExecuted();
    }
    /**
     * A callback which is called when the Activate action is executed.
     */
    onActivateExecuted() {
        this.controller.onActivateExecuted();
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: 'popout-dialog', ref: this.viewContainerRef },
            FSComponent.buildComponent("h1", null, this.props.title),
            this.renderWaypointInput(),
            FSComponent.buildComponent("hr", null),
            FSComponent.buildComponent("div", { class: "slct-appr-container" },
                FSComponent.buildComponent("div", { class: "slct-appr-label" }, "APR"),
                this.renderApproachSelectControl(ContextMenuPosition.CENTER),
                FSComponent.buildComponent("div", { class: "slct-appr-trans-label" }, "TRANS"),
                this.renderTransitionSelectControl(ContextMenuPosition.CENTER),
                FSComponent.buildComponent("div", { class: "slct-appr-rnav-id" }, "ID _ _ _ _ _"),
                FSComponent.buildComponent("div", { class: "slct-appr-mins-label" }, "MINS"),
                FSComponent.buildComponent(ArrowToggle, { class: "slct-appr-mins-toggle", onRegister: this.register, onOptionSelected: this.controller.onMinimumsOptionSelected, options: this.store.minsToggleOptions, dataref: this.store.minimumsMode }),
                FSComponent.buildComponent("div", { "data-id": "select-min", class: "slct-appr-mins-value cyan size18" }),
                FSComponent.buildComponent("div", { class: "slct-appr-mins-value" },
                    this.renderMinimumsNumberInput(),
                    FSComponent.buildComponent("span", { class: "size12" }, "FT")),
                FSComponent.buildComponent("div", { class: "slct-appr-freq-label" }, "PRIM FREQ"),
                FSComponent.buildComponent("div", { "data-id": "select-freq", class: "slct-appr-freq-value cyan size18" }, this.store.frequencySubject),
                FSComponent.buildComponent("div", { class: "slct-appr-freq-ident" }, "IVII")),
            FSComponent.buildComponent("hr", null),
            FSComponent.buildComponent(ActionButton, { onRegister: this.register, class: "slct-appr-load", isVisible: this.controller.canLoad, onExecute: this.onLoadExecuted.bind(this), text: "Load?" }),
            FSComponent.buildComponent("div", { class: "slct-appr-or" }, this.controller.canLoadOrText),
            FSComponent.buildComponent(ActionButton, { onRegister: this.register, class: "slct-appr-activate", isVisible: this.controller.canActivate, onExecute: this.onActivateExecuted.bind(this), text: "Activate?" })));
    }
}

/** The controller for the DTO view */
class DirectToController {
    /**
     * Creates an instance of direct to controller.
     * @param store is the Direct To Store
     * @param fms is the Direct To Controller
     */
    constructor(store, fms) {
        this.store = store;
        this.fms = fms;
        this.inputIcao = Subject.create('');
        this.canActivate = Subject.create(false);
        this.directToExisting = undefined;
        /**
         * A function which handles changes in waypoint input's selected waypoint.
         * @param waypoint The selected waypoint.
         */
        this.waypointChangedHandler = async (waypoint) => {
            var _a;
            const facility = waypoint instanceof FacilityWaypoint ? waypoint.facility : null;
            if ((facility === null || facility === void 0 ? void 0 : facility.icao) !== ((_a = this.directToExisting) === null || _a === void 0 ? void 0 : _a.icao)) {
                this.directToExisting = undefined;
                const plan = this.fms.getFlightPlan();
                for (let i = 0; i < plan.length; i++) {
                    const leg = plan.getLeg(i);
                    if (leg.leg.fixIcao === (facility === null || facility === void 0 ? void 0 : facility.icao) && leg.leg.type !== LegType.FC && leg.leg.type !== LegType.FD && leg.leg.type !== LegType.PI) {
                        const segmentIndex = plan.getSegmentIndex(i);
                        const segment = plan.getSegment(segmentIndex);
                        const directToExisting = {
                            segmentIndex: segmentIndex,
                            legIndex: i - segment.offset,
                            icao: facility === null || facility === void 0 ? void 0 : facility.icao
                        };
                        this.directToExisting = directToExisting;
                    }
                }
            }
            this.store.waypoint.set(waypoint);
            this.canActivate.set(!!facility);
        };
        // ---- ACTION CALLBACKS
        this.onActivateSelected = () => {
            const selectedWaypoint = this.store.waypoint.get();
            const facility = selectedWaypoint instanceof FacilityWaypoint ? selectedWaypoint.facility : null;
            if (facility) {
                if (this.directToExisting !== undefined && this.directToExisting.segmentIndex !== undefined && this.directToExisting.legIndex !== undefined) {
                    this.fms.createDirectToExisting(this.directToExisting.segmentIndex, this.directToExisting.legIndex);
                }
                else {
                    this.fms.createDirectToRandom(facility);
                }
                this.directToExisting = undefined;
            }
        };
    }
    /**
     * Initializes the direct to target based on input data. If the input data is defined, the target will be set to that
     * defined by the input data. If the input data is undefined, an attempt will be made to set the target to the
     * following, in order:
     * * The current active direct to target.
     * * The current active flight plan leg.
     * * The next leg in the primary flight plan, following the active leg, that is a valid direct to target.
     * * The previous leg in the primary flight plan, before the active leg, that is a valid direct to target.
     * @param dtoData The input data.
     */
    initializeTarget(dtoData) {
        this.directToExisting = undefined;
        let targetIcao = '';
        if ((dtoData === null || dtoData === void 0 ? void 0 : dtoData.legIndex) !== undefined && (dtoData === null || dtoData === void 0 ? void 0 : dtoData.segmentIndex) !== undefined) {
            this.directToExisting = dtoData;
            targetIcao = dtoData.icao;
        }
        else {
            const dtoState = this.fms.getDirectToState();
            if (dtoState === DirectToState.TOEXISTING) {
                const plan = this.fms.getPrimaryFlightPlan();
                this.directToExisting = {
                    icao: plan.getLeg(plan.activeLateralLeg).leg.fixIcao,
                    segmentIndex: plan.directToData.segmentIndex,
                    legIndex: plan.directToData.segmentLegIndex
                };
                targetIcao = this.directToExisting.icao;
            }
            else if (dtoState === DirectToState.TORANDOM) {
                const plan = this.fms.getDirectToFlightPlan();
                targetIcao = plan.getLeg(plan.activeLateralLeg).leg.fixIcao;
            }
            else if (this.fms.hasPrimaryFlightPlan()) {
                const plan = this.fms.getPrimaryFlightPlan();
                const activeLegIndex = plan.activeLateralLeg;
                let dtoExisting;
                // search forwards in plan for valid DTO target
                const len = plan.length;
                for (let i = activeLegIndex; i < len; i++) {
                    const segmentIndex = plan.getSegmentIndex(i);
                    const segmentLegIndex = i - plan.getSegment(segmentIndex).offset;
                    if (this.fms.canDirectTo(segmentIndex, segmentLegIndex)) {
                        dtoExisting = DirectToController.createDtoExistingData(plan, segmentIndex, segmentLegIndex);
                        break;
                    }
                }
                if (!dtoExisting) {
                    // search backwards in plan for valid DTO target
                    for (let i = activeLegIndex - 1; i >= 0; i--) {
                        const segmentIndex = plan.getSegmentIndex(i);
                        const segmentLegIndex = i - plan.getSegment(segmentIndex).offset;
                        if (this.fms.canDirectTo(segmentIndex, segmentLegIndex)) {
                            dtoExisting = DirectToController.createDtoExistingData(plan, segmentIndex, segmentLegIndex);
                            break;
                        }
                    }
                }
                if (dtoExisting) {
                    this.directToExisting = dtoExisting;
                    targetIcao = dtoExisting.icao;
                }
            }
        }
        this.inputIcao.set(targetIcao);
    }
    /**
     * Creates a direct to existing data object for a flight plan leg.
     * @param plan A flight plan.
     * @param segmentIndex The index of the segment in which the leg resides.
     * @param segmentLegIndex The index of the leg in its segment.
     * @returns A direct to existing data object.
     */
    static createDtoExistingData(plan, segmentIndex, segmentLegIndex) {
        return {
            icao: plan.getSegment(segmentIndex).legs[segmentLegIndex].leg.fixIcao,
            segmentIndex,
            legIndex: segmentLegIndex
        };
    }
}

/** The store for the DTO view */
class DirectToStore {
    /**
     * Constructor.
     * @param planePos A subscribable which provides the current airplane position for this store.
     */
    constructor(planePos) {
        this.planePos = planePos;
        this.waypointInfoStore = new WaypointInfoStore(undefined, planePos);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** A subject which provides this store's selected waypoint. */
    get waypoint() {
        return this.waypointInfoStore.waypoint;
    }
}

/**
 * A view which provides control of the Direct-To function.
 */
class DirectTo extends UiView {
    constructor() {
        super(...arguments);
        this.planePosSub = GeoPointSubject.createFromGeoPoint(new GeoPoint(NaN, NaN));
        this.planeHeadingSub = Subject.create(NaN);
        this.planePosConsumer = this.props.bus.getSubscriber().on('gps-position').whenChanged();
        this.planeHeadingConsumer = this.props.bus.getSubscriber().on('hdg_deg_true').withPrecision(1);
        this.planePosHandler = this.onPlanePosChanged.bind(this);
        this.planeHeadingHandler = this.onPlaneHeadingChanged.bind(this);
        this.store = new DirectToStore(this.planePosSub);
        this.controller = new DirectToController(this.store, this.props.fms);
        this.isOpen = false;
        /** @inheritdoc */
        this.gotoActivateButton = () => {
            this.scrollController.gotoNext();
        };
        /**
         * Callback for when the Hold button is pressed.
         */
        this.onHoldButtonPressed = () => {
            //Do stuff
        };
        /**
         * A callback which is called when the Load action is executed.
         */
        this.onLoadExecuted = () => {
            this.controller.onActivateSelected();
            this.close();
        };
    }
    /** @inheritdoc */
    onInputDataSet(directToInputData) {
        if (this.isOpen) {
            this.controller.initializeTarget(directToInputData);
        }
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.DIRECTTO:
            case FmsHEvent.CLR:
                this.close();
                return true;
        }
        return false;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewOpened() {
        this.isOpen = true;
        this.planePosConsumer.handle(this.planePosHandler);
        this.planeHeadingConsumer.handle(this.planeHeadingHandler);
        this.controller.initializeTarget(this.inputData.get());
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewClosed() {
        this.isOpen = false;
        this.planePosConsumer.off(this.planePosHandler);
        this.planeHeadingConsumer.off(this.planeHeadingHandler);
    }
    /**
     * A callback which is called when the plane's current position changes.
     * @param pos The new position.
     */
    onPlanePosChanged(pos) {
        this.planePosSub.set(pos.lat, pos.long);
    }
    /**
     * A callback which is called when the plane's current true heading changes.
     * @param heading The new heading, in degrees.
     */
    onPlaneHeadingChanged(heading) {
        this.planeHeadingSub.set(heading);
    }
    /**
     * Renders a waypoint input component.
     * @returns a waypoint input component, as a VNode.
     */
    renderWaypointInput() {
        return (FSComponent.buildComponent(WaypointInput, { bus: this.props.bus, onRegister: this.register, onInputEnterPressed: this.gotoActivateButton, onWaypointChanged: this.controller.waypointChangedHandler, selectedIcao: this.controller.inputIcao, filter: FacilitySearchType.None }));
    }
    /**
     * Renders a component which displays the bearing to the store's selected waypoint.
     * @param cssClass CSS class(es) to apply to the root of the component.
     * @returns a component which displays the bearing to the store's selected waypoint, as a VNode.
     */
    renderBearing(cssClass) {
        return (FSComponent.buildComponent(NumberUnitDisplay, { value: this.store.waypointInfoStore.bearing, displayUnit: Subject.create(UnitType.DEGREE), formatter: NumberFormatter.create({ precision: 1, pad: 3, nanString: '___' }), class: cssClass }));
    }
    /**
     * Renders a component which displays the distance to the store's selected waypoint.
     * @param cssClass CSS class(es) to apply to the root of the component.
     * @returns a component which displays the distance to the store's selected waypoint, as a VNode.
     */
    renderDistance(cssClass) {
        return (FSComponent.buildComponent(NumberUnitDisplay, { value: this.store.waypointInfoStore.distance, displayUnit: Subject.create(UnitType.NMILE), formatter: NumberFormatter.create({ precision: 0.1, maxDigits: 3, forceDecimalZeroes: false, nanString: '__._' }), class: cssClass }));
    }
}

/**
 * The PFD direct-to popout.
 */
class PFDDirectTo extends DirectTo {
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: 'popout-dialog pfd-dto', ref: this.viewContainerRef },
            FSComponent.buildComponent("h1", null, this.props.title),
            this.renderWaypointInput(),
            FSComponent.buildComponent("hr", null),
            FSComponent.buildComponent("div", { class: "pfd-dto-alt-offset" },
                FSComponent.buildComponent("div", { class: "offset-grey size14" },
                    "ALT ",
                    FSComponent.buildComponent("span", { class: "cyan" }, "_ _ _ _ _FT")),
                FSComponent.buildComponent("div", { class: "offset-grey size14" },
                    "Offset ",
                    FSComponent.buildComponent("span", { class: "cyan" },
                        "+0",
                        FSComponent.buildComponent("span", { class: "size12 cyan" }, "NM")))),
            FSComponent.buildComponent("hr", null),
            FSComponent.buildComponent("div", { class: 'pfd-dto-wpt-data' },
                FSComponent.buildComponent("div", { class: 'pfd-dto-wpt-data-field pfd-dto-bearing' },
                    FSComponent.buildComponent("div", { class: 'pfd-dto-wpt-data-field-title' }, "BRG"),
                    this.renderBearing()),
                FSComponent.buildComponent("div", { class: 'pfd-dto-wpt-data-field pfd-dto-distance' },
                    FSComponent.buildComponent("div", { class: 'pfd-dto-wpt-data-field-title' }, "DIS"),
                    this.renderDistance()),
                FSComponent.buildComponent("div", { class: 'pfd-dto-wpt-data-field pfd-dto-course' },
                    FSComponent.buildComponent("div", { class: 'pfd-dto-wpt-data-field-title' }, "CRS"),
                    FSComponent.buildComponent("div", null, "- - -\u00B0"))),
            FSComponent.buildComponent(ActionButton, { onRegister: this.register, class: "activate", isVisible: this.controller.canActivate, onExecute: this.onLoadExecuted, text: "Activate?" })));
    }
}

/**
 *
 */
class SetRunwayStore {
    /**
     * Constructor.
     */
    constructor() {
        /** A subject which provides this store's airport. */
        this.airport = Subject.create(null);
        this._airportIdent = Subject.create('');
        /** An array of runways at this store's airport. */
        this.oneWayRunways = ArraySubject.create([]);
        this.airport.sub(this.onAirportChanged.bind(this));
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The ident of this store's airport. */
    get airportIdent() {
        return this._airportIdent;
    }
    /**
     * A callback which is called when this store's airport changes.
     * @param airport The new airport.
     */
    onAirportChanged(airport) {
        var _a;
        this._airportIdent.set(airport ? ICAO.getIdent(airport.icao) : '');
        const runways = (_a = airport === null || airport === void 0 ? void 0 : airport.runways.reduce((acc, runway, index) => {
            acc.push(...RunwayUtils.getOneWayRunways(runway, index));
            return acc;
        }, []).sort(RunwayUtils.sortRunways)) !== null && _a !== void 0 ? _a : [];
        runways.unshift(RunwayUtils.createEmptyOneWayRunway());
        this.oneWayRunways.set(runways);
    }
}

/**
 * A dialog for setting runways.
 */
class SetRunway extends UiView {
    constructor() {
        super(...arguments);
        this.store = new SetRunwayStore();
        this.selectedRunway = undefined;
    }
    /** @inheritdoc */
    onInputDataSet(input) {
        this.store.airport.set(input !== null && input !== void 0 ? input : null);
        this.scrollController.gotoFirst();
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.ENT:
                return this.onEnterPressed();
            case FmsHEvent.CLR:
                return this.onCLRPressed();
        }
        return false;
    }
    /**
     * This method is called when an Enter button event occurs.
     * @returns whether the event was handled.
     */
    onEnterPressed() {
        this.accept(this.selectedRunway, true);
        return true;
    }
    /**
     * This method is called when a CLR button event occurs.
     * @returns whether the event was handled.
     */
    onCLRPressed() {
        this.selectedRunway = undefined;
        this.close();
        return true;
    }
    /**
     * A callback which is called when a runway is selected.
     * @param index The index of the selection.
     * @param runway The runway which was selected.
     */
    onRunwaySelected(index, runway) {
        this.selectedRunway = (runway !== undefined && runway.designation !== '') ? runway : undefined;
    }
    /**
     * Builds a runway menu item definition for a runway.
     * @param runway A runway.
     * @param index The index of the item in the menu.
     * @returns a menu item definition for the runway.
     */
    buildRunwayMenuItem(runway, index) {
        const text = (runway.designation !== '') ? runway.designation : 'NONE';
        return { id: index.toString(), renderContent: () => FSComponent.buildComponent("span", null, text), estimatedWidth: text.length * ContextMenuDialog.CHAR_WIDTH };
    }
}

/**
 * A dialog for setting runways.
 */
class PFDSetRunway extends SetRunway {
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: 'popout-dialog pfd-setrunway', ref: this.viewContainerRef },
            FSComponent.buildComponent("h1", null, this.props.title),
            FSComponent.buildComponent("div", { class: "pfd-setrunway-container" },
                FSComponent.buildComponent("div", { class: "pfd-setrunway-airport" }, "Airport"),
                FSComponent.buildComponent("div", { class: "pfd-setrunway-airport-value" }, this.store.airportIdent),
                FSComponent.buildComponent("div", { class: "pfd-setrunway-runway" }, "Runway"),
                FSComponent.buildComponent(SelectControl, { onRegister: this.register, dialogPosition: ContextMenuPosition.BOTTOM, outerContainer: this.viewContainerRef, data: this.store.oneWayRunways, buildMenuItem: this.buildRunwayMenuItem.bind(this), onItemSelected: this.onRunwaySelected.bind(this), class: "pfd-setrunway-runway-value" }),
                FSComponent.buildComponent("div", { class: "pfd-setrunway-press-ent" }, "Press \"ENT\" to accept"))));
    }
}

/** The controller for SelectProcedure views. */
class SelectProcedureController {
    /**
     * Ctor
     * @param store The store.
     * @param selectNextCb Callback when the next control should be focused.
     * @param fms The FMS instance.
     * @param procType is the procedure type for this controller.
     */
    constructor(store, selectNextCb, fms, procType) {
        this.store = store;
        this.selectNextCb = selectNextCb;
        this.fms = fms;
        this.procType = procType;
        this.inputIcao = Subject.create('');
        this.canLoad = Subject.create(false);
        /**
         * Handler method to handle when the facility in wpt input changed.
         * @param facility The facility selected in wpt input.
         */
        this.facilityChangedHandler = async (facility) => {
            this.store.clearFacility();
            if (facility !== undefined) {
                this.store.loadFacility(facility);
            }
        };
        /**
         * Evaluates if the next select should be focused.
         * @param isRefresh If select event happened based on a data refresh.
         */
        this.gotoNextSelect = (isRefresh) => {
            if (!isRefresh) {
                this.selectNextCb();
            }
        };
        /**
         * Callback handler for when a procedure is selected.
         * @param index The index of the selected procedure.
         * @param item The procedure selected.
         * @param isRefresh If select event happened based on a data refresh.
         */
        this.onProcSelected = (index, item, isRefresh) => {
            this.store.selectedProcIndex.set(index);
            this.store.runways.set((index > -1) ? this.store.getRunways() : []);
            this.store.transitions.set((index > -1) ? this.store.getTransitions() : []);
            this.canLoad.set(this.store.selectedProcIndex.get() !== -1);
            this.buildSequence();
            this.gotoNextSelect(isRefresh);
        };
        /**
         * Builds a procedure menu item.
         * @param proc The procedure to build the menu item for.
         * @param index The index of the procedure.
         * @returns A menu item definition.
         */
        this.buildProcMenuItem = (proc, index) => {
            return { id: index.toString(), renderContent: () => FSComponent.buildComponent("span", null, proc.name), estimatedWidth: proc.name.length * ContextMenuDialog.CHAR_WIDTH };
        };
        /**
         * Callback handler for when a runway transition is selected.
         * @param index The index of the selected transition.
         * @param item The transition selected.
         * @param isRefresh If select event happened based on a data refresh.
         */
        this.onRwySelected = (index, item, isRefresh) => {
            this.store.selectedRwyIndex.set(index);
            this.buildSequence();
            this.gotoNextSelect(isRefresh);
        };
        /**
         * Builds a runway transition menu item.
         * @param rwyTrans The runway transition to build the menu item for.
         * @param index The index of the runway transition.
         * @returns A menu item definition.
         **/
        this.buildRwyMenuItem = (rwyTrans, index) => {
            const name = this.store.getRunwayString(rwyTrans);
            return { id: index.toString(), renderContent: () => FSComponent.buildComponent("span", null, name), estimatedWidth: name.length * ContextMenuDialog.CHAR_WIDTH };
        };
        /**
         * Callback handler for when an enroute transition is selected.
         * @param index The index of the selected transition.
         * @param item The transition selected.
         * @param isRefresh If select event happened based on a data refresh.
         */
        this.onTransSelected = (index, item, isRefresh) => {
            this.store.selectedTransIndex.set(index - 1);
            this.buildSequence();
            this.gotoNextSelect(isRefresh);
        };
        /**
         * Builds a enroute transition menu item.
         * @param trans The transition to build the menu item for.
         * @param index The index of the transition.
         * @returns A menu item definition.
         */
        this.buildTransMenuItem = (trans, index) => {
            const name = trans.name.trim().length < 1 ? 'NONE' : trans.name;
            return {
                id: index.toString(),
                renderContent: () => FSComponent.buildComponent("span", null, name),
                estimatedWidth: name.length * ContextMenuDialog.CHAR_WIDTH
            };
        };
        /** Callback handler for when load is pressed. */
        this.onLoadSelected = () => {
            this.onLoadExecute();
        };
        const fpl = this.fms.bus.getSubscriber();
        fpl.on('fplCalculated').handle((e) => {
            if (e.planIndex == 2) {
                const plan = this.fms.flightPlanner.getFlightPlan(2);
                if (plan.segmentCount > 0) {
                    const segment = plan.getSegment(0);
                    for (let i = 0; i < segment.legs.length; i++) {
                        const leg = this.store.sequence.tryGet(i);
                        if (leg !== undefined) {
                            leg.get().calculated = segment.legs[i].calculated;
                            leg.notify();
                        }
                    }
                }
            }
        });
    }
    /** Initialize the controller. */
    initialize() {
        var _a;
        this.canLoad.set(false);
        const initIcao = (_a = this.getInitialICAO()) !== null && _a !== void 0 ? _a : '';
        this.inputIcao.set(initIcao);
        if (initIcao !== '') {
            setTimeout(() => {
                this.gotoNextSelect(false);
            }, 100);
        }
    }
    /**
     * Builds the sequence list for the approach preview
     */
    buildSequence() {
        if (this.store.selectedProcIndex.get() > -1) {
            const legs = [];
            if (this.store.selectedFacility !== undefined) {
                const previewPlanIndex = this.fms.buildProcedurePreviewPlan(this.store.selectedFacility, this.procType, this.store.selectedProcIndex.get(), this.store.selectedTransIndex.get(), this.store.getOneWayRunway(), this.store.selectedRwyIndex.get());
                const previewPlan = this.fms.getFlightPlan(previewPlanIndex);
                previewPlan.getSegment(0).legs.forEach((l) => {
                    legs.push(Subject.create(l));
                });
                this.store.sequence.set(legs);
            }
        }
    }
}

/** The data store for SelectProcedure pages */
class SelectProcedureStore {
    constructor() {
        this.selectedProcIndex = Subject.create(-1);
        this.selectedRwyIndex = Subject.create(-1);
        this.selectedTransIndex = Subject.create(-1);
        this.procedures = ArraySubject.create();
        this.runways = ArraySubject.create();
        this.transitions = ArraySubject.create();
        this.sequence = ArraySubject.create();
        // /**
        //  * Gets the enroute transitions of the selected procedure.
        //  * @returns The enroute transitions.
        //  */
        // public abstract getTransitions(): readonly EnrouteTransition[];
    }
    /**
     * Sets the data to display the facility.
     * @param facility The airport facility to be shown.
     */
    loadFacility(facility) {
        this.selectedFacility = facility;
        this.procedures.clear();
        this.runways.clear();
        this.transitions.clear();
        this.procedures.set(this.getProcedures());
    }
    /**
     * Empties the display content when no facility is selected
     */
    clearFacility() {
        this.selectedFacility = undefined;
        this.procedures.clear();
        this.runways.clear();
        this.transitions.clear();
    }
    /**
     * Gets the one-way runway from the selected procedure runway
     * @returns the OneWayRunway object or undefined
     */
    getOneWayRunway() {
        if (this.selectedFacility !== undefined && this.selectedRwyIndex.get() > -1) {
            const procRunway = this.getRunwayString(this.procedures.get(this.selectedProcIndex.get()).runwayTransitions[this.selectedRwyIndex.get()]);
            const oneWayRunway = RunwayUtils.matchOneWayRunwayFromDesignation(this.selectedFacility, procRunway);
            if (oneWayRunway !== undefined) {
                return oneWayRunway;
            }
        }
        return undefined;
    }
    /**
     * Gets a runway designation string from the runway transition.
     * @param runwayTransition is the runway transition object
     * @returns The runway designation string.
     */
    getRunwayString(runwayTransition) {
        if (runwayTransition !== undefined) {
            return RunwayUtils.getRunwayNameString(runwayTransition.runwayNumber, runwayTransition.runwayDesignation);
        }
        return '';
    }
    /**
     * Gets the runways of the selected procedure.
     * @returns The runways.
     */
    getRunways() {
        const rwys = this.procedures.get(this.selectedProcIndex.get()).runwayTransitions;
        return rwys;
    }
    /**
     * Gets the enroute transitions of the selected procedure.
     * @returns The enroute transitions.
     */
    getTransitions() {
        const transitions = [];
        const defaultTranstion = { name: this.getTransitionName(-1), legs: [] };
        transitions.push(defaultTranstion);
        const procedureTransitions = this.procedures.get(this.selectedProcIndex.get()).enRouteTransitions;
        for (let i = 0; i < procedureTransitions.length; i++) {
            const transition = procedureTransitions[i];
            transitions.push({ name: this.getTransitionName(i), legs: transition.legs });
        }
        return transitions;
    }
}

/** Controller for SelectDeparture */
class SelectDepartureController extends SelectProcedureController {
    constructor() {
        super(...arguments);
        this.onLoadExecute = () => {
            if (this.store.selectedFacility !== undefined) {
                this.fms.insertDeparture(this.store.selectedFacility, this.store.selectedProcIndex.get(), this.store.selectedRwyIndex.get(), this.store.selectedTransIndex.get(), this.store.getOneWayRunway());
            }
        };
    }
    /** @inheritdoc */
    getInitialICAO() {
        let icao;
        if (this.fms.hasPrimaryFlightPlan()) {
            const plan = this.fms.getPrimaryFlightPlan();
            icao = plan.originAirport;
            if (icao === undefined) {
                // get the FIRST airport in the flight plan.
                for (const leg of plan.legs()) {
                    if (leg.isInDirectToSequence) {
                        continue;
                    }
                    switch (leg.leg.type) {
                        case LegType.IF:
                        case LegType.TF:
                        case LegType.DF:
                        case LegType.CF:
                        case LegType.AF:
                        case LegType.RF:
                            if (ICAO.isFacility(leg.leg.fixIcao) && ICAO.getFacilityType(leg.leg.fixIcao) === FacilityType.Airport) {
                                icao = leg.leg.fixIcao;
                            }
                            break;
                    }
                    if (icao !== undefined) {
                        break;
                    }
                }
            }
        }
        return icao;
    }
}
/** Store for SelectDeparture */
class SelectDepartureStore extends SelectProcedureStore {
    /** @inheritdoc */
    getProcedures() {
        var _a, _b;
        return (_b = (_a = this.selectedFacility) === null || _a === void 0 ? void 0 : _a.departures) !== null && _b !== void 0 ? _b : [];
    }
    /** @inheritdoc */
    getTransitionName(transitionIndex) {
        if (this.selectedFacility !== undefined) {
            const procedure = this.procedures.get(this.selectedProcIndex.get());
            if (transitionIndex == -1) {
                if (procedure.commonLegs.length > 0) {
                    const legsLen = procedure.commonLegs.length;
                    /** For Departures, default transition name should be last leg icao - override in child method */
                    return ICAO.getIdent(procedure.commonLegs[legsLen - 1].fixIcao);
                }
                else {
                    const rwyTrans = procedure.runwayTransitions[this.selectedRwyIndex.get()];
                    const legsLen = rwyTrans.legs.length;
                    /** For Departures, default transition name should be last leg icao - override in child method */
                    return ICAO.getIdent(rwyTrans.legs[legsLen - 1].fixIcao);
                }
            }
            else {
                const enrTrans = procedure.enRouteTransitions[transitionIndex];
                if (enrTrans.name.length > 0) {
                    return enrTrans.name;
                }
                else {
                    /** For Departures, default transition name should be last leg icao - override in child method */
                    const legsLen = enrTrans.legs.length;
                    return ICAO.getIdent(enrTrans.legs[legsLen - 1].fixIcao);
                }
            }
        }
        return 'NONE';
    }
}

/** Controller for SelectArrival */
class SelectArrivalController extends SelectProcedureController {
    constructor() {
        super(...arguments);
        this.onLoadExecute = () => {
            if (this.store.selectedFacility !== undefined) {
                this.fms.insertArrival(this.store.selectedFacility, this.store.selectedProcIndex.get(), this.store.selectedRwyIndex.get(), this.store.selectedTransIndex.get(), this.store.getOneWayRunway());
            }
        };
    }
    /** @inheritdoc */
    getInitialICAO() {
        let icao;
        const dtoTargetIcao = this.fms.getDirectToTargetIcao();
        if (dtoTargetIcao !== undefined && ICAO.isFacility(dtoTargetIcao) && ICAO.getFacilityType(dtoTargetIcao) === FacilityType.Airport) {
            icao = dtoTargetIcao;
        }
        else if (this.fms.hasPrimaryFlightPlan()) {
            const plan = this.fms.getPrimaryFlightPlan();
            icao = plan.destinationAirport;
            if (icao === undefined) {
                // get the LAST airport in the flight plan.
                // TODO: would be nice to be able to iterate thru legs in reverse order
                for (const leg of plan.legs()) {
                    if (leg.isInDirectToSequence) {
                        continue;
                    }
                    switch (leg.leg.type) {
                        case LegType.IF:
                        case LegType.TF:
                        case LegType.DF:
                        case LegType.CF:
                        case LegType.AF:
                        case LegType.RF:
                            if (ICAO.isFacility(leg.leg.fixIcao) && ICAO.getFacilityType(leg.leg.fixIcao) === FacilityType.Airport) {
                                icao = leg.leg.fixIcao;
                            }
                            break;
                    }
                }
            }
        }
        return icao;
    }
}
/** Store for SelectArrival */
class SelectArrivalStore extends SelectProcedureStore {
    /** @inheritdoc */
    getProcedures() {
        var _a, _b;
        return (_b = (_a = this.selectedFacility) === null || _a === void 0 ? void 0 : _a.arrivals) !== null && _b !== void 0 ? _b : [];
    }
    /** @inheritdoc */
    getTransitionName(transitionIndex) {
        if (this.selectedFacility !== undefined) {
            const procedure = this.procedures.get(this.selectedProcIndex.get());
            if (transitionIndex == -1) {
                if (procedure.commonLegs.length > 0) {
                    /** For Arrivals, default transition name should be first leg icao - override in child method */
                    return ICAO.getIdent(procedure.commonLegs[0].fixIcao);
                }
                else {
                    const rwyTrans = procedure.runwayTransitions[this.selectedRwyIndex.get()];
                    /** For Arrivals, default transition name should be first leg icao - override in child method */
                    return ICAO.getIdent(rwyTrans.legs[0].fixIcao);
                }
            }
            else {
                const enrTrans = procedure.enRouteTransitions[transitionIndex];
                if (enrTrans.name.length > 0) {
                    return enrTrans.name;
                }
                else {
                    /** For Arrivals, default transition name should be first leg icao - override in child method */
                    return ICAO.getIdent(enrTrans.legs[0].fixIcao);
                }
            }
        }
        return 'NONE';
    }
}

/**
 * A view for selecting departures/arrivals.
 */
class SelectProcedure extends UiView {
    /**
     * Creates an instance of select procedure.
     * @param props The props.
     */
    constructor(props) {
        super(props);
        /** Goto and activate next select control. */
        this.gotoNextSelect = () => {
            this.scrollController.gotoNext();
            setTimeout(() => {
                const focusedCtrl = this.scrollController.getFocusedUiControl();
                if (focusedCtrl instanceof SelectControl) {
                    if (focusedCtrl.MenuItems.length > 1) {
                        focusedCtrl.onUpperKnob();
                    }
                    else {
                        this.gotoNextSelect();
                    }
                }
            }, 50);
        };
        this.store = this.getStore();
        this.controller = this.getController();
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.CLR:
                this.close();
                return true;
        }
        return false;
    }
    /** @inheritdoc */
    onViewOpened() {
        this.controller.initialize();
    }
    /**
     * Renders the waypoint input component.
     * @returns The rendered waypoint input component, as a VNode.
     */
    renderWaypointInput() {
        return (FSComponent.buildComponent(WaypointInput, { bus: this.props.bus, onRegister: this.register, onInputEnterPressed: this.gotoNextSelect, selectedIcao: this.controller.inputIcao, onFacilityChanged: this.controller.facilityChangedHandler, filter: FacilitySearchType.Airport }));
    }
    /**
     * Renders the procedure select control component.
     * @param dialogPosition The position of the pop-up context menu dialog spawned by the select control.
     * @returns The rendered procedure select control component, as a VNode.
     */
    renderProcedureSelectControl(dialogPosition) {
        return (FSComponent.buildComponent(SelectControl, { onRegister: this.register, outerContainer: this.viewContainerRef, data: this.store.procedures, onItemSelected: this.controller.onProcSelected, buildMenuItem: this.controller.buildProcMenuItem, dialogPosition: dialogPosition, class: 'slctproc-proc-value' }));
    }
    /**
     * Renders the runway transition select control component.
     * @param dialogPosition The position of the pop-up context menu dialog spawned by the select control.
     * @returns The rendered runway transition select control component, as a VNode.
     */
    renderRunwaySelectControl(dialogPosition) {
        return (FSComponent.buildComponent(SelectControl, { onRegister: this.register, outerContainer: this.viewContainerRef, data: this.store.runways, onItemSelected: this.controller.onRwySelected, buildMenuItem: this.controller.buildRwyMenuItem, dialogPosition: dialogPosition, class: 'slctproc-rwy-value' }));
    }
    /**
     * Renders the enroute transition select control component.
     * @param dialogPosition The position of the pop-up context menu dialog spawned by the select control.
     * @returns The rendered enroute transition select control component, as a VNode.
     */
    renderEnrouteSelectControl(dialogPosition) {
        return (FSComponent.buildComponent(SelectControl, { onRegister: this.register, outerContainer: this.viewContainerRef, data: this.store.transitions, onItemSelected: this.controller.onTransSelected, buildMenuItem: this.controller.buildTransMenuItem, dialogPosition: dialogPosition, class: 'slctproc-trans-value' }));
    }
}

/**
 * A PFD view for selecting departures/arrivals.
 */
class PFDSelectProcedure extends SelectProcedure {
    /**
     * A callback which is called when the Load action is executed.
     */
    onLoadSelected() {
        this.controller.onLoadSelected();
        this.props.viewService.open('FPL');
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: 'popout-dialog', ref: this.viewContainerRef },
            FSComponent.buildComponent("h1", null, this.props.title),
            this.renderWaypointInput(),
            FSComponent.buildComponent("hr", null),
            FSComponent.buildComponent("div", { class: "slctproc-container" },
                FSComponent.buildComponent("div", { class: "slctproc-proc-label" }, this.getProcLabel()),
                this.renderProcedureSelectControl(ContextMenuPosition.LEFT),
                FSComponent.buildComponent("div", { class: "slctproc-rwy-label" }, "Runway"),
                this.renderRunwaySelectControl(ContextMenuPosition.LEFT),
                FSComponent.buildComponent("div", { class: "slctproc-trans-label" }, "Transition"),
                this.renderEnrouteSelectControl(ContextMenuPosition.LEFT)),
            FSComponent.buildComponent("hr", null),
            FSComponent.buildComponent(ActionButton, { onRegister: this.register, class: "slctproc-load", onExecute: this.onLoadSelected.bind(this), isVisible: this.controller.canLoad, text: "Load?" })));
    }
}
/**
 * A PFD view to select departures.
 */
class PFDSelectDeparture extends PFDSelectProcedure {
    /** @inheritdoc */
    getController() {
        return new SelectDepartureController(this.getStore(), this.gotoNextSelect, this.props.fms, ProcedureType.DEPARTURE);
    }
    /** @inheritdoc */
    getProcLabel() {
        return 'Departure';
    }
    /** @inheritdoc */
    getStore() {
        var _a;
        return (_a = this.store) !== null && _a !== void 0 ? _a : new SelectDepartureStore();
    }
}
/**
 * A PFD view to select arrivals.
 */
class PFDSelectArrival extends PFDSelectProcedure {
    /** @inheritdoc */
    getController() {
        return new SelectArrivalController(this.getStore(), this.gotoNextSelect, this.props.fms, ProcedureType.ARRIVAL);
    }
    /** @inheritdoc */
    getProcLabel() {
        return 'Arrival';
    }
    /** @inheritdoc */
    getStore() {
        var _a;
        return (_a = this.store) !== null && _a !== void 0 ? _a : new SelectArrivalStore();
    }
}

/** A UiPage component. */
class UiPage extends UiView {
    /** @inheritdoc */
    constructor(props) {
        props.title = '';
        props.showTitle = false;
        super(props);
        this._title = Subject.create('');
        this.isPaused = false;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The title of this page. */
    get title() {
        return this._title;
    }
    /**
     * Opens the page.
     */
    open() {
        super.open(false);
    }
    /**
     * This method has no effect.
     */
    setZIndex() {
        // noop
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    processScrollEvent(evt) {
        // Do not handle scroll inputs while paused.
        if (this.isPaused) {
            return false;
        }
        return super.processScrollEvent(evt);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewResumed() {
        this.isPaused = false;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onViewPaused() {
        this.isPaused = true;
        // commenting this out for now because it seems to break some stuff with components expecting lists to keep track
        // of selections even when the list is not in the active view.
        //this.blur();
    }
}

/**
 * A service to manage views.
 */
class ViewService {
    /**
     * Constructs the view service.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.registeredViews = new Map();
        this.refsMap = new Map();
        this.openViews = [];
        this.openPageKeySub = Subject.create('');
        this.openPageSub = this.openPageKeySub.map(key => { var _a, _b; return (_b = (_a = this.refsMap.get(key)) === null || _a === void 0 ? void 0 : _a.instance) !== null && _b !== void 0 ? _b : null; });
        /** override in child class */
        this.fmsEventMap = new Map([]);
        const hEvtPub = this.bus.getSubscriber();
        hEvtPub.on('hEvent').handle(hEvent => {
            this.onInteractionEvent(hEvent);
        });
        this.viewClosedHandler = this.handleViewClosed.bind(this);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The key of the currently open page. */
    get openPageKey() {
        return this.openPageKeySub;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The currently open page. */
    get openPage() {
        return this.openPageSub;
    }
    /**
     * Routes the HEvents to the views.
     * @param hEvent The event identifier.
     */
    onInteractionEvent(hEvent) {
        console.log(hEvent);
        const evt = this.fmsEventMap.get(hEvent);
        if (evt !== undefined) {
            this.routeInteractionEventToViews(evt);
        }
    }
    /**
     * Routes an interaction to the active view, and if it is not handled, re-routes the interaction to the currently
     * open page if it exists and is not the active view.
     * @param evt An interaction event.
     * @returns Whether the event was handled.
     */
    routeInteractionEventToViews(evt) {
        const activeView = this.getActiveView();
        if (activeView) {
            let handled = activeView.processHEvent(evt);
            if (!handled) {
                // If the event was not handled, then give the open page (if any) a chance to handle the event.
                const page = this.openPage.get();
                if (page && page !== activeView) {
                    handled = page.processHEvent(evt);
                }
            }
            if (handled) {
                return true;
            }
        }
        return false;
    }
    /**
     * Gets the active view.
     * @returns The topmost view that is considered active.
     */
    getActiveView() {
        return this.openViews[this.openViews.length - 1];
    }
    /**
     * Gets an array of all currently open views.
     * @returns an array of all currently open views.
     */
    getOpenViews() {
        return this.openViews;
    }
    /**
     * Registers a view with the service.
     * @param [type] The type of the view.
     * @param vnodeFn A function creating the VNode.
     */
    registerView(type, vnodeFn) {
        console.log('registering ' + type);
        this.registeredViews.set(type, vnodeFn);
    }
    /**
     * Opens a view. The opened view can be a page, regular view, or subview. Opening a page will close all other views,
     * including the currently open page. Opening a regular view will close all other views except the currently open
     * page. Opening a subview does not close any other views. The opened view will immediately become the active view,
     * and the previously active view (if one exists) will be paused.
     * @param type The type of the view to open.
     * @param isSubView A boolean indicating if the view to be opened is a subview.
     * @returns The view that was opened.
     * @throws Error if the view type is not registered with this service.
     */
    open(type, isSubView = false) {
        var _a;
        let viewRef = this.refsMap.get(type);
        if (viewRef === undefined) {
            // when we hve no ref, create the view
            viewRef = this.createView(type);
            this.refsMap.set(type, viewRef);
        }
        const view = viewRef.instance;
        const isPage = view instanceof UiPage;
        if (isPage) {
            this.clearStack(true);
        }
        else if (!isSubView) {
            this.clearStack(false);
        }
        (_a = this.getActiveView()) === null || _a === void 0 ? void 0 : _a.pause();
        view.open(isSubView, 900 + this.openViews.length);
        view.onClose.clear();
        view.onClose.on(this.viewClosedHandler);
        const index = this.openViews.indexOf(view);
        if (index >= 0) {
            this.openViews.splice(index, 1);
        }
        this.openViews.push(view);
        if (isPage) {
            this.openPageKeySub.set(type);
        }
        return view;
    }
    /**
     * Creates a view.
     * @param type The type string of the view to create.
     * @returns A NodeReference to the created view.
     * @throws When type of view is not registered.
     */
    createView(type) {
        const vnodeFn = this.registeredViews.get(type);
        if (vnodeFn === undefined) {
            console.error(`Could not find a registered view of type ${type.toString()}!`);
            throw new Error(`Could not find a registered view of type ${type.toString()}!`);
        }
        const node = vnodeFn();
        FSComponent.render(node, document.getElementById('InstrumentsContainer'));
        const viewRef = FSComponent.createRef();
        viewRef.instance = node.instance;
        return viewRef;
    }
    /**
     * Handles views that got closed, removing them from the stack.
     * @param closedView The view that was closed.
     */
    handleViewClosed(closedView) {
        var _a;
        const viewIndex = this.openViews.findIndex((v) => {
            return v === closedView;
        });
        closedView.onClose.off(this.viewClosedHandler);
        if (viewIndex > -1) {
            this.openViews.splice(viewIndex, 1);
            // need to reset z-indices.
            const len = this.openViews.length;
            for (let i = viewIndex; i < len; i++) {
                this.openViews[i].setZIndex(900 + i);
            }
            (_a = this.getActiveView()) === null || _a === void 0 ? void 0 : _a.resume();
        }
        if (closedView === this.openPageSub.get()) {
            this.openPageKeySub.set('');
        }
    }
    /**
     * Closes the currently active view.
     */
    closeActiveView() {
        this.getActiveView().close();
    }
    /**
     * Closes all open views except for the currently open page, if one exists.
     */
    closeAllViews() {
        this.clearStack(false);
    }
    /**
     * Closes all open views and clears the stack.
     * @param closePage Whether to close the currently open page, if one exists.
     */
    clearStack(closePage) {
        if (this.openViews.length === 0) {
            return;
        }
        const views = [...this.openViews];
        const len = views.length;
        for (let i = len - 1; i > 0; i--) {
            views[i].close(true);
        }
        this.openViews.length = 1;
        if (closePage || !(views[0] instanceof UiPage)) {
            views[0].close(true);
            this.openViews.length = 0;
        }
    }
}

/**
 * The TimerInput Component.
 */
class ADFFreqInput extends UiControl {
    constructor() {
        super(...arguments);
        this.inputCtrls = [];
        this.highlightIndex = 0;
        this.freqSubjects = [
            Subject.create(0),
            Subject.create(0),
            Subject.create(0),
            Subject.create(0),
            Subject.create(0)
        ];
        /**
         * Registers the inputs with this control
         * @param ctrl The number input to register.
         */
        this.register = (ctrl) => {
            this.inputCtrls.push(ctrl);
        };
    }
    /** @inheritdoc */
    onAfterRender() {
        super.onAfterRender();
        this.focusSubject.sub((v) => {
            if (v) {
                this.props.enterToTransferSubject.set('ENT TO TRANSFER');
            }
            else {
                this.props.enterToTransferSubject.set('');
            }
        });
    }
    /**
     * Sets and formats the freq.
     */
    setFreq() {
        if (!this.getIsActivated()) {
            const freq = this.props.adfInputSubject.get();
            const thousands = Math.floor(freq / 1000);
            const hundreds = Math.floor((freq - (thousands * 1000)) / 100);
            const tens = Math.floor((freq - (thousands * 1000) - (hundreds * 100)) / 10);
            const ones = Math.floor(freq - (thousands * 1000) - (hundreds * 100) - (tens * 10));
            const decimal = Math.round(10 * (freq - Math.floor(freq)));
            this.freqSubjects[0].set(thousands);
            this.freqSubjects[1].set(hundreds);
            this.freqSubjects[2].set(tens);
            this.freqSubjects[3].set(ones);
            this.freqSubjects[4].set(decimal);
        }
    }
    /** @inheritdoc */
    onUpperKnobInc() {
        if (!this.isActivated) {
            this.activate();
        }
        else {
            this.activeInput.onUpperKnobInc();
        }
    }
    /** @inheritdoc */
    onUpperKnobDec() {
        if (!this.isActivated) {
            this.activate();
        }
        else {
            this.activeInput.onUpperKnobDec();
        }
    }
    /** @inheritdoc */
    onLowerKnobInc() {
        this.highlightIndex++;
        this.highlightInput(this.highlightIndex);
    }
    /** @inheritdoc */
    onLowerKnobDec() {
        this.highlightIndex--;
        this.highlightInput(this.highlightIndex);
    }
    /** @inheritdoc */
    onEnter() {
        if (this.isActivated) {
            const value = this.freqSubjects[0].get() * 1000
                + this.freqSubjects[1].get() * 100
                + this.freqSubjects[2].get() * 10
                + this.freqSubjects[3].get()
                + this.freqSubjects[4].get() / 10;
            this.props.adfInputSubject.set(value);
            SimVar.SetSimVarValue('K:ADF_COMPLETE_SET', 'Frequency ADF BCD32', Avionics.Utils.make_adf_bcd32(value * 1000));
            this.deactivate();
            return true;
        }
        else {
            SimVar.SetSimVarValue('K:ADF1_RADIO_SWAP', 'number', 0);
            return true;
        }
    }
    /** @inheritdoc */
    onClr() {
        this.deactivate();
        return true;
    }
    /**
     * Highlights the specified input control.
     * @param index The index of the input to highlight.
     */
    highlightInput(index) {
        if (this.activeInput) {
            this.activeInput.blur();
        }
        this.highlightIndex = MathUtils.clamp(index, 0, this.inputCtrls.length - 1);
        this.activeInput = this.inputCtrls[this.highlightIndex];
        this.activeInput.focus();
    }
    /** @inheritdoc */
    onActivated() {
        var _a;
        this.highlightIndex = 0;
        (_a = this.getHighlightElement()) === null || _a === void 0 ? void 0 : _a.classList.remove(UiControl.FOCUS_CLASS);
        this.highlightInput(this.highlightIndex);
    }
    /** @inheritdoc */
    onDeactivated() {
        var _a;
        this.activeInput.blur();
        if (this.getIsFocused()) {
            (_a = this.getHighlightElement()) === null || _a === void 0 ? void 0 : _a.classList.add(UiControl.FOCUS_CLASS);
        }
    }
    /** @inheritdoc */
    renderControl() {
        return (FSComponent.buildComponent("div", { class: "ADFDME-standby-adf" },
            FSComponent.buildComponent(NumberInput, { onRegister: this.register, dataSubject: this.freqSubjects[0], minValue: 0, maxValue: 1, increment: 1, wrap: true, class: 'timerref-timer-number' }),
            FSComponent.buildComponent(NumberInput, { onRegister: this.register, dataSubject: this.freqSubjects[1], minValue: 0, maxValue: 9, increment: 1, wrap: true, class: 'timerref-timer-number' }),
            FSComponent.buildComponent(NumberInput, { onRegister: this.register, dataSubject: this.freqSubjects[2], minValue: 0, maxValue: 9, increment: 1, wrap: true, class: 'timerref-timer-number' }),
            FSComponent.buildComponent(NumberInput, { onRegister: this.register, dataSubject: this.freqSubjects[3], minValue: 0, maxValue: 9, increment: 1, wrap: true, class: 'timerref-timer-number' }),
            ".",
            FSComponent.buildComponent(NumberInput, { onRegister: this.register, dataSubject: this.freqSubjects[4], minValue: 0, maxValue: 9, increment: 1, wrap: true, class: 'timerref-timer-number' })));
    }
}

/**
 * The ADFDME
 * component.
 */
class ADFDME extends UiView {
    constructor() {
        super(...arguments);
        // private adfdmeToggleOptions = ['ADF', 'ANT', 'ADF/BFO', 'ANT/BFO'];
        this.adfdmeToggleOptions = ['ADF'];
        this.dmeToggleOptions = ['NAV1', 'NAV2'];
        this.freqComponentRef = FSComponent.createRef();
        this.adfInputSubject = Subject.create(0);
        this.adfActiveFreq = ComputedSubject.create(0, (v) => {
            if (isNaN(v) || v <= 0) {
                return '----.-';
            }
            else {
                return v.toFixed(1);
            }
        });
        this.enterToTransferSubject = Subject.create('');
        // ---- TOGGLE ADF MODE CALLBACK
        this.onADFToggleSelected = (index) => {
            console.log('MODE TOGGLED:' + index);
        };
        this.onDmeToggleSelected = (index) => {
            this.props.navIndicatorController.dmeSourceIndex.set(index);
        };
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        const adf = this.props.bus.getSubscriber();
        adf.on('adf1ActiveFreq').whenChanged().handle((f) => {
            this.adfActiveFreq.set(f);
        });
        adf.on('adf1StandbyFreq').whenChanged().handle((f) => {
            this.adfInputSubject.set(Math.round(f * 10) / 10);
            this.freqComponentRef.instance.setFreq();
        });
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: 'popout-dialog', ref: this.viewContainerRef },
            FSComponent.buildComponent("h1", null, this.props.title),
            FSComponent.buildComponent("div", { class: "ADFDME-adf-row1" },
                FSComponent.buildComponent("div", null, "ADF"),
                FSComponent.buildComponent("div", { class: "ADFDME-active-adf" }, this.adfActiveFreq),
                FSComponent.buildComponent("div", null,
                    FSComponent.buildComponent("svg", { width: "25", height: "16" },
                        FSComponent.buildComponent("path", { d: "M 12 8 m 0 0.75 l -5 0 l 1 3.25 l 0 1 l -4.5 -5 l 4.5 -5 l 0 1 l -1 3.25 l 10 0 l -1 -3.25 l 0 -1 l 4.5 5 l -4.5 5 l 0 -1 l 1 -3.25 l -5 0 z", fill: "cyan" }))),
                FSComponent.buildComponent(ADFFreqInput, { ref: this.freqComponentRef, adfInputSubject: this.adfInputSubject, onRegister: this.register, enterToTransferSubject: this.enterToTransferSubject })),
            FSComponent.buildComponent("div", { class: "ADFDME-adf-row2" },
                FSComponent.buildComponent("div", null, "MODE"),
                FSComponent.buildComponent(ArrowToggle, { onRegister: this.register, onOptionSelected: this.onADFToggleSelected, options: this.adfdmeToggleOptions }),
                FSComponent.buildComponent("div", null, "VOL"),
                FSComponent.buildComponent("div", { class: "cyan size16" }, "100%")),
            FSComponent.buildComponent("hr", null),
            FSComponent.buildComponent("div", { class: "ADFDME-dme-row1" },
                FSComponent.buildComponent("div", null, "DME"),
                FSComponent.buildComponent("div", null, "MODE"),
                FSComponent.buildComponent("div", { class: "ADFDME-dme-select" },
                    FSComponent.buildComponent(ArrowToggle, { onRegister: this.register, onOptionSelected: this.onDmeToggleSelected, options: this.dmeToggleOptions }))),
            FSComponent.buildComponent("hr", null),
            FSComponent.buildComponent("div", { class: "ADFDME-ent-transfer" }, this.enterToTransferSubject)));
    }
}

/**
 * Setting modes for backlighting.
 */
var BacklightMode;
(function (BacklightMode) {
    BacklightMode[BacklightMode["Auto"] = 0] = "Auto";
    BacklightMode[BacklightMode["Manual"] = 1] = "Manual";
})(BacklightMode || (BacklightMode = {}));
/**
 * Utility class for retrieving backlight user setting managers.
 */
class BacklightUserSettings {
    /**
     * Retrieves a manager for backlight user settings.
     * @param bus The event bus.
     * @returns a manager for backlight user settings.
     */
    static getManager(bus) {
        var _a;
        return (_a = BacklightUserSettings.INSTANCE) !== null && _a !== void 0 ? _a : (BacklightUserSettings.INSTANCE = new DefaultUserSettingManager(bus, [
            {
                name: 'pfdScreenBacklightMode',
                defaultValue: BacklightMode.Auto
            },
            {
                name: 'pfdScreenBacklightIntensity',
                defaultValue: 100
            },
            {
                name: 'pfdKeyBacklightMode',
                defaultValue: BacklightMode.Auto
            },
            {
                name: 'pfdKeyBacklightIntensity',
                defaultValue: 100
            },
            {
                name: 'mfdScreenBacklightMode',
                defaultValue: BacklightMode.Auto
            },
            {
                name: 'mfdScreenBacklightIntensity',
                defaultValue: 100
            },
            {
                name: 'mfdKeyBacklightMode',
                defaultValue: BacklightMode.Auto
            },
            {
                name: 'mfdKeyBacklightIntensity',
                defaultValue: 100
            },
        ]));
    }
}

/**
 * A controller which binds a user setting to a control component.
 */
class UserSettingController {
    /**
     * Constructor.
     * @param settingManager This controller's settings manager.
     * @param settingName The name of the setting associated with this controller.
     */
    constructor(settingManager, settingName) {
        this.settingManager = settingManager;
        this.settingName = settingName;
        /** The setting associated with this controller. */
        this.setting = this.settingManager.getSetting(this.settingName);
    }
    /**
     * Initializes this controller. This will immediately change the state of this controller's control component to
     * reflect the current value of this controller's setting. Furthermore, any future changes to the setting's value
     * will be synced to the control component.
     */
    init() {
        this.settingManager.whenSettingChanged(this.settingName).handle(this.onSettingChanged.bind(this));
    }
}

/**
 * A controller which binds a user setting that can take one of several enumerated values to a SelectControl
 * component.
 */
class UserSettingSelectController extends UserSettingController {
    /**
     * Constructor.
     * @param settingManager This controller's settings manager.
     * @param settingName The name of the setting associated with this controller.
     * @param values A subscribable array which provides the values this controller can assign to its setting.
     * @param selectControlRef A node reference to the SelectControl which this controller controls.
     */
    constructor(settingManager, settingName, values, selectControlRef) {
        super(settingManager, settingName);
        this.settingManager = settingManager;
        this.settingName = settingName;
        this.values = values;
        this.selectControlRef = selectControlRef;
        /**
         * A function which handles item selected events from the SelectControl component which this controller controls.
         * This handler should be passed to the SelectControl component via its `onItemSelected` prop.
         */
        this.itemSelectedHandler = this.onItemSelected.bind(this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onSettingChanged(value) {
        var _a;
        (_a = this.selectControlRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.SelectedValue.set(this.values.getArray().indexOf(value));
    }
    /**
     * A callback which is called when an item is selected using the SelectControl component.
     * @param index The index of the selected item.
     * @param item The selected item.
     * @param isRefresh Whether the selection was made due to a refresh.
     */
    onItemSelected(index, item, isRefresh) {
        if (item === undefined || isRefresh) {
            return;
        }
        this.setting.value = item;
    }
}

/**
 * A controller which binds a user setting with numeric values to a NumberInput component.
 */
class UserSettingNumberController extends UserSettingController {
    /**
     * Constructor.
     * @param settingManager This controller's settings manager.
     * @param settingName The name of the setting associated with this controller.
     */
    constructor(settingManager, settingName) {
        super(settingManager, settingName);
        this.settingManager = settingManager;
        this.settingName = settingName;
        /**
         * A subject which provides a numeric value for the NumberInput component which this controller controls. This
         * subject should be passed to the NumberInput component via the `dataSubject` prop.
         */
        this.dataSub = Subject.create(0);
        /**
         * A function which handles input change events from the NumberInput component which this controller controls. This
         * handler should be passed to the NumberInput component via the `onValueChanged` prop.
         */
        this.inputChangedHandler = this.onInputChanged.bind(this);
        if (typeof this.setting.value !== 'number') {
            throw new Error(`Setting '${this.setting.definition.name}' does not use numeric values`);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onSettingChanged(value) {
        this.dataSub.set(value);
    }
    /**
     * A callback which is called when the number input changes.
     * @param value The new value of the input.
     */
    onInputChanged(value) {
        this.setting.value = value;
    }
}

/** Brightness control for a portion of a display. */
class ItemBrightnessControl extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.container = FSComponent.createRef();
        this.modeDiv = FSComponent.createRef();
        this.modeControl = FSComponent.createRef();
        this.valDiv = FSComponent.createRef();
        this.valInput = FSComponent.createRef();
        this.modeValues = ArraySubject.create(this.props.noManualMode
            ? [BacklightMode.Auto]
            : [BacklightMode.Auto, BacklightMode.Manual]);
        this.modeSetting = this.props.settingManager.getSetting(this.props.modeSettingName);
        this.modeController = new UserSettingSelectController(this.props.settingManager, this.props.modeSettingName, this.modeValues, this.modeControl);
        this.intensitySetting = this.props.settingManager.getSetting(this.props.intensitySettingName);
        this.intensityController = new UserSettingNumberController(this.props.settingManager, this.props.intensitySettingName);
    }
    /** Init after rendering. */
    onAfterRender() {
        this.props.settingManager.whenSettingChanged(this.props.modeSettingName).handle(this.onManAutoSelected.bind(this));
        this.modeController.init();
        this.intensityController.init();
    }
    /**
     * Disable the element.
     */
    disable() {
        this.container.instance.style.display = 'none';
        this.valInput.instance.setIsEnabled(false);
        this.modeControl.instance.setIsEnabled(false);
    }
    /**
     * Enable the element.
     */
    enable() {
        this.container.instance.style.display = '';
        this.modeControl.instance.setIsEnabled(true);
        if (this.modeSetting.value == BacklightMode.Manual) {
            this.valInput.instance.setIsEnabled(true);
        }
    }
    /**
     * Handle a manual/auto switch.
     * @param mode The index number of the option chosen.
     */
    onManAutoSelected(mode) {
        var _a, _b;
        switch (mode) {
            case BacklightMode.Auto:
                // Auto enabled.
                this.valInput.instance.setIsEnabled(false);
                (_a = this.valInput.instance.getHighlightElement()) === null || _a === void 0 ? void 0 : _a.classList.add('inactive-dim');
                break;
            case BacklightMode.Manual:
                // Manual enabled.
                this.valInput.instance.setIsEnabled(true);
                (_b = this.valInput.instance.getHighlightElement()) === null || _b === void 0 ? void 0 : _b.classList.remove('inactive-dim');
                break;
            default:
                // Shouldn't happen.
                console.log(`Unknown option for onManAutoSelected: ${mode}`);
        }
    }
    /**
     * Builds a menu item definition for a setting value.
     * @param value A setting value.
     * @param index The index of the value in the menu.
     * @returns a menu item definition for the setting value.
     */
    buildModeMenuItem(value, index) {
        return {
            id: `${index}`,
            renderContent: () => FSComponent.buildComponent("span", null, ItemBrightnessControl.MODE_TEXT[value]),
            estimatedWidth: ItemBrightnessControl.MODE_TEXT[value].length * ContextMenuDialog.CHAR_WIDTH
        };
    }
    /**
     * Render the control.
     * @returns The VNode for the control.
     */
    render() {
        return (FSComponent.buildComponent("div", { ref: this.container, class: 'pfd-setup-item-block pfd-setup-inline' },
            FSComponent.buildComponent("div", { class: 'pfd-setup-mode-switch pfd-setup-inline', ref: this.modeDiv },
                FSComponent.buildComponent(SelectControl, { class: 'pfd-setup-inline', ref: this.modeControl, onRegister: this.props.onRegister, buildMenuItem: this.buildModeMenuItem.bind(this), data: this.modeValues, onItemSelected: this.modeController.itemSelectedHandler, outerContainer: this.container })),
            FSComponent.buildComponent("div", { class: 'pfd-setup-number-input pfd-setup-inline', ref: this.valDiv },
                FSComponent.buildComponent(NumberInput, { class: 'pfd-setup-inline', ref: this.valInput, onRegister: this.props.onRegister, onValueChanged: this.intensityController.inputChangedHandler, dataSubject: this.intensityController.dataSub, minValue: 0, maxValue: 100, increment: 1, formatter: (num) => `${num.toFixed(2)}%`, wrap: false }))));
    }
}
ItemBrightnessControl.MODE_TEXT = {
    [BacklightMode.Auto]: 'Auto',
    [BacklightMode.Manual]: 'Manual'
};
/** Display brightness control component. */
class BrightnessControl extends DisplayComponent {
    /**
     * Create a BrightnessControl
     * @param props The properties for the control.
     */
    constructor(props) {
        super(props);
        this.itemValue = Subject.create(0);
        this.dispInput = FSComponent.createRef();
        this.keyInput = FSComponent.createRef();
        this.screenModeSettingName = `${this.props.displayName}ScreenBacklightMode`;
        this.screenIntensitySettingName = `${this.props.displayName}ScreenBacklightIntensity`;
        this.keyModeSettingName = `${this.props.displayName}KeyBacklightMode`;
        this.keyIntensitySettingName = `${this.props.displayName}KeyBacklightIntensity`;
        this.setupItems = [`${this.props.displayName.toUpperCase()} Display`, `${this.props.displayName.toUpperCase()} Key`];
    }
    /** Do things after render. */
    onAfterRender() {
        this.keyInput.instance.disable();
    }
    /**
     * Handle an item selection event.
     * @param option The index number of the option chosen
     */
    onItemSelected(option) {
        switch (option) {
            case 0:
                // Display selected.
                this.dispInput.instance.enable();
                this.keyInput.instance.disable();
                break;
            case 1:
                // Key selected.
                this.dispInput.instance.disable();
                this.keyInput.instance.enable();
                break;
            default:
                console.log(`Invalid option for onItemSelected: ${option}`);
        }
    }
    /**
     * Render a brightness control.
     * @returns a VNode
     */
    render() {
        return (FSComponent.buildComponent("div", { class: 'pfd-setup-row' },
            FSComponent.buildComponent("div", { class: 'pfd-setup-mode-toggle pfd-setup-inline' },
                FSComponent.buildComponent(ArrowToggle, { class: 'pfd-setup-inline', onRegister: this.props.onRegister, onOptionSelected: this.onItemSelected.bind(this), options: this.setupItems, dataref: this.itemValue })),
            FSComponent.buildComponent(ItemBrightnessControl, { ref: this.dispInput, onRegister: this.props.onRegister, settingManager: this.props.settingManager, modeSettingName: this.screenModeSettingName, intensitySettingName: this.screenIntensitySettingName }),
            FSComponent.buildComponent(ItemBrightnessControl, { ref: this.keyInput, onRegister: this.props.onRegister, settingManager: this.props.settingManager, modeSettingName: this.keyModeSettingName, intensitySettingName: this.keyIntensitySettingName, noManualMode: true })));
    }
}
/** A PFD setup menu. */
class PFDSetup extends UiView {
    constructor() {
        super(...arguments);
        this.backlightSettingManager = BacklightUserSettings.getManager(this.props.bus);
    }
    /**
     * Render the menu.
     * @returns a VNode
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "popout-dialog", ref: this.viewContainerRef },
            FSComponent.buildComponent("h1", null, this.props.title),
            FSComponent.buildComponent("div", { class: 'pfd-setup-popout' },
                FSComponent.buildComponent(BrightnessControl, { onRegister: this.register, displayName: 'pfd', settingManager: this.backlightSettingManager }),
                FSComponent.buildComponent(BrightnessControl, { onRegister: this.register, displayName: 'mfd', settingManager: this.backlightSettingManager }))));
    }
}

/**
 * A service to manage views.
 */
class PFDViewService extends ViewService {
    /**
     * Constructs the view service.
     * @param bus The event bus.
     */
    constructor(bus) {
        super(bus);
        this.bus = bus;
        this.fmsEventMap = new Map([
            ['AS1000_PFD_FMS_Upper_INC', FmsHEvent.UPPER_INC],
            ['AS1000_PFD_FMS_Upper_DEC', FmsHEvent.UPPER_DEC],
            ['AS1000_PFD_FMS_Lower_INC', FmsHEvent.LOWER_INC],
            ['AS1000_PFD_FMS_Lower_DEC', FmsHEvent.LOWER_DEC],
            ['AS1000_PFD_MENU_Push', FmsHEvent.MENU],
            ['AS1000_PFD_CLR', FmsHEvent.CLR],
            ['AS1000_PFD_ENT_Push', FmsHEvent.ENT],
            ['AS1000_PFD_FMS_Upper_PUSH', FmsHEvent.UPPER_PUSH],
            ['AS1000_PFD_DIRECTTO', FmsHEvent.DIRECTTO],
            ['AS1000_PFD_FPL_Push', FmsHEvent.FPL],
            ['AS1000_PFD_PROC_Push', FmsHEvent.PROC],
            ['AS1000_PFD_RANGE_INC', FmsHEvent.RANGE_INC],
            ['AS1000_PFD_RANGE_DEC', FmsHEvent.RANGE_DEC]
        ]);
        const g1000Pub = this.bus.getSubscriber();
        g1000Pub.on('pfd_timerref_push').handle(() => {
            this.onInteractionEvent('pfd_timerref_push');
        });
        g1000Pub.on('pfd_nearest_push').handle(() => {
            this.onInteractionEvent('pfd_nearest_push');
        });
        g1000Pub.on('pfd_dme_push').handle(() => {
            this.onInteractionEvent('pfd_dme_push');
        });
    }
    /**
     * Routes the HEvents to the views.
     * @param hEvent The event identifier.
     */
    onInteractionEvent(hEvent) {
        // Handling a few special cases here to keep the other stuff nice ;)
        // No active view and MENU pressed
        if (hEvent === 'AS1000_PFD_MENU_Push') {
            const activeView = this.getActiveView();
            if (activeView === undefined) {
                this.open(PFDSetup.name);
            }
            else if (activeView instanceof PFDSetup) {
                activeView.close();
            }
        }
        const evt = this.fmsEventMap.get(hEvent);
        if (evt !== undefined && this.routeInteractionEventToViews(evt)) {
            return;
        }
        switch (hEvent) {
            // TODO move these events out in the next iteration, since we dont want type refs to the views in here
            case 'AS1000_PFD_FPL_Push':
                if (this.getActiveView() instanceof FPL) {
                    this.clearStack(false);
                }
                else {
                    this.open('FPL');
                }
                break;
            case 'AS1000_PFD_PROC_Push':
                if (this.getActiveView() instanceof PFDProc) {
                    this.clearStack(false);
                }
                else {
                    this.open('PROC');
                }
                break;
            case 'pfd_timerref_push':
                if (this.getActiveView() instanceof TimerRef) {
                    this.clearStack(false);
                }
                else {
                    this.open(TimerRef.name);
                }
                break;
            case 'pfd_nearest_push':
                if (this.getActiveView() instanceof Nearest) {
                    this.clearStack(false);
                }
                else {
                    this.open(Nearest.name);
                }
                break;
            case 'pfd_dme_push':
                if (this.getActiveView() instanceof ADFDME) {
                    this.clearStack(false);
                }
                else {
                    this.open(ADFDME.name);
                }
                break;
            case 'AS1000_PFD_DIRECTTO':
                this.open('DirectTo');
                break;
        }
    }
}

/**
 * This will display system warnings.
 */
class WarningDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.divRef = FSComponent.createRef();
    }
    /** Instantiate a warning manager with our passed-in props after rendering. */
    onAfterRender() {
        new WarningManager(this.props.warnings, this.props.logicHandler, this.onWarningText.bind(this), this.onWarningSound.bind(this));
    }
    /**
     * Turt the text of a warning on or off.
     * @param warning The warning text to display, undefined if it's cleared.
     */
    onWarningText(warning) {
        if (warning) {
            if (warning.shortText) {
                this.divRef.instance.textContent = warning.shortText;
                switch (warning.type) {
                    case WarningType.Warning:
                        this.divRef.instance.className = 'warnings-display red';
                        break;
                    case WarningType.Caution:
                        this.divRef.instance.className = 'warnings-display yellow';
                        break;
                    case WarningType.Test:
                        this.divRef.instance.className = 'warnings-display white';
                        break;
                }
            }
            else {
                this.divRef.instance.textContent = '';
                this.divRef.instance.className = 'warnings-display';
            }
        }
        else {
            this.divRef.instance.textContent = '';
            this.divRef.instance.className = 'warnings-display';
        }
    }
    /**
     * Start or stop playing a continuour warning sound.
     * @param warning The warning.
     * @param active Whether the warning is turning on or off.
     */
    onWarningSound(warning, active) {
        if (warning.soundId) {
            if (active) {
                this.props.soundPublisher.startSound(warning.soundId);
            }
            else {
                this.props.soundPublisher.stopSound(warning.soundId);
            }
        }
    }
    /**
     * Render a WarningDisplay
     * @returns a VNode
     */
    render() {
        return FSComponent.buildComponent("div", { class: "warnings-display", ref: this.divRef });
    }
}

/** A class for syncing a flight plan with the game */
class FlightPlanAsoboSync {
    /**
     * Inits flight plan asobo sync
     */
    static init() {
        if (!FlightPlanAsoboSync.fpListenerInitialized) {
            RegisterViewListener('JS_LISTENER_FLIGHTPLAN');
            FlightPlanAsoboSync.fpListenerInitialized = true;
        }
    }
    /**
     * Loads the flight plan from the sim.
     * @param fms The fms.
     * @returns a Promise which is fulfilled when the flight plan has been loaded.
     */
    static async loadFromGame(fms) {
        FlightPlanAsoboSync.init();
        await Wait.awaitDelay(200);
        Coherent.call('LOAD_CURRENT_ATC_FLIGHTPLAN');
        // Coherent.call('LOAD_CURRENT_GAME_FLIGHT');
        await Wait.awaitDelay(5000);
        const isBushtrip = await Coherent.call('GET_IS_BUSHTRIP');
        if (!isBushtrip) {
            const data = await Coherent.call('GET_FLIGHTPLAN');
            const isDirectTo = data.isDirectTo;
            let lastEnrouteSegment = 1;
            // TODO: dirto
            if (!isDirectTo) {
                if (data.waypoints.length === 0) {
                    return;
                }
                // init a flightplan
                await fms.emptyPrimaryFlightPlan();
                const plan = fms.getPrimaryFlightPlan();
                // set origin
                let originFacilityType = undefined;
                if (ICAO.isFacility(data.waypoints[0].icao)) {
                    originFacilityType = ICAO.getFacilityType(data.waypoints[0].icao);
                }
                if (originFacilityType === FacilityType.Airport) {
                    const originFac = await fms.facLoader.getFacility(ICAO.getFacilityType(data.waypoints[0].icao), data.waypoints[0].icao);
                    if (originFac !== undefined) {
                        FlightPlanAsoboSync.setDeparture(originFac, data, fms);
                    }
                }
                else if (originFacilityType !== undefined) {
                    FlightPlanAsoboSync.buildNonAirportOriginLeg(data, plan, fms);
                }
                // set dest
                const destIndex = data.waypoints.length - 1;
                let destFacilityType = undefined;
                if (ICAO.isFacility(data.waypoints[destIndex].icao)) {
                    destFacilityType = ICAO.getFacilityType(data.waypoints[destIndex].icao);
                }
                if (destFacilityType === FacilityType.Airport) {
                    const destFac = await fms.facLoader.getFacility(ICAO.getFacilityType(data.waypoints[destIndex].icao), data.waypoints[destIndex].icao);
                    if (destFac !== undefined) {
                        FlightPlanAsoboSync.setDestination(destFac, data, fms);
                    }
                }
                // set enroute waypoints
                lastEnrouteSegment = FlightPlanAsoboSync.setEnroute(data, plan, fms);
                // set non-airport destination leg as the last enroute leg
                if (destFacilityType !== FacilityType.Airport && destFacilityType !== undefined) {
                    FlightPlanAsoboSync.buildNonAirportDestLeg(data, plan, fms, lastEnrouteSegment);
                }
                // if (destinationSet && !originSet) {
                //   if (plan.length >= 1) {
                //     plan.getSegmentIndex(0)
                //     fms.createDirectToExisting()
                //   }
                // }
                plan.calculate(0).then(() => {
                    plan.setLateralLeg(0);
                });
            }
        }
    }
    // public static async SaveToGame(fpln: FlightPlanManager): Promise<void> {
    //   // eslint-disable-next-line no-async-promise-executor
    //   return new Promise(async (resolve, reject) => {
    //     FlightPlanAsoboSync.init();
    //     const plan = fpln.getCurrentFlightPlan();
    //     if (WTDataStore.get('WT_CJ4_FPSYNC', 0) !== 0 && (plan.checksum !== this.fpChecksum)) {
    //       // await Coherent.call("CREATE_NEW_FLIGHTPLAN");
    //       await Coherent.call("SET_CURRENT_FLIGHTPLAN_INDEX", 0).catch(console.log);
    //       await Coherent.call("CLEAR_CURRENT_FLIGHT_PLAN").catch(console.log);
    //       if (plan.hasOrigin && plan.hasDestination) {
    //         if (plan.hasOrigin) {
    //           await Coherent.call("SET_ORIGIN", plan.originAirfield.icao, false);
    //         }
    //         if (plan.hasDestination) {
    //           await Coherent.call("SET_DESTINATION", plan.destinationAirfield.icao, false);
    //         }
    //         let coIndex = 1;
    //         for (let i = 0; i < plan.enroute.waypoints.length; i++) {
    //           const wpt = plan.enroute.waypoints[i];
    //           if (wpt.icao.trim() !== "") {
    //             await Coherent.call("ADD_WAYPOINT", wpt.icao, coIndex, false);
    //             coIndex++;
    //           }
    //         }
    //         await Coherent.call("SET_ORIGIN_RUNWAY_INDEX", plan.procedureDetails.originRunwayIndex).catch(console.log);
    //         await Coherent.call("SET_DEPARTURE_RUNWAY_INDEX", plan.procedureDetails.departureRunwayIndex);
    //         await Coherent.call("SET_DEPARTURE_PROC_INDEX", plan.procedureDetails.departureIndex);
    //         await Coherent.call("SET_DEPARTURE_ENROUTE_TRANSITION_INDEX", plan.procedureDetails.departureTransitionIndex);
    //         await Coherent.call("SET_ARRIVAL_RUNWAY_INDEX", plan.procedureDetails.arrivalRunwayIndex);
    //         await Coherent.call("SET_ARRIVAL_PROC_INDEX", plan.procedureDetails.arrivalIndex);
    //         await Coherent.call("SET_ARRIVAL_ENROUTE_TRANSITION_INDEX", plan.procedureDetails.arrivalTransitionIndex);
    //         await Coherent.call("SET_APPROACH_INDEX", plan.procedureDetails.approachIndex).then(() => {
    //           Coherent.call("SET_APPROACH_TRANSITION_INDEX", plan.procedureDetails.approachTransitionIndex);
    //         });
    //       }
    //       this.fpChecksum = plan.checksum;
    //     }
    //     Coherent.call("RECOMPUTE_ACTIVE_WAYPOINT_INDEX");
    //   });
    // }
    /**
     * Sets the departure procedure or facility if specified
     * @param facility is the origin airport facility record
     * @param data is the flight plan sync data object from the world map
     * @param fms an instance of the fms
     * @returns whether a departure was set.
     */
    static setDeparture(facility, data, fms) {
        let originOneWayRunway = undefined;
        if (data.originRunwayIndex > -1) {
            const oneWayRunways = [];
            let index = 0;
            facility.runways.forEach((runway) => {
                for (const rw of RunwayUtils.getOneWayRunways(runway, index)) {
                    oneWayRunways.push(rw);
                }
                index++;
            });
            oneWayRunways.sort(RunwayUtils.sortRunways);
            originOneWayRunway = oneWayRunways[data.originRunwayIndex];
        }
        if (data.departureProcIndex !== -1) {
            if (data.departureRunwayIndex > -1) {
                const runwayTransition = facility.departures[data.departureProcIndex].runwayTransitions[data.departureRunwayIndex];
                const runwayString = RunwayUtils.getRunwayNameString(runwayTransition.runwayNumber, runwayTransition.runwayDesignation);
                originOneWayRunway = RunwayUtils.matchOneWayRunwayFromDesignation(facility, runwayString);
            }
            const enrouteTransitionIndex = data.departureEnRouteTransitionIndex === 0 &&
                facility.departures[data.departureProcIndex].enRouteTransitions.length < 1 ? -1 : data.departureEnRouteTransitionIndex;
            fms.insertDeparture(facility, data.departureProcIndex, data.departureRunwayIndex, enrouteTransitionIndex, originOneWayRunway);
            return true;
        }
        else if (facility !== undefined) {
            fms.setOrigin(facility, originOneWayRunway);
            return true;
        }
        return false;
    }
    /**
     * Sets the destination airport
     * @param facility is the destination airport facility record
     * @param data is the flight plan sync data object from the world map
     * @param fms an instance of the fms
     * @returns true if a destination was set
     */
    static setDestination(facility, data, fms) {
        let destOneWayRunway = undefined;
        let setDestination = false;
        if (data.arrivalProcIndex !== -1) {
            if (data.arrivalRunwayIndex > -1) {
                const runwayTransition = facility.arrivals[data.arrivalProcIndex].runwayTransitions[data.arrivalRunwayIndex];
                if (runwayTransition !== undefined) {
                    const runwayString = RunwayUtils.getRunwayNameString(runwayTransition.runwayNumber, runwayTransition.runwayDesignation);
                    destOneWayRunway = RunwayUtils.matchOneWayRunwayFromDesignation(facility, runwayString);
                }
            }
            const enrouteTransitionIndex = data.arrivalEnRouteTransitionIndex === 0 &&
                facility.arrivals[data.arrivalProcIndex].enRouteTransitions.length < 1 ? -1 : data.arrivalEnRouteTransitionIndex;
            fms.insertArrival(facility, data.arrivalProcIndex, data.arrivalRunwayIndex, enrouteTransitionIndex, destOneWayRunway);
            setDestination = true;
        }
        if (data.approachIndex !== -1) {
            const approachTransitionIndex = data.approachTransitionIndex === 0 &&
                facility.approaches[data.approachIndex].transitions.length < 1 ? -1 : data.approachTransitionIndex;
            fms.insertApproach(facility, data.approachIndex, approachTransitionIndex);
            setDestination = true;
        }
        if (facility !== undefined && data.arrivalProcIndex === -1 && data.approachIndex === -1) {
            fms.setDestination(facility);
            setDestination = true;
        }
        return setDestination;
    }
    /**
     * Sets the enroute portion of the flight plan
     * @param data is the flight plan sync data object from the world map
     * @param plan an instance of the flight plan
     * @param fms an instance of the fms
     * @returns the last enroute segment
     */
    static setEnroute(data, plan, fms) {
        const enrouteStart = (data.departureWaypointsSize == -1) ? 1 : data.departureWaypointsSize;
        const enroute = data.waypoints.slice(enrouteStart, -(data.arrivalWaypointsSize + 1));
        let custIdx = 1;
        let currentSegment = 1;
        let lastDepartureLegIcao = undefined;
        let lastLegWasAirway = false;
        if (data.departureProcIndex > -1) {
            const depSegment = plan.getSegment(0);
            if (depSegment.legs.length > 1) {
                lastDepartureLegIcao = depSegment.legs[depSegment.legs.length - 1].leg.fixIcao;
            }
        }
        for (let i = 0; i < enroute.length; i++) {
            const wpt = enroute[i];
            const segment = plan.getSegment(currentSegment);
            if (wpt.airwayIdent) {
                if (currentSegment == 1 && lastDepartureLegIcao == wpt.icao) ;
                else {
                    const leg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: wpt.icao
                    });
                    plan.addLeg(currentSegment, leg);
                    if (!lastLegWasAirway) {
                        plan.insertSegment(currentSegment + 1, FlightPlanSegmentType.Enroute, wpt.airwayIdent);
                        currentSegment += 1;
                        // plan.setAirway(currentSegment, segment.airway + '.' + wpt.ident);
                    }
                }
                for (let j = i + 1; j < enroute.length; j++) {
                    i++;
                    const airwayLeg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: enroute[j].icao
                    });
                    plan.addLeg(currentSegment, airwayLeg);
                    if (enroute[j].airwayIdent !== wpt.airwayIdent) {
                        lastLegWasAirway = enroute[j].airwayIdent ? true : false;
                        break;
                    }
                }
                plan.setAirway(currentSegment, wpt.airwayIdent + '.' + enroute[i].ident);
                currentSegment += 1;
                plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute, lastLegWasAirway ? enroute[i].airwayIdent : undefined);
            }
            else {
                let skip = false;
                if (currentSegment == 1 && lastDepartureLegIcao == wpt.icao) {
                    skip = true;
                }
                let leg = undefined;
                if (!skip && wpt.icao.trim() == '') {
                    const re = /(?:[D][\d])|(?:DLast)|(?:TIMEVERT)|(?:TIMECLIMB)|(?:TIMECRUIS)|(?:TIMEDSCNT)|(?:TIMEAPPROACH)/;
                    skip = wpt.ident.match(re) !== null;
                }
                if (!skip && (wpt.ident === 'Custom' || wpt.icao.trim() == '')) {
                    const userFacility = UserFacilityUtils.createFromLatLon(`U      USR${custIdx.toString().padStart(2, '0')}`, wpt.lla.lat, wpt.lla.long, true, wpt.icao.trim() === '' ? wpt.ident : `Custom ${custIdx.toString().padStart(2, '0')}`);
                    fms.addUserFacility(userFacility);
                    leg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: userFacility.icao,
                        lat: wpt.lla.lat,
                        lon: wpt.lla.long
                    });
                    custIdx++;
                }
                else if (!skip && wpt.icao.trim() !== '') {
                    leg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: wpt.icao
                    });
                }
                if (leg) {
                    plan.addLeg(currentSegment, leg);
                    if (lastLegWasAirway) {
                        plan.setAirway(currentSegment, segment.airway + '.' + wpt.ident);
                        currentSegment += 1;
                        plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute);
                    }
                    lastLegWasAirway = false;
                }
            }
        }
        if (plan.getSegment(currentSegment).airway) {
            currentSegment += 1;
            plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute);
        }
        return currentSegment;
    }
    /**
     * Sets the first leg of the enroute plan as the first leg in the world map plan, but as an IF leg
     * @param data is the flight plan sync data object from the world map
     * @param plan an instance of the flight plan
     * @param fms an instance of FMS
     */
    static buildNonAirportOriginLeg(data, plan, fms) {
        const wpt = data.waypoints[0];
        if (wpt.ident === 'CUSTD' || wpt.ident === 'CUSTA') {
            const userFacility = UserFacilityUtils.createFromLatLon('U      CUSTD', wpt.lla.lat, wpt.lla.long, true, 'Custom Origin');
            fms.addUserFacility(userFacility);
            const leg = FlightPlan.createLeg({
                type: LegType.IF,
                fixIcao: 'U      CUSTD',
                lat: wpt.lla.lat,
                lon: wpt.lla.long
            });
            plan.addLeg(1, leg);
        }
        else if (wpt.icao.trim() !== '') {
            const leg = FlightPlan.createLeg({
                type: LegType.IF,
                fixIcao: wpt.icao
            });
            plan.addLeg(1, leg);
        }
    }
    /**
     * Sets the last leg of the enroute plan as the last leg in the world map plan, but as an TF leg
     * @param data is the flight plan sync data object from the world map
     * @param plan an instance of the flight plan
     * @param fms an instance of FMS
     * @param lastEnrouteSegment is the last enroute segment
     */
    static buildNonAirportDestLeg(data, plan, fms, lastEnrouteSegment) {
        const wpt = data.waypoints[data.waypoints.length - 1];
        if (wpt.ident === 'CUSTD' || wpt.ident === 'CUSTA') {
            const userFacility = UserFacilityUtils.createFromLatLon('U      CUSTA', wpt.lla.lat, wpt.lla.long, true, 'Custom Destination');
            fms.addUserFacility(userFacility);
            const leg = FlightPlan.createLeg({
                type: LegType.TF,
                fixIcao: userFacility.icao,
                lat: wpt.lla.lat,
                lon: wpt.lla.long
            });
            plan.addLeg(lastEnrouteSegment, leg);
        }
        else if (wpt.icao.trim() !== '') {
            const leg = FlightPlan.createLeg({
                type: LegType.TF,
                fixIcao: wpt.icao
            });
            plan.addLeg(lastEnrouteSegment, leg);
        }
    }
}
FlightPlanAsoboSync.fpChecksum = 0;
FlightPlanAsoboSync.fpListenerInitialized = false;

/** The data store for SelectProcedure pages */
class SelectAirwayStore {
    constructor() {
        this.inputSegment = -1;
        this.inputLeg = -1;
        this.airways = ArraySubject.create();
        this.exits = ArraySubject.create();
        this.sequence = ArraySubject.create();
    }
    /**
     * Gets the airways array for this facility.
     * @returns The an array of unique airway names.
     */
    getFacilityAirways() {
        const airways = [];
        airways.push('NONE');
        if (this.selectedFacility !== undefined && this.selectedFacility.routes.length > 0) {
            this.selectedFacility.routes.forEach((route) => {
                airways.push(route.name);
            });
            const uniqueAirways = airways.filter((v, i, a) => a.indexOf(v) === i);
            return uniqueAirways;
        }
        return [];
    }
    /**
     * Gets the airway.
     * @param airwayName is the name of the airway as a string.
     * @param facLoader is an instance of the facility loader.
     */
    async loadAirway(airwayName, facLoader) {
        var _a, _b;
        const route = (_a = this.selectedFacility) === null || _a === void 0 ? void 0 : _a.routes.find((r) => r.name === airwayName);
        if (route !== undefined && this.selectedFacility !== undefined) {
            this.selectedAirway = await facLoader.getAirway(airwayName, route.type, (_b = this.selectedFacility) === null || _b === void 0 ? void 0 : _b.icao);
        }
    }
    /**
     * Builds the sequence list for the approach preview
     * @param fms is an instance of the FMS
     */
    buildSequence(fms) {
        if (this.selectedFacility !== undefined && this.selectedAirway !== undefined && this.selectedExit !== undefined) {
            const legs = [];
            const previewPlanIndex = fms.buildAirwayPreviewSegment(this.selectedAirway, this.selectedFacility, this.selectedExit);
            const previewPlan = fms.getFlightPlan(previewPlanIndex);
            previewPlan.getSegment(0).legs.forEach((l) => {
                legs.push(Subject.create(l));
            });
            this.sequence.set(legs);
        }
    }
    /**
     * Sets the data to display the facility.
     * @param facility The airport facility to be shown.
     */
    loadFacility(facility) {
        this.selectedFacility = facility;
        this.airways.clear();
        this.exits.clear();
        this.sequence.clear();
        this.airways.set(this.getFacilityAirways());
    }
    /**
     * Empties the display content when no facility is selected
     */
    clearFacility() {
        this.selectedFacility = undefined;
        this.airways.clear();
        this.exits.clear();
        this.sequence.clear();
    }
    /**
     * Gets the exits of the selected airway.
     * @returns The airway exits.
     */
    getExits() {
        var _a;
        const exits = [];
        if (this.selectedAirway !== undefined && this.selectedAirway.waypoints.length > 1) {
            (_a = this.selectedAirway) === null || _a === void 0 ? void 0 : _a.waypoints.forEach((waypoint) => {
                exits.push(waypoint);
            });
        }
        return exits;
    }
}

/** The controller for SelectProcedure views. */
class SelectAirwayController {
    /**
     * Creates a Select Airway Controller
     * @param store The store.
     * @param selectNextCb Callback when the next control should be focused.
     * @param fms The FMS instance.
     * @param exitSelectControlRef is the ref for the exit select control.
     */
    constructor(store, selectNextCb, fms, exitSelectControlRef) {
        this.store = store;
        this.selectNextCb = selectNextCb;
        this.fms = fms;
        this.exitSelectControlRef = exitSelectControlRef;
        this.inputIcao = Subject.create('');
        this.entrySubject = Subject.create('');
        this.canLoad = Subject.create(false);
        this.emptyListText = Subject.create('NONE');
        this.entryIndex = -1;
        this.entryIndexSubject = Subject.create(-1);
        /**
         * Evaluates if the next select should be focused.
         * @param isRefresh If select event happened based on a data refresh.
         */
        this.gotoNextSelect = (isRefresh) => {
            if (!isRefresh) {
                this.selectNextCb();
            }
        };
        /**
         * Callback handler for when an airway is selected.
         * @param index is the index of the item selected
         * @param airway The airway name selected.
         * @param isRefresh If select event happened based on a data refresh.
         */
        this.onAirwaySelected = (index, airway, isRefresh) => {
            this.emptyListText.set(index <= 0 ? 'NONE' : 'LOADING...');
            this.canLoad.set(false);
            this.store.exits.clear();
            this.store.sequence.clear();
            if (!isRefresh && index > 0) {
                this.store.loadAirway(airway, this.fms.facLoader).then(() => {
                    this.store.exits.set(this.store.getExits());
                    this.exitSelectControlRef.instance.SelectedValue.set(this.entryIndex);
                    this.entryIndexSubject.set(this.entryIndex);
                    this.gotoNextSelect(isRefresh);
                });
            }
        };
        /**
         * Builds an airway menu item.
         * @param airway The airway to build the menu item for.
         * @returns A menu item definition.
         */
        this.buildAirwayMenuItem = (airway) => {
            return { id: airway, renderContent: () => FSComponent.buildComponent("span", null, airway), estimatedWidth: airway.length * ContextMenuDialog.CHAR_WIDTH };
        };
        /**
         * Callback handler for when an enroute transition is selected.
         * @param index The index of the selected transition.
         * @param item The transition selected.
         * @param isRefresh If select event happened based on a data refresh.
         */
        this.onExitSelected = (index, item, isRefresh) => {
            this.store.selectedExit = item;
            if (!isRefresh) {
                this.store.buildSequence(this.fms);
                this.gotoNextSelect(isRefresh);
                this.canLoad.set(true);
            }
        };
        /**
         * Builds an airway exit menu item.
         * @param waypoint The intersection facility of the exit.
         * @param index The index of the airway.
         * @returns A menu item definition.
         */
        this.buildExitMenuItem = (waypoint, index) => {
            const isEnabled = waypoint.icao !== this.inputIcao.get();
            if (!isEnabled) {
                console.log('entry index: ' + index);
                this.entryIndex = index;
            }
            const ident = ICAO.getIdent(waypoint.icao);
            return {
                id: index.toString(),
                renderContent: () => FSComponent.buildComponent("span", null, ident),
                isEnabled: isEnabled,
                estimatedWidth: ident.length * ContextMenuDialog.CHAR_WIDTH
            };
        };
        /** Callback handler for when load is pressed. */
        this.onLoadSelected = () => {
            this.onLoadExecuted();
        };
        /** Callback handler for when load is pressed. */
        this.onLoadExecuted = () => {
            if (this.store.selectedFacility !== undefined && this.store.selectedAirway !== undefined && this.store.selectedExit !== undefined) {
                this.fms.insertAirwaySegment(this.store.selectedAirway, this.store.selectedFacility, this.store.selectedExit, this.store.inputSegment, this.store.inputLeg);
            }
        };
        const fpl = this.fms.bus.getSubscriber();
        fpl.on('fplCalculated').handle((e) => {
            if (e.planIndex == 2) {
                const plan = this.fms.flightPlanner.getFlightPlan(2);
                if (plan.segmentCount > 0) {
                    const segment = plan.getSegment(0);
                    for (let i = 0; i < segment.legs.length; i++) {
                        const leg = this.store.sequence.tryGet(i);
                        if (leg !== undefined) {
                            leg.get().calculated = segment.legs[i].calculated;
                            leg.notify();
                        }
                    }
                }
            }
        });
    }
    /**
     * Sets existing fix for Direct To Existing
     * @param inputData is the DirectToInputData
     */
    async setExistingFix(inputData) {
        if ((inputData === null || inputData === void 0 ? void 0 : inputData.legIndex) !== undefined && (inputData === null || inputData === void 0 ? void 0 : inputData.segmentIndex) !== undefined) {
            const plan = this.fms.getFlightPlan();
            const segment = plan.getSegment(inputData.segmentIndex);
            const fixIcao = segment.legs[inputData.legIndex].leg.fixIcao;
            this.inputIcao.set(fixIcao);
            this.entrySubject.set(ICAO.getIdent(this.inputIcao.get()));
            const fac = await this.getFacility(this.inputIcao.get());
            this.store.loadFacility(fac);
            this.gotoNextSelect(false);
        }
        else {
            this.inputIcao.set('');
        }
    }
    /** Initialize the controller. */
    initialize() {
        this.emptyListText.set('NONE');
        this.canLoad.set(false);
        this.store.clearFacility();
    }
    /** Get the facility.
     * @param icao is the intersection icao
     * @returns an Intersection Facility
     */
    async getFacility(icao) {
        const facility = await this.fms.facLoader.getFacility(FacilityType.Intersection, icao);
        return facility;
    }
}

/**
 * A view which allows the user to select an airway.
 */
class SelectAirway extends UiView {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.exitSelectControlRef = FSComponent.createRef();
        /** Goto and activate next select control. */
        this.gotoNextSelect = () => {
            this.scrollController.gotoNext();
        };
        this.store = new SelectAirwayStore();
        this.controller = new SelectAirwayController(this.store, this.gotoNextSelect, this.props.fms, this.exitSelectControlRef);
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.CLR:
                this.close();
                return true;
        }
        return false;
    }
    /** @inheritdoc */
    onInputDataSet(inputData) {
        this.store.inputSegment = (inputData === null || inputData === void 0 ? void 0 : inputData.segmentIndex) !== undefined ? inputData === null || inputData === void 0 ? void 0 : inputData.segmentIndex : -1;
        this.store.inputLeg = (inputData === null || inputData === void 0 ? void 0 : inputData.legIndex) !== undefined ? inputData === null || inputData === void 0 ? void 0 : inputData.legIndex : -1;
        this.controller.setExistingFix(inputData);
    }
    /** @inheritdoc */
    onViewOpened() {
        this.controller.initialize();
    }
    /**
     * A callback which is called when the Load action is executed.
     */
    onLoadExecuted() {
        this.controller.onLoadExecuted();
        this.close();
    }
    /**
     * Renders the airway select control component.
     * @param dialogPosition The position of the pop-up context menu dialog spawned by the select control.
     * @returns The rendered airway select control component, as a VNode.
     */
    renderAirwaySelectControl(dialogPosition) {
        return (FSComponent.buildComponent(SelectControl, { onRegister: this.register, class: "set-airway-airway-value", dialogPosition: dialogPosition, outerContainer: this.viewContainerRef, data: this.store.airways, buildMenuItem: this.controller.buildAirwayMenuItem, onItemSelected: this.controller.onAirwaySelected }));
    }
    /**
     * Renders the exit waypoint select control component.
     * @param dialogPosition The position of the pop-up context menu dialog spawned by the select control.
     * @returns The rendered exit waypoint select control component, as a VNode.
     */
    renderExitSelectControl(dialogPosition) {
        return (FSComponent.buildComponent(SelectControl, { onRegister: this.register, class: "set-airway-exit-value", ref: this.exitSelectControlRef, dialogPosition: dialogPosition, outerContainer: this.viewContainerRef, nullSelectionText: this.controller.emptyListText, data: this.store.exits, onItemSelected: this.controller.onExitSelected, buildMenuItem: this.controller.buildExitMenuItem, dialogScrollStartIndex: this.controller.entryIndexSubject }));
    }
    /**
     * Renders the load button.
     * @returns the rendered load button, as a VNode.
     */
    renderLoadButton() {
        return (FSComponent.buildComponent(ActionButton, { onRegister: this.register, onExecute: this.onLoadExecuted.bind(this), isVisible: this.controller.canLoad, text: "Load?" }));
    }
}

/**
 * A view which allows the user to select an airway on the PFD.
 */
class PFDSelectAirway extends SelectAirway {
    // eslint-disable-next-line jsdoc/require-jsdoc
    render() {
        return (FSComponent.buildComponent("div", { class: 'popout-dialog', ref: this.viewContainerRef },
            FSComponent.buildComponent("h1", null, this.props.title),
            FSComponent.buildComponent("div", { class: "set-airway-container" },
                FSComponent.buildComponent("div", { class: "set-airway-entry" }, "Entry"),
                FSComponent.buildComponent("div", { class: "set-airway-entry-value" }, this.controller.entrySubject),
                FSComponent.buildComponent("div", { class: "set-airway-airway" }, "Airway"),
                this.renderAirwaySelectControl(ContextMenuPosition.BOTTOM),
                FSComponent.buildComponent("div", { class: "set-airway-exit" }, "Exit"),
                this.renderExitSelectControl(ContextMenuPosition.BOTTOM),
                FSComponent.buildComponent("div", { class: "set-airway-press-ent" }, this.renderLoadButton()))));
    }
}

/**
 * The DMEWindow
 * component.
 */
class DMEWindow extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.navSource = Subject.create('NAV1');
        this.navFreq = Subject.create('___.__');
        this.navDist = Subject.create('- - . -');
        this.dmeElement = FSComponent.createRef();
        /**
         * Updated the DME Display.
         * @param toggle If the DME button has been turned on or off
         */
        this.updateDMEDisplay = (toggle) => {
            if (toggle) {
                this.dmeElement.instance.style.display = '';
            }
            else {
                this.dmeElement.instance.style.display = 'none';
            }
        };
        /**
         * Offsets the display to the left when the HSI map is active to prevent it from being obscured
         * @param isHSIMAP Boolean if HSI map is active or not
         */
        this.setOffset = (isHSIMAP) => {
            if (isHSIMAP) {
                this.dmeElement.instance.classList.add('DME-window-hsi-map');
            }
            else {
                this.dmeElement.instance.classList.remove('DME-window-hsi-map');
            }
        };
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        const control = this.props.bus.getSubscriber();
        control.on('dme_toggle').handle(this.updateDMEDisplay);
        const navcom = this.props.bus.getSubscriber();
        navcom.on('setFrequency').handle((setFrequency) => {
            if (setFrequency.radio.radioType === RadioType.Nav && setFrequency.bank == FrequencyBank.Active) {
                const srcIndex = this.props.navIndicatorController.dmeSourceIndex.get();
                this.navSource.set(`NAV${srcIndex + 1}`);
                const frequency = this.props.navIndicatorController.navStates[srcIndex].frequency;
                if (frequency) {
                    this.navFreq.set(`${(Math.round(frequency * 100) / 100).toFixed(2)}`);
                }
            }
        });
        PFDUserSettings.getManager(this.props.bus).whenSettingChanged('mapLayout').handle((mode) => {
            this.setOffset(mode === PfdMapLayoutSettingMode.HSI);
        });
        this.dmeElement.instance.style.display = 'none';
        this.props.navIndicatorController.dmeSourceIndex.sub((v) => {
            this.navSource.set(`NAV${v + 1}`);
            const frequency = this.props.navIndicatorController.navStates[v].frequency;
            if (frequency) {
                this.navFreq.set(`${(Math.round(frequency * 100) / 100).toFixed(2)}`);
            }
        });
        this.props.navIndicatorController.dmeDistanceSubject.sub((v) => {
            if (v >= 100) {
                this.navDist.set(v.toFixed(0));
            }
            else if (v > 0) {
                this.navDist.set(v.toFixed(1));
            }
            else {
                this.navDist.set('- - . -');
            }
        });
        this.init();
    }
    /**
     * Inits the DME Display.
     */
    init() {
        setTimeout(() => {
            const frequency = this.props.navIndicatorController.navStates[0].frequency;
            if (frequency) {
                this.navFreq.set(`${(Math.round(frequency * 100) / 100).toFixed(2)}`);
            }
        }, 2000);
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { ref: this.dmeElement, class: "DME-window" },
            FSComponent.buildComponent("div", null, "DME"),
            FSComponent.buildComponent("div", { class: "cyan" }, this.navSource),
            FSComponent.buildComponent("div", { class: "cyan" }, this.navFreq),
            FSComponent.buildComponent("div", null,
                this.navDist,
                FSComponent.buildComponent("span", { class: "size14" }, " NM"))));
    }
}

/** The controller for the Wind Overlay. */
class WindOptionController {
    /**
     * Creates the Wind Overlay Controller
     * @param bus is the event bus
     * @param store is the WindOptionStore
     */
    constructor(bus, store) {
        this.bus = bus;
        this.store = store;
        const settingManager = PFDUserSettings.getManager(bus);
        settingManager.whenSettingChanged('windOption').handle((opt) => {
            this.store.selectedView.set(opt);
        });
        const adc = this.bus.getSubscriber();
        adc.on('ambient_wind_velocity').withPrecision(1).handle((v) => {
            this.store.lastWindVelocity = v;
            this.store.currentWind.set({ direction: this.store.lastWindDirection, velocity: v });
        });
        adc.on('ambient_wind_direction').withPrecision(1).handle((v) => {
            this.store.lastWindDirection = v;
            this.store.currentWind.set({ direction: v, velocity: this.store.lastWindVelocity });
        });
        adc.on('hdg_deg').withPrecision(1).handle((hdg) => {
            this.store.currentHeading.set(hdg);
        });
        adc.on('ias').withPrecision(0).handle((v) => {
            this.store.lastIas = v;
            this.noWindHandler(undefined, v);
        });
        adc.on('on_ground').handle((v) => {
            this.store.lastOnGround = v;
            this.noWindHandler(v, undefined);
        });
        this.store.noWindData.sub(() => {
            this.updateView();
        });
        this.store.selectedView.sub(() => {
            this.updateView();
        }, true);
    }
    /**
     * The No Wind Handler.
     * @param onGround is whether the plane is on the ground
     * @param ias is the indicated airspeed
     */
    noWindHandler(onGround, ias) {
        onGround = onGround === undefined ? this.store.lastOnGround : onGround;
        ias = ias === undefined ? this.store.lastIas : ias;
        if (onGround && ias < 30) {
            this.store.noWindData.set(true);
        }
        else {
            this.store.noWindData.set(false);
        }
    }
    /** Updates the view. */
    updateView() {
        const view = this.store.selectedView.get();
        const noData = this.store.noWindData.get();
        if (view === WindOverlaySettingMode.Off) {
            this.store.renderOption.set(WindOverlayRenderOption.NONE);
        }
        else if (noData) {
            this.store.renderOption.set(WindOverlayRenderOption.NOWIND);
        }
        else {
            switch (view) {
                case WindOverlaySettingMode.Opt1:
                    this.store.renderOption.set(WindOverlayRenderOption.OPT1);
                    break;
                case WindOverlaySettingMode.Opt2:
                    this.store.renderOption.set(WindOverlayRenderOption.OPT2);
                    break;
                case WindOverlaySettingMode.Opt3:
                    this.store.renderOption.set(WindOverlayRenderOption.OPT3);
                    break;
            }
        }
    }
}
var WindOverlayRenderOption;
(function (WindOverlayRenderOption) {
    WindOverlayRenderOption[WindOverlayRenderOption["NONE"] = 0] = "NONE";
    WindOverlayRenderOption[WindOverlayRenderOption["OPT1"] = 1] = "OPT1";
    WindOverlayRenderOption[WindOverlayRenderOption["OPT2"] = 2] = "OPT2";
    WindOverlayRenderOption[WindOverlayRenderOption["OPT3"] = 3] = "OPT3";
    WindOverlayRenderOption[WindOverlayRenderOption["NOWIND"] = 4] = "NOWIND";
})(WindOverlayRenderOption || (WindOverlayRenderOption = {}));
/** The data store for Wind Overlay */
class WindOptionStore {
    constructor() {
        this.selectedView = Subject.create(WindOverlaySettingMode.Off);
        this.currentWind = Subject.create({ direction: 0, velocity: 0 });
        this.currentHeading = Subject.create(0);
        this.noWindData = Subject.create(true);
        this.renderOption = Subject.create(WindOverlayRenderOption.NONE);
        this.lastWindDirection = 0;
        this.lastWindVelocity = 0;
        this.lastIas = 0;
        this.lastOnGround = true;
    }
}

/**
 * The Wind Option Component
 */
class WindOption extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
    }
    /**
     * Do stuff after rendering.
     */
    onAfterRender() {
        //noop
    }
    /**
     * Set as visible or not.
     * @param isVisible is whether to set this visible or not.
     */
    setVisible(isVisible) {
        if (isVisible) {
            this.containerRef.instance.classList.remove('disabled');
        }
        else {
            this.containerRef.instance.classList.add('disabled');
        }
    }
    /**
     * Renders the component - to be overridden.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", null));
    }
}

/**
 * The Wind Option 1 Component
 */
class WindOption1 extends WindOption {
    constructor() {
        super(...arguments);
        this.leftXwindArrowRef = FSComponent.createRef();
        this.rightXwindArrowRef = FSComponent.createRef();
        this.headwindArrowRef = FSComponent.createRef();
        this.tailwindArrowRef = FSComponent.createRef();
        this.headwindValue = Subject.create(0);
        this.crosswindValue = Subject.create(0);
    }
    /**
     * Do stuff after rendering.
     */
    onAfterRender() {
        var _a;
        this.props.renderOption.sub((v) => {
            if (v === WindOverlayRenderOption.OPT1) {
                this.setVisible(true);
            }
            else {
                this.setVisible(false);
            }
        });
        this.props.windData.sub(() => {
            this.update();
        });
        (_a = this.props.aircraftHeading) === null || _a === void 0 ? void 0 : _a.sub(() => {
            this.update();
        });
    }
    /**
     * Update the component data.
     */
    update() {
        var _a, _b;
        const hdg = ((_a = this.props.aircraftHeading) === null || _a === void 0 ? void 0 : _a.get()) !== undefined ? (_b = this.props.aircraftHeading) === null || _b === void 0 ? void 0 : _b.get() : 0;
        const windData = this.props.windData.get();
        const crosswind = Math.trunc(windData.velocity *
            (Math.sin((hdg * Math.PI / 180) - (windData.direction * Math.PI / 180))));
        const headwind = Math.trunc(windData.velocity *
            (Math.cos((hdg * Math.PI / 180) - (windData.direction * Math.PI / 180))));
        this.crosswindValue.set(Math.abs(crosswind));
        this.headwindValue.set(Math.abs(headwind));
        if (crosswind > 0 && this.leftXwindArrowRef.instance !== null) {
            this.leftXwindArrowRef.instance.classList.remove('disabled');
            this.rightXwindArrowRef.instance.classList.add('disabled');
        }
        else if (crosswind < 0 && this.rightXwindArrowRef.instance !== null) {
            this.rightXwindArrowRef.instance.classList.remove('disabled');
            this.leftXwindArrowRef.instance.classList.add('disabled');
        }
        else {
            this.rightXwindArrowRef.instance.classList.add('disabled');
            this.leftXwindArrowRef.instance.classList.add('disabled');
        }
        if (headwind > 0 && this.headwindArrowRef.instance !== null) {
            this.headwindArrowRef.instance.classList.remove('disabled');
            this.tailwindArrowRef.instance.classList.add('disabled');
        }
        else if (headwind < 0 && this.tailwindArrowRef.instance !== null) {
            this.tailwindArrowRef.instance.classList.remove('disabled');
            this.headwindArrowRef.instance.classList.add('disabled');
        }
        else {
            this.tailwindArrowRef.instance.classList.add('disabled');
            this.headwindArrowRef.instance.classList.add('disabled');
        }
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { ref: this.containerRef, class: "opt1 disabled" },
            FSComponent.buildComponent("svg", null,
                FSComponent.buildComponent("path", { d: "M 7 11 l 0 2 l 20 0 l 0 -2 l -20 0 z", fill: "whitesmoke", stroke: "rgb(128,128,128)", "stroke-width": "1px" }),
                FSComponent.buildComponent("path", { d: "M 16 2 l 0 20 l 2 0 l 0 -20 z", fill: "whitesmoke", stroke: "rgb(128,128,128)", "stroke-width": "1px" })),
            FSComponent.buildComponent("div", { ref: this.leftXwindArrowRef, class: "left-xwind-arrow disabled" },
                FSComponent.buildComponent("svg", null,
                    FSComponent.buildComponent("path", { class: "left-xwind", d: "M 29 12 l -5 5 l 0 -10 z", fill: "whitesmoke", stroke: "gray", "stroke-width": "1px" }))),
            FSComponent.buildComponent("div", { ref: this.rightXwindArrowRef, class: "right-xwind-arrow disabled" },
                FSComponent.buildComponent("svg", null,
                    FSComponent.buildComponent("path", { d: "M 5 12 l 5 -5 l 0 10 z", fill: "whitesmoke", stroke: "gray", "stroke-width": "1px" }))),
            FSComponent.buildComponent("div", { ref: this.headwindArrowRef, class: "headwind-arrow disabled" },
                FSComponent.buildComponent("svg", null,
                    FSComponent.buildComponent("path", { d: "M 17 24 l -5 -5 l 10 0 z", fill: "whitesmoke", stroke: "gray", "stroke-width": "1px" }))),
            FSComponent.buildComponent("div", { ref: this.tailwindArrowRef, class: "tailwind-arrow disabled" },
                FSComponent.buildComponent("svg", null,
                    FSComponent.buildComponent("path", { class: "tailwind", d: "M 17 0 l -5 5 l 10 0 z", fill: "whitesmoke", stroke: "gray", "stroke-width": "1px" }))),
            FSComponent.buildComponent("div", { class: "crosswind-value size18" }, this.crosswindValue),
            FSComponent.buildComponent("div", { class: "headwind-value size18" }, this.headwindValue)));
    }
}

/**
 * The Wind Option 2 Component
 */
class WindOption2 extends WindOption {
    constructor() {
        super(...arguments);
        this.option2RotateRef = FSComponent.createRef();
        this.windSpeedValue = Subject.create(0);
    }
    /**
     * Do stuff after rendering.
     */
    onAfterRender() {
        var _a;
        this.props.renderOption.sub((v) => {
            if (v === WindOverlayRenderOption.OPT2) {
                this.setVisible(true);
            }
            else {
                this.setVisible(false);
            }
        });
        this.props.windData.sub(() => {
            this.update();
        });
        (_a = this.props.aircraftHeading) === null || _a === void 0 ? void 0 : _a.sub(() => {
            this.update();
        });
    }
    /**
     * Update the component data.
     */
    update() {
        var _a, _b;
        const hdg = ((_a = this.props.aircraftHeading) === null || _a === void 0 ? void 0 : _a.get()) !== undefined ? (_b = this.props.aircraftHeading) === null || _b === void 0 ? void 0 : _b.get() : 0;
        const windData = this.props.windData.get();
        const windAbsolute = Math.abs(Math.round(windData.velocity));
        let rotate = windData.direction - hdg;
        if (rotate > 180) {
            rotate = rotate - 360;
        }
        else if (rotate < -180) {
            rotate = rotate + 360;
        }
        rotate = (rotate + 180) % 360;
        this.windSpeedValue.set(windAbsolute);
        if (this.option2RotateRef.instance !== null && windAbsolute !== 0) {
            this.option2RotateRef.instance.style.transform = `rotate3d(0, 0, 1, ${rotate}deg)`;
        }
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { ref: this.containerRef, class: "opt2 disabled" },
            FSComponent.buildComponent("div", { ref: this.option2RotateRef, class: "arrow-rotate" },
                FSComponent.buildComponent("svg", null,
                    FSComponent.buildComponent("path", { d: "M 6 21 L 6 5 L 10 5 L 5 0 l -5 5 l 4 0 L 4 21 z", fill: "whitesmoke", stroke: "gray", "stroke-width": "1px" }))),
            FSComponent.buildComponent("div", { class: "wind-speed-solo size18" }, this.windSpeedValue)));
    }
}

/**
 * The Wind Option 3 Component
 */
class WindOption3 extends WindOption {
    constructor() {
        super(...arguments);
        this.option3RotateRef = FSComponent.createRef();
        this.windSpeedValue = Subject.create(0);
        this.windDirectionValue = ComputedSubject.create(0, (v) => {
            if (v === 0) {
                return '360°';
            }
            else {
                return v.toFixed(0).padStart(3, '0') + '°';
            }
        });
    }
    /**
     * Do stuff after rendering.
     */
    onAfterRender() {
        var _a;
        this.props.renderOption.sub((v) => {
            if (v === WindOverlayRenderOption.OPT3) {
                this.setVisible(true);
            }
            else {
                this.setVisible(false);
            }
        });
        this.props.windData.sub(() => {
            this.update();
        });
        (_a = this.props.aircraftHeading) === null || _a === void 0 ? void 0 : _a.sub(() => {
            this.update();
        });
    }
    /**
     * Update the component data.
     */
    update() {
        var _a, _b;
        const hdg = ((_a = this.props.aircraftHeading) === null || _a === void 0 ? void 0 : _a.get()) !== undefined ? (_b = this.props.aircraftHeading) === null || _b === void 0 ? void 0 : _b.get() : 0;
        const windData = this.props.windData.get();
        const windAbsolute = Math.abs(Math.round(windData.velocity));
        let rotate = windData.direction - hdg;
        if (rotate > 180) {
            rotate = rotate - 360;
        }
        else if (rotate < -180) {
            rotate = rotate + 360;
        }
        rotate = (rotate + 180) % 360;
        this.windSpeedValue.set(windAbsolute);
        if (this.option3RotateRef.instance !== null && windAbsolute !== 0) { //Prevents rotation spasms when the sim returns chaotic wind direction with zero velocity
            this.option3RotateRef.instance.style.transform = `rotate3d(0, 0, 1, ${rotate}deg)`;
            this.windDirectionValue.set(Math.round(windData.direction));
        }
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { ref: this.containerRef, class: "opt3 disabled" },
            FSComponent.buildComponent("div", { ref: this.option3RotateRef, class: "arrow-rotate" },
                FSComponent.buildComponent("svg", null,
                    FSComponent.buildComponent("path", { d: "M 6 21 L 6 5 L 10 5 L 5 0 l -5 5 l 4 0 L 4 21 z", fill: "whitesmoke", stroke: "gray", "stroke-width": "1px" }))),
            FSComponent.buildComponent("div", { class: "wind-direction size14" },
                FSComponent.buildComponent("span", null, this.windDirectionValue)),
            FSComponent.buildComponent("div", { class: "wind-speed size14" },
                FSComponent.buildComponent("span", null, this.windSpeedValue),
                FSComponent.buildComponent("span", { class: "size10" }, "KT"))));
    }
}

/** The PFD wind overlay. */
class WindOverlay extends DisplayComponent {
    /**
     * Creates an instance of Wind Overlay.
     * @param props The props.
     */
    constructor(props) {
        super(props);
        this.option1Ref = FSComponent.createRef();
        this.option2Ref = FSComponent.createRef();
        this.option3Ref = FSComponent.createRef();
        this.windBoxRef = FSComponent.createRef();
        this.noDataRef = FSComponent.createRef();
        this.store = new WindOptionStore();
        this.controller = new WindOptionController(this.props.bus, this.store);
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        this.store.renderOption.sub((v) => {
            if (v === WindOverlayRenderOption.NOWIND) {
                this.noDataRef.instance.classList.remove('disabled');
            }
            else {
                this.noDataRef.instance.classList.add('disabled');
            }
            if (v === WindOverlayRenderOption.NONE) {
                this.windBoxRef.instance.classList.add('disabled');
            }
            else {
                this.windBoxRef.instance.classList.remove('disabled');
            }
        }, true);
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { ref: this.windBoxRef, class: "wind-overlay disabled" },
            FSComponent.buildComponent("div", { ref: this.noDataRef }, "NO WIND DATA"),
            FSComponent.buildComponent(WindOption1, { ref: this.option1Ref, windData: this.store.currentWind, aircraftHeading: this.store.currentHeading, renderOption: this.store.renderOption }),
            FSComponent.buildComponent(WindOption2, { ref: this.option2Ref, windData: this.store.currentWind, aircraftHeading: this.store.currentHeading, renderOption: this.store.renderOption }),
            FSComponent.buildComponent(WindOption3, { ref: this.option3Ref, windData: this.store.currentWind, aircraftHeading: this.store.currentHeading, renderOption: this.store.renderOption })));
    }
}

/**
 * Traffic Advisory System for the G1000.
 */
class TrafficAdvisorySystem extends TCAS {
    constructor() {
        super(...arguments);
        this.operatingModeSetting = TrafficUserSettings.getManager(this.bus).getSetting('trafficOperatingMode');
        this.cdiScalingLabel = CDIScaleLabel.Enroute;
        this.operatingModeChangeTimer = null;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    createSensitivity() {
        return new TASSensitivity();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    init() {
        super.init();
        this.bus.getSubscriber().on('lnavCdiScalingLabel').whenChanged().handle(label => { this.cdiScalingLabel = label; });
        this.bus.getSubscriber().on('trafficOperatingMode').whenChanged().handle((value) => {
            this.operatingModeSub.set(value === TrafficOperatingModeSetting.Operating ? TCASOperatingMode.TAOnly : TCASOperatingMode.Standby);
        });
        this.operatingModeSub.sub(() => this.cancelOperatingModeChange());
        this.bus.getSubscriber().on('on_ground').whenChanged().handle(this.onGroundChanged.bind(this));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    createIntruderEntry(contact) {
        return new TASIntruder(contact);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    updateIntruderAlertLevel(simTime, intruder) {
        intruder.updateAlertLevel(simTime, this.isOwnAirplaneOnGround);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    updateSensitivity() {
        // TODO: Add radar alt data for planes that have it
        this.sensitivity.update(this.ownAirplaneSubs.altitude.get(), this.cdiScalingLabel);
    }
    /**
     * A callback which is called when whether own airplane is on the ground changes.
     * @param isOnGround Whether own airplane is on the ground.
     */
    onGroundChanged(isOnGround) {
        this.cancelOperatingModeChange();
        if (isOnGround) {
            if (this.operatingModeSetting.value === TrafficOperatingModeSetting.Operating) {
                this.scheduleOperatingModeChange(TrafficOperatingModeSetting.Standby, TrafficAdvisorySystem.LANDING_STANDBY_DELAY);
            }
        }
        else {
            if (this.operatingModeSetting.value === TrafficOperatingModeSetting.Standby) {
                this.scheduleOperatingModeChange(TrafficOperatingModeSetting.Operating, TrafficAdvisorySystem.TAKEOFF_OPER_DELAY);
            }
        }
    }
    /**
     * Schedules a delayed operating mode change.
     * @param toMode The target operating mode.
     * @param delay The delay, in milliseconds.
     */
    scheduleOperatingModeChange(toMode, delay) {
        this.cancelOperatingModeChange();
        this.operatingModeChangeTimer = setTimeout(() => {
            this.operatingModeSetting.value = toMode;
            this.operatingModeChangeTimer = null;
        }, delay);
    }
    /**
     * Cancels the currently scheduled operating mode change, if one exists.
     */
    cancelOperatingModeChange() {
        if (this.operatingModeChangeTimer === null) {
            return;
        }
        clearTimeout(this.operatingModeChangeTimer);
        this.operatingModeChangeTimer = null;
    }
}
TrafficAdvisorySystem.TAKEOFF_OPER_DELAY = 8000; // milliseconds
TrafficAdvisorySystem.LANDING_STANDBY_DELAY = 24000; // milliseconds
/**
 * An intruder tracked by the the G1000 TAS.
 */
class TASIntruder extends AbstractTCASIntruder {
    constructor() {
        super(...arguments);
        this.lastHorizontalSep = UnitType.NMILE.createNumber(0);
        this.lastVerticalSep = UnitType.FOOT.createNumber(0);
        this.taOnTime = 0;
        this.taOffTime = 0;
    }
    /**
     * Updates this intruder's assigned alert level.
     * @param simTime The current sim time.
     * @param isOnGround Whether the own airplane is on the ground.
     */
    updateAlertLevel(simTime, isOnGround) {
        if (!this.isPredictionValid) {
            this.alertLevel.set(TCASAlertLevel.None);
        }
        let isTA = false;
        const currentTime = simTime;
        const currentAlertLevel = this.alertLevel.get();
        if (isOnGround) {
            // suppress traffic advisories while own aircraft is on the ground
            if (currentAlertLevel === TCASAlertLevel.TrafficAdvisory) {
                this.taOffTime = currentTime;
            }
        }
        else if (this.tcaNorm <= 1) {
            if (currentAlertLevel !== TCASAlertLevel.TrafficAdvisory) {
                const dt = currentTime - this.taOffTime;
                if (dt >= TASIntruder.TA_ON_HYSTERESIS) {
                    isTA = true;
                    this.taOnTime = currentTime;
                }
            }
            else {
                isTA = true;
            }
        }
        else if (currentAlertLevel === TCASAlertLevel.TrafficAdvisory) {
            const dt = currentTime - this.taOnTime;
            if (dt >= TASIntruder.TA_OFF_HYSTERESIS) {
                this.taOffTime = currentTime;
            }
            else {
                isTA = true;
            }
        }
        if (isTA) {
            this.alertLevel.set(TCASAlertLevel.TrafficAdvisory);
        }
        else {
            this.updateNonTAAlertLevel(simTime);
        }
    }
    /**
     * Updates this intruder's assigned alert level, assuming it does not quality for a traffic advisory.
     * @param simTime The current sim time.
     */
    updateNonTAAlertLevel(simTime) {
        this.predictSeparation(simTime, this.lastHorizontalSep, this.lastVerticalSep);
        if (this.lastHorizontalSep.number <= 6 // 6 nm
            && this.lastVerticalSep.number <= 1200 // 1200 ft
        ) {
            this.alertLevel.set(TCASAlertLevel.ProximityAdvisory);
        }
        else {
            this.alertLevel.set(TCASAlertLevel.None);
        }
    }
}
TASIntruder.TA_ON_HYSTERESIS = 2000; // ms
TASIntruder.TA_OFF_HYSTERESIS = 8000; // ms
/**
 * Sensitivity settings for the the G1000 TAS.
 */
class TASSensitivity extends AbstractTCASSensitivity {
    /**
     * Updates the sensitivity level.
     * @param altitude The indicated altitude of the own airplane.
     * @param cdiScalingLabel The CDI scaling sensitivity of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     */
    update(altitude, cdiScalingLabel, radarAltitude) {
        const altFeet = altitude.asUnit(UnitType.FOOT);
        const radarAltFeet = radarAltitude === null || radarAltitude === void 0 ? void 0 : radarAltitude.asUnit(UnitType.FOOT);
        let isApproach = false;
        switch (cdiScalingLabel) {
            case CDIScaleLabel.LNav:
            case CDIScaleLabel.LNavPlusV:
            case CDIScaleLabel.LNavVNav:
            case CDIScaleLabel.LP:
            case CDIScaleLabel.LPPlusV:
            case CDIScaleLabel.LPV:
            case CDIScaleLabel.MissedApproach:
                isApproach = true;
        }
        let level;
        if ((radarAltFeet === undefined || radarAltFeet > 2350)
            && (!isApproach && cdiScalingLabel !== CDIScaleLabel.Terminal)) {
            if (altFeet > 42000) {
                level = 6;
            }
            else if (altFeet > 20000) {
                level = 5;
            }
            else if (altFeet > 10000) {
                level = 4;
            }
            else if (altFeet > 5000) {
                level = 3;
            }
            else {
                level = 2;
            }
        }
        else if (cdiScalingLabel === CDIScaleLabel.Terminal
            || (radarAltFeet !== undefined && radarAltFeet > 1000)) {
            level = 1;
        }
        else {
            level = 0;
        }
        const parameters = TASSensitivity.LEVELS[level];
        this.lookaheadTime.set(parameters.lookaheadTime);
        this.protectedRadius.set(parameters.protectedRadius);
        this.protectedHeight.set(parameters.protectedHeight);
    }
}
TASSensitivity.LEVELS = [
    {
        lookaheadTime: 20,
        protectedRadius: 0.2,
        protectedHeight: 850
    },
    {
        lookaheadTime: 25,
        protectedRadius: 0.2,
        protectedHeight: 850
    },
    {
        lookaheadTime: 30,
        protectedRadius: 0.35,
        protectedHeight: 850
    },
    {
        lookaheadTime: 40,
        protectedRadius: 0.55,
        protectedHeight: 850
    },
    {
        lookaheadTime: 45,
        protectedRadius: 0.8,
        protectedHeight: 850
    },
    {
        lookaheadTime: 48,
        protectedRadius: 1.1,
        protectedHeight: 850
    },
    {
        lookaheadTime: 48,
        protectedRadius: 1.1,
        protectedHeight: 1200
    }
];

/**
 * Manages backlight levels for the PFD and MFD screens and softkeys.
 */
class BacklightManager {
    /**
     * Constructor.
     * @param display The display to manage. Either the PFD or the MFD.
     * @param bus The event bus.
     */
    constructor(display, bus) {
        this.display = display;
        this.simTimeChangeConsumer = null;
        this.simTime = 0;
        this.pposChangeConsumer = null;
        this.ppos = new Float64Array(3);
        this.simTimeHandler = this.onSimTimeChanged.bind(this);
        this.pposHandler = this.onPPosChanged.bind(this);
        this.needRecalcAuto = true;
        this.MODE_SETTING_NAME = `${this.display}ScreenBacklightMode`;
        this.INTENSITY_SETTING_NAME = `${this.display}ScreenBacklightIntensity`;
        this.LVAR_NAME = `L:AS1000_${this.display}_Brightness`;
        this.settingManager = BacklightUserSettings.getManager(bus);
        this.screenIntensitySetting = this.settingManager.getSetting(this.INTENSITY_SETTING_NAME);
        const clockSubscriber = bus.getSubscriber();
        this.simTimeConsumer = clockSubscriber.on('simTime');
        this.pposConsumer = bus.getSubscriber().on('gps-position');
        clockSubscriber.on('realTime').atFrequency(BacklightManager.AUTO_UPDATE_REALTIME_FREQ).handle(this.onUpdate.bind(this));
    }
    /**
     * Initializes this manager. Once this manager is initialized, it will automatically set backlight levels in response
     * to changes in their settings.
     */
    init() {
        // TODO: Support key levels.
        this.settingManager.whenSettingChanged(this.MODE_SETTING_NAME).handle(this.onBacklightModeChanged.bind(this));
        this.settingManager.whenSettingChanged(this.INTENSITY_SETTING_NAME).handle(this.onScreenIntensityChanged.bind(this, this.LVAR_NAME));
    }
    /**
     * A callback which is called when the backlight mode changes.
     * @param mode The new backlight mode.
     */
    onBacklightModeChanged(mode) {
        if (this.simTimeChangeConsumer) {
            this.simTimeChangeConsumer.off(this.simTimeHandler);
            this.simTimeChangeConsumer = null;
        }
        if (this.pposChangeConsumer) {
            this.pposChangeConsumer.off(this.pposHandler);
            this.pposChangeConsumer = null;
        }
        if (mode === BacklightMode.Auto) {
            this.simTimeChangeConsumer = this.simTimeConsumer.whenChangedBy(BacklightManager.AUTO_UPDATE_SIMTIME_THRESHOLD);
            this.simTimeChangeConsumer.handle(this.simTimeHandler);
            this.pposChangeConsumer = this.pposConsumer.atFrequency(BacklightManager.AUTO_UPDATE_REALTIME_FREQ);
            this.pposChangeConsumer.handle(this.pposHandler);
        }
        else {
            this.needRecalcAuto = false;
        }
    }
    /**
     * A callback which is called when the screen intensity value changes.
     * @param simvar The simvar to adjust.
     * @param intensity The new intensity value.
     */
    onScreenIntensityChanged(simvar, intensity) {
        const level = BacklightManager.RESPONSE_MIN + (Math.exp(BacklightManager.RESPONSE_FACTOR * intensity / 100) - 1) * BacklightManager.RESPONSE_SCALE;
        SimVar.SetSimVarValue(simvar, 'number', level);
    }
    /**
     * A callback which is called when the sim time changes.
     * @param time The new sim time.
     */
    onSimTimeChanged(time) {
        this.simTime = time;
        this.needRecalcAuto = true;
    }
    /**
     * A callback which is called when the sim time changes.
     * @param ppos The new plane position.
     */
    onPPosChanged(ppos) {
        const pposVec = GeoPoint.sphericalToCartesian(ppos.lat, ppos.long, BacklightManager.tempVec3);
        if (Vec3Math.dot(pposVec, this.ppos) >= 1 - 1e-4) { // ~600 m
            return;
        }
        Vec3Math.copy(pposVec, this.ppos);
        this.needRecalcAuto = true;
    }
    /**
     * This method runs once per update cycle.
     */
    onUpdate() {
        if (this.needRecalcAuto) {
            this.updateAutoBacklightIntensity();
            this.needRecalcAuto = false;
        }
    }
    /**
     * Updates backlight intensity according to the auto setting algorithm.
     */
    updateAutoBacklightIntensity() {
        const subSolarPoint = BacklightManager.calculateSubSolarPoint(this.simTime, BacklightManager.tempVec3);
        const sinSolarAngle = Vec3Math.dot(this.ppos, subSolarPoint);
        const sinSolarAngleClamped = Utils.Clamp(sinSolarAngle, BacklightManager.AUTO_MIN_SOLAR_ANGLE_SIN, BacklightManager.AUTO_MAX_SOLAR_ANGLE_SIN);
        const intensityFrac = (sinSolarAngleClamped - BacklightManager.AUTO_MIN_SOLAR_ANGLE_SIN) / BacklightManager.AUTO_SOLAR_ANGLE_RANGE_SIN;
        this.screenIntensitySetting.value = Math.round(BacklightManager.AUTO_MIN_INTENSITY + intensityFrac * BacklightManager.AUTO_INTENSITY_RANGE);
    }
    /**
     * Calculates the subsolar point (the point on Earth's surface directly below the Sun, where solar zenith angle = 0)
     * given a specific time.
     * @param time A UNIX timestamp in milliseconds.
     * @param out A Float64Array object to which to write the result.
     * @returns the subsolar point at the specified time.
     */
    static calculateSubSolarPoint(time, out) {
        // Source: Zhang, T et al. https://doi.org/10.1016/j.renene.2021.03.047
        const PI2 = 2 * Math.PI;
        const days = (time - BacklightManager.EPOCH) / BacklightManager.DAY;
        const daysFrac = days - Math.floor(days);
        const L = (4.895055 + 0.01720279 * days);
        const g = (6.240041 + 0.01720197 * days);
        const lambda = L + 0.033423 * Math.sin(g) + 0.000349 * Math.sin(2 * g);
        const epsilon = 0.40910518 - 6.98e-9 * days;
        const rAscension = Math.atan2(Math.cos(epsilon) * Math.sin(lambda), Math.cos(lambda));
        const declination = Math.asin(Math.sin(epsilon) * Math.sin(lambda));
        // equation of time in days.
        const E = (((L - rAscension) % PI2 + 3 * Math.PI) % PI2 - Math.PI) * 0.159155;
        const lat = declination * Avionics.Utils.RAD2DEG;
        const lon = -15 * (daysFrac - 0.5 + E) * 24;
        return GeoPoint.sphericalToCartesian(lat, lon, out);
    }
}
// The following constants control the response of the backlight simvar to the set intensity level.
BacklightManager.RESPONSE_MIN = 0.01; // minimum backlight response
BacklightManager.RESPONSE_MAX = 2; // maximum backlight response
BacklightManager.RESPONSE_FACTOR = 3; // the greater the factor, the steeper the response curve
BacklightManager.RESPONSE_SCALE = (BacklightManager.RESPONSE_MAX - BacklightManager.RESPONSE_MIN) / (Math.exp(BacklightManager.RESPONSE_FACTOR) - 1);
BacklightManager.AUTO_UPDATE_REALTIME_FREQ = 10; // max frequency (Hz) of auto backlight level updates in real time
BacklightManager.AUTO_UPDATE_SIMTIME_THRESHOLD = 60000; // minimum interval (ms) between auto backlight level updates in sim time
BacklightManager.AUTO_MAX_INTENSITY = 100; // The maximum intensity applied by auto backlight.
BacklightManager.AUTO_MIN_INTENSITY = 30; // The minimum intensity applied by auto backlight.
BacklightManager.AUTO_INTENSITY_RANGE = BacklightManager.AUTO_MAX_INTENSITY - BacklightManager.AUTO_MIN_INTENSITY;
BacklightManager.AUTO_MAX_SOLAR_ANGLE = 3; // The solar altitude angle at which auto backlight reaches maximum intensity.
BacklightManager.AUTO_MIN_SOLAR_ANGLE = -8; // The solar altitude angle at which auto backlight reaches minimum intensity.
BacklightManager.AUTO_MAX_SOLAR_ANGLE_SIN = Math.sin(BacklightManager.AUTO_MAX_SOLAR_ANGLE * Avionics.Utils.DEG2RAD);
BacklightManager.AUTO_MIN_SOLAR_ANGLE_SIN = Math.sin(BacklightManager.AUTO_MIN_SOLAR_ANGLE * Avionics.Utils.DEG2RAD);
BacklightManager.AUTO_SOLAR_ANGLE_RANGE_SIN = BacklightManager.AUTO_MAX_SOLAR_ANGLE_SIN - BacklightManager.AUTO_MIN_SOLAR_ANGLE_SIN;
BacklightManager.EPOCH = 946684800000; // Jan 1, 2000 00:00:00 UTC
BacklightManager.DAY = 86400000; // milliseconds in one day
BacklightManager.tempVec3 = new Float64Array(3);

/**
 * A manager for G1000 settings which are saved to pilot profiles.
 */
class G1000SettingSaveManager extends UserSettingSaveManager {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
        const backlightSettingManager = BacklightUserSettings.getManager(bus);
        const mapSettingManager = MapUserSettings.getManager(bus);
        const pfdSettingManager = PFDUserSettings.getManager(bus);
        const trafficSettingManager = TrafficUserSettings.getManager(bus);
        const settings = [
            ...backlightSettingManager.getAllSettings(),
            ...pfdSettingManager.getAllSettings(),
            ...mapSettingManager.getAllSettings(),
            ...trafficSettingManager.getAllSettings().filter(setting => setting.definition.name !== 'trafficOperatingMode')
        ];
        super(settings, bus);
    }
}

/**
 * An input that can switch between time and distance.
 */
class TimeDistanceInput extends UiControlGroup {
    constructor() {
        super(...arguments);
        this.distanceSubject = Subject.create(0);
        this.minutesSubject = Subject.create(0);
        this.secondsTensSubject = Subject.create(0);
        this.secondsOnesSubject = Subject.create(0);
        this.distanceInput = FSComponent.createRef();
        this.minutesInput = FSComponent.createRef();
        this.tensInput = FSComponent.createRef();
        this.onesInput = FSComponent.createRef();
        this.minutesGroup = FSComponent.createRef();
        this.distanceGroup = FSComponent.createRef();
        this.isTimeMode = true;
        this.ignoreUpdate = false;
    }
    /** @inheritdoc */
    onAfterRender() {
        this.minutesSubject.sub(() => this.update());
        this.secondsTensSubject.sub(() => this.update());
        this.secondsOnesSubject.sub(() => this.update());
        this.distanceSubject.sub(() => this.update());
        this.props.distanceSubject.sub(v => {
            this.ignoreUpdate = true;
            this.distanceSubject.set(v.asUnit(UnitType.NMILE));
            this.ignoreUpdate = false;
        }, true);
        this.props.timeSubject.sub(v => {
            const minutes = Math.floor(v.asUnit(UnitType.MINUTE));
            const seconds = v.asUnit(UnitType.SECOND) % 60;
            this.ignoreUpdate = true;
            this.minutesSubject.set(minutes);
            this.secondsTensSubject.set(Math.floor(seconds / 10));
            this.secondsOnesSubject.set(seconds % 10);
            this.ignoreUpdate = false;
        }, true);
        this.setMode(true);
    }
    /**
     * Sets the input mode to time or distance.
     * @param isTime True if the input mode should be time, false otherwise.
     */
    setMode(isTime) {
        this.isTimeMode = isTime;
        this.minutesInput.instance.setIsEnabled(isTime);
        this.tensInput.instance.setIsEnabled(isTime);
        this.onesInput.instance.setIsEnabled(isTime);
        this.distanceInput.instance.setIsEnabled(!isTime);
        this.minutesGroup.instance.style.display = isTime ? '' : 'none';
        this.distanceGroup.instance.style.display = isTime ? 'none' : '';
    }
    /**
     * Updates the props subjects.
     */
    update() {
        if (this.ignoreUpdate) {
            return;
        }
        if (this.isTimeMode) {
            const seconds = (this.minutesSubject.get() * 60)
                + (this.secondsTensSubject.get() * 10)
                + this.secondsOnesSubject.get();
            this.props.timeSubject.set(seconds, UnitType.SECOND);
        }
        else {
            this.props.distanceSubject.set(this.distanceSubject.get(), UnitType.NMILE);
        }
    }
    /**
     * Renders the control.
     * @returns The rendered VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: this.props.class },
            FSComponent.buildComponent("div", { ref: this.distanceGroup },
                FSComponent.buildComponent(NumberInput, { ref: this.distanceInput, class: 'time-distance-input-number', minValue: 0, maxValue: 40, increment: 0.1, onRegister: this.register, wrap: true, dataSubject: this.distanceSubject, formatter: (v) => `${v.toFixed(1)}` }),
                FSComponent.buildComponent("span", { class: 'time-distance-input-nm' }, "NM")),
            FSComponent.buildComponent("div", { ref: this.minutesGroup },
                FSComponent.buildComponent(NumberInput, { class: 'time-distance-input-number', ref: this.minutesInput, minValue: 0, maxValue: 9, increment: 1, onRegister: this.register, wrap: true, dataSubject: this.minutesSubject }),
                FSComponent.buildComponent("div", { class: 'time-distance-input-number' }, ":"),
                FSComponent.buildComponent(NumberInput, { class: 'time-distance-input-number', ref: this.tensInput, minValue: 0, maxValue: 5, increment: 1, onRegister: this.register, wrap: true, dataSubject: this.secondsTensSubject }),
                FSComponent.buildComponent(NumberInput, { class: 'time-distance-input-number', ref: this.onesInput, minValue: 0, maxValue: 9, increment: 1, onRegister: this.register, wrap: true, dataSubject: this.secondsOnesSubject }))));
    }
}

/**
 * A controller for the Hold dialog.
 */
class HoldController {
    /**
     * Creates an instance of a HoldController.
     * @param store The hold store to use with this instance.
     * @param fms The FMS to use with this instance.
     */
    constructor(store, fms) {
        this.store = store;
        this.fms = fms;
        store.indexes.sub(i => {
            const plan = this.fms.getFlightPlan();
            const def = plan.getSegment(i.segmentIndex).legs[i.legIndex];
            this.store.fixIcao.set(def.leg.fixIcao);
            try {
                this.fms.facLoader.getFacility(ICAO.getFacilityType(def.leg.fixIcao), def.leg.fixIcao)
                    .then(fac => this.store.waypoint.set(new FacilityWaypoint(fac)));
            }
            catch ( /** Continue */_a) { /** Continue */ }
        }, true);
    }
    /**
     * Resets the hold dialog data.
     */
    reset() {
        this.store.distance.set(4);
        this.store.time.set(60);
        this.store.isInbound.set(0);
        this.store.isTime.set(0);
        this.store.turnDirection.set(1);
        this.store.waypoint.set(null);
        this.store.fixIcao.set('');
    }
    /**
     * Accepts the currently defined hold and adds it to the flight plan.
     */
    accept() {
        const indexes = this.store.indexes.get();
        const isTime = this.store.isTime.get() === 0 ? true : false;
        const leg = FlightPlan.createLeg({
            type: LegType.HM,
            turnDirection: this.store.turnDirection.get() + 1,
            course: this.store.isInbound.get() === 1 ? NavMath.normalizeHeading(this.store.course.get() + 180) : this.store.course.get(),
            distance: isTime ? this.store.time.get().asUnit(UnitType.MINUTE) : this.store.distance.get().asUnit(UnitType.METER),
            distanceMinutes: isTime,
            fixIcao: this.store.fixIcao.get()
        });
        this.fms.addHold(indexes.segmentIndex, indexes.legIndex, leg);
        this.reset();
    }
    /**
     * Gets a hold direction UI string for a given inbound course.
     * @param course The inbound course to get the string for.
     * @returns A UI human readable course string.
     */
    getDirectionString(course) {
        if (course >= 0 && course < 22.5) {
            return 'South';
        }
        else if (course >= 22.5 && course < 67.5) {
            return 'Southwest';
        }
        else if (course >= 67.5 && course < 112.5) {
            return 'West';
        }
        else if (course >= 112.5 && course < 157.5) {
            return 'Northwest';
        }
        else if (course >= 157.5 && course < 202.5) {
            return 'North';
        }
        else if (course >= 202.5 && course < 247.5) {
            return 'Northeast';
        }
        else if (course >= 247.5 && course < 292.5) {
            return 'East';
        }
        else if (course >= 292.5 && course < 337.5) {
            return 'Southeast';
        }
        else {
            return 'South';
        }
    }
}

/**
 * A store for the Hold page data.
 */
class HoldStore {
    constructor() {
        /** The indexes for the hold. */
        this.indexes = Subject.create({ segmentIndex: 0, legIndex: 0 });
        /** The course for the hold. */
        this.course = Subject.create(0);
        /** Whether or not the course is inbound or outbound. */
        this.isInbound = Subject.create(0);
        /** Whether or not the hold is based on time or distance. */
        this.isTime = Subject.create(0);
        /** The time that the hold legs should be. */
        this.time = NumberUnitSubject.createFromNumberUnit(UnitType.SECOND.createNumber(60));
        /** The distance of the hold legs. */
        this.distance = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(4));
        /** The direction of the hold. */
        this.turnDirection = Subject.create(0);
        /** The current leg waypoint. */
        this.waypoint = Subject.create(null);
        this.fixIcao = Subject.create('');
    }
}

/**
 * A class that displays a hold dialog.
 */
class Hold extends UiView {
    /**
     * Creates an instance of PFDHold.
     * @param props The props for this instance.
     */
    constructor(props) {
        super(props);
        this.distanceInput = FSComponent.createRef();
        this.store = new HoldStore();
        this.controller = new HoldController(this.store, props.fms);
        this.controller.reset();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.store.isTime.sub(v => this.distanceInput.instance.setMode(v === 0 ? true : false));
    }
    /** @inheritdoc */
    onInteractionEvent(evt) {
        switch (evt) {
            case FmsHEvent.CLR:
                this.close();
                return true;
        }
        return super.onInteractionEvent(evt);
    }
    /** @inheritdoc */
    onInputDataSet(input) {
        var _a, _b;
        if (input !== undefined) {
            const def = this.props.fms.getFlightPlan().getSegment(input.segmentIndex).legs[input.legIndex];
            this.store.course.set((_b = (_a = def.calculated) === null || _a === void 0 ? void 0 : _a.initialDtk) !== null && _b !== void 0 ? _b : 0);
            this.store.indexes.set(input);
        }
        else {
            this.controller.reset();
        }
    }
    /**
     * Creates a subscribable which provides a direction string based on the set hold inbound course.
     * @returns A subscribable which provides a direction string based on the set hold inbound course.
     */
    createDirectionStringSubscribable() {
        const courseString = Subject.create('');
        const courseStringHandler = () => {
            const course = this.store.course.get();
            courseString.set(this.controller.getDirectionString(this.store.isInbound.get() === 0 ? course : NavMath.normalizeHeading(course + 180)));
        };
        this.store.course.sub(courseStringHandler);
        this.store.isInbound.sub(courseStringHandler, true);
        return courseString;
    }
}

/**
 * A class that displays the PFD hold dialog.
 */
class PFDHold extends Hold {
    /**
     * Renders the PFD hold dialog.
     * @returns The rendered VNode.
     */
    render() {
        const icao = this.store.indexes.map(indexes => { var _a; return (_a = this.props.fms.getFlightPlan().getSegment(indexes.segmentIndex).legs[indexes.legIndex].name) !== null && _a !== void 0 ? _a : ''; });
        const directionString = this.createDirectionStringSubscribable();
        return (FSComponent.buildComponent("div", { class: 'popout-dialog pfd-hold', ref: this.viewContainerRef },
            FSComponent.buildComponent("h1", null, "Hold at"),
            FSComponent.buildComponent("div", { class: 'pfd-hold-grid' },
                FSComponent.buildComponent("div", { class: 'pfd-hold-row' },
                    FSComponent.buildComponent("div", null,
                        "Hold ",
                        FSComponent.buildComponent("span", null, directionString),
                        " of"),
                    FSComponent.buildComponent("div", null, icao)),
                FSComponent.buildComponent("div", { class: 'pfd-hold-row pfd-hold-linerow' },
                    FSComponent.buildComponent("div", null,
                        "Course ",
                        FSComponent.buildComponent(NumberInput, { class: 'pfd-hold-course', minValue: 1, maxValue: 360, wrap: true, dataSubject: this.store.course, increment: 1, onRegister: this.register, formatter: (v) => `${v.toFixed(0).padStart(3, '0')}°` })),
                    FSComponent.buildComponent("div", null,
                        FSComponent.buildComponent(ArrowToggle, { class: 'pfd-hold-inbound', options: ['Inbound', 'Outbound'], dataref: this.store.isInbound, onRegister: this.register }))),
                FSComponent.buildComponent("div", { class: 'pfd-hold-row pfd-hold-linerow' },
                    FSComponent.buildComponent("div", null,
                        "Leg ",
                        FSComponent.buildComponent(ArrowToggle, { class: 'pfd-hold-time', options: ['Time', 'Distance'], dataref: this.store.isTime, onRegister: this.register })),
                    FSComponent.buildComponent("div", null,
                        FSComponent.buildComponent(TimeDistanceInput, { ref: this.distanceInput, class: 'pfd-hold-distance', timeSubject: this.store.time, distanceSubject: this.store.distance, onRegister: this.register }))),
                FSComponent.buildComponent("div", { class: 'pfd-hold-row pfd-hold-linerow' },
                    FSComponent.buildComponent("div", null, "Turns"),
                    FSComponent.buildComponent("div", null,
                        FSComponent.buildComponent(ArrowToggle, { class: 'pfd-hold-direction', options: ['Left', 'Right'], dataref: this.store.turnDirection, onRegister: this.register })))),
            FSComponent.buildComponent(ActionButton, { class: 'pfd-hold-load', text: 'Load?', onExecute: () => { this.controller.accept(); this.close(); }, onRegister: this.register })));
    }
}

/**
 * Projection utils for the SVT
 */
class SvtProjectionUtils {
    /**
     * Projects vector3 to screen FoV.
     * @param x the x value
     * @param y the y value
     * @param z the z value
     * @param out The vector to which to write the results.
     * @returns The projected vector.
     */
    static project(x, y, z, out) {
        return Vec2Math.set(x * SvtProjectionUtils.FOCAL_LENGTH / z, y * SvtProjectionUtils.FOCAL_LENGTH / z, out);
    }
    /**
     * Relative yaw/pitch to plane, both in radians
     * @param yaw Yaw in radians
     * @param pitch Pitch in radians
     * @param roll Roll in radians
     * @param out The vector to which to write the results.
     * @returns projected vector with yaw/pitch
     */
    static projectYawPitch(yaw, pitch, roll, out) {
        const cos = Math.cos, sin = Math.sin;
        let x = 0;
        let y = 0;
        let z = 1;
        // pitch
        y = -sin(pitch);
        z = cos(pitch);
        // yaw
        x = z * sin(yaw);
        z = z * cos(yaw);
        // roll
        if (roll !== 0) {
            const x0 = x;
            const y0 = y;
            const sinR = sin(roll);
            const cosR = cos(roll);
            x = x0 * cosR - y0 * sinR;
            y = x0 * sinR + y0 * cosR;
        }
        return this.project(x, y, z, out);
    }
    /**
     * Projects lat long alt
     * @param latLongAlt  The coordinates of the position to project.
     * @param planeCoordinates The plane position.
     * @param heading The heading of the plane in degrees.
     * @param roll Roll in radians
     * @param out The vector to which to write the results.
     * @returns The projected position.
     */
    static projectLatLongAlt(latLongAlt, planeCoordinates, heading, roll, out) {
        const directionToPos = Avionics.Utils.computeGreatCircleHeading(planeCoordinates, latLongAlt);
        const yaw = NavMath.diffAngle(heading, directionToPos) * Avionics.Utils.DEG2RAD;
        const deltaPos = Avionics.Utils.computeGreatCircleDistance(planeCoordinates, latLongAlt) * 6076;
        const deltaAlt = Math.abs(latLongAlt.alt - planeCoordinates.alt);
        const pitch = -Math.atan2(deltaAlt, deltaPos);
        return this.projectYawPitch(yaw, pitch, roll, out);
    }
}
SvtProjectionUtils.FOV = 65;
SvtProjectionUtils.FOCAL_LENGTH = 614.4 / Math.tan(SvtProjectionUtils.FOV / 2 * Avionics.Utils.DEG2RAD);

/**
 * Artificial horizon
 */
class ArtificialHorizon extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.innerRef = FSComponent.createRef();
        this.pxPerDegY = SvtProjectionUtils.projectYawPitch(0, 0.1 * Avionics.Utils.DEG2RAD, 0, new Float64Array(2))[1] * 5; // artificial horizon pitch ratio is half of svt
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.isActive.sub(this.onIsActiveChanged.bind(this), true);
    }
    /**
     * Responds to changes in whether the artifical horizon is active.
     * @param active Whether the artifical horizon is active.
     */
    onIsActiveChanged(active) {
        this.containerRef.instance.style.display = active ? '' : 'none';
    }
    /**
     * Update method.
     * @param planeState The plane state info
     */
    update(planeState) {
        if (this.props.isActive.get()) {
            this.innerRef.instance.style.transform = `rotate(${planeState.roll}deg) translate3d(0px, ${planeState.pitch * this.pxPerDegY}px, 0px)`;
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "artificial-horizon", ref: this.containerRef },
            FSComponent.buildComponent("div", { class: "artificial-horizon-inner", ref: this.innerRef },
                FSComponent.buildComponent("div", { class: "sky" }),
                FSComponent.buildComponent("div", { class: "horizon" }),
                FSComponent.buildComponent("div", { class: "ground" }))));
    }
}

/**
 * The PFD attitude indicator.
 */
class AttitudeIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.scroll_increment = 10;
        this.pxPerDegY = SvtProjectionUtils.projectYawPitch(0, 0.1 * Avionics.Utils.DEG2RAD, 0, new Float64Array(2))[1] * 10;
        this.pitchIncrements = 2.5;
        this.numberIncrements = 2;
        this.pitchIncrementsDistance = this.pxPerDegY * this.pitchIncrements;
        this.currentPitch = 0;
        this.cutoutElement = FSComponent.createRef();
        this.pitchLinesContainer = FSComponent.createRef();
        this.pitchLinesGroup = FSComponent.createRef();
        this.bankElement = FSComponent.createRef();
        this.innerBankElement = FSComponent.createRef();
        this.zeroPitchLine = FSComponent.createRef();
        this.pitchNumbersLeft = [];
        this.pitchNumbersRight = [];
        this.turnCoordinatorElement = FSComponent.createRef();
        this.lastPitchOffset = 0;
        /**
         * A callback called when the pitch updates from the event bus.
         * @param pitch The current pitch value.
         * @param forceRedraw An override for the redraw.
         */
        this.onUpdatePitch = (pitch, forceRedraw = false) => {
            this.currentPitch = pitch;
            if (this.pitchLinesContainer.instance !== null) {
                const pitchOffset = Math.trunc((pitch / this.scroll_increment));
                if (pitchOffset !== this.lastPitchOffset || forceRedraw) {
                    this.lastPitchOffset = pitchOffset;
                    if (this.zeroPitchLine.instance !== null) {
                        this.zeroPitchLine.instance.style.visibility = pitchOffset === 0 ? 'hidden' : 'visible';
                    }
                    this.updatePitchNumbers(pitch, pitchOffset);
                }
                this.updateLinesPos(pitch);
            }
        };
        /**
         * A callback called when the ADC updates from the event bus.
         * @param roll The current ADC roll value.
         */
        this.onUpdateRoll = (roll) => {
            if (this.bankElement.instance !== null) {
                this.bankElement.instance.style.transform = `rotate(${roll}deg)`;
                this.cutoutElement.instance.style.transform = `rotate(${-roll}deg)`;
                this.innerBankElement.instance.style.transform = `rotate(${roll}deg)`;
            }
        };
        /**
         * A callback called when the ADC updates from the event bus.
         * @param turnCoordinator The current ADC turn_coordinator_ball value.
         */
        this.onUpdateTurnCoordinator = (turnCoordinator) => {
            if (this.turnCoordinatorElement.instance !== null) {
                const translation = turnCoordinator * 54;
                this.turnCoordinatorElement.instance.style.transform = `translate3d(${translation}px, 0px, 0px)`;
            }
        };
        /**
         * Sets whether SVT scales are active or not.
         * @param svt The toggle for SVT.
         */
        this.updateSVTDisplay = (svt) => {
            if (svt) {
                this.numberIncrements = 2; // every n-th increment there is number
                this.scroll_increment = 10; // how big is one area to scroll
                this.pxPerDegY = SvtProjectionUtils.projectYawPitch(0, 0.1 * Avionics.Utils.DEG2RAD, 0, AttitudeIndicator.vec2Cache[0])[1] * 10;
            }
            else {
                this.numberIncrements = 4; // every n-th increment there is number
                this.scroll_increment = 20; // how big is one area to scroll
                this.pxPerDegY = SvtProjectionUtils.projectYawPitch(0, 0.1 * Avionics.Utils.DEG2RAD, 0, AttitudeIndicator.vec2Cache[0])[1] * 5; // pitch ratio is half of svt
            }
            this.pitchIncrementsDistance = (this.pxPerDegY * this.pitchIncrements);
            this.rebuildAttitudeLadder();
        };
    }
    /**
     * Builds pitch tick marks on the attitude indicator.
     */
    buildPitchLines() {
        for (let i = -this.scroll_increment; i < (this.scroll_increment + 1); i++) {
            const length = i % 4 == 0 ? 108 : i % 2 == 0 ? 54 : 28;
            const startX = 153 + (length == 108 ? 0 : length == 54 ? 27 : 40);
            const posY = 0 - (i * this.pitchIncrementsDistance);
            const endX = startX + length;
            const lineEl = FSComponent.buildComponent("line", { x1: startX, y1: posY, x2: endX, y2: posY, stroke: "white", "stroke-width": ".5px" }, ".");
            if (i === 0) {
                lineEl.instance.style.visibility = 'hidden';
                this.zeroPitchLine.instance = lineEl.instance;
            }
            FSComponent.render(lineEl, this.pitchLinesGroup.instance);
        }
    }
    /**
     * Builds the pitch value numbers for the attitude indicator.
     */
    buildPitchNumbers() {
        this.pitchNumbersLeft = [];
        this.pitchNumbersRight = [];
        for (let i = -this.scroll_increment; i < (this.scroll_increment + 1); i++) {
            const length = i % 4 == 0 ? 108 : i % 2 == 0 ? 54 : 28;
            const leftNumberX = 136 + (length == 108 ? 0 : length == 54 ? 27 : 40);
            const rightNumberX = 168 + (length == 108 ? 0 : length == 54 ? 27 : 40) + length;
            const startY = 6 - (i * this.pitchIncrementsDistance);
            if (i % this.numberIncrements == 0) {
                const number = Math.abs(i * this.pitchIncrements);
                const numberText = number !== 0 ? number.toFixed(0) : '';
                const textElementLeft = FSComponent.createRef();
                const textElementRight = FSComponent.createRef();
                const leftEl = FSComponent.buildComponent("text", { x: leftNumberX, y: startY, fill: "white", "font-family": "Roboto-Bold", "text-anchor": "middle", "font-size": "20px", stroke: "black", "stroke-width": "1px", ref: textElementLeft }, numberText);
                const rightEl = FSComponent.buildComponent("text", { x: rightNumberX, y: startY, fill: "white", "font-family": "Roboto-Bold", "text-anchor": "middle", "font-size": "20px", stroke: "black", "stroke-width": "1px", ref: textElementRight }, numberText);
                this.pitchNumbersLeft.push(textElementLeft);
                this.pitchNumbersRight.push(textElementRight);
                FSComponent.render(leftEl, this.pitchLinesGroup.instance);
                FSComponent.render(rightEl, this.pitchLinesGroup.instance);
            }
        }
    }
    /**
     * Rebuilds the attitude ladder.
     */
    rebuildAttitudeLadder() {
        this.pitchLinesGroup.instance.innerHTML = '';
        this.buildPitchLines();
        this.buildPitchNumbers();
        this.onUpdatePitch(this.currentPitch, true);
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        const adc = this.props.bus.getSubscriber();
        adc.on('turn_coordinator_ball')
            .withPrecision(2)
            .handle(this.onUpdateTurnCoordinator);
        PFDUserSettings.getManager(this.props.bus).whenSettingChanged('svtToggle').handle(this.updateSVTDisplay.bind(this));
        this.onUpdatePitch(this.currentPitch, true);
    }
    /**
     * Updates attitude indicator.
     * @param planeState The plane state information.
     */
    update(planeState) {
        this.onUpdatePitch(planeState.pitch, false);
        this.onUpdateRoll(planeState.roll);
    }
    /**
     * Updates pitch lines position.
     * @param pitch The current pitch value.
     */
    updateLinesPos(pitch) {
        pitch = pitch % this.scroll_increment;
        this.pitchLinesGroup.instance.style.transform = `translate3d(0px, ${pitch * (this.pxPerDegY)}px, 0px)`;
    }
    /**
     * Updates pitch number positions.
     * @param pitch The current pitch value.
     * @param offset The current scroll increment offset.
     */
    updatePitchNumbers(pitch, offset) {
        const initNumber = (this.scroll_increment * this.pitchIncrements) - (offset * this.scroll_increment);
        for (let i = 0; i < this.pitchNumbersLeft.length; i++) {
            const number = Math.abs(initNumber - (i * (this.pitchIncrements * this.numberIncrements)));
            const numberText = number !== 0 ? number.toFixed(0) : '';
            this.pitchNumbersLeft[i].instance.textContent = numberText;
            this.pitchNumbersRight[i].instance.textContent = numberText;
        }
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "attitude-container" },
            FSComponent.buildComponent("div", { class: "turn-coordinator", ref: this.turnCoordinatorElement },
                FSComponent.buildComponent("svg", null,
                    FSComponent.buildComponent("path", { d: "M 15 15 l 15 0 l -3 -6 l -24 0 l -3 6 l 15 0", fill: "#fff", stroke: "black", "stroke-width": ".5" }))),
            FSComponent.buildComponent("div", { class: "attitude-bank", ref: this.bankElement, style: "transform: rotate(0deg)" },
                FSComponent.buildComponent("svg", { width: "414", height: "315" },
                    FSComponent.buildComponent("path", { d: "M 207 214 m 0 -193 l -10 -20 l 20 0 l -10 20 a 193 193 0 0 1 32.53 2.76 l 2.43 -13.79 l 1.97 0.35 l -2.43 13.79 a 193 193 0 0 1 29.63 7.86 l 4.79 -13.16 l 1.88 0.68 l -4.79 13.16 a 193 193 0 0 1 28.76 13.22 l 14 -24.25 l 1.73 1 l -14 24.25 a 193 193 0 0 1 38.56 29.26 l 9.9 -9.9 l 1.41 1.41 l -9.9 9.9 a 193 193 0 0 1 29.67 38.24 l 24.24 -14 l 1 1.73 l -25.98 15 a 191 191 0 0 0 -330.8 0 l -25.98 -15 l 1 -1.73 l 24.25 14 a 193 193 0 0 1 29.67 -38.24 l -9.9 -9.9 l 1.41 -1.41 l 9.9 9.9 a 193 193 0 0 1 38.56 -29.26 l -14 -24.25 l 1.73 -1 l 14 24.25 a 193 193 0 0 1 28.76 -13.22 l -4.79 -13.16 l 1.88 -0.68 l 4.79 13.16 a 193 193 0 0 1 29.63 -7.86 l -2.43 -13.79 l 1.97 -0.35 l 2.43 13.79 a 193 193 0 0 1 32.53 -2.76", fill: "#fff", stroke: "black", "stroke-width": ".5" })),
                FSComponent.buildComponent("div", { class: "attitude-cutout", ref: this.cutoutElement, style: "transform: rotate(0deg)" },
                    FSComponent.buildComponent("div", { class: "attitude-inner-bank", ref: this.innerBankElement, style: "transform: rotate(0deg)" },
                        FSComponent.buildComponent("div", { class: "attitude-pitchlines", style: "transform: translate3d(0px, 0px, 0px)", ref: this.pitchLinesContainer },
                            FSComponent.buildComponent("svg", { width: "414px", style: "overflow:visible" },
                                FSComponent.buildComponent("g", { class: "pitchLines", ref: this.pitchLinesGroup })))))),
            FSComponent.buildComponent("svg", { width: "414", height: "315" },
                FSComponent.buildComponent("path", { d: "M 47 204 l -3 -4 l -43 0 l 0 4 ", fill: "rgb(255,255,0)", stroke: "black", "stroke-width": "1px" }),
                FSComponent.buildComponent("path", { d: "M 47 204 l -3 4 l -43 0 l 0 -4 ", fill: "rgb(152,140,0)", stroke: "black", "stroke-width": "1px" }),
                FSComponent.buildComponent("path", { d: "M 365 204 l 3 -4 l 43 0 l 0 4 ", fill: "rgb(255,255,0)", stroke: "black", "stroke-width": "1px" }),
                FSComponent.buildComponent("path", { d: "M 365 204 l 3 4 l 43 0 l 0 -4 ", fill: "rgb(152,140,0)", stroke: "black", "stroke-width": "1px" }),
                FSComponent.buildComponent("path", { d: "M 207 204 l 0 -1 l -120 31 l 35 0 ", fill: "rgb(255,255,0)", stroke: "black", "stroke-width": ".5px" }),
                FSComponent.buildComponent("path", { d: "M 207 204 l -66 30 l -19 0 ", fill: "rgb(152,140,0)", stroke: "black", "stroke-width": ".5px" }),
                FSComponent.buildComponent("path", { d: "M 207 204 l 0 -1 l 120 31 l -35 0 ", fill: "rgb(255,255,0)", stroke: "black", "stroke-width": ".5px" }),
                FSComponent.buildComponent("path", { d: "M 207 204 l 66 30 l 19 0 ", fill: "rgb(152,140,0)", stroke: "black", "stroke-width": ".5px" }),
                FSComponent.buildComponent("path", { d: "M 207 214 m 0 -192 l -10 20 l 20 0 l -10 -20 ", fill: "#fff", stroke: "black", "stroke-width": ".5" }))));
    }
}
AttitudeIndicator.vec2Cache = [new Float64Array(2)];

/**
 * The FlightPathMarker component.
 */
class FlightPathMarker extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.fpvMarkerRef = FSComponent.createRef();
        this.groundTrackSmoother = new ExpSmoother(FlightPathMarker.GROUND_TRACK_TIME_CONSTANT);
        this.vAngleSmoother = new ExpSmoother(FlightPathMarker.VANGLE_TIME_CONSTANT);
        this.isVisible = true;
    }
    /**
     * Updates flight path marker
     * @param dt The elapsed time, in milliseconds, since the previous update.
     * @param planeState The state of own airplane.
     */
    update(dt, planeState) {
        this.updateIsVisible(planeState);
        if (this.isVisible) {
            this.updatePosition(dt, planeState);
        }
    }
    /**
     * Updates whether this flight path marker should be visible.
     * @param planeState The state of own airplane.
     */
    updateIsVisible(planeState) {
        const isVisible = this.props.isActive.get() && planeState.gs > 30;
        if (this.isVisible !== isVisible) {
            this.isVisible = isVisible;
            this.fpvMarkerRef.instance.style.display = isVisible ? '' : 'none';
        }
    }
    /**
     * Updates this flight path marker's position.
     * @param dt The elapsed time, in milliseconds, since the previous update.
     * @param planeState The state of own airplane.
     */
    updatePosition(dt, planeState) {
        const vAngle = this.vAngleSmoother.next(Math.atan2(planeState.vs, UnitType.KNOT.convertTo(planeState.gs, UnitType.FPM)), dt);
        const pitch = planeState.pitch * Avionics.Utils.DEG2RAD + vAngle;
        const trkAvg = this.smoothGroundTrack(planeState.track, dt);
        const yaw = NavMath.diffAngle(planeState.heading, trkAvg) * Avionics.Utils.DEG2RAD;
        const roll = planeState.roll * Avionics.Utils.DEG2RAD;
        const offset = SvtProjectionUtils.projectYawPitch(yaw, pitch, roll, FlightPathMarker.vec2Cache[0]);
        this.fpvMarkerRef.instance.style.transform = `translate3d(${offset[0]}px, ${offset[1]}px, 0)`;
    }
    /**
     * Smooths a ground track value.
     * @param track A ground track value.
     * @param dt The elapsed time, in milliseconds, since the last smoothed value was calculated.
     * @returns A smoothed ground track value.
     */
    smoothGroundTrack(track, dt) {
        const last = this.groundTrackSmoother.last();
        if (last !== null && !isNaN(last)) {
            // need to handle wraparounds
            let delta = track - last;
            if (delta > 180) {
                delta = delta - 360;
            }
            else if (delta < -180) {
                delta = delta + 360;
            }
            track = last + delta;
        }
        const next = last !== null && isNaN(last) ? this.groundTrackSmoother.reset(track) : this.groundTrackSmoother.next(track, dt);
        const normalized = (next + 360) % 360; // enforce range 0-359
        return this.groundTrackSmoother.reset(normalized);
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "fpv-marker", ref: this.fpvMarkerRef, style: "transform3d(0, 0, 0); position: absolute; top: 33%; left: 42%; width: 58px;" },
            FSComponent.buildComponent("svg", { viewBox: "-29 -25 58 42" },
                FSComponent.buildComponent("path", { d: "M -14 0 a 14 14 0 1 0 28 0 m 16 0 l -16 0 a 14 14 0 1 0 -28 0 l -16 0 m 30 -14 l 0 -12", stroke: "black", "stroke-width": "5", fill: "none" }),
                FSComponent.buildComponent("path", { d: "M -14 0 a 14 14 0 1 0 28 0 m 14 0 l -14 0 a 14 14 0 1 0 -28 0 l -14 0 m 28 -14 l 0 -10", stroke: "rgb(0,255,0)", "stroke-width": "2", fill: "none" }))));
    }
}
FlightPathMarker.GROUND_TRACK_TIME_CONSTANT = 2000 / Math.LN2; // ms
FlightPathMarker.VANGLE_TIME_CONSTANT = 2000 / Math.LN2; // ms
FlightPathMarker.vec2Cache = [new Float64Array(2)];

/// <reference types="msfstypes/JS/common" />
/**
 * A FSComponent that display the MSFS Bing Map, weather radar, and 3D terrain.
 */
class SynVisComponent extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.bingRef = FSComponent.createRef();
        /**
         * A callback which is called when the Bing component is bound.
         */
        this.onBingBound = () => {
            // noop
        };
    }
    /**
     * Renders the syn vis component.
     * @returns A component VNode.
     */
    render() {
        return (FSComponent.buildComponent(BingComponent, { ref: this.bingRef, id: this.props.bingId, mode: EBingMode.HORIZON, onBoundCallback: this.onBingBound, resolution: this.props.resolution, earthColors: this.props.earthColors, skyColor: this.props.skyColor }));
    }
}

/**
 * Horizon Compass
 */
class HorizonCompass extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.horizonLineElement = FSComponent.createRef();
        this.headingTapeValues = [];
        this.headingLabelsRef = FSComponent.createRef();
        this.currentDrawnHeading = 0;
        this.pxPerDegX = SvtProjectionUtils.projectYawPitch(0.1 * Avionics.Utils.DEG2RAD, 0, 0, new Float64Array(2))[0] * 10;
        /**
         * A callback called when the heading tape updates.
         * @param heading The current heading value.
         */
        this.onUpdateHeadingTape = (heading) => {
            if (heading / 10 >= this.currentDrawnHeading + 1 || heading / 10 <= this.currentDrawnHeading) {
                this.currentDrawnHeading = Math.floor(heading / 10);
                const start = 300 + (this.currentDrawnHeading) * 10;
                for (let i = 0; i < this.headingTapeValues.length; i++) {
                    const scrollerValue = this.headingTapeValues[i].instance;
                    if (scrollerValue !== null) {
                        const hdg = (start + i * 10) % 360;
                        if (hdg % 30 == 0) {
                            scrollerValue.textContent = hdg != 0 ? (hdg).toString().padStart(3, '0') : '360';
                        }
                        else {
                            scrollerValue.textContent = '';
                        }
                    }
                }
            }
        };
    }
    /**
     * Updates horizon compass
     * @param planeState The plane state info.
     */
    update(planeState) {
        const offset = SvtProjectionUtils.projectYawPitch(0, planeState.pitch * Avionics.Utils.DEG2RAD, 0, HorizonCompass.vec2Cache[0]);
        // need to use linear approximation for yaw otherwise ticks will appear to stutter since they are spaced according
        // to this approximation
        offset[0] = planeState.heading % 10 * this.pxPerDegX;
        this.horizonLineElement.instance.style.transform = `rotate(${planeState.roll}deg) translate3d(${-offset[0]}px,${offset[1]}px,0)`;
        this.onUpdateHeadingTape(planeState.heading);
    }
    /**
     * Sets the heading label visibility.
     * @param v bool indicating if the labels should be shown
     */
    setHdgLabelVisibility(v) {
        if (this.headingLabelsRef.instance !== null) {
            this.headingLabelsRef.instance.style.visibility = v ? 'visible' : 'hidden';
        }
    }
    /**
     * Builds the tick marks on the horizon compass.
     * @returns Arrays of tick marks and labels.
     */
    // eslint-disable-next-line jsdoc/require-jsdoc
    buildHeadingTicks() {
        const result = {
            ticks: [],
            labels: []
        };
        const tickLength = 4;
        const labelBottomY = -6;
        result.ticks.push(FSComponent.buildComponent("line", { x1: '0', y1: '0', x2: '0', y2: -tickLength, stroke: "rgb(203,203,203)", "stroke-width": "1" }));
        let textRef = FSComponent.createRef();
        result.labels.push(FSComponent.buildComponent("text", { x: '0', y: labelBottomY, fill: "rgb(203,203,203)", "text-anchor": "middle", "font-size": "15", ref: textRef }, "360"));
        this.headingTapeValues.push(textRef);
        for (let i = 0; i < 6; i++) {
            const headingOffset = (i + 1) * 10;
            const dX = this.pxPerDegX * headingOffset;
            result.ticks.unshift(FSComponent.buildComponent("line", { x1: -dX, y1: '0', x2: -dX, y2: -tickLength, stroke: "rgb(203,203,203)", "stroke-width": "1" }));
            result.ticks.push(FSComponent.buildComponent("line", { x1: dX, y1: '0', x2: dX, y2: -tickLength, stroke: "rgb(203,203,203)", "stroke-width": "1" }));
            textRef = FSComponent.createRef();
            result.labels.unshift(FSComponent.buildComponent("text", { x: -dX, y: labelBottomY, fill: "rgb(203,203,203)", "text-anchor": "middle", "font-size": "15", ref: textRef }, 360 - headingOffset));
            this.headingTapeValues.unshift(textRef);
            textRef = FSComponent.createRef();
            result.labels.push(FSComponent.buildComponent("text", { x: dX, y: labelBottomY, fill: "rgb(203,203,203)", "text-anchor": "middle", "font-size": "15", ref: textRef }, headingOffset));
            this.headingTapeValues.push(textRef);
        }
        return result;
    }
    /**
     * Gets the altitude corrected pitch for the horizon.
     * @param pitch input pitch value in degrees
     * @param alt altitude in meters
     * @returns corrected pitch in degrees
     */
    getCorrectedPitch(pitch, alt) {
        alt /= 1000;
        if (alt > HorizonCompass.EPSILON) {
            const horizonDistance = Math.sqrt(alt * (2 * 6371 + alt));
            pitch += 125 * (alt / horizonDistance);
        }
        return pitch;
    }
    /** @inheritdoc */
    render() {
        const ticks = this.buildHeadingTicks();
        return (FSComponent.buildComponent("svg", { ref: this.horizonLineElement, class: "horizon-line", viewBox: "-982 -25 1964 50" },
            FSComponent.buildComponent("g", { class: "HeadingTape" },
                FSComponent.buildComponent("line", { x1: "-982", y1: "0", x2: "982", y2: "0", stroke: "white", "stroke-width": "2" }),
                ticks.ticks,
                FSComponent.buildComponent("g", { ref: this.headingLabelsRef }, ticks.labels))));
    }
}
HorizonCompass.vec2Cache = [new Float64Array(2)];
HorizonCompass.EPSILON = 0.0001;

/**
 * G1000 syn vis component
 */
class G1000SynVis extends DisplayComponent {
    /**
     * Ctor
     * @param props the props.
     */
    constructor(props) {
        super(props);
        this.containerRef = FSComponent.createRef();
        this.horizonRef = FSComponent.createRef();
        this.settingManager = PFDUserSettings.getManager(props.bus);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.isActive.sub(this.onIsActiveChanged.bind(this), true);
        this.settingManager.whenSettingChanged('svtHdgLabelToggle').handle(this.onHdgLblActiveChanged.bind(this));
    }
    /**
     * Callback when the Hdg label setting is changed.
     * @param v true if hdg label is active, false otherwise.
     */
    onHdgLblActiveChanged(v) {
        this.horizonRef.instance.setHdgLabelVisibility(v);
    }
    /**
     * Responds to changes in whether synthetic vision is active.
     * @param active Whether synthetic vision is active.
     */
    onIsActiveChanged(active) {
        this.containerRef.instance.style.display = active ? '' : 'none';
    }
    /**
     * Creates a full Bing component earth color array for SVT which is darker than the regular topo map.
     * @returns a full Bing component earth color array for SVT absolute terrain colors.
     */
    createSVTEarthColors() {
        return BingComponent.createEarthColorsArray('#000049', [
            {
                elev: 0,
                color: '#0c2e04'
            },
            {
                elev: 500,
                color: '#113300'
            },
            {
                elev: 2000,
                color: '#463507'
            },
            {
                elev: 3000,
                color: '#5c421f'
            },
            {
                elev: 6000,
                color: '#50331b'
            },
            {
                elev: 8000,
                color: '#512d15'
            },
            {
                elev: 10500,
                color: '#673118'
            },
            {
                elev: 27000,
                color: '#4d4d4d'
            },
            {
                elev: 29000,
                color: '#666666'
            }
        ]);
    }
    /**
     * Updates the components of the g1000 syn vis.
     * @param planeState The current plane state info.
     */
    update(planeState) {
        if (this.props.isActive.get()) {
            this.horizonRef.instance.update(planeState);
        }
    }
    /**
     * Renders the syn vis component.
     * @returns A component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "synthetic-vision", ref: this.containerRef },
            FSComponent.buildComponent(SynVisComponent, { bingId: this.props.bingId, resolution: this.props.resolution, earthColors: ArraySubject.create(this.createSVTEarthColors()), skyColor: Subject.create(BingComponent.hexaToRGBColor('0033E6')) }),
            FSComponent.buildComponent(HorizonCompass, { ref: this.horizonRef })));
    }
}

/**
 * The PFD primary horizon display.
 */
class PrimaryHorizonDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.artificalHorizonRef = FSComponent.createRef();
        this.attitudeIndicatorRef = FSComponent.createRef();
        this.flightPathMarkerRef = FSComponent.createRef();
        this.synVisRef = FSComponent.createRef();
        this.isSvtActiveSub = Subject.create(false);
        this.planeState = {
            roll: 0,
            pitch: 0,
            heading: 0,
            track: 0,
            altitude: 0,
            gs: 0,
            vs: 0,
            aoa: 0
        };
        this.shouldUpdate = true;
        this.lastUpdateTime = 0;
        /**
         * A callback called when the pitch updates from the event bus.
         * @param pitch The current pitch value.
         */
        this.onUpdatePitch = (pitch) => {
            this.planeState.pitch = pitch;
            this.shouldUpdate = true;
        };
        /**
         * A callback called when the roll updates from the event bus.
         * @param roll The current ADC roll value.
         */
        this.onUpdateRoll = (roll) => {
            this.planeState.roll = roll;
            this.shouldUpdate = true;
        };
        /**
         * A callback called when the altitude updates from the event bus.
         * @param alt The current ADC altitude.
         */
        this.onUpdateAltitude = (alt) => {
            this.planeState.altitude = alt;
            this.shouldUpdate = true;
        };
        /**
         * A callback called when the true heading updates from the event bus.
         * @param hdg The current ADC true heading value.
         */
        this.onUpdateHeading = (hdg) => {
            this.planeState.heading = hdg;
            this.shouldUpdate = true;
        };
        /**
         * A callback called when the true track updates from the event bus.
         * @param track The current ADC true track value.
         */
        this.onUpdateTrack = (track) => {
            this.planeState.track = track;
            this.shouldUpdate = true;
        };
        /**
         * A callback called when the ground speed updates from the event bus.
         * @param gs The current ADC ground speed value.
         */
        this.onUpdateGroundSpeed = (gs) => {
            this.planeState.gs = gs;
            this.shouldUpdate = true;
        };
        /**
         * A callback called when the vertical speed updates from the event bus.
         * @param vs The current ADC vertical speed value.
         */
        this.onUpdateVerticalSpeed = (vs) => {
            this.planeState.vs = vs;
            this.shouldUpdate = true;
        };
        /**
         * A callback called when the angle of attack updates from the event bus.
         * @param aoa The current angle of attack.
         */
        this.onUpdateAoA = (aoa) => {
            this.planeState.aoa = aoa;
            this.shouldUpdate = true;
        };
        this.onFrameUpdate = (realTime) => {
            const dt = realTime - this.lastUpdateTime;
            if (this.shouldUpdate) {
                this.shouldUpdate = false;
                this.synVisRef.instance.update(this.planeState);
                this.attitudeIndicatorRef.instance.update(this.planeState);
                this.artificalHorizonRef.instance.update(this.planeState);
            }
            this.flightPathMarkerRef.instance.update(dt, this.planeState);
            // this.aptLabelsRef.instance.update(this.planeState);
            this.lastUpdateTime = realTime;
        };
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        const sub = this.props.bus.getSubscriber();
        sub.on('pitch_deg')
            .withPrecision(2)
            .handle(this.onUpdatePitch);
        sub.on('roll_deg')
            .withPrecision(3)
            .handle(this.onUpdateRoll);
        sub.on('alt')
            .whenChanged()
            .handle(this.onUpdateAltitude);
        sub.on('hdg_deg')
            .withPrecision(2)
            .handle(this.onUpdateHeading);
        sub.on('track_deg_magnetic')
            .withPrecision(2)
            .handle(this.onUpdateTrack);
        sub.on('ground_speed')
            .withPrecision(2)
            .handle(this.onUpdateGroundSpeed);
        sub.on('vs')
            .withPrecision(2)
            .handle(this.onUpdateVerticalSpeed);
        sub.on('aoa')
            .withPrecision(2)
            .handle(this.onUpdateAoA);
        sub.on('realTime').handle(this.onFrameUpdate);
        PFDUserSettings.getManager(this.props.bus).whenSettingChanged('svtToggle').handle(isActive => { this.isSvtActiveSub.set(isActive); });
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", null,
            FSComponent.buildComponent(ArtificialHorizon, { ref: this.artificalHorizonRef, isActive: this.isSvtActiveSub.map(isActive => !isActive) }),
            FSComponent.buildComponent(G1000SynVis, { ref: this.synVisRef, bus: this.props.bus, bingId: 'wtg1000-horizon', resolution: Vec2Subject.createFromVector(new Float64Array([1228, 921])), isActive: this.isSvtActiveSub }),
            FSComponent.buildComponent(FlightPathMarker, { ref: this.flightPathMarkerRef, isActive: this.isSvtActiveSub }),
            FSComponent.buildComponent(AttitudeIndicator, { ref: this.attitudeIndicatorRef, bus: this.props.bus })));
    }
}

/// <reference types="msfstypes/Pages/VCockpit/Instruments/Shared/BaseInstrument" />
/**
 * The base G1000 PFD instrument class.
 */
class WTG1000_PFD extends BaseInstrument {
    /**
     * Creates an instance of the WTG1000_PFD.
     */
    constructor() {
        super();
        this.lastCalculate = 0;
        this.airspaceSearcher = new AirspaceSearcher();
        RegisterViewListener('JS_LISTENER_INSTRUMENTS');
        WaypointIconImageCache.init();
        this.bus = new EventBus();
        this.hEventPublisher = new HEventPublisher(this.bus);
        this.adcPublisher = new ADCPublisher(this.bus);
        this.gnssPublisher = new GNSSPublisher(this.bus);
        this.soundPublisher = new SoundPublisher(this.bus);
        this.adcPublisher.subscribe('tas');
        this.adcPublisher.subscribe('ias');
        this.adcPublisher.subscribe('hdg_deg');
        this.adcPublisher.subscribe('hdg_deg_true');
        this.adcPublisher.subscribe('vs');
        this.adcPublisher.subscribe('alt');
        this.adcPublisher.subscribe('pitch_deg');
        this.adcPublisher.subscribe('roll_deg');
        this.adcPublisher.subscribe('kohlsman_setting_hg_1');
        this.adcPublisher.subscribe('kohlsman_setting_mb_1');
        this.adcPublisher.subscribe('turn_coordinator_ball');
        this.adcPublisher.subscribe('delta_heading_rate');
        this.adcPublisher.subscribe('ambient_temp_c');
        this.adcPublisher.subscribe('ambient_wind_velocity');
        this.adcPublisher.subscribe('ambient_wind_direction');
        this.adcPublisher.subscribe('on_ground');
        this.adcPublisher.subscribe('aoa');
        this.lNavPublisher = new LNavSimVarPublisher(this.bus);
        this.lNavPublisher.subscribe('lnavBrgMag');
        this.lNavPublisher.subscribe('lnavDis');
        this.lNavPublisher.subscribe('lnavDisTurn');
        this.lNavPublisher.subscribe('lnavDtkMag');
        this.lNavPublisher.subscribe('lnavNextDtkMag');
        this.lNavPublisher.subscribe('lnavXtk');
        this.lNavPublisher.subscribe('lnavCdiScaling');
        this.lNavPublisher.subscribe('lnavCdiScalingLabel');
        this.lNavPublisher.subscribe('lnavCurrentVector');
        this.vNavPublisher = new VNavSimVarPublisher(this.bus);
        this.vNavPublisher.subscribe('vnavPathMode');
        this.vNavPublisher.subscribe('vnavTodDistance');
        this.vNavPublisher.subscribe('vnavTodLegIndex');
        this.vNavPublisher.subscribe('vnavTodLegDistance');
        this.vNavPublisher.subscribe('vnavBodLegIndex');
        this.vNavPublisher.subscribe('vnavAltCaptureType');
        this.vNavPublisher.subscribe('vnavTargetAlt');
        this.vNavPublisher.subscribe('vnavVDev');
        this.vNavPublisher.subscribe('vnavFpa');
        this.vNavPublisher.subscribe('vnavLpvVDev');
        this.vNavPublisher.subscribe('vnavLpvDistance');
        this.vNavPublisher.subscribe('vnavApproachMode');
        this.vNavPublisher.subscribe('vnavAltCaptureType');
        this.vNavPublisher.subscribe('vnavBodDistance');
        this.vNavPublisher.subscribe('vnavConstraintAltitude');
        this.vNavPublisher.subscribe('vnavConstraintLegIndex');
        this.vNavPublisher.subscribe('vnavRequiredVs');
        this.controlPublisher = new ControlPublisher(this.bus);
        this.g1000ControlPublisher = new G1000ControlPublisher(this.bus);
        this.navComInstrument = new NavComInstrument(this.bus, G1000Config, 2, 2, true);
        this.apInstrument = new AutopilotInstrument(this.bus);
        this.xpdrInstrument = new XPDRInstrument(this.bus);
        this.trafficInstrument = new TrafficInstrument(this.bus, { realTimeUpdateFreq: 2, simTimeUpdateFreq: 1, contactDeprecateTime: 10 });
        this.clock = new Clock(this.bus);
        this.facLoader = new FacilityLoader(FacilityRespository.getRepository(this.bus));
        this.calculator = new FlightPathCalculator(this.facLoader, { defaultClimbRate: 300, defaultSpeed: 85, bankAngle: 17.5 });
        this.planner = FlightPlanner.getPlanner(this.bus, this.calculator);
        this.viewService = new PFDViewService(this.bus);
        this.navProcessor = new NavProcessor(this.bus, new NPConfig(this.bus, this.planner));
        this.backplane = new InstrumentBackplane();
        this.backplane.addPublisher('adc', this.adcPublisher);
        this.backplane.addPublisher('lnav', this.lNavPublisher);
        this.backplane.addPublisher('vnav', this.vNavPublisher);
        this.backplane.addPublisher('hEvents', this.hEventPublisher);
        this.backplane.addPublisher('control', this.controlPublisher);
        this.backplane.addPublisher('g1000', this.g1000ControlPublisher);
        this.backplane.addPublisher('gnss', this.gnssPublisher);
        this.backplane.addPublisher('sound', this.soundPublisher);
        this.backplane.addInstrument('navcom', this.navComInstrument);
        this.backplane.addInstrument('ap', this.apInstrument);
        this.backplane.addInstrument('nav', this.navProcessor);
        this.backplane.addInstrument('xpdr', this.xpdrInstrument);
        this.backplane.addInstrument('traffic', this.trafficInstrument);
        this.tas = new TrafficAdvisorySystem(this.bus, this.trafficInstrument, 30, 2, 1);
        this.fms = new Fms(this.bus, this.planner, this.viewService, this.g1000ControlPublisher);
        FlightPlanAsoboSync.init();
        this.navIndicatorController = new NavIndicatorController(this.bus, this.fms);
        this.xmlLogicHost = new CompositeLogicXMLHost();
        this.annunciationFactory = new XMLAnnunciationFactory(this);
        this.warningFactory = new XMLWarningFactory(this);
        this.soundServer = new SoundServer(this.bus, this.soundPublisher, this);
        this.backlightManager = new BacklightManager('pfd', this.bus);
        // TODO: Support pilot profiles.
        this.settingSaveManager = new G1000SettingSaveManager(this.bus);
        const saveKey = `${SimVar.GetSimVarValue('ATC MODEL', 'string')}.profile_1`;
        this.settingSaveManager.load(saveKey);
    }
    /**
     * The instrument template ID.
     * @returns The instrument template ID.
     */
    get templateID() {
        return 'WTG1000_PFD';
    }
    /**
     * Whether or not the instrument is interactive (a touchscreen instrument).
     * @returns True
     */
    get isInteractive() {
        return true;
    }
    /**
     * A callback called when the element is attached to the DOM.
     */
    connectedCallback() {
        super.connectedCallback();
        this.backplane.init();
        const menuSystem = new MenuSystem(this.bus, 'AS1000_PFD_SOFTKEYS_');
        // if (alertsPopoutRef.instance !== null) {
        menuSystem.addMenu('root', new RootMenu(menuSystem, this.controlPublisher, this.g1000ControlPublisher, this.bus));
        // }
        menuSystem.addMenu('map-hsi', new MapHSIMenu(menuSystem));
        menuSystem.addMenu('map-hsi-layout', new MapHSILayoutMenu(menuSystem));
        menuSystem.addMenu('pfd-opt', new PFDOptMenu(menuSystem, this.controlPublisher, this.g1000ControlPublisher, this.bus));
        menuSystem.addMenu('svt', new SVTMenu(menuSystem));
        menuSystem.addMenu('wind', new WindMenu(menuSystem));
        menuSystem.addMenu('alt-units', new ALTUnitsMenu(menuSystem));
        menuSystem.addMenu('xpdr', new XPDRMenu(menuSystem, this.controlPublisher, this.g1000ControlPublisher, this.bus));
        menuSystem.addMenu('xpdr-code', new XPDRCodeMenu(menuSystem, this.bus, this.g1000ControlPublisher));
        menuSystem.pushMenu('root');
        FSComponent.render(FSComponent.buildComponent(PrimaryHorizonDisplay, { bus: this.bus }), document.getElementById('HorizonContainer'));
        FSComponent.render(FSComponent.buildComponent(HSI, { bus: this.bus, flightPlanner: this.planner, navIndicatorController: this.navIndicatorController, airspaceSearcher: this.airspaceSearcher, tas: this.tas }), document.getElementById('InstrumentsContainer'));
        FSComponent.render(FSComponent.buildComponent(FlightDirector, { bus: this.bus }), document.getElementById('InstrumentsContainer'));
        FSComponent.render(FSComponent.buildComponent(AirspeedIndicator, { bus: this.bus }), document.getElementById('InstrumentsContainer'));
        FSComponent.render(FSComponent.buildComponent(VerticalSpeedIndicator, { bus: this.bus, navIndicatorController: this.navIndicatorController }), document.getElementById('InstrumentsContainer'));
        FSComponent.render(FSComponent.buildComponent(Altimeter, { bus: this.bus, g1000Publisher: this.g1000ControlPublisher }), document.getElementById('InstrumentsContainer'));
        FSComponent.render(FSComponent.buildComponent(MarkerBeacon, { bus: this.bus }), document.getElementById('InstrumentsContainer'));
        FSComponent.render(FSComponent.buildComponent(DMEWindow, { bus: this.bus, navIndicatorController: this.navIndicatorController }), document.getElementById('InstrumentsContainer'));
        FSComponent.render(FSComponent.buildComponent(VerticalDeviation, { bus: this.bus, navIndicatorController: this.navIndicatorController }), document.getElementById('InstrumentsContainer'));
        FSComponent.render(FSComponent.buildComponent(NavComRadio, { bus: this.bus, title: 'NAV', position: 'left' }), document.querySelector('#NavComBox #Left'));
        FSComponent.render(FSComponent.buildComponent(NavComRadio, { bus: this.bus, title: 'COM', position: 'right' }), document.querySelector('#NavComBox #Right'));
        FSComponent.render(FSComponent.buildComponent(Fma, { bus: this.bus, planner: this.planner, navController: this.navIndicatorController }), document.getElementById('NavComBox'));
        FSComponent.render(FSComponent.buildComponent(BottomInfoPanel, { bus: this.bus, controlPublisher: this.controlPublisher }), document.getElementById('InstrumentsContainer'));
        FSComponent.render(FSComponent.buildComponent(SoftKeyBar, { menuSystem: menuSystem }), document.getElementById('Electricity'));
        FSComponent.render(FSComponent.buildComponent(WindOverlay, { bus: this.bus }), document.getElementById('InstrumentsContainer'));
        FSComponent.render(FSComponent.buildComponent(MapInset, { bus: this.bus, flightPlanner: this.planner, airspaceSearcher: this.airspaceSearcher, tas: this.tas }), document.getElementById('InstrumentsContainer'));
        FSComponent.render(FSComponent.buildComponent(CAS, { bus: this.bus, logicHandler: this.xmlLogicHost, annunciations: this.annunciationFactory.parseConfig(this.xmlConfig) }), document.getElementById('cas'));
        FSComponent.render(FSComponent.buildComponent(WarningDisplay, { bus: this.bus, soundPublisher: this.soundPublisher, logicHandler: this.xmlLogicHost, warnings: this.warningFactory.parseConfig(this.xmlConfig) }), document.getElementById('warnings'));
        this.viewService.registerView('FPL', () => FSComponent.buildComponent(FPL, { viewService: this.viewService, bus: this.bus, fms: this.fms, title: "Flight Plan", showTitle: true }));
        this.viewService.registerView('PROC', () => FSComponent.buildComponent(PFDProc, { viewService: this.viewService, title: "Procedures", showTitle: true, fms: this.fms }));
        this.viewService.registerView('DirectTo', () => FSComponent.buildComponent(PFDDirectTo, { viewService: this.viewService, bus: this.bus, fms: this.fms, title: "Direct To", showTitle: true }));
        this.viewService.registerView('WptInfo', () => FSComponent.buildComponent(PFDWptInfo, { viewService: this.viewService, bus: this.bus, title: "Waypoint Information", showTitle: true }));
        this.viewService.registerView('MessageDialog', () => FSComponent.buildComponent(MessageDialog, { viewService: this.viewService, title: "", showTitle: false }));
        this.viewService.registerView('SetRunway', () => FSComponent.buildComponent(PFDSetRunway, { viewService: this.viewService, title: "Set Runway", showTitle: true }));
        this.viewService.registerView('SelectDeparture', () => FSComponent.buildComponent(PFDSelectDeparture, { viewService: this.viewService, bus: this.bus, fms: this.fms, title: "Select Departure", showTitle: true }));
        this.viewService.registerView('SelectApproach', () => FSComponent.buildComponent(PFDSelectApproach, { viewService: this.viewService, bus: this.bus, fms: this.fms, title: "Select Approach", showTitle: true }));
        this.viewService.registerView('SelectArrival', () => FSComponent.buildComponent(PFDSelectArrival, { viewService: this.viewService, bus: this.bus, fms: this.fms, title: "Select Arrival", showTitle: true }));
        this.viewService.registerView(ContextMenuDialog.name, () => FSComponent.buildComponent(ContextMenuDialog, { viewService: this.viewService, title: "", showTitle: false, upperKnobCanScroll: true }));
        this.viewService.registerView(PageMenuDialog.name, () => FSComponent.buildComponent(PageMenuDialog, { viewService: this.viewService, title: "Page Menu", showTitle: true }));
        this.viewService.registerView(TimerRef.name, () => FSComponent.buildComponent(TimerRef, { viewService: this.viewService, bus: this.bus, fms: this.fms, title: "TimerRef", showTitle: false }));
        this.viewService.registerView(ADFDME.name, () => FSComponent.buildComponent(ADFDME, { viewService: this.viewService, bus: this.bus, title: "ADF/DME TUNING", showTitle: true, navIndicatorController: this.navIndicatorController }));
        this.viewService.registerView(PFDWptDupDialog.name, () => FSComponent.buildComponent(PFDWptDupDialog, { viewService: this.viewService, title: "Duplicate Waypoints", showTitle: true }));
        this.viewService.registerView(Nearest.name, () => FSComponent.buildComponent(Nearest, { viewService: this.viewService, bus: this.bus, fms: this.fms, loader: this.facLoader, publisher: this.controlPublisher, title: "Nearest Airports", showTitle: true }));
        this.viewService.registerView(PFDSetup.name, () => FSComponent.buildComponent(PFDSetup, { viewService: this.viewService, title: "PFD Setup Menu", showTitle: true, bus: this.bus }));
        this.viewService.registerView('SelectAirway', () => FSComponent.buildComponent(PFDSelectAirway, { viewService: this.viewService, title: "Select Airway", showTitle: true, fms: this.fms }));
        this.viewService.registerView('HoldAt', () => FSComponent.buildComponent(PFDHold, { viewService: this.viewService, title: "Hold at", showTitle: true, fms: this.fms, bus: this.bus }));
        this.controlPublisher.publishEvent('init_cdi', true);
        // force enable animations
        document.documentElement.classList.add('animationsEnabled');
    }
    /**
     * A callback called when the instrument is initialized.
     */
    Init() {
        super.Init();
        this.initPrimaryFlightPlan();
        this.clock.init();
        this.tas.setOperatingMode(TCASOperatingMode.TA_RA); // TODO: putting this here until we get user control set up
        this.tas.init();
        this.backlightManager.init();
    }
    /**
     * Initializes the primary flight plan.
     */
    async initPrimaryFlightPlan() {
        // Request a sync from the MFD in case of an instrument reload
        this.fms.flightPlanner.requestSync();
        await Wait.awaitDelay(500);
        // Initialize the primary plan in case one was not synced.
        this.fms.initPrimaryFlightPlan();
    }
    /**
     * Callback called when the flight starts.
     */
    onFlightStart() {
        super.onFlightStart();
        Wait.awaitCondition(() => this.planner.hasFlightPlan(Fms.PRIMARY_PLAN_INDEX), 1000)
            .then(() => FlightPlanAsoboSync.loadFromGame(this.fms));
    }
    /**
     * A callback called when the instrument gets a frame update.
     */
    Update() {
        super.Update();
        this.clock.onUpdate();
        this.backplane.onUpdate();
        const now = Date.now();
        if (now - this.lastCalculate > 3000) {
            if (this.planner.hasFlightPlan(this.planner.activePlanIndex)) {
                this.planner.getActiveFlightPlan().calculate();
            }
            SimVar.SetSimVarValue('K:HEADING_GYRO_SET', SimVarValueType.Number, 0);
            this.lastCalculate = now;
        }
        this.xmlLogicHost.update();
    }
    /**
     * A callback for when sounds are done playing.  This is needed to support the sound server.
     * @param soundEventId The sound that got played.
     */
    onSoundEnd(soundEventId) {
        console.log(`PFD onSoundEnd for ${soundEventId.originalStr}`);
        this.soundServer.onSoundEnd(soundEventId);
    }
    /**
     * A callback called when the instrument received a H event.
     * @param args The H event and associated arguments, if any.
     */
    onInteractionEvent(args) {
        this.hEventPublisher.dispatchHEvent(args[0]);
    }
}
registerInstrument('wtg1000-pfd', WTG1000_PFD);
